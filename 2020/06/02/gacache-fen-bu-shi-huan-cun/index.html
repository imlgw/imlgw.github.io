
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="开源项目,Gacache," />
  

  
    <meta name="description" content="大悲无泪，大悟无言，大笑无声。" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/img/cat.ico">
  
  <title>Gacache分布式缓存 [ iMlGw0 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">iMlGw0</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">分类</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">归档</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">标签</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="LC" class="pure-menu-link">LC</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/05/04/leetcode-shu-zu/" style="color:#202020;" class="pure-menu-link">数组</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/" style="color:#202020;" class="pure-menu-link">链表</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/" style="color:#202020;" class="pure-menu-link">栈&amp;队列</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/" style="color:#202020;" class="pure-menu-link">查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/" style="color:#202020;" class="pure-menu-link">滑动窗口</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/" style="color:#202020;" class="pure-menu-link">动态规划</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/" style="color:#202020;" class="pure-menu-link">二分查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/" style="color:#202020;" class="pure-menu-link">二叉树</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/" style="color:#202020;" class="pure-menu-link">背包问题</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/10/leetcode-hui-su/" style="color:#202020;" class="pure-menu-link">回溯</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/01/21/leetcode-tan-xin/" style="color:#202020;" class="pure-menu-link">贪心</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        Gacache分布式缓存
      </h1>
      <span>
        
        <time class="time" datetime="2020-06-01T16:00:00.000Z">
        2020-06-02
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gacache/" rel="tag">Gacache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" rel="tag">开源项目</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 32 分钟</span>
    </header>

    <div class="post-content">
      <h2 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h2><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#整体流程">整体流程</a></li>
<li><a href="#LRU队列">LRU队列</a></li>
<li><a href="#并发控制">并发控制</a></li>
<li><a href="#一致性Hash">一致性Hash</a><ul>
<li><a href="#实现">实现</a></li>
</ul>
</li>
<li><a href="#分布式节点通信">分布式节点通信</a><ul>
<li><a href="#Client端">Client端</a></li>
<li><a href="#Server端">Server端</a></li>
</ul>
</li>
<li><a href="#热点互备">热点互备</a><ul>
<li><a href="#思路">思路</a></li>
<li><a href="#测试">测试</a></li>
</ul>
</li>
<li><a href="#缓存击穿">缓存击穿</a><ul>
<li><a href="#复现">复现</a></li>
<li><a href="#解决方案">解决方案</a></li>
<li><a href="#测试-1">测试</a></li>
</ul>
</li>
<li><a href="#缓存穿透">缓存穿透</a><ul>
<li><a href="#复现-1">复现</a></li>
<li><a href="#解决方案1">解决方案</a></li>
</ul>
</li>
<li><a href="#TODO">TODO</a></li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本项目是模仿<a href="https://github.com/golang/groupcache" target="_blank" rel="noopener">groupcache</a>实现的一个分布式缓存库，其可以作为单独服务部署，亦可以作为一个<code>lib</code>来用，使用一致性Hash进行节点的选取和数据的分片，节点之间采用http协议进行通信，使用<a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">Protobuf</a>序列化数据进行传输，提高传输效率，节点之间支持热点数据互备，减少网络开销，同时还实现了并发访问控制机制，防止缓存击穿，相比于原项目，对热点互备的功能进行了增强</p>
<blockquote>
<p>本项目为练手项目，不可用于生产</p>
</blockquote>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="http://static.imlgw.top/blog/20200602/Glc7aMrySiqF.png?imageslim" alt="mark"></p>
<h2 id="LRU队列"><a href="#LRU队列" class="headerlink" title="LRU队列"></a>LRU队列</h2><p>因为缓存的数据都是在内存中的，内存资源是有限的，所以我们需要选择一种合适的策略，在内存快要满的时候剔除部分数据，这里选择了较为平衡且实现简单的方案LRU（最近最少使用）可以参考我之前的一篇博文 <a href="http://imlgw.top/2019/11/16/lrucache/">LRU队列的实现（Java）</a> 这里为了方便，以及避免重复造轮子，直接使用<code>container</code> 包中的<code>List</code>双向链表和<code>map</code>来实现，具体代码见 <a href="https://github.com/imlgw/gacache/blob/master/gacache/lru/lru.go" target="_blank" rel="noopener">gacache/lru/lru.go</a></p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>golang中的map并不是并发安全的容器，并发的访问可能会出现错误，所以我们需要加锁来控制并发的读写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu         sync.Mutex <span class="comment">//互斥锁</span></span><br><span class="line">    lru        *lru.Cache</span><br><span class="line">    cacheBytes <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">put</span><span class="params">(key <span class="keyword">string</span>, value ByteView)</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123; <span class="comment">//尚未初始化,lazyinit</span></span><br><span class="line">        c.lru = lru.New(c.cacheBytes, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.lru.Put(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value ByteView, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> v, ok := c.lru.Get(key); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v.(ByteView), ok</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h2><p>对于一个<strong>分布式缓存</strong>来讲，客户端在向某一个节点请求数据的时候，该节点应该如何去获取数据呢？是自己拿，还是去其他节点拿？如果这里不做处理，让当前节点自己去数据源取数据，那么最终可能每个节点都会缓存一份数据源的数据，这样不仅效率低下（需要和DB交互），而且浪费了很多空间，严格来说这就称不上是<strong>分布式缓存</strong>了，只能称之为<strong>缓存集群</strong></p>
<p>所以我们需要一个方案能够将<code>key</code>和节点对应起来，有一种比较简单的方案就是将<code>key</code>哈希后对节点数量取余，这样每次请求都会打到同一个节点，但是这样的方案扩展性和容错性比较差，如果节点的数量发生变化可能会导致大量缓存的迁移，一瞬间大量缓存都失效了，这就可能导致缓存雪崩，所以这里我采用<strong>一致性Hash算法</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>构造一个 <code>0 ~ 2^32-1</code> 大小的环</li>
<li>服务节点经过 hash 之后将定位到环中</li>
<li>将<code>key</code>哈希之后也定位到这个环中</li>
<li>顺时针找到离<code>hash(key)</code>最近的一个节点，也就是最终选择的缓存节点</li>
<li>考虑到服务节点的个数以及 hash 算法的问题导致环中的数据分布不均匀时引入了虚拟节点</li>
</ul>
<p><strong>一致性Hash的Map</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    hash     Hash           <span class="comment">//hash函数</span></span><br><span class="line">    replicas <span class="keyword">int</span>            <span class="comment">//虚拟节点倍数</span></span><br><span class="line">    keys     []<span class="keyword">int</span>          <span class="comment">//节点的地址,完整的协议/ip/port [eg. http://localhost:8001]</span></span><br><span class="line">    hashMap  <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> <span class="comment">//虚拟节点和真实节点映射关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加机器/节点的方法</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加机器/节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Add</span><span class="params">(keys ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//hashMap := make(map[string][]int, len(keys))</span></span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="comment">//每台机器copy指定倍数的虚拟节点</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.replicas; i++ &#123;</span><br><span class="line">            <span class="comment">//计算虚拟节点的 hash值</span></span><br><span class="line">            hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(strconv.Itoa(i) + key)))</span><br><span class="line">            <span class="comment">//添加到环上</span></span><br><span class="line">            m.keys = <span class="built_in">append</span>(m.keys, hash)</span><br><span class="line">            <span class="comment">//hashMap[key] = append(hashMap[key], hash)</span></span><br><span class="line">            <span class="comment">//记录映射关系</span></span><br><span class="line">            m.hashMap[hash] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fmt.Println(hashMap)</span></span><br><span class="line">    <span class="comment">//环上hash值进行排序</span></span><br><span class="line">    sort.Ints(m.keys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Get获取节点</strong></p>
<p>因为整个环是有序的，所以可以直接通过二分去找第一个大于等于<code>hash(key)</code>的节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(m.keys) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(key)))</span><br><span class="line">    <span class="comment">//二分找第一个大于等于hash的节点idx</span></span><br><span class="line">    idx := sort.Search(<span class="built_in">len</span>(m.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.keys[i] &gt;= hash</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> m.hashMap[m.keys[idx%<span class="built_in">len</span>(m.keys)]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式节点通信"><a href="#分布式节点通信" class="headerlink" title="分布式节点通信"></a>分布式节点通信</h2><p>集群之间的通信通过Http协议，同时采用<a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">Protobuf</a>序列化数据提高传输效率</p>
<h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>通过节点地址和<code>groupName</code>以及<code>key</code>构成的地址请求数据，通过<code>protobuf</code>解码数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpGetter)</span> <span class="title">Get</span><span class="params">(in *pb.Request, out *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    u := fmt.Sprintf(</span><br><span class="line">        <span class="string">"%v%v/%v"</span>,</span><br><span class="line">        h.baseURL,</span><br><span class="line">        url.QueryEscape(in.GetGroup()),</span><br><span class="line">        url.QueryEscape(in.GetKey()),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//通过http请求远程节点的数据</span></span><br><span class="line">    res, err := http.Get(u)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"server returned: %v"</span>, res.Status)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换成[]byte</span></span><br><span class="line">    bytes, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"reading response body: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解码proto并将结果存到out中</span></span><br><span class="line">    <span class="keyword">if</span> err != proto.Unmarshal(bytes, out) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"decoding response body : %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><p>实现<code>http.Handler</code>接口，对缓存中其他节点暴露地址，提供服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(req.URL.Path, p.basePath) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"HTTPPool serving unexpect path"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    p.Log(<span class="string">"%s %s"</span>, req.Method, req.URL.Path)</span><br><span class="line">    <span class="comment">// basePath/groupName/key</span></span><br><span class="line">    <span class="comment">// 以‘/’为界限将groupName和key划分为2个part</span></span><br><span class="line">    parts := strings.SplitN(req.URL.Path[<span class="built_in">len</span>(p.basePath):], <span class="string">"/"</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span> &#123;</span><br><span class="line">        http.Error(w, <span class="string">"bad request"</span>, http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    groupName := parts[<span class="number">0</span>]</span><br><span class="line">    key := parts[<span class="number">1</span>]</span><br><span class="line">    group := GetGroup(groupName)</span><br><span class="line">    <span class="keyword">if</span> group == <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, <span class="string">"no such group: "</span>+groupName, http.StatusNotFound)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    view, err := group.Get(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用proto编码Http响应</span></span><br><span class="line">    body, err := proto.Marshal(&amp;pb.Response&#123;Value: view.ByteSlice()&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</span><br><span class="line">    w.Write(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>一个存在的<code>key</code>突然失效，在失效的同时有大量的请求来请求这个<code>key</code>，这个时候大量请求就会直接打到DB，导致DB压力变大，甚至宕机</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>这里简单的演示缓存击穿的效果，我们用下面的脚本启动4个<code>cache server</code> 并且在端口号为<code>8004</code>的<code>server</code>上启动一个前端服务，用于和客户端交互</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start go run .  -port=8001</span><br><span class="line">start go run .  -port=8002</span><br><span class="line">start go run .  -port=8003</span><br><span class="line">start go run .  -port=8004 -api=1</span><br></pre></td></tr></table></figure>

<p>(windows平台的bat，其他平台可以用这个 <a href="https://github.com/imlgw/gacache/blob/master/test.sh" target="_blank" rel="noopener">test.sh</a>)</p>
<p>尝试了用window的批处理写并发访问的脚本，但是效果不是很好，所以直接用<code>go</code>写了个小脚本测试并发请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> curl(<span class="string">"resolmi"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curl</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    res, _ := http.Get(<span class="string">"http://localhost:9999/api?key="</span> + key)</span><br><span class="line">    bytes, _ := ioutil.ReadAll(res.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启5个<code>goroutine</code>，并发的去请求<code>resolmi</code>，此时<code>cache</code>肯定是没有这个key的，所以需要到DB中去取</p>
<p>然后就可以看到如下的情况：</p>
<p><img src="http://static.imlgw.top/blog/20200529/pU2omvLdDqyQ.png?imageslim" alt="mark"></p>
<p>前台<code>Server</code>收到了Get “resolmi”请求，通过一致性Hash选择了远程节点<code>port:8003</code></p>
<p><img src="http://static.imlgw.top/blog/20200529/uovtpKufQME4.png?imageslim" alt="mark"></p>
<p>可以看到，5次请求全部打到了<code>SlowDB</code>中！！这就说明发生了缓存穿透！请求穿过了缓存层，打到DB</p>
<blockquote>
<p>这里如果效果不明显可以尝试在<code>load</code>函数执行前加上一个<code>time.Sleep</code>，这样并发缓存击穿效果会更明显</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实常见的方案就两种：</p>
<p><strong>1. 缓存永不过期</strong></p>
<p>缓存值不设置<code>ttl</code>，而是在<code>value</code>中添加一个逻辑的过期时间，这样请求就不会直接穿透到DB，同时我们可以通过当前时间判断该key是否过期，如果过期了就启动一个异步线程去更新缓存，这种方式用户延迟是最低的，但是可能会造成缓存的不一致</p>
<p><strong>2. 互斥锁</strong></p>
<p>在第一个请求获取数据的时候设置一个<code>mutex</code>互斥锁，让其他请求阻塞，当前第一个请求请求到数据返回之后释放<code>mutex</code>锁，其他请求停止阻塞，然后直接从缓存中获取数据</p>
<p>因为我们的项目本身是不支持<code>ttl</code>和删除操作的，所以第一种方案不太适合，所以采用第二种互斥锁的方案，实现了一个<code>singleflight</code>结构来处理缓存击穿</p>
<p><strong>封装请求call</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装每个请求/调用</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125; <span class="comment">//请求的值</span></span><br><span class="line">    err error       <span class="comment">//err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//singleflight核心结构</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call <span class="comment">//key与call的映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>并发控制核心代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并发请求控制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        g.mu.Unlock() <span class="comment">//释放锁,按顺序进来</span></span><br><span class="line">        c.wg.Wait()   <span class="comment">//等着,等第一个请求完成</span></span><br><span class="line">        <span class="keyword">return</span> c.val, c.err</span><br><span class="line">    &#125;</span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()       <span class="comment">//这里释放锁，让其他请求进入上面的分支中wait(其实只有并发量大的时候才会进入上面的分支)</span></span><br><span class="line">    c.val, c.err = fn() <span class="comment">//请求数据</span></span><br><span class="line">    c.wg.Done()         <span class="comment">//获取到值,第一个请求结束,其他请求可以获取到值了</span></span><br><span class="line">    <span class="comment">//删除m中的key,避免key发生变化,而取到的还是旧值</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当多个并发的请求来请求同一个<code>key</code>的时候，只有<strong>第一个请求</strong>能拿到锁去DB中取数据，其他的请求就只能在方法外阻塞，当第一个请求构造好<code>call</code>就释放锁，这个时候其他并发的请求获取锁，进入阻塞的分支释放锁，然后再次阻塞，等待<strong>第一个请求</strong>获取到数据并封装进与<code>key</code>对应的<code>call</code>中，然后直接返回，不再向数据库请求，从而避免了缓存击穿</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>用<code>singleFlight</code>包装一下我们的<code>load</code>方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">view, err := g.loader.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> g.peers != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//根据一致性Hash选择节点Peer</span></span><br><span class="line">        <span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class="line">            <span class="comment">//从上面的Peer中获取数据</span></span><br><span class="line">            <span class="keyword">if</span> value, err = g.getFromPeer(peer, key); err == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            log.Println(<span class="string">"[Gacache] Fail to get from remote peer!!!"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.getLocally(key)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再次使用上面同样的脚本进行测试</p>
<p><img src="http://static.imlgw.top/blog/20200530/OThgxtFJrFIG.png?imageslim" alt="mark"></p>
<p>可以看到5个请求都成功了，我们再看看<code>log</code></p>
<p><img src="http://static.imlgw.top/blog/20200530/fsgxPPXNeVoo.png?imageslim" alt="mark"></p>
<p>可以看到，我请求了5次，但是实际上<code>getFromPeer</code>从远程节点取数据只执行了一次</p>
<p><img src="http://static.imlgw.top/blog/20200530/ChE0FxjwlYbl.png?imageslim" alt="mark"></p>
<p>从<code>SlowDB</code>的查询也只执行了一次，说明我们的<code>singleFlight</code>并发控制生效了！</p>
<h2 id="热点互备"><a href="#热点互备" class="headerlink" title="热点互备"></a>热点互备</h2><p>热点互备也是<code>groupcache</code>的特点之一，在源码注释中写到</p>
<blockquote>
<p>hotCache contains keys/values for which this peer is not authoritative (otherwise they would be in <strong>mainCache</strong>), but are popular enough to warrant mirroring in this process to avoid going over the network to fetch from a peer.  Having a hotCache avoids network hotspotting, where a peer’s network card could become the bottleneck on a popular key. This cache is used sparingly to maximize the total number of key/value pairs that can be stored globally.</p>
</blockquote>
<p>大致意思就是，<code>hotCache</code>中存储的主要是该节点没有的键值对（否则就在<code>mainCache</code>中了），但是这些键值对请求的非常频繁，所以需要保证在此过程中进行热点备份，避免通过网络从远程节点去获取，<code>hotCache</code>避免了网络热点，使节点的网卡成为热点<code>key</code>的瓶颈</p>
<p>但是在<code>groupcache</code>中对<code>hotCache</code>的处理只是随机的存储，每次从远程节点获取数据的时候有1/10的概率存储到<code>hotCache</code>中（<a href="https://github.com/golang/groupcache/blob/master/groupcache.go#L318" target="_blank" rel="noopener">code</a>）</p>
<p><img src="http://static.imlgw.top/blog/20200601/A0oPStJGqht3.png?imageslim" alt="mark"></p>
<p>可以看到这是一个TODO，注释中也提到了可以使用QPS来判断是否是热点<code>key</code>，所以我按照这个想法写了一个简单的统计</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们需要添加一个<code>hotCache</code>的结构，这个cache和<code>mainCache</code>一样，都是并发安全的<code>lru</code>队列，然后我们在向某个节点请求数据的时候就可以先从<code>mainCache</code>中请求如果没有就从<code>hotCache</code>中请求 ，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="string">"key nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;</span><br><span class="line">        log.Printf(<span class="string">"[GaCache (mainCache)] hit"</span>)</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add: hotCache</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := g.hotCache.get(key); ok &#123;</span><br><span class="line">        log.Printf(<span class="string">"[GaCache (hotCache)] hit"</span>)</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前节点没有数据,去其他地方加载</span></span><br><span class="line">    <span class="keyword">return</span> g.load(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后封装了一个<code>KeyStats</code>的结构，用于统计<code>key</code>的请求信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Key的统计信息</span></span><br><span class="line"><span class="keyword">type</span> KeyStats <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstGetTime time.Time <span class="comment">//第一次请求的时间</span></span><br><span class="line">    remoteCnt    AtomicInt <span class="comment">//请求的次数（利用atomic包封装的原子类）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，还需要将<code>key</code>和<code>KeyStats</code>对应，所以需要在cache的核心结构<code>Group</code>中加入映射关系</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    keys <span class="keyword">map</span>[<span class="keyword">string</span>]*KeyStats</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在节点请求远程节点的时候统计请求的信息，也就是<code>getFromPeer</code>函数中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从远程节点获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(peer PeerGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//构建proto的message</span></span><br><span class="line">    req := &amp;pb.Request&#123;</span><br><span class="line">        Group: g.name,</span><br><span class="line">        Key:   key,</span><br><span class="line">    &#125;</span><br><span class="line">    res := &amp;pb.Response&#123;&#125;</span><br><span class="line">    err := peer.Get(req, res)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"getFromPeer"</span>, key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//远程获取cnt++</span></span><br><span class="line">    <span class="keyword">if</span> stat, ok := g.keys[key]; ok &#123;</span><br><span class="line">        stat.remoteCnt.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//计算QPS</span></span><br><span class="line">        interval := <span class="keyword">float64</span>(time.Now().Unix()-stat.firstGetTime.Unix()) / <span class="number">60</span></span><br><span class="line">        qps := stat.remoteCnt.Get() / <span class="keyword">int64</span>(math.Max(<span class="number">1</span>, math.Round(interval)))</span><br><span class="line">        <span class="keyword">if</span> qps &gt;= maxMinuteRemoteQPS &#123;</span><br><span class="line">            <span class="comment">//存入hotCache</span></span><br><span class="line">            g.populateCache(key, ByteView&#123;b: res.Value&#125;, &amp;g.hotCache)</span><br><span class="line">            <span class="comment">//删除映射关系,节省内存</span></span><br><span class="line">            mu.Lock()</span><br><span class="line">            <span class="built_in">delete</span>(g.keys, key)</span><br><span class="line">            mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//第一次获取</span></span><br><span class="line">        g.keys[key] = &amp;KeyStats&#123;</span><br><span class="line">            firstGetTime: time.Now(),</span><br><span class="line">            remoteCnt:    <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ByteView&#123;b: res.Value&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>maxMinuteRemoteQPS</code>是一个常量，每个key每分钟远程请求最大的QPS，每次向远程节点请求数据的时候计算当前<code>key</code>第一次获取的时间到目前为止的QPS，如果大于阈值<code>maxMinuteRemoteQPS</code>，就会将其存入<code>hotCache</code>中，之后就可以直接从<code>hotCache</code>中获取数据，而不用在通过网络去获取</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>同样使用前面的go脚本来测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//go curl("resolmi")</span></span><br><span class="line">        <span class="comment">//i not exist</span></span><br><span class="line">        <span class="comment">//go curl(strconv.Itoa(i))</span></span><br><span class="line">        time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        curl(<span class="string">"resolmi"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curl</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    res, _ := http.Get(<span class="string">"http://localhost:9999/api?key="</span> + key)</span><br><span class="line">    bytes, _ := ioutil.ReadAll(res.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里请求不要请求太快，如果一个key请求的太快会被<code>singleFlight</code>并发控制组件拦截，多数请求不会走网络（这个组件作用还是挺大的），所以并没有使用<code>goroutine</code>，而是正常的调用，并且中间停顿0.5s</p>
</blockquote>
<p>这里为了方便模拟，我设置了 <code>maxMinuteRemoteQPS = 10</code> ，上面的脚本一分钟之内会请求<code>“resolmi”</code> 20次，这个<code>key</code>的分片已知是远程节点（8003）的，所以会在第10次的时候触发<code>hotCache</code>，将数据存入当前节点（8004）的<code>hotCache</code>中，后续的请求就会直接从<code>hotCache</code>中取，如下图所演示</p>
<p><img src="http://static.imlgw.top/blog/20200602/hKH8u6E1gpcA.gif" alt="mark"></p>
<p>可以看到效果确实达到了，但是这样做有一个比较大的缺点就是内存耗费会比原来大，需要额外维护一个map，不过这部分信息并不大，仅仅需要存储<code>key</code>和对应<code>keyStats</code> ，key的长度一般不会很长，<code>keyStats</code> 的长度是固定的，一个<code>time</code>和一个<code>int64</code>，所以一定程度上还是可行的。</p>
<blockquote>
<p>这种方案只是我能想到的一种比较简单的处理方法，肯定会有更好的处理方式。但是截至目前（2020.6.2）<code>groupcache</code>中没有对这里进行改进，如果以后有更新可以再学习下</p>
</blockquote>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB就会导致宕机</p>
<h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>使用上面的脚本再次启动<code>Cache Server</code>，然后用下面的go代码测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//go curl("resolmi")</span></span><br><span class="line">        <span class="comment">//i not exist</span></span><br><span class="line">        <span class="keyword">go</span>  curl(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curl</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    res, _ := http.Get(<span class="string">"http://localhost:9999/api?key="</span> + key)</span><br><span class="line">    bytes, _ := ioutil.ReadAll(res.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里需要构造不同的key，相同的key会被前面的<code>singleFlight</code>组件拦截</p>
</blockquote>
<p>结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[ <span class="string">`go run .`</span> | done: <span class="number">1.8734423</span>s ]</span><br><span class="line">  <span class="number">1</span> not exist</span><br><span class="line">  <span class="number">2</span> not exist</span><br><span class="line">  <span class="number">0</span> not exist</span><br><span class="line">  <span class="number">4</span> not exist</span><br><span class="line">  <span class="number">3</span> not exist</span><br><span class="line">  Done!</span><br></pre></td></tr></table></figure>

<p>然后我们看看<code>Server</code>的情况</p>
<p><img src="http://static.imlgw.top/blog/20200531/kV5ojfIeddm4.png?imageslim" alt="mark"></p>
<p>可以看到，5个<code>key</code>通过一致性Hash分散到不同的节点，但是由于<code>DB</code>中根本就没有这些数据，所以这些数据并不会缓存，每次查询都会到<code>DB</code>中去重新查询，如果短时间内有大量请求查询这些根本不存在的数据，那么这些请求都会直接打到DB层，将DB层压垮！</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>1.缓存空对象</strong></p>
<p>之所以发生缓存穿透，是因为缓存中没有存储这些空数据的key，导致这些请求全都打到数据库上。那么，我们可以稍微修改一下业务层的代码，将数据库查询结果为空的key也存储在缓存中。当后续又出现该key的查询请求时，缓存直接返回null，而无需查询数据库。</p>
<p><strong>2.布隆过滤器</strong></p>
<p>当业务层有查询请求的时候，首先去<code>BloomFilter</code>中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。</p>
<p>这里第一个种方案可以直接排除，一方面因为我们这个cache是不能删除数据的，只能被动的淘汰数据，缓存大量的空对象且得不到及时的删除会浪费大量内存，另一方面，缓存空对象的做法，如果每次查询的不存在的<code>key</code>都不一样，那么这种方案也就起不到作用了</p>
<p>至于第二种方案，可行，但是不应该在缓存层来做，应该在业务层处理，也就是在上层处理，因为这是一个分布式的缓存组件，每个节点的数据都是不一样的，用布隆过滤器你只能判断在<strong>当前节点</strong>有没有，无法判断<strong>远程节点</strong>有没有，所以一开始就要将所有数据预热到布隆过滤器中，但是这样每一个节点都会需要一个布隆过滤器，这样做没有任何意义，所以缓存穿透的问题应该放到应用层去处理</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 分布式节点通信</li>
<li><input checked="" disabled="" type="checkbox"> 一致性Hash</li>
<li><input checked="" disabled="" type="checkbox"> 缓存击穿</li>
<li><input checked="" disabled="" type="checkbox"> 布隆过滤器</li>
<li><input checked="" disabled="" type="checkbox"> 热点互备</li>
<li><input disabled="" type="checkbox"> 配置解耦</li>
<li><input disabled="" type="checkbox"> 集群管理</li>
</ul>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TOC"><span class="toc-text">TOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整体流程"><span class="toc-text">整体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU队列"><span class="toc-text">LRU队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发控制"><span class="toc-text">并发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一致性Hash"><span class="toc-text">一致性Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式节点通信"><span class="toc-text">分布式节点通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Client端"><span class="toc-text">Client端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server端"><span class="toc-text">Server端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存击穿"><span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复现"><span class="toc-text">复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方案"><span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#热点互备"><span class="toc-text">热点互备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思路"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试-1"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存穿透"><span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复现-1"><span class="toc-text">复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方案-1"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO"><span class="toc-text">TODO</span></a></li></ol>
  </div>


  </div>
</div>


    <section id="comments" style="margin:10px;padding:10px;background:#fff;">
      <div id="vcomment" class="comment"></div> 
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
   var notify = 'false' == true ? true : false;
   var verify = 'true' == true ? true : false;
    window.onload = function() {
        new Valine({
            el: '.comment',
            notify: notify,
            verify: verify,
            app_id: "MkcXmeDvktRNBDBrVqb9KYPH-MdYXbMMI",
            app_key: "swDnb5a9u9Ksp2Rwkdm7Qulh",
            placeholder: "留下邮箱才能收到收到回复喔 ~",
            avatar:"monsterid"
        });
    }
</script>
    </section>
  
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/05/27/linux-de-wen-jian-quan-xian-yu-mu-lu-pei-zhi/" rel="next" title="Linux文件权限和目录配置">
          Linux文件权限和目录配置
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
      </div>
    </div>
  

    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/imlgw" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="https://imlgw.avosapps.us/" target="_blank" rel="noopener">博客评论管理</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body>
</html>
