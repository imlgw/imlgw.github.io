
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="算法," />
  

  
    <meta name="description" content="大悲无泪，大悟无言，大笑无声。" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/img/cat.ico">
  
  <title>DP：数字三角形模型 [ iMlGw0 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">iMlGw0</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">分类</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">归档</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">标签</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="算法" class="pure-menu-link">算法</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/05/04/leetcode-shu-zu/" style="color:#202020;" class="pure-menu-link">数组</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/" style="color:#202020;" class="pure-menu-link">链表</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/" style="color:#202020;" class="pure-menu-link">栈&amp;队列</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/" style="color:#202020;" class="pure-menu-link">查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/" style="color:#202020;" class="pure-menu-link">滑动窗口</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/" style="color:#202020;" class="pure-menu-link">动态规划</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/" style="color:#202020;" class="pure-menu-link">二分查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/" style="color:#202020;" class="pure-menu-link">二叉树</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/" style="color:#202020;" class="pure-menu-link">背包问题</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/10/leetcode-hui-su/" style="color:#202020;" class="pure-menu-link">回溯</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/01/21/leetcode-tan-xin/" style="color:#202020;" class="pure-menu-link">贪心</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/07/03/leetcode-wei-yun-suan/" style="color:#202020;" class="pure-menu-link">位运算</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/08/28/leetcode-dan-diao-zhan/" style="color:#202020;" class="pure-menu-link">单调栈</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">Github</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        DP：数字三角形模型
      </h1>
      <span>
        
        <time class="time" datetime="2020-11-09T02:03:32.434Z">
        2020-11-09
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 22 分钟</span>
    </header>

    <div class="post-content">
      <blockquote>
<p>现在打算写一些短点的文章了，LeetCode系列不会再append了，如果写lc题会单独开一篇文章，然后写题解</p>
</blockquote>
<h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a><em>数字三角形模型</em></h2><p><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">120. 三角形最小路径和</a></p>
<p><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">64. 最小路径和</a></p>
<p><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#Path-sum-three-ways">Path sum: three ways</a></p>
<p>之前写过题解的就不重复写了，还有很多类似的题就不一一列举出来了，详见<a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/">LeetCode动态规划</a></p>
<blockquote>
<p>后续如果还有类似的题会append进来</p>
</blockquote>
<h2 id="1027-方格取数"><a href="#1027-方格取数" class="headerlink" title="1027. 方格取数"></a><a href="https://www.acwing.com/problem/content/1029/" target="_blank" rel="noopener">1027. 方格取数</a></h2><p>设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：</p>
<p><img src="https://files.catbox.moe/hhonhx.png" alt=""></p>
<p>某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。</p>
<p>在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。</p>
<p>此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p>
<p><strong>输入格式</strong></p>
<p>第一行为一个整数N，表示 N×N 的方格图。</p>
<p>接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。</p>
<p>行和列编号从 1 开始。</p>
<p>一行“0 0 0”表示结束。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示两条路径上取得的最大的和。</p>
<p><strong>数据范围</strong></p>
<p>N≤10</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">13</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">21</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">14</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure>
<p><strong>难度：</strong> 简单</p>
<p><strong>来源：</strong>《信息学奥赛一本通》 , NOIP2000提高组</p>
<p><strong>解法一</strong></p>
<p>一开始确实没想出来，主要是看着范围好小，然后不确定复杂度，以为可以搜索的，看了y总讲解了一点，然后想过来了，自己写了一个N^4的解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//input output省略</span></span><br><span class="line"><span class="comment">//N^4 dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span>[][] w, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][N+<span class="number">1</span>][N+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt;= N; i1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">1</span>; j1 &lt;= N; j1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">1</span>; i2 &lt;= N; i2++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">1</span>; j2 &lt;= N; j2++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = dp[i1][j1][i2][j2];</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1][i2-<span class="number">1</span>][j2]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1][i2][j2-<span class="number">1</span>]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1][j1-<span class="number">1</span>][i2-<span class="number">1</span>][j2]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1][j1-<span class="number">1</span>][i2][j2-<span class="number">1</span>]);</span><br><span class="line">                    dp[i1][j1][i2][j2] = temp + ((i1==i2&amp;&amp;j1==j2) ? w[i1-<span class="number">1</span>][j1-<span class="number">1</span>] : (w[i1-<span class="number">1</span>][j1-<span class="number">1</span>] + w[i2-<span class="number">1</span>][j2-<span class="number">1</span>])); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][N][N][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实如果是只有一条路径就很简单，线性DP就行了，<code>dp[i][j] = Max(dp[i-1][j], dp[i][j-1])</code>，但是这题涉及到了两条路径，所以我们可以将状态定义为<code>dp[i1][j1][i2][j2]</code>，含义为从（1，1）到（i1，j1）,(i2，j2)这两个点的最大和，到每个点有两种走法，2*2一共4种子状态，取Max就行了</p>
<p>但是这里会有一个问题，某个点的val被取走之后就不能再被取了。也就是说，这两条路径可能会有交点，这种情况需要额外处理，而相交的情况实际上也就是<code>i1==i2 &amp;&amp; j1 == j2</code>的时候，这种情况交点的值就只能算一次</p>
<p><strong>解法二</strong></p>
<p>y总讲的解法，优化了一维状态，N^3的解法，非常的巧妙，因为只能向下和向右走，所以从（1，1）到（N-1，N-1），走的总步数一定是<code>2*N</code>，那么我们就可以通过步数K计算出另一个坐标，从而省去一维状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N^3优化，根据走的总步数计算另一个坐标位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">slove2</span><span class="params">(<span class="keyword">int</span>[][] w, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*N+<span class="number">1</span>][N+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">2</span>*N; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt;= N; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">1</span>; i2 &lt;= N; i2++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j1 = k-i1, j2 = k-i2;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;= j1 &amp;&amp; j1 &lt;= N &amp;&amp; <span class="number">1</span> &lt;= j2 &amp;&amp; j2 &lt;= N) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = dp[k][i1][i2]; </span><br><span class="line">                    temp = Math.max(temp, dp[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2-<span class="number">1</span>]);</span><br><span class="line">                    temp = Math.max(temp, dp[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2]);</span><br><span class="line">                    temp = Math.max(temp, dp[k-<span class="number">1</span>][i1][i2-<span class="number">1</span>]);</span><br><span class="line">                    temp = Math.max(temp, dp[k-<span class="number">1</span>][i1][i2]);</span><br><span class="line">                    dp[k][i1][i2] = temp + ((i1==i2&amp;&amp;j1==j2) ? w[i1-<span class="number">1</span>][j1-<span class="number">1</span>] : (w[i1-<span class="number">1</span>][j1-<span class="number">1</span>] + w[i2-<span class="number">1</span>][j2-<span class="number">1</span>]));     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>*N][N][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="275-传纸条"><a href="#275-传纸条" class="headerlink" title="275. 传纸条"></a><a href="https://www.acwing.com/problem/content/277/" target="_blank" rel="noopener">275. 传纸条</a></h2><p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。</p>
<p>一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。</p>
<p>幸运的是，他们可以通过传纸条来进行交流。</p>
<p>纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。</p>
<p>从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 </p>
<p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。</p>
<p>班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 </p>
<p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。</p>
<p>小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。</p>
<p>现在，请你帮助小渊和小轩找到这样的两条路径。</p>
<p><strong>输入格式</strong></p>
<p>第一行有2个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。</p>
<p>接下来的 m 行是一个 m∗n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p>
<p><strong>数据范围:</strong></p>
<p>1≤n,m≤50</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure>
<p><strong>解法一</strong></p>
<p>和上面一题一样，虽然题目说的是一个从左上向右下，一个是从右下到左上，但是实际上依然是要求两条路径连接左上到右下，使得和最大，所以实际上直接照搬上面的代码就ok了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N^3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[][] w, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+n+<span class="number">1</span>][m+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= m+n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt;= m; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">1</span>; i2 &lt;= m; i2++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">                <span class="keyword">if</span> (j1 &lt; <span class="number">1</span> || j1 &gt; n || j2 &lt; <span class="number">1</span> || j2 &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> temp = dp[k][i1][i2]; </span><br><span class="line">                temp = Math.max(temp, dp[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2]);</span><br><span class="line">                temp = Math.max(temp, dp[k-<span class="number">1</span>][i1][i2-<span class="number">1</span>]);</span><br><span class="line">                temp = Math.max(temp, dp[k-<span class="number">1</span>][i1][i2]);</span><br><span class="line">                temp = Math.max(temp, dp[k-<span class="number">1</span>][i1-<span class="number">1</span>][i2-<span class="number">1</span>]);</span><br><span class="line">                dp[k][i1][i2] = temp + (i1==i2 ? w[i1-<span class="number">1</span>][j1-<span class="number">1</span>] : (w[i1-<span class="number">1</span>][j1-<span class="number">1</span>] + w[i2-<span class="number">1</span>][j2-<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m+n][m][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1463-摘樱桃-II"><a href="#1463-摘樱桃-II" class="headerlink" title="1463. 摘樱桃 II"></a><a href="https://leetcode-cn.com/problems/cherry-pickup-ii/" target="_blank" rel="noopener">1463. 摘樱桃 II</a></h2><p>Difficulty: <strong>困难</strong></p>
<p>给你一个 <code>rows x cols</code> 的矩阵 <code>grid</code> 来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<ul>
<li>从格子 <code>(i,j)</code> 出发，机器人可以移动到格子 <code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者 <code>(i+1, j+1)</code> 。</li>
<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>
<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>
<li>两个机器人在任意时刻都不能移动到 <code>grid</code> 外面。</li>
<li>两个机器人最后都要到达 <code>grid</code> 最底下一行。</li>
</ul>
<p>给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://files.catbox.moe/da5rxh.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：机器人 <span class="number">1</span> 和机器人 <span class="number">2</span> 的路径在上图中分别用绿色和蓝色表示。</span><br><span class="line">机器人 <span class="number">1</span> 摘的樱桃数目为 (<span class="number">3</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">2</span>) = <span class="number">12</span> 。</span><br><span class="line">机器人 <span class="number">2</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span>) = <span class="number">12</span> 。</span><br><span class="line">樱桃总数为： <span class="number">12</span> + <span class="number">12</span> = <span class="number">24</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://i.loli.net/2020/11/10/aSykAceXPH1snjM.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：机器人 <span class="number">1</span> 和机器人 <span class="number">2</span> 的路径在上图中分别用绿色和蓝色表示。</span><br><span class="line">机器人 <span class="number">1</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">9</span> + <span class="number">5</span> + <span class="number">2</span>) = <span class="number">17</span> 。</span><br><span class="line">机器人 <span class="number">2</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">3</span>) = <span class="number">11</span> 。</span><br><span class="line">樱桃总数为： <span class="number">17</span> + <span class="number">11</span> = <span class="number">28</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">22</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>rows == grid.length</li>
<li>cols == grid[i].length</li>
<li>2 &lt;= rows, cols &lt;= 70</li>
<li>0 &lt;= grid[i][j] &lt;= 100 </li>
</ul>
<p><strong>解法一</strong></p>
<p>本来只写了前两题就打算push的，y总也只讲了这几道题，但是突然想起来很久之前的一道周赛题（27th双周赛T4），大概半年前了，没想到居然能想起来😄，看了下，和上面两题是一样的，随手写了下，一开始写的有bug，调试了好一会儿，最后把状态打出来手推了下，发现有些状态没有初始化好，导致递推的时候使用了非法的状态</p>
<p>先上暴力N^4的解法，这题范围不大，N^4勉强能扛过去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力N^4解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cherryPickup2</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">2</span>][m+<span class="number">1</span>][n+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> INF = -<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt;= m; i1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt;= n+<span class="number">1</span>; j1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt;= m; i2++) &#123;</span><br><span class="line">                Arrays.fill(dp[i1][j1][i2], INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][n] = grid[<span class="number">0</span>][<span class="number">0</span>]+grid[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">2</span>; i1 &lt;= m; i1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">1</span>; j1 &lt;= n; j1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">2</span>; i2 &lt;= m; i2++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">1</span>; j2 &lt;= n; j2++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = INF;</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1][i2-<span class="number">1</span>][j2]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1][i2-<span class="number">1</span>][j2+<span class="number">1</span>]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1][i2-<span class="number">1</span>][j2-<span class="number">1</span>]);</span><br><span class="line">                    </span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1+<span class="number">1</span>][i2-<span class="number">1</span>][j2]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1+<span class="number">1</span>][i2-<span class="number">1</span>][j2+<span class="number">1</span>]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1+<span class="number">1</span>][i2-<span class="number">1</span>][j2-<span class="number">1</span>]);   </span><br><span class="line">                    </span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1-<span class="number">1</span>][i2-<span class="number">1</span>][j2]);</span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1-<span class="number">1</span>][i2-<span class="number">1</span>][j2+<span class="number">1</span>]);   </span><br><span class="line">                    temp = Math.max(temp, dp[i1-<span class="number">1</span>][j1-<span class="number">1</span>][i2-<span class="number">1</span>][j2-<span class="number">1</span>]);</span><br><span class="line">                    dp[i1][j1][i2][j2] = temp + ((i1==i2&amp;&amp;j1==j2) ? grid[i1-<span class="number">1</span>][j1-<span class="number">1</span>] : (grid[i1-<span class="number">1</span>][j1-<span class="number">1</span>] + grid[i2-<span class="number">1</span>][j2-<span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt;= n; j1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt;= n; j2++) &#123;</span><br><span class="line">            res = Math.max(res, dp[m][j1][m][j2]);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>和上面两题一样，两个机器人走的层数是固定的，都是m层，所以可以优化掉一维的状态，同时上面的写法看起来也很ugly，可以用方向变量简化写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N^3解法，优化代码写法，简化代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dir = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//这题求最大值，在dp数组上边和左右两边各加一行作为边界</span></span><br><span class="line">    <span class="comment">//这里也可以用滚动数组优化下空间</span></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> INF = -<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="comment">//全部初始化为INF（实际上初始化两边和最上面的就ok了）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= m; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt;= n+<span class="number">1</span>; j1++) &#123;</span><br><span class="line">            Arrays.fill(dp[r][j1], INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][n] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= m; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">1</span>; j1 &lt;= n; j1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">1</span>; j2 &lt;= n; j2++) &#123;</span><br><span class="line">                <span class="comment">//方向向量，简化写法</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d1 = <span class="number">0</span>; d1 &lt; <span class="number">3</span>; d1++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> d2 = <span class="number">0</span>; d2 &lt; <span class="number">3</span>; d2++) &#123;</span><br><span class="line">                        dp[r][j1][j2] = Math.max(dp[r][j1][j2], dp[r-<span class="number">1</span>][j1+dir[d1]][j2+dir[d2]]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[r][j1][j2] += (j1==j2 ? grid[r-<span class="number">1</span>][j1-<span class="number">1</span>] : (grid[r-<span class="number">1</span>][j1-<span class="number">1</span>] + grid[r-<span class="number">1</span>][j2-<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt;= n; j1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt;= n; j2++) &#123;</span><br><span class="line">            res = Math.max(res, dp[m][j1][j2]);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数字三角形模型"><span class="toc-text">数字三角形模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1027-方格取数"><span class="toc-text">1027. 方格取数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#275-传纸条"><span class="toc-text">275. 传纸条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1463-摘樱桃-II"><span class="toc-text">1463. 摘樱桃 II</span></a></li></ol>
  </div>


  </div>
</div>


    <section id="comments" style="margin:10px;padding:10px;background:#fff;">
      <div id="vcomment" class="comment"></div> 
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
   var notify = 'false' == true ? true : false;
   var verify = 'false' == true ? true : false;
    window.onload = function() {
        new Valine({
            el: '.comment',
            notify: notify,
            verify: verify,
            app_id: "MkcXmeDvktRNBDBrVqb9KYPH-MdYXbMMI",
            app_key: "swDnb5a9u9Ksp2Rwkdm7Qulh",
            placeholder: "留下邮箱才能收到回复喔 ~",
            avatar:"monsterid"
        });
    }
</script>
    </section>
  
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/08/28/leetcode-dan-diao-zhan/" rel="next" title="LeetCode单调栈">
          LeetCode单调栈
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/11/14/dp-zui-chang-shang-sheng-zi-xu-lie-mo-xing/" rel="prev" title="DP：最长上升子序列模型">
            DP：最长上升子序列模型
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/imlgw" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="https://imlgw.avosapps.us/" target="_blank" rel="noopener">博客评论管理</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body>
</html>
