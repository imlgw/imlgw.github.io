
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="LeetCode,贪心," />
  

  
    <meta name="description" content="大悲无泪，大悟无言，大笑无声。" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/img/cat.ico">
  
  <title>LeetCode贪心 [ iMlGw0 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">iMlGw0</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">分类</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">归档</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">标签</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="LC" class="pure-menu-link">LC</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/05/04/leetcode-shu-zu/" style="color:#202020;" class="pure-menu-link">数组</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/" style="color:#202020;" class="pure-menu-link">链表</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/" style="color:#202020;" class="pure-menu-link">栈&amp;队列</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/" style="color:#202020;" class="pure-menu-link">查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/" style="color:#202020;" class="pure-menu-link">滑动窗口</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/" style="color:#202020;" class="pure-menu-link">动态规划</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/" style="color:#202020;" class="pure-menu-link">二分查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/" style="color:#202020;" class="pure-menu-link">二叉树</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/" style="color:#202020;" class="pure-menu-link">背包问题</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/10/leetcode-hui-su/" style="color:#202020;" class="pure-menu-link">回溯</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/01/21/leetcode-tan-xin/" style="color:#202020;" class="pure-menu-link">贪心</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        LeetCode贪心
      </h1>
      <span>
        
        <time class="time" datetime="2020-01-20T16:00:00.000Z">
        2020-01-21
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 50 分钟</span>
    </header>

    <div class="post-content">
      <h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>注意：</strong></p>
<p>你可以假设胃口值为正。<br>一个小朋友最多只能拥有一块饼干</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，<span class="number">3</span>个孩子的胃口值分别是：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是<span class="number">1</span>，你只能让胃口值是<span class="number">1</span>的孩子满足。</span><br><span class="line">所以你应该输出<span class="number">1</span>。</span><br></pre></td></tr></table></figure>


<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，<span class="number">2</span>个孩子的胃口值分别是<span class="number">1</span>,<span class="number">2</span>。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出<span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>贪就完事儿了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g==<span class="keyword">null</span> || s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i]&lt;=s[index]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="274-H指数"><a href="#274-H指数" class="headerlink" title="274. H指数"></a><a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">274. H指数</a></h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p>
<p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）<del>至多</del>有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: citations = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 给定数组表示研究者总共有 <span class="number">5</span> 篇论文，每篇论文相应的被引用了 <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span> 次。</span><br><span class="line">     由于研究者有 <span class="number">3</span> 篇论文每篇至少被引用了 <span class="number">3</span> 次，其余两篇论文每篇被引用不多于 <span class="number">3</span> 次，所以她的 h 指数是 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 如果 h 有多种可能的值，h 指数是其中最大的那个。</p>
<p><strong>解法一</strong></p>
<p>题目意思搞懂就ok</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=citations.length;</span><br><span class="line">    Arrays.sort(citations);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (citations[i]&lt;=len-(i+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> len-(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"abc"</span>, t = <span class="string">"ahbgdc"</span></span><br><span class="line">返回 <span class="keyword">true</span>.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"axc"</span>, t = <span class="string">"ahbgdc"</span></span><br><span class="line">返回 <span class="keyword">false</span>.</span><br></pre></td></tr></table></figure>

<p><strong>后续挑战 :</strong></p>
<p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || t==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sindex=<span class="number">0</span>,tindex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sindex&lt;s.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tindex&lt;t.length() &amp;&amp; sindex&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(sindex)==t.charAt(tindex)) &#123;</span><br><span class="line">                sindex++;</span><br><span class="line">            &#125;</span><br><span class="line">            tindex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tindex==t.length()) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sindex==s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改成递归（多练习递归）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s,String t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subsequence(s,t,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">subsequence</span><span class="params">(String s,String t,<span class="keyword">int</span> sindex,<span class="keyword">int</span> tindex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sindex == s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上下if不能交换,可能最后一个才相等</span></span><br><span class="line">    <span class="keyword">if</span> (tindex == t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.charAt(sindex)==t.charAt(tindex)?subsequence(s,t,sindex+<span class="number">1</span>,tindex+<span class="number">1</span>):subsequence(s,t,sindex,tindex+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大量的s字符串 处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence3</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; hash=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">        hash.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++) &#123;</span><br><span class="line">        hash.get(t.charAt(i)-<span class="string">'a'</span>).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过上面的预处理,后面的处理就会很快,不用再遍历t字符串</span></span><br><span class="line">    <span class="keyword">int</span> lastIndex=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; indexList=hash.get(s.charAt(i)-<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">int</span> temp=binarySearch(indexList,lastIndex);</span><br><span class="line">        <span class="keyword">if</span> (temp==indexList.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastIndex=indexList.get(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个比target大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=list.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.get(mid)&gt;target) &#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a></h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p>
<p>然而，两个<strong>相同种类</strong>的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的<strong>最短时间</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: tasks = [<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>], n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">8</span></span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>任务的总个数为 <code>[1, 10000]</code></li>
<li>n 的取值范围为 <code>[0, 100]</code></li>
</ul>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tasks.length;i++) &#123;</span><br><span class="line">        map[tasks[i]-<span class="string">'A'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找最大值</span></span><br><span class="line">    <span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map.length;i++) &#123;</span><br><span class="line">        max=Math.max(map[i],max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[i]==max) &#123;</span><br><span class="line">            maxCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比如 a b c d e f g,n=1</span></span><br><span class="line">    <span class="keyword">return</span> Math.max((n+<span class="number">1</span>)*(max-<span class="number">1</span>)+maxCount,tasks.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心思想就是将出现次数最多的任务优先执行并且尽可能的分散，比如  <code>A A A B B C n=2</code> 最短的时间就是<code>A X X A X X A</code> ，最终的时间就是<code>(n+1)*(max-1)+1</code> 也就是 <code>(2+1) *(3-1)+1=7</code>， 但是可能会有多个最多次数的任务，所以我们还需要加上最多的相同的个数，最后就是 <code>(n+1)*(max-1)+maxCount</code> ，但是还不够，还是有可能会出现代码中的例子，也就是最后得到的结果比我们的任务列表还有短，所以我们需要取一个最大值</p>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 无论怎样，你总会到达索引为 <span class="number">3</span> 的位置。但该位置的最大跳跃长度是 <span class="number">0</span> ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>回溯，勉强能过。。。太蠢了，为啥想不到简单的方法，就非得往复杂了想？就这么傻么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Boolean[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    cache=<span class="keyword">new</span> Boolean[nums.length];</span><br><span class="line">    <span class="keyword">return</span> jump(nums,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[index] &gt;= nums.length-<span class="number">1</span> -index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache[index]!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums[index];i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index+i&lt;nums.length &amp;&amp; jump(nums,index+i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[index]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[index]=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>不用多说了，遍历数组，不断更新能到达的最远距离，如果<strong>某个位置的index大于当前能到达的最远距离就直接返回false</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MDZZ</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxIndex &gt;= nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;maxIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxIndex=Math.max(maxIndex,i+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 <span class="number">2</span>。</span><br><span class="line">     从下标为 <span class="number">0</span> 跳到下标为 <span class="number">1</span> 的位置，跳 <span class="number">1</span> 步，然后跳 <span class="number">3</span> 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<p><strong>解法一</strong></p>
<p>兴致勃勃写了个dp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        dp[i]=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]&gt;=i-j) &#123;</span><br><span class="line">                dp[i]=Math.min(dp[j]+<span class="number">1</span>,dp[i]);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这就过了那你也太小瞧这题了😂人家可是hard题，那能这么容易就让你过了？</p>
<p>没错，这里直接TLE了，最后一个CASE过不去</p>
<p><strong>解法二</strong></p>
<p>贪心，核心思想不是每次都跳到最远的地方，<strong>而是跳到当前位置能跳到的最远的位置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次选能跳的位置中跳的最远的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;<span class="comment">//最大边界</span></span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>,curMaxIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        curMaxIndex=Math.max(curMaxIndex,nums[i]+i); <span class="comment">//i能跳的位置中,跳的最远的</span></span><br><span class="line">        <span class="keyword">if</span> (i==max) &#123;<span class="comment">//走到边界就++</span></span><br><span class="line">            step++;</span><br><span class="line">            max=curMaxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码需要细细品，一下可能看不太明白</p>
<p><strong>解法三</strong></p>
<p>回顾的时候这道题始终是没搞清楚，<a href="https://leetcode-cn.com/problems/jump-game-ii/solution/xun-huan-bu-bian-shi-fen-xi-cban-by-huai-an-2/" target="_blank" rel="noopener">看了一个大佬的题解</a> （这个大佬好像是个初中的妹子）后明白了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参考了一个大佬循环不变表达式的分析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前这一跳能选择的最远距离</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//目前能达到的最远距离</span></span><br><span class="line">    <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ptr=<span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right&lt;nums.length-<span class="number">1</span>) &#123;</span><br><span class="line">        left=right;</span><br><span class="line">        <span class="keyword">while</span>(ptr&lt;nums.length &amp;&amp; ptr&lt;=left) &#123;</span><br><span class="line">            right=Math.max(right,nums[ptr]+ptr);</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></h2><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>


<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>思路也没啥好说的，类似贪心吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals ==<span class="keyword">null</span> || intervals.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    LinkedList&lt;<span class="keyword">int</span>[]&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">1</span>]&gt;intervals[i-<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                intervals[i][<span class="number">0</span>]=intervals[i-<span class="number">1</span>][<span class="number">0</span>];   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intervals[i][<span class="number">0</span>]=intervals[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>]=intervals[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list.add(intervals[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(intervals[intervals.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/*  int[][] res=new int[list.size()][2];</span></span><br><span class="line"><span class="comment">        for (int i=0;i&lt;list.size();i++) &#123;</span></span><br><span class="line"><span class="comment">            res[i][0]=list.get(i)[0];</span></span><br><span class="line"><span class="comment">            res[i][1]=list.get(i)[1];</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//题解哪里学到一招</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大的收获就是学到了一招list转array的方法😁</p>
<p>偶然看到，简化下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update：2020.4.16</span></span><br><span class="line"><span class="comment">//偶然看到,简化下代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals ==<span class="keyword">null</span> || intervals.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    LinkedList&lt;<span class="keyword">int</span>[]&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            intervals[i][<span class="number">0</span>]=intervals[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            intervals[i][<span class="number">1</span>]=Math.max(intervals[i-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list.add(intervals[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(intervals[intervals.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始还没注意这个解法，现在回头看看这个方法挺妙的，当无法覆盖的时候将<code>intervals[i-1]</code> 入栈，当可以覆盖的时候修改当前元素值，在下一轮继续添加或覆盖，其实还是有一点点不好理解，刚刚又重写了一个，思路很直白</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span>(intervals==<span class="keyword">null</span> || intervals.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">    Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]!=b[<span class="number">0</span>]?a[<span class="number">0</span>]-b[<span class="number">0</span>]:a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre=res.get(res.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=pre[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=pre[<span class="number">1</span>])&#123;</span><br><span class="line">                pre[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<ul>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [<span class="number">1</span>,<span class="number">2</span>] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>动态规划，其实和最长递增子序列是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="keyword">null</span> || intervals.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span>[]dp=<span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">    <span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;=intervals[j][<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i]=Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max=Math.max(max,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals.length-max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先根据左边界排个序，保证后面的不会覆盖前面的，然后反手求一下最长的无重叠区间长度，和最长递增子序列一样，最后用总长度减去这个最长的区间长度结果就是答案</p>
<p>171ms，8%，感觉快要过不了了。。。本来是是写的记忆化递归的，结果过不了。。。卡在倒数第二个case上</p>
<p><strong>记忆化递归写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Pair,Integer&gt; cache=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//TLE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals2</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> intervals.length-dfs(intervals,<span class="number">0</span>,Integer.MIN_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//背包问题,返回最多可以留下的区间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] intervals,<span class="keyword">int</span> index,<span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index==intervals.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Pair key=<span class="keyword">new</span> Pair(index,prev);</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=dfs(intervals,index+<span class="number">1</span>,prev);</span><br><span class="line">    <span class="keyword">if</span> (intervals[index][<span class="number">0</span>]&gt;=prev) &#123;</span><br><span class="line">        res=Math.max(res,dfs(intervals,index+<span class="number">1</span>,intervals[index][<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(key,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>贪心，时间复杂度降低为线性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="keyword">null</span> || intervals.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照起点排序,重叠的时候选择保留结尾小的那一个</span></span><br><span class="line">    <span class="comment">//Arrays.sort(intervals,(a,b)-&gt;a[0]-b[0]); lambda初始化效率会低一点</span></span><br><span class="line">    Arrays.sort(intervals,<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]&gt;=intervals[prev][<span class="number">1</span>]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            prev=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&lt;intervals[prev][<span class="number">1</span>])&#123;</span><br><span class="line">            prev=i; <span class="comment">//选择结尾小的那一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals.length-res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照起点排序，在重叠的时候优先选择结尾小的哪一个，这样就可能得到更多的区间组合，关于这个算法的正确性我就不证明了</p>
<h2 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">1024. 视频拼接</a></h2><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>
<p>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</p>
<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：clips = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">9</span>]], T = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们选中 [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">8</span>,<span class="number">10</span>], [<span class="number">1</span>,<span class="number">9</span>] 这三个片段。</span><br><span class="line">然后，按下面的方案重制比赛片段：</span><br><span class="line">将 [<span class="number">1</span>,<span class="number">9</span>] 再剪辑为 [<span class="number">1</span>,<span class="number">2</span>] + [<span class="number">2</span>,<span class="number">8</span>] + [<span class="number">8</span>,<span class="number">9</span>] 。</span><br><span class="line">现在我们手上有 [<span class="number">0</span>,<span class="number">2</span>] + [<span class="number">2</span>,<span class="number">8</span>] + [<span class="number">8</span>,<span class="number">10</span>]，而这些涵盖了整场比赛 [<span class="number">0</span>, <span class="number">10</span>]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：clips = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]], T = <span class="number">5</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">我们无法只用 [<span class="number">0</span>,<span class="number">1</span>] 和 [<span class="number">0</span>,<span class="number">2</span>] 覆盖 [<span class="number">0</span>,<span class="number">5</span>] 的整个过程。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：clips = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">8</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">7</span>],[<span class="number">6</span>,<span class="number">9</span>]], T = <span class="number">9</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释： </span><br><span class="line">我们选取片段 [<span class="number">0</span>,<span class="number">4</span>], [<span class="number">4</span>,<span class="number">7</span>] 和 [<span class="number">6</span>,<span class="number">9</span>] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：clips = [[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">8</span>]], T = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">注意，你可能录制超过比赛结束时间的视频。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= clips.length &lt;= 100</code></li>
<li><code>0 &lt;= clips[i][0], clips[i][1] &lt;= 100</code></li>
<li><code>0 &lt;= T &lt;= 100</code></li>
</ul>
<p><strong>解法一</strong></p>
<p>感觉这个贪心还是很经典的，很多题都是这个思路，上面的 跳跃游戏2，包括172周赛的最后一题，都是这个类似的区间覆盖问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(clips,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,res=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;clips.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=last;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;clips.length&amp;&amp;clips[i][<span class="number">0</span>]&lt;=temp) &#123;</span><br><span class="line">            last=Math.max(last,clips[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last==temp) &#123; <span class="comment">//没有找到能覆盖的</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">if</span> (last&gt;=T) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先按照左边界排序，然后找的时候<strong>每次都在序列中找能覆盖<code>overlap</code>上一次右边界的最长区间</strong> ，第一次覆盖其实就是找的左边界能覆盖0的最长的区间，然后下一次就要找能覆盖这个区间右边界的最长的区间。最终的结果就是最少的区间数目，正确性这里其实思考一下就知道了，每次都选择最优区间，对后面的选择没有负面影响，具体如何证明还是留给大佬们吧</p>
<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></h2><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对<code>(h, k)</code>表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p>
<p>注意：<br>总人数少于1100人。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[<span class="number">7</span>,<span class="number">0</span>], [<span class="number">4</span>,<span class="number">4</span>], [<span class="number">7</span>,<span class="number">1</span>], [<span class="number">5</span>,<span class="number">0</span>], [<span class="number">6</span>,<span class="number">1</span>], [<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[<span class="number">5</span>,<span class="number">0</span>], [<span class="number">7</span>,<span class="number">0</span>], [<span class="number">5</span>,<span class="number">2</span>], [<span class="number">6</span>,<span class="number">1</span>], [<span class="number">4</span>,<span class="number">4</span>], [<span class="number">7</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>贪心，没想出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people==<span class="keyword">null</span> ||people.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Arrays.sort(people,(p1,p2)-&gt;p1[<span class="number">0</span>]!=p2[<span class="number">0</span>]?p2[<span class="number">0</span>]-p1[<span class="number">0</span>]:p1[<span class="number">1</span>]-p2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;people.length;i++) &#123;</span><br><span class="line">        res.add(people[i][<span class="number">1</span>],people[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对身高h降序，k升序进行排列得到，然后将元素<code>（h，k）</code>插入前面比它大的元素中的第k个位置，保证该元素前面有k个比当前元素大的，使之合法，<strong>后面的比它矮的元素的移动对前面其实的没有任何影响</strong>，这个算法的正确性很容易想到，身高高的人是看不到身高矮的人的~，也就是身高矮的人在身高高的人前或后对身高高的人是没有任何影响的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>,<span class="number">0</span>] [<span class="number">7</span>,<span class="number">1</span>] [<span class="number">6</span>,<span class="number">1</span>] [<span class="number">5</span>,<span class="number">0</span>] [<span class="number">5</span>,<span class="number">2</span>] [<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">[]                (<span class="number">7</span>,<span class="number">0</span>) -&gt; []</span><br><span class="line"><span class="number">0</span>                 (<span class="number">7</span>,<span class="number">1</span>) -&gt; [<span class="number">7</span>,<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span> <span class="number">1</span>               (<span class="number">6</span>,<span class="number">1</span>) -&gt; [<span class="number">7</span>,<span class="number">0</span>] [<span class="number">7</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span>             (<span class="number">5</span>,<span class="number">0</span>) -&gt; [<span class="number">7</span>,<span class="number">0</span>] [<span class="number">6</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>           (<span class="number">5</span>,<span class="number">2</span>) -&gt; [<span class="number">5</span>,<span class="number">0</span>] [<span class="number">7</span>,<span class="number">0</span>] [<span class="number">6</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>         (<span class="number">4</span>,<span class="number">4</span>) -&gt; [<span class="number">5</span>,<span class="number">0</span>] [<span class="number">7</span>,<span class="number">0</span>] [<span class="number">5</span>,<span class="number">2</span>] [<span class="number">6</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>                [<span class="number">5</span>,<span class="number">0</span>] [<span class="number">7</span>,<span class="number">0</span>] [<span class="number">5</span>,<span class="number">2</span>] [<span class="number">6</span>,<span class="number">1</span>] [<span class="number">4</span>,<span class="number">4</span>] [<span class="number">7</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="1262-可被三整除的最大和"><a href="#1262-可被三整除的最大和" class="headerlink" title="1262. 可被三整除的最大和"></a><a href="https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/" target="_blank" rel="noopener">1262. 可被三整除的最大和</a></h2><p>给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：选出数字 <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span> 和 <span class="number">8</span>，它们的和是 <span class="number">18</span>（可被 <span class="number">3</span> 整除的最大和）。</span><br></pre></td></tr></table></figure>


<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="number">4</span> 不能被 <span class="number">3</span> 整除，所以无法选出数字，返回 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：选出数字 <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span> 以及 <span class="number">4</span>，它们的和是 <span class="number">12</span>（可被 <span class="number">3</span> 整除的最大和）。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 4 * 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<p><strong>解法三</strong></p>
<p>O(NlogN)贪心，最优解法应该是dp，放在dp<a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/">专题中</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumDivThree3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; one=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; two=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n:nums) &#123;</span><br><span class="line">        sum+=n;</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">3</span>==<span class="number">1</span>) one.add(n);</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">3</span>==<span class="number">2</span>) two.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(one);</span><br><span class="line">    Collections.sort(two);</span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">3</span>==<span class="number">1</span>) &#123; <span class="comment">//移除一个余数为1的 或者两个余数为2的</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(one.size()&gt;=<span class="number">1</span>?sum-one.get(<span class="number">0</span>):<span class="number">0</span>,two.size()&gt;=<span class="number">2</span>?sum-two.get(<span class="number">0</span>)-two.get(<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">3</span>==<span class="number">2</span>) &#123; <span class="comment">//移除一个余数为2 或者两个余数为1的</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(two.size()&gt;=<span class="number">1</span>?sum-two.get(<span class="number">0</span>):<span class="number">0</span>,one.size()&gt;=<span class="number">2</span>?sum-one.get(<span class="number">0</span>)-one.get(<span class="number">1</span>):<span class="number">0</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果总和%3=1我们就可以移除数组中%3=1的最小那个或者移除两个%3=2的最小的，同理，总和%3=2，我们可以移除一个最小的%2=0的元素，或者移除两个%2=1的最小元素</p>
<p>这里我们需要记录的仅仅是数组中%3=1和%3=2的最小的4个值就ok，其实不用排序就可以，直接O(N)遍历就行，嫌麻烦没改，后面有时间来改改</p>
<p><strong>解法二</strong></p>
<p>履行上面的承诺，改好了一版O(N)的贪心解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="comment">//余1最小值</span></span><br><span class="line">    <span class="keyword">int</span> min1_0=M,min1_1=M;</span><br><span class="line">    <span class="comment">//余2最小值</span></span><br><span class="line">    <span class="keyword">int</span> min2_0=M,min2_1=M;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(nums[i]%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=min1_0)&#123;</span><br><span class="line">                min1_1=min1_0; <span class="comment">//更新次小值</span></span><br><span class="line">                min1_0=nums[i]; <span class="comment">//更新最小值</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;=min1_1)&#123;</span><br><span class="line">                min1_1=nums[i]; <span class="comment">//更新次小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=min2_0)&#123;</span><br><span class="line">                min2_1=min2_0;</span><br><span class="line">                min2_0=nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;=min2_1)&#123;</span><br><span class="line">                min2_1=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">1</span>) <span class="keyword">return</span> sum-Math.min(min2_0+min2_1,min1_0);</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">2</span>) <span class="keyword">return</span> sum-Math.min(min1_0+min1_1,min2_0);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5172-形成三的最大倍数"><a href="#5172-形成三的最大倍数" class="headerlink" title="5172. 形成三的最大倍数"></a><a href="https://leetcode-cn.com/problems/largest-multiple-of-three/" target="_blank" rel="noopener">5172. 形成三的最大倍数</a></h2><p>给你一个整数数组 <code>digits</code>，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。</p>
<p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p>
<p>如果无法得到答案，请返回一个空字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="string">"981"</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">"8760"</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">""</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">"0"</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= digits.length &lt;= 10^4</li>
<li>0 &lt;= digits[i] &lt;= 9</li>
<li>返回的结果不应包含不必要的前导零。</li>
</ul>
<p><strong>解法一</strong></p>
<p>177周赛的T4，时隔多日，周赛又出了这一题，和上面一样，思路差不多的，需要优先考虑只删除一个的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestMultipleOfThree</span><span class="params">(<span class="keyword">int</span>[] digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length;i++) &#123;</span><br><span class="line">        sum+=digits[i];</span><br><span class="line">        freq[digits[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="comment">//删除一个余1的或者两个余2的,优先删除一个余1的</span></span><br><span class="line">    <span class="comment">//删除1个得到的结果肯定比删除2个大</span></span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">1</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!deleteMin(freq,<span class="number">1</span>))&#123; </span><br><span class="line">            deleteMin(freq,<span class="number">2</span>);</span><br><span class="line">            deleteMin(freq,<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">2</span>)&#123; <span class="comment">//删除一个余2的或者两个余1的</span></span><br><span class="line">        <span class="keyword">if</span>(!deleteMin(freq,<span class="number">2</span>))&#123;</span><br><span class="line">            deleteMin(freq,<span class="number">1</span>);</span><br><span class="line">            deleteMin(freq,<span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//逆序构建结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=freq[i];</span><br><span class="line">        <span class="keyword">while</span>(count-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteMin</span><span class="params">(<span class="keyword">int</span>[] freq,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=y;i&lt;<span class="number">9</span>;i+=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (freq[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">            freq[i]--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1111-有效括号的嵌套深度"><a href="#1111-有效括号的嵌套深度" class="headerlink" title="1111. 有效括号的嵌套深度"></a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">1111. 有效括号的嵌套深度</a></h2><p>迷惑题，不想粘题目了</p>
<p><strong>解法一</strong></p>
<p>按照深度的奇偶划分两个子串。。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxDepthAfterSplit(String seq) &#123;</span><br><span class="line">    <span class="comment">//Deque&lt;Character&gt; stack=new ArrayDeque&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[seq.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;seq.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(seq.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">            res[i]=depth++%<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//根据左括号奇偶判断</span></span><br><span class="line">            res[i]=--depth%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1353-最多可以参加的会议数目"><a href="#1353-最多可以参加的会议数目" class="headerlink" title="1353. 最多可以参加的会议数目"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/" target="_blank" rel="noopener">1353. 最多可以参加的会议数目</a></h2><p>给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。</p>
<p>你可以在满足 startDayi &lt;= d &lt;= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。</p>
<p>请你返回你可以参加的 最大 会议数目。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://s1.ax1x.com/2020/04/17/JELWN9.png" alt="JELWN9.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以参加所有的三个会议。</span><br><span class="line">安排会议的一种方案如上图。</span><br><span class="line">第 <span class="number">1</span> 天参加第一个会议。</span><br><span class="line">第 <span class="number">2</span> 天参加第二个会议。</span><br><span class="line">第 <span class="number">3</span> 天参加第三个会议。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：events= [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">100000</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">7</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= events.length &lt;= 10^5</code></li>
<li><code>events[i].length == 2</code></li>
<li><code>1 &lt;= events[i][0] &lt;= events[i][1] &lt;= 10^5</code></li>
</ul>
<p><strong>解法一</strong></p>
<p>暴力贪心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[[1,4],[4,4],[2,2],[3,4],[1,1]]</span></span><br><span class="line"><span class="comment">// 1,1  2,2  1,4  3,4  4,4</span></span><br><span class="line"><span class="comment">// 暴力贪心，按结束时间排序，优先安排结束时间短的，O(N^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="keyword">int</span>[][] events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events==<span class="keyword">null</span> || events.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(events,(e1,e2)-&gt;e1[<span class="number">1</span>]-e2[<span class="number">1</span>]);</span><br><span class="line">    HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;events.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> start=events[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end=events[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end;j++)&#123; <span class="comment">//在对应时间段内进行安排</span></span><br><span class="line">            <span class="keyword">if</span>(!set.contains(j))&#123;</span><br><span class="line">                set.add(j);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先队列优化，NlogN</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="keyword">int</span>[][] events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events==<span class="keyword">null</span> || events.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(events,(e1,e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//结束时间构建小根堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>,res=<span class="number">0</span>,n=events.length;</span><br><span class="line">    <span class="keyword">int</span> curDay=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;n || !pq.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//将当天开始的会议的结束时间加入小根堆</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;n &amp;&amp; curDay==events[index][<span class="number">0</span>])&#123;</span><br><span class="line">            pq.add(events[index++][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将过期会议的移除</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty() &amp;&amp; pq.peek()&lt;curDay)&#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//优先选择结束时间最短的</span></span><br><span class="line">        <span class="keyword">if</span>(!pq.isEmpty())&#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        curDay++; <span class="comment">//安排下一天</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong> </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 <span class="number">3</span> 号加油站(索引为 <span class="number">3</span> 处)出发，可获得 <span class="number">4</span> 升汽油。此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">4</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">1</span> + <span class="number">5</span> = <span class="number">8</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">8</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span> 升汽油</span><br><span class="line">开往 <span class="number">2</span> 号加油站，此时油箱有 <span class="number">6</span> - <span class="number">4</span> + <span class="number">3</span> = <span class="number">5</span> 升汽油</span><br><span class="line">开往 <span class="number">3</span> 号加油站，你需要消耗 <span class="number">5</span> 升汽油，正好足够你返回到 <span class="number">3</span> 号加油站。</span><br><span class="line">因此，<span class="number">3</span> 可为起始索引。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 <span class="number">0</span> 号或 <span class="number">1</span> 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 <span class="number">2</span> 号加油站出发，可以获得 <span class="number">4</span> 升汽油。 此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">3</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">3</span> - <span class="number">3</span> + <span class="number">3</span> = <span class="number">3</span> 升汽油</span><br><span class="line">你无法返回 <span class="number">2</span> 号加油站，因为返程需要消耗 <span class="number">4</span> 升汽油，但是你的油箱只有 <span class="number">3</span> 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="keyword">int</span>, cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(gas)</span><br><span class="line">    curGas:=<span class="number">0</span> <span class="comment">//当前油量</span></span><br><span class="line">    start:=<span class="number">0</span> <span class="comment">//起点</span></span><br><span class="line">    total:=<span class="number">0</span> <span class="comment">//gas和cost之差,小于0的话肯定无法绕圈</span></span><br><span class="line">    <span class="keyword">for</span> i:=start;i&lt;n;i++&#123;</span><br><span class="line">        curGas+=(gas[i]-cost[i])</span><br><span class="line">        total+=(gas[i]-cost[i])</span><br><span class="line">        <span class="comment">//油量不够，i无法继续前进到i+1,说明从start~i无法绕环</span></span><br><span class="line">        <span class="keyword">if</span> curGas&lt;<span class="number">0</span>&#123; </span><br><span class="line">            start=i+<span class="number">1</span></span><br><span class="line">            curGas=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> total&lt;<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a><a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener">1046. 最后一块石头的重量</a></h2><p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">先选出 <span class="number">7</span> 和 <span class="number">8</span>，得到 <span class="number">1</span>，所以数组转换为 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">再选出 <span class="number">2</span> 和 <span class="number">4</span>，得到 <span class="number">2</span>，所以数组转换为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">接着是 <span class="number">2</span> 和 <span class="number">1</span>，得到 <span class="number">1</span>，所以数组转换为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">最后选出 <span class="number">1</span> 和 <span class="number">1</span>，得到 <span class="number">0</span>，最终数组转换为 [<span class="number">1</span>]，这就是最后剩下那块石头的重量。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ol>
<p><strong>解法一</strong></p>
<p>虽然tag有贪心，但是并不是贪心。。。直接模拟就行了，反而是这题的<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">进阶版本</a>，我以为可以这样贪心过，结果发现不对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stones==<span class="keyword">null</span> ||stones.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">        pq.add(stones[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//NlogN</span></span><br><span class="line">    <span class="keyword">while</span>(pq.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=pq.poll();</span><br><span class="line">        <span class="keyword">int</span> x=pq.poll();</span><br><span class="line">        pq.add(y-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时间再把这些利用堆的单独整理下，都放数组里面快放不下了</p>
</blockquote>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#455-分发饼干"><span class="toc-text">455. 分发饼干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#274-H指数"><span class="toc-text">274. H指数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#392-判断子序列"><span class="toc-text">392. 判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#621-任务调度器"><span class="toc-text">621. 任务调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-跳跃游戏"><span class="toc-text">55. 跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-跳跃游戏-II"><span class="toc-text">45. 跳跃游戏 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-合并区间"><span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#435-无重叠区间"><span class="toc-text">435. 无重叠区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1024-视频拼接"><span class="toc-text">1024. 视频拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#406-根据身高重建队列"><span class="toc-text">406. 根据身高重建队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1262-可被三整除的最大和"><span class="toc-text">1262. 可被三整除的最大和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5172-形成三的最大倍数"><span class="toc-text">5172. 形成三的最大倍数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1111-有效括号的嵌套深度"><span class="toc-text">1111. 有效括号的嵌套深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1353-最多可以参加的会议数目"><span class="toc-text">1353. 最多可以参加的会议数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134-加油站"><span class="toc-text">134. 加油站</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1046-最后一块石头的重量"><span class="toc-text">1046. 最后一块石头的重量</span></a></li></ol>
  </div>


  </div>
</div>


    <section id="comments" style="margin:10px;padding:10px;background:#fff;">
      <div id="vcomment" class="comment"></div> 
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
   var notify = 'false' == true ? true : false;
   var verify = 'true' == true ? true : false;
    window.onload = function() {
        new Valine({
            el: '.comment',
            notify: notify,
            verify: verify,
            app_id: "MkcXmeDvktRNBDBrVqb9KYPH-MdYXbMMI",
            app_key: "swDnb5a9u9Ksp2Rwkdm7Qulh",
            placeholder: "留下邮箱才能收到收到回复喔 ~",
            avatar:"monsterid"
        });
    }
</script>
    </section>
  
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/12/23/wo-chang-yong-de-yi-xie-gong-ju-he-wang-zhan/" rel="next" title="常用的一些工具和网站">
          常用的一些工具和网站
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/02/02/bing-cha-ji/" rel="prev" title="并查集">
            并查集
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/imlgw" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="https://imlgw.avosapps.us/" target="_blank" rel="noopener">博客评论管理</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body>
</html>
