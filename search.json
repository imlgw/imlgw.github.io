[{"title":"记两道并查集的题","url":"/2021/01/18/ji-liang-dao-bing-cha-ji-de-ti/","content":"\n> LeetCode最近每日一题出了好几道并查集的题，有几道挺有意思的，记录一下\n## [947. 移除最多的同行或同列石头](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/)\n\nDifficulty: **中等**\n\n\n`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n\n如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。\n\n给你一个长度为 `n` 的数组 `stones` ，其中 stones[i] = [x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>] 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。\n\n**示例 1：**\n\n```c\n输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n输出：5\n解释：一种移除 5 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,1] 同行。\n2. 移除石头 [2,1] ，因为它和 [0,1] 同列。\n3. 移除石头 [1,2] ，因为它和 [1,0] 同行。\n4. 移除石头 [1,0] ，因为它和 [0,0] 同列。\n5. 移除石头 [0,1] ，因为它和 [0,0] 同行。\n石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。\n```\n\n**示例 2：**\n\n```c\n输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\n输出：3\n解释：一种移除 3 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,0] 同行。\n2. 移除石头 [2,0] ，因为它和 [0,0] 同列。\n3. 移除石头 [0,2] ，因为它和 [0,0] 同行。\n石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。\n```\n\n**示例 3：**\n\n```c\n输入：stones = [[0,0]]\n输出：0\n解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。\n```\n\n**提示：**\n\n*   1 <= stones.length <= 1000\n*   0 <= x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub> <= 10<sup>4</sup>\n*   不会有两块石头放在同一个坐标点上\n\n\n### 解法一\n\n简单的想法肯定是直接双重循环枚举所有的点对，如果两个点横纵坐标有一样的就合并，最后统计下就行了，但是这样时间复杂度就比较高了。\n\n这里我们换一个思路来合并，因为我们并不关心各个点是如何联通的，只要各个点在同一行或者同一列那么他们就是连通的，所以我们可以直接将每个点的行列坐标进行合并，也就相当于我们将 **该行以及该列的所有元素** 与 **当前的元素** 合并起来，最后用石头数量减去连通分量的个数就行了。需要注意的点就是我们需要区分横纵坐标，避免混淆。比如（1，2）和（2，4）不是同一行列，如果不加区分就会被合并成一个连通分量，这里题目给了行列的范围，我们直接加上一个10001就行了\n\n```python\nclass Solution(object):\n    def removeStones(self, stones: List[List[int]]) -> int:\n        n = len(stones)\n        parent = {}\n        count = 0\n\n        def union(a, b):\n            nonlocal count\n            pa = find(a)\n            pb = find(b)\n            if pa == pb:\n                return\n            count -= 1\n            parent[pa] = pb\n\n        def find(a):\n            nonlocal count\n            if a not in parent:\n                count += 1\n                parent[a] = a\n                return a\n            if a == parent[a]:\n                return a\n            parent[a] = find(parent.get(a))\n            return parent.get(a)\n\n        for s in stones:\n            union(s[0]+10001, s[1])\n        return n - count\n```\n\n## [803. 打砖块](https://leetcode-cn.com/problems/bricks-falling-when-hit/)\n\nDifficulty: **困难**\n\n\n有一个 `m x n` 的二元网格，其中 `1` 表示砖块，`0` 表示空白。砖块 **稳定**（不会掉落）的前提是：\n\n*   一块砖直接连接到网格的顶部，或者\n*   至少有一块相邻（4 个方向之一）砖块 **稳定** 不会掉落时\n\n给你一个数组 `hits` ，这是需要依次消除砖块的位置。每当消除 `hits[i] = (rowi, coli)` 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。\n\n返回一个数组 `result` ，其中 `result[i]` 表示第 `i` 次消除操作对应掉落的砖块数目。\n\n**注意**，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。\n\n**示例 1：**\n\n```c\n输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\n输出：[2]\n解释：\n网格开始为：\n[[1,0,0,0]，\n [1,1,1,0]]\n消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0]\n [0,1,1,0]]\n两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n因此，结果为 [2] 。\n```\n\n**示例 2：**\n\n```c\n输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\n输出：[0,0]\n解释：\n网格开始为：\n[[1,0,0,0],\n [1,1,0,0]]\n消除 (1,1) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [1,0,0,0]]\n剩下的砖都很稳定，所以不会掉落。网格保持不变：\n[[1,0,0,0], \n [1,0,0,0]]\n接下来消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n剩下的砖块仍然是稳定的，所以不会有砖块掉落。\n因此，结果为 [0,0] 。\n```\n\n**提示：**\n\n*   m == grid.length\n*   n == grid[i].length\n*   1 <= m, n <= 200\n*   grid[i][j] 为 `0` 或 `1`\n*   1 <= hits.length <= 4 * 10<sup>4</sup>\n*   hits[i].length == 2\n*   0 <= x<sub style=\"display: inline;\">i </sub><= m - 1\n*   0 <= y<sub style=\"display: inline;\">i</sub> <= n - 1\n*   所有 (x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>) 互不相同\n\n\n### 解法一\n\n也是一道很有意思的并查集的题。常规意义上的并查集只能处理连通块的合并，而这题打掉一个砖块意味着连通分量的拆分，那我们应该如何利用并查集呢？\n\n这里的解法很巧妙的采用了 **逆向思维**，既然打掉砖块无法操作，那么我们可以反过来补砖块，先将原本待打击的地方置为0，然后逆向的的补上去，而补的操作就代表着连通块的合并，我们就可以通过连通块数量的变化统计掉落的砖块，整体的思路非常巧妙。\n\n具体的算法实现还是有一些细节需要注意，都注释在代码中了\n\n```java\nimport java.util.*;\nimport java.io.*;\n \nclass Solution {\n\n    int[] parent;\n    int[] size;\n\n    public int find(int a) {\n        if (parent[a] == a) return a;\n        return parent[a] = find(parent[a]);\n    }\n\n    public void union(int a, int b) {\n        int pa = find(a);\n        int pb = find(b);\n        if (pa == pb) return;\n        if (size[pa] > size[pb]) {\n            parent[pb] = pa;\n            size[pa] += size[pb]; \n        } else {\n            parent[pa] = pb;\n            size[pb] += size[pa];\n        }\n    }\n\n    public int[] hitBricks(int[][] grid, int[][] hits) {\n        int n = grid.length, m = grid[0].length;\n        int hlen = hits.length;\n        //记录当前hits对应的位置有没有砖块\n        int[] exist = new int[hlen];\n        for (int i = 0; i < hlen; i++) {\n            int x = hits[i][0], y = hits[i][1];\n            exist[i] = grid[x][y]&1;\n            grid[x][y] = 0;\n        }\n        parent = new int[m*n+1];\n        size = new int[m*n+1];\n        //抽象的屋顶节点\n        int ROOT = m*n;\n        for (int i = 0; i <= m*n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n        //和屋顶有关联的先合并下\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) {\n                union(ROOT, j);\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j]==1) {\n                    //与左边和上边方块合并\n                    if (j-1 >= 0 && grid[i][j-1] == 1) {\n                        union(m*i+j, m*i+j-1);\n                    }\n                    if (/*i-1 >= 0 &&*/ grid[i-1][j] == 1) {\n                        union(m*i+j, m*(i-1)+j);\n                    }\n                }\n            }\n        }\n        int[] res = new int[hlen];\n        int[] dir = {1, 0, -1, 0, 1};\n        for (int i = hlen-1; i >= 0; i--) {\n            int last = size[find(ROOT)];\n            int x = hits[i][0], y = hits[i][1];\n            //WA_2: 还原错误，hit原本可能没有砖块，一开始直接还原成1了\n            grid[x][y] = exist[i]&1;\n            if (grid[x][y] == 0) continue;\n            //WA_1: 还原后和ROOT连接的别忘了合并\n            if (x == 0) union(ROOT, x*m+y);\n            //与周围4个方向的方块合并\n            for (int k = 0; k < 4; k++) {\n                int nx = x + dir[k], ny = y + dir[k+1];\n                if (nx < 0 || ny < 0 || nx >= n || ny >= m || grid[nx][ny] != 1) {\n                    continue;\n                }\n                union(x*m+y, nx*m+ny);\n            }\n            res[i] = Math.max(0, size[find(ROOT)]-last-1);\n        }\n        return res;\n    }\n}\n```\n\n## [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)\n\nDifficulty: **中等**\n\n\n给定一个列表 `accounts`，每个元素 `accounts[i]` 是一个字符串列表，其中第一个元素 `accounts[i][0]` 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。\n\n现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。\n\n合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按字符 ASCII 顺序排列的邮箱地址。账户本身可以以任意顺序返回。\n\n**示例 1：**\n\n```c\n输入：\naccounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n输出：\n[[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n解释：\n第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 \"johnsmith@mail.com\"。 \n第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。\n可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，\n['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。\n```\n\n**提示：**\n\n*   `accounts`的长度将在`[1，1000]`的范围内。\n*   `accounts[i]`的长度将在`[1，10]`的范围内。\n*   `accounts[i][j]`的长度将在`[1，30]`的范围内。\n\n\n### 解法一\n\n>没错，这是第二道，上面的是第0道和第1道😁\n\n本来不想记这道题的，没啥意思，业务题，但是写都写了，还是记一下，难倒是不难，就是要理清楚思路，我感觉很麻烦直接看了题解😂，不过题解也有点小瑕疵，邮件映射姓名的时候可以用邮件的编号直接映射的，题解依然用的字符串。这种题其实只想理清楚先干嘛后干嘛就好做了，别老想着一步都求出来，先分步，后面能合并再合并。\n\n```java\n​import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    \n    int[] parent;\n\n    public void union(int a, int b) {\n        parent[find(a)] = find(b);\n    }\n\n    public int find(int a) {\n        if (parent[a] == a) return a;\n        return parent[a] = find(parent[a]);\n    }\n\n    // 比较繁琐，想清楚了写就很简单，没啥意思\n    public List<List<String>> accountsMerge(List<List<String>> acc) {\n        //email : idx\n        HashMap<String, Integer> e2i = new HashMap<>();\n        //idx : name\n        HashMap<Integer, String> i2n = new HashMap<>();\n        int cnt = 0;\n        for (int i = 0; i < acc.size(); i++) {\n            String name = acc.get(i).get(0);\n            for (int j = 1; j < acc.get(i).size(); j++) {\n                String email = acc.get(i).get(j);\n                if (!e2i.containsKey(email)) {\n                    e2i.put(email, cnt);\n                    i2n.put(cnt++, name);\n                }\n            }\n        }\n        parent = new int[cnt];\n        for (int i = 0; i < cnt; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < acc.size(); i++) {\n            int first = e2i.get(acc.get(i).get(1));\n            for (int j = 2; j < acc.get(i).size(); j++) {\n                union(first, e2i.get(acc.get(i).get(j)));\n            }\n        }\n        // idx : emails\n        HashMap<Integer, List<String>> map = new HashMap<>();\n        for (String email : e2i.keySet()) {\n            map.computeIfAbsent(find(e2i.get(email)), k->new LinkedList<>()).add(email);\n        }\n        List<List<String>> res = new ArrayList<>();\n        for (Integer idx : map.keySet()) {\n            String name = i2n.get(idx);\n            List<String> emails = map.get(idx);\n            Collections.sort(emails);\n            emails.add(0, name);\n            res.add(emails);\n        }\n        return res;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"贪心：绝对值不等式","url":"/2021/01/17/tan-xin-jue-dui-zhi-bu-deng-shi/","content":"\n## [104. 货仓选址](https://www.acwing.com/problem/content/description/106/)\n\n在一条数轴上有$N$家商店，它们的坐标分别为 $A_1$ ~ $A_N$。\n\n现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。\n\n为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。\n\n**输入格式**\n\n第一行输入整数$N$。\n\n第二行N个整数$A_1$ ~ $A_N$。\n\n**输出格式**\n\n输出一个整数，表示距离之和的最小值。\n\n**数据范围**： $1 ≤ N ≤ 100000$\n\n**输入样例：**\n```c\n4\n6 2 9 1\n```\n**输出样例：**\n```c\n12\n```\n### 解法一\n\n![mark](http://static.imlgw.top/blog/20210117/Tt7g9UupN0RX.png?imageslim)\n货仓位置为$A_i$，修建点为$x$，那么货仓到$x$点的距离之和为：\n$$\n\\begin{aligned}\nf(x) &= \\sum_{i=0}^{n-1}|A_i-x| \\\\\\\\ &= |A_0-x|+|A_1-x|+...+|A_{n-2}-x|+|A_{n-1}-x| \\\\\\\\ &= (|A_0-x|+|A_{n-1}-x|) + (|A_1-x|+|A_{n-2}-x|) + ... + (|A_{mid-1}-x|+|A_{mid+1}-x|) \\\\\\\\ &\\geq(A_{n-1}-A_0) + (A_{n-2}-A_1) +...+ (A_{mid+1}-A_{mid-1})\n\\end{aligned}\n$$\n\n当且仅当$X$取在$A_n$和$A_1$中间，$A_{n-2}$和$A_2$中间...以及$A_{mid+1}$和$A_{mid-1}$中间时，不等式取得最小值，即$X$为$A_i$中位数时（奇偶同理）\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String... args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"./input.txt\")));\n        int N = Integer.parseInt(br.readLine());\n        int[] A = read(br);\n        Arrays.sort(A);\n        int mid = A[(N-1)/2];  // 下取整\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            res += Math.abs(A[i]-mid);\n        }\n        System.out.println(res);\n    }\n\n    public static int[] read(BufferedReader br) throws Exception {\n        return Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n}\n```\n\n## [462. 最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)\n\nDifficulty: **中等**\n\n\n给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。\n\n**例如:**\n\n```c\n输入:\n[1,2,3]\n\n输出:\n2\n\n说明：\n只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： \n\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n```\n\n\n### 解法一\n同上，不多解释\n```java\n​class Solution {\n    public int minMoves2(int[] nums) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += Math.abs(nums[i]-nums[n>>1]);\n        }\n        return res;\n    }\n}\n```\n\n## [912. 最佳见面地点](https://www.lintcode.com/problem/best-meeting-point/description)\n\n有一群住在不同地方的朋友（两个或以上）想要在某地见面，要求他们去往目的地的路程和最短。现在给一个0、1组成的二维数组，1表示此地有一个人居住。使用曼哈顿距离作为计算总距离，公式为：$(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|$\n\n\n**样例 1:**\n```c\n输入: \n[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]\n输出:\n6\n解释:\n点(0, 2)是最佳见面地点，最小的路程总和为2+2+2=6，返回6。\n```\n\n**样例 2:**\n```c\n输入:\n[[1,1,0,0,1],[1,0,1,0,0],[0,0,1,0,1]]\n输出:\n14\n```\n\n### 解法一\n和前面一样\n$$\nf(n) = \\sum_{i=0}^{n-1}(|x_i-x| + |y_i-y|) = \\sum_{i=0}^{n-1}|x_i-x| + \\sum_{i=0}^{n-1}|y_i-y|)  \n$$\n所以我们分别取$x_i$和$y_i$中点就行了\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * @param grid: a 2D grid\n     * @return: the minimize travel distance\n     */\n    public int minTotalDistance(int[][] grid) {\n        // Write your code here\n        int n = grid.length;\n        int m = grid[0].length;\n        List<Integer> xlis = new ArrayList<>();\n        List<Integer> ylis = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    xlis.add(i);\n                    ylis.add(j);\n                }\n            }\n        }\n        Collections.sort(xlis);\n        Collections.sort(ylis);\n        int xmid = xlis.get(xlis.size()>>1);\n        int ymid = ylis.get(ylis.size()>>1);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    res += Math.abs(i-xmid) + Math.abs(j-ymid);      \n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n## [1703. 得到连续K个1的最少相邻交换次数](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/)\n\nDifficulty: **困难**\n\n\n给你一个整数数组 `nums` 和一个整数 `k` 。 `nums` 仅包含 `0` 和 `1` 。每一次移动，你可以选择 **相邻** 两个数字并将它们交换。\n\n请你返回使 `nums` 中包含 `k` 个连续 `1` 的最少交换次数。\n\n**示例 1：**\n\n```c\n输入：nums = [1,0,0,1,0,1], k = 2\n输出：1\n解释：在第一次操作时，nums 可以变成 [1,0,0,0,1,1] 得到连续两个 1 。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [1,0,0,0,0,0,1,1], k = 3\n输出：5\n解释：通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,1,1,1] 。\n```\n\n**示例 3：**\n\n```c\n输入：nums = [1,1,0,1], k = 2\n输出：0\n解释：nums 已经有连续 2 个 1 了。\n```\n\n**提示：**\n\n*   1 <= nums.length <= 10<sup>5</sup>\n*   `nums[i]` 要么是 `0` ，要么是 `1` 。\n*   1 <= k <= sum(nums)\n\n\n### 解法一\n42th双周赛T4，相比上面的题就有了一些思维的转换。\n\n我们要把$k$个1聚拢在一起，我们设定原始位置为$A_0$ ~ $A_k-1$，聚集后的位置为 $X, X+1, X+2...., X+k-1$。推导过程如下：\n\n交换次数为：\n$$f(k) = \\sum_{i=0}^{k-1}|A_i-(X+i)|$$\n要求这个式子的最小值，将式子转换一下，设$A_i=B_i+i$，那么我们的式子就变成了\n$$f(k) = \\sum_{i=0}^{k-1}|B_i-X|$$\n根据我们[上面的结论](#104-货仓选址)，这个式子当$X$取在$B_i$中位数的时候，取得最小值。此时$X=B_{mid}$ (奇偶同理)\n$$\n\\begin{aligned}\n    f(k) &= \\sum_{i=l}^r|B_i-B_{mid}| \\\\\\\\\n         &= \\sum_{i=l}^{mid}(B_{mid}-B_i) + \\sum_{i = mid+1}^{r}(B_i-B_{mid}) \\\\\\\\\n         &= B_{mid}  (2mid-l-r+1) - \\sum_{i = l}^{mid}B_i  +  \\sum_{i = mid+1}^{r}B_i\n\\end{aligned}\n$$\n前半部分可以直接计算得到，后半部分可以通过预处理前缀和快速求得，如此我们就可以在$O(1)$的时间内滑窗求出窗口内1需要交换的次数，滑动过程中统计出最小值就ok了\n```java\nimport java.util.*;\nimport java.io.*;\n\n/*\n1.    得到连续 K 个 1 的最少相邻交换次数\n给你一个整数数组 nums 和一个整数 k 。 nums 仅包含 0 和 1 。每一次移动你可以选择 相邻 两个数字并将它们交换。\n请你返回使 nums 中包含 k 个 连续 1 的 最少 交换次数。\n */\n\nclass Solution {\n    public int minMoves(int[] nums, int k) {\n        int n = nums.length;\n        // int[] w = new int[k];\n        List<Integer> lis = new ArrayList<>();\n        int x = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i]==1) {\n                lis.add(i-x);\n                x++;\n            }\n        }\n        int[] w = lis.stream().mapToInt(Integer::valueOf).toArray();\n        int m = w.length;\n        int[] sum = new int[m+1];\n        for (int i = 1; i <= m; i++) {\n            sum[i] = sum[i-1] + w[i-1];\n        }\n        //sum[i]: [0,i-1]\n        int res = Integer.MAX_VALUE;\n        int left = 0;\n        for (int right = k-1; right < m; right++) {\n            int mid = left+(right-left)/2; //左中位数\n            res = Math.min(res, w[mid]*(2*mid-left-right+1)-(sum[mid+1]-sum[left])+(sum[right+1]-sum[mid+1]));\n            left++;\n        }\n        return res;\n    }\n}\n```\n这里其实有一个[小的问题](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/solution/de-dao-lian-xu-k-ge-1-de-zui-shao-xiang-lpa9i/724362)。比如窗口第一次向右滑动时，从$[A_0，A_1-1，...，A_{k-1}-{k-1}]$，滑动到$[A_1-1，...，A_{k-1}-{k-1}，A_{k}-k]$但是实际上按照我们前面的推导，这里我们需要的应该是$[A_1，A_2-1，A_3-2，...，A_n-n]$，那么我们需要重新计算吗？\n\n显然并不需要，这里两个窗口之间差距仅仅只是在坐标轴上**整体的**移动了一步，而我们求的是窗口内元素和中位数差值的和，对结果的计算并没有影响。\n\n## [LCP 24. 数字游戏](https://leetcode-cn.com/problems/5TxKeK/)\n\n小扣在秋日市集入口处发现了一个数字游戏。主办方共有 N 个计数器，计数器编号为 0 ~ N-1。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 nums。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。\n\n主办方请小扣回答出一个长度为 N 的数组，第 i 个元素(0 <= i < N)表示将 0~i 号计数器 初始 所示数字操作成满足所有条件 nums[a]+1 == nums[a+1],(0 <= a < i) 的最小操作数。回答正确方可进入秋日市集。\n\n由于答案可能很大，请将每个最小操作数对 1,000,000,007 取余。\n\n**示例 1：**\n\n```c\n输入：nums = [3,4,5,1,6,7]\n\n输出：[0,0,0,5,6,7]\n\n解释：\ni = 0，[3] 无需操作\ni = 1，[3,4] 无需操作；\ni = 2，[3,4,5] 无需操作；\ni = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作；\ni = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作；\ni = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作；\n返回 [0,0,0,5,6,7]。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [1,2,3,4,5]\n\n输出：[0,0,0,0,0]\n\n解释：对于任意计数器编号 i 都无需操作。\n```\n**示例 3：**\n```c\n输入：nums = [1,1,1,2,3,4]\n\n输出：[0,1,2,3,3,3]\n\n解释：\ni = 0，无需操作；\ni = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作；\ni = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作；\ni = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作；\ni = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作；\ni = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作；\n返回 [0,1,2,3,3,3]。\n```\n\n**提示：**\n\n- 1 <= nums.length <= 10^5\n- 1 <= nums[i] <= 10^3\n\n### 解法一\n在补上面的题的时候看见有人提到和这题一样，所以顺便一起写一下这题，因为已经知道了和上面哪题差不多，所以这里很快就转换成和上面类似的问题了，设原来的数组为$A_i$数组，转换后新数组以$X$开头，则从0~n的转换次数为：\n$$f(n) = \\sum_{i=0}^{n-1}|A_i-(X+i)|$$\n我们要求的就是这个式子的最小值，这里我们将式子转换一下，设$A_i=B_i+i$，那么我们的式子就变成了\n$$f(n) = \\sum_{i=0}^{n-1}|B_i-X|$$\n根据前面的[结论](#104-货仓选址)，很显然$X$取$B_i$的中位数时该式得到最小值。那么问题就转换成了如何动态的求区间的中位数，[上一题](#1703-得到连续K个1的最少相邻交换次数)因为变化的值是下标，窗口内的下标肯定是有序的，所以直接通过左右端点就可以计算得到中位数，但是这题我们变化的是数组的值，并且是无序的，所以我们需要借助一些其他的结构，这里我采用**双堆**的做法动态的维护中位数，详见[数据流的中位数](http://imlgw.top/2019/05/04/leetcode-shu-zu/#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0)\n\n有了中位数后，我们还需要滑动的过程中快速的求出上面的式子的值，这里我们再把上面的式子拆分一下就变成\n\n$$f(n) = \\sum_{B_i \\leq B_{mid}}(B_{mid}-B_{i}) + \\sum_{B_i > B_{mid}}(B_i-B_{mid})\n$$\n左右两部分其实就对应了小于等于$B_{mid}$的元素以及大于$B_{mid}$的元素，我们只需要在维护双堆的同时，维护一下各个堆的元素和以及元素个数就可以快速的求出上面式子的值，时间复杂度大概$O(NlogN)$的样子\n\n```java\nimport java.util.*;\nimport java.io.*;\n\nclass Solution {\n\n\n    int[] w;\n    //小根堆和大根堆的和\n    long minSum = 0l, maxSum = 0l;\n    //存后1/2小的元素\n    PriorityQueue<Integer> max = new PriorityQueue<>((a, b)->w[b]-w[a]);\n    //存前1/2大的元素\n    PriorityQueue<Integer> min = new PriorityQueue<>((a, b)->w[a]-w[b]);\n\n    //n = 10^5\n    public int[] numsGame(int[] nums) {\n        int MOD = (int)1e9+7;\n        int n = nums.length;\n        w = new int[n];\n        for (int i = 0; i < n; i++) {\n            w[i] = nums[i]-i;\n        }\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            add(i);\n            int mid = find();\n            //这里取模WA了两发...int后面没打括号，给强转了\n            //小根堆的个数以及sum代表的实际是大于mid的元素部分，大根堆同理\n            res[i] = (int)(((long)w[mid]*(max.size()-min.size()) - maxSum + minSum) % MOD);\n        }\n        return res;\n    }\n\n    //维护大根堆以及小根堆\n    public void add(int x) {\n        min.add(x);\n        minSum += w[x];\n        minSum -= w[min.peek()]; maxSum += w[min.peek()];\n        max.add(min.poll());\n        if (min.size() < max.size()) {\n            minSum += w[max.peek()]; maxSum -= w[max.peek()];\n            min.add(max.poll());\n        }\n    }\n\n    public int find() {\n        return min.peek();\n    }\n\n}\n\npublic class LeetCode_LCP24数字游戏 {\n    public static void main(String[] args) {\n        Arrays.stream(new Solution().numsGame(new int[]{3,4,5,1,6,7})).forEach(System.out::println);\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"力扣42th双周赛","url":"/2021/01/06/li-kou-42th-shuang-zhou-sai/","content":"\n## [1702. 修改后的最大二进制字符串](https://leetcode-cn.com/problems/maximum-binary-string-after-change/)\n\nDifficulty: **中等**\n\n\n给你一个二进制字符串 `binary` ，它仅有 `0` 或者 `1` 组成。你可以使用下面的操作任意次对它进行修改：\n\n*   操作 1 ：如果二进制串包含子字符串 \"00\" ，你可以用 \"10\" 将其替换。\n    *   比方说， \"00010\" -> \"10010\"\n*   操作 2 ：如果二进制串包含子字符串 \"10\" ，你可以用 \"01\" 将其替换。\n    *   比方说， \"00010\" -> \"00001\"\n\n请你返回执行上述操作任意次以后能得到的 **最大二进制字符串** 。如果二进制字符串 `x` 对应的十进制数字大于二进制字符串 `y` 对应的十进制数字，那么我们称二进制字符串`x`大于二进制字符串`y`。\n\n**示例 1：**\n\n```c\n输入：binary = \"000110\"\n输出：\"111011\"\n解释：一个可行的转换为：\n\"000110\" -> \"000101\" \n\"000101\" -> \"100101\" \n\"100101\" -> \"110101\" \n\"110101\" -> \"110011\" \n\"110011\" -> \"111011\"\n```\n\n**示例 2：**\n\n```c\n输入：binary = \"01\"\n输出：\"01\"\n解释：\"01\" 没办法进行任何转换。\n```\n\n**提示：**\n\n*   1 <= binary.length <= 10<sup>5</sup>\n*   `binary` 仅包含 '0' 和 '1' 。\n\n\n### 解法一\n\n因为是补题，之前在群里有看见讨论，大致的提到了一些，所以这里很快就想到了贪心的思路。首先01是无法继续变化的，10是可以变成01的，而开头连续的1肯定是不需要再变化的，变化只会使得结果变小，所以我们可以将除了开头连续的1以外的所有的1都转换到最后（一定是可以的，因为10可以变成01），然后再将中间的00都转换成10最后剩下的就只有中间的一个0，这样就使得结果最大了。最终的结果就是1111...0...111类似的形式\n```java\n​public class MaximumBinaryString {\n    //100101100 --> 100000111 --> 111110111\n1   //1100 --> 1110\n    public String maximumBinaryString(String binary) {\n        int n = binary.length();\n        int cnt = 0;\n        int i = 0;\n        while (i < n && binary.charAt(i) == '1') i++;\n        if (i==n) return binary;\n        while (i < n) {\n            if (binary.charAt(i) == '1') cnt++;\n            i++;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < n-cnt-1; j++) {\n            sb.append(\"1\");\n        }\n        sb.append(\"0\");\n        for (int j = 0; j < cnt; j++) {\n            sb.append(\"1\");\n        }\n        return sb.toString();\n    }\n}\n```\n\n## [1703. 得到连续K个1的最少相邻交换次数](https://leetcode-cn.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/)\n\nDifficulty: **困难**\n\n\n给你一个整数数组 `nums` 和一个整数 `k` 。 `nums` 仅包含 `0` 和 `1` 。每一次移动，你可以选择 **相邻** 两个数字并将它们交换。\n\n请你返回使 `nums` 中包含 `k` 个连续 `1` 的最少交换次数。\n\n**示例 1：**\n\n```c\n输入：nums = [1,0,0,1,0,1], k = 2\n输出：1\n解释：在第一次操作时，nums 可以变成 [1,0,0,0,1,1] 得到连续两个 1 。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [1,0,0,0,0,0,1,1], k = 3\n输出：5\n解释：通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,1,1,1] 。\n```\n\n**示例 3：**\n\n```c\n输入：nums = [1,1,0,1], k = 2\n输出：0\n解释：nums 已经有连续 2 个 1 了。\n```\n\n**提示：**\n\n*   1 <= nums.length <= 10<sup>5</sup>\n*   `nums[i]` 要么是 `0` ，要么是 `1` 。\n*   1 <= k <= sum(nums)\n\n\n### 解法一\n\n单独写了一篇文章整理类似的题，[详见](http://imlgw.top/2021/01/17/tan-xin-jue-dui-zhi-bu-deng-shi/#1703-%E5%BE%97%E5%88%B0%E8%BF%9E%E7%BB%ADK%E4%B8%AA1%E7%9A%84%E6%9C%80%E5%B0%91%E7%9B%B8%E9%82%BB%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0)","tags":["LeetCode","动态规划"],"categories":["算法"]},{"title":"力扣220th周赛","url":"/2020/12/29/li-kou-220th-zhou-sai/","content":"\n> 好久没写LeetCode的题了，来补一下[220周赛](https://leetcode-cn.com/contest/weekly-contest-220/)的T3和T4\n## [1696. 跳跃游戏 VI](https://leetcode-cn.com/problems/jump-game-vi/)\n\nDifficulty: **中等**\n\n\n给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。\n\n一开始你在下标 `0` 处。每一步，你最多可以往前跳 `k` 步，但你不能跳出数组的边界。也就是说，你可以从下标 `i` 跳到 `[i + 1， min(n - 1, i + k)]` **包含** 两个端点的任意位置。\n\n你的目标是到达数组最后一个位置（下标为 `n - 1` ），你的 **得分** 为经过的所有数字之和。\n\n请你返回你能得到的 **最大得分** 。\n\n**示例 1：**\n\n```c\n输入：nums = [1,-1,-2,4,-7,3], k = 2\n输出：7\n解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\n```\n\n**示例 2：**\n\n```c\n输入：nums = [10,-5,-2,4,0,3], k = 3\n输出：17\n解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。\n```\n\n**示例 3：**\n\n```c\n输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n输出：0\n```\n\n**提示：**\n\n*   1 <= nums.length, k <= 10<sup>5</sup>\n*   -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>\n\n\n### 解法一\n递推公式很容易得到，先来一发暴力解法，不出意料的T了\n```java\n//1 2 3 4 5 k=2\npublic int maxResult(int[] nums, int k) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    dp[0] = nums[0];\n    for (int i = 1; i < n; i++) {\n        dp[i] = -0x3f3f3f3f;\n        for (int j = i-1; i-j <= k && j >= 0; j--) {\n            dp[i] = Math.max(dp[j]+nums[i], dp[i]);\n        }\n    }\n    return dp[n-1];\n}\n```\n\n### 解法二\n其实这题想了挺久的，主要是没想到T3会用到单调队列去优化dp，很巧的是这个单调队列优化这个知识点我刚刚在yxc那边学了一点，那个题目相对这题会复杂很多，是多重背包的问题。然后我就感觉这个题好像也可以用单调队列来优化，然后就试了一发，然后就AC了😁\n> 这里也可以借助其他的数据结构，比如线段树，st表，优先队列什么的去维护连续的大小为k的区间的最大值，这里我就不写了\n```java\n//1 2 3 4 5 k=2\npublic int maxResult(int[] nums, int k) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    dp[0] = nums[0];\n    //dp[i]   = Max(       dp[i-1], dp[i-2], dp[i-3],... dp[i-k+1], dp[i-k])\n    //dp[i+1] = Max(dp[i], dp[i-1], dp[i-2], dp[i-3],... dp[i-k+1])\n    //dp[i] --> dp[i+1] 滑动窗口最大值\n    LinkedList<int[]> queue = new LinkedList<>();\n    for (int i = 1; i < n; i++) {\n        while (!queue.isEmpty() && dp[i-1] > queue.getLast()[0]) {\n            queue.removeLast();\n        }\n        if (!queue.isEmpty() && i-queue.getFirst()[1] >= k) {\n            queue.removeFirst();\n        }\n        //这里也可以在队列中只存dp值的坐标，简化代码\n        queue.addLast(new int[]{dp[i-1], i});\n        dp[i] = queue.getFirst()[0]+nums[i];\n    }\n    return dp[n-1];\n}\n```\n\n## [1697. 检查边长度限制的路径是否存在](https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/)\n\nDifficulty: **困难**\n\n\n给你一个 `n` 个点组成的无向图边集 `edgeList` ，其中edgeList[i] = [u<sub style=\"display: inline;\">i</sub>, v<sub style=\"display: inline;\">i</sub>, dis<sub style=\"display: inline;\">i</sub>] 表示点 u<sub style=\"display: inline;\">i</sub>` 和点 `v<sub style=\"display: inline;\">i</sub> 之间有一条长度为 dis<sub style=\"display: inline;\">i</sub> 的边。请注意，两个点之间可能有超过一条边。\n\n给你一个查询数组`queries` ，其中 queries[j] = [p<sub style=\"display: inline;\">j</sub>, q<sub style=\"display: inline;\">j</sub>, limit<sub style=\"display: inline;\">j</sub>] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 p<sub style=\"display: inline;\">j</sub> 到 q<sub style=\"display: inline;\">j</sub>的路径，且这条路径上的每一条边都 **严格小于** limit<sub style=\"display: inline;\">j</sub>。\n\n请你返回一个 **布尔数组**`answer`，其中`answer.length == queries.length` ，当 `queries[j]` 的查询结果为 `true` 时， `answer` 第`j` 个值为`true`，否则为 `false` 。\n\n**示例 1：**\n\n![](https://i.loli.net/2020/12/30/WiZjdPCsFca4JlE.png)\n\n```c\n输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n输出：[false,true]\n解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。\n对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。\n对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。\n```\n\n**示例 2：**\n\n![](https://i.loli.net/2020/12/30/TRQdGcei1S8UX9k.png)\n\n```c\n输入：n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n输出：[true,false]\n解释：上图为给定数据。\n```\n\n**提示：**\n\n*   2 <= n <= 10<sup>5</sup>\n*   1 <= edgeList.length, queries.length <= 10<sup>5</sup>\n*   edgeList[i].length == 3\n*   queries[j].length == 3\n*   0 <= u<sub style=\"display: inline;\">i</sub>, v<sub style=\"display: inline;\">i</sub>, p<sub style=\"display: inline;\">j</sub>, q<sub style=\"display: inline;\">j</sub> <= n - 1\n*   u<sub style=\"display: inline;\">i</sub> != v<sub style=\"display: inline;\">i</sub>\n*   p<sub style=\"display: inline;\">j</sub> != q<sub style=\"display: inline;\">j</sub>\n*   1 <= dis<sub style=\"display: inline;\">i</sub>, limit<sub style=\"display: inline;\">j</sub> <= 10<sup>9</sup>\n*   两个点之间可能有 **多条** 边。\n\n\n### 解法一\n\n看到了评论区的一句提示然后写出了下面的解法，后来看题解区大佬科普这种类型的题目属于[离线算法](https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-shi-yao-j-pn1b/)，其实核心的思想就是，对查询的limit和边权值进行排序，然后从小query的limit开始，将edge权值不大于limit的都丢到并查集里面，然后查询一下就行了\n```java\nint[] parent;\n\npublic int find(int a) {\n    if (parent[a] == a) {\n        return a;\n    }\n    return parent[a] = find(parent[a]);\n}\n\npublic void union(int a,int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) return;\n    parent[pa] = pb; \n}\n\nclass Pair {\n    int p, q;\n    int limit;\n    int idx;\n    public Pair(int p, int q, int limit, int idx) {\n        this.p = p;\n        this.q = q;\n        this.limit = limit;\n        this.idx = idx;\n    }\n}\n\npublic boolean[] distanceLimitedPathsExist(int n, int[][] edge, int[][] q) {\n    parent = new int[n];\n    for (int i = 0; i < n; i++) parent[i] = i;\n    boolean[] res = new boolean[q.length];\n    Pair[] query = new Pair[q.length];\n    for (int i = 0; i < q.length; i++) {\n        query[i] = new Pair(q[i][0], q[i][1], q[i][2], i);\n    }\n    Arrays.sort(edge, (e1, e2)->e1[2]-e2[2]);\n    Arrays.sort(query, (q1, q2)->q1.limit-q2.limit);\n    int j = 0;\n    for (int i = 0; i < query.length; i++) {\n        while (j < edge.length && edge[j][2] < query[i].limit) {\n            union(edge[j][0], edge[j][1]);\n            j++;\n        }\n        res[query[i].idx] = find(query[i].p) == find(query[i].q);\n    }\n    return res;\n}\n```\n看了大佬们的代码后稍微做了下点简化\n```java\nint[] parent;\n\npublic int find(int a) {\n    if (parent[a] == a) return a;\n    return parent[a] = find(parent[a]);\n}\n\npublic void union(int a,int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) return;\n    parent[pa] = pb; \n}\n\npublic boolean[] distanceLimitedPathsExist(int n, int[][] edge, int[][] q) {\n    parent = new int[n];\n    int qlen = q.length;\n    for (int i = 0; i < n; i++) parent[i] = i;\n    boolean[] res = new boolean[qlen];\n    //记录query排序后的id\n    Integer[] qid = new Integer[qlen];\n    for (int i = 0; i < qlen; i++) qid[i] = i;\n    Arrays.sort(edge, (e1, e2)->e1[2]-e2[2]);\n    Arrays.sort(qid, (i1, i2)->q[i1][2]-q[i2][2]);\n    int j = 0;\n    for (int i = 0; i < qlen; i++) {\n        while (j < edge.length && edge[j][2] < q[qid[i]][2]) {\n            union(edge[j][0], edge[j][1]);\n            j++;\n        }\n        res[qid[i]] = find(q[qid[i]][0]) == find(q[qid[i]][1]);\n    }\n    return res;\n}\n```","tags":["LeetCode","动态规划"],"categories":["算法"]},{"title":"Lc1621.大小为K的不重叠线段的数目","url":"/2020/11/24/lc1621-da-xiao-wei-k-de-bu-chong-die-xian-duan-de-shu-mu/","content":"\n## [1621. 大小为 K 的不重叠线段的数目](https://leetcode-cn.com/problems/number-of-sets-of-k-non-overlapping-line-segments/)\n\nDifficulty: **中等**\n\n\n给你一维空间的 `n` 个点，其中第 `i` 个点（编号从 `0` 到 `n-1`）位于 `x = i` 处，请你找到 **恰好** `k` **个不重叠** 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 **整数坐标** 。这 `k` 个线段不需要全部覆盖全部 `n` 个点，且它们的端点可以重合。\n请你返回 `k` 个不重叠线段的方案数。由于答案可能很大，请将结果对 `1e9+7` **取余** 后返回。\n\n**示例 1：**\n\n![](https://i.loli.net/2020/11/24/CO2b9MBa5WFTNnU.png)\n\n```c\n输入：n = 4, k = 2\n输出：5\n解释：\n如图所示，两个线段分别用红色和蓝色标出。\n上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。\n```\n\n**示例 2：**\n\n```c\n输入：n = 3, k = 1\n输出：3\n解释：总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。\n```\n\n**示例 3：**\n\n```c\n输入：n = 30, k = 7\n输出：796297179\n解释：画 7 条线段的总方案数为 3796297200 种。将这个数对 109 + 7 取余得到 796297179 。\n```\n\n**示例 4：**\n\n```c\n输入：n = 5, k = 3\n输出：7\n```\n\n**示例 5：**\n\n```c\n输入：n = 3, k = 2\n输出：1\n```\n\n**提示：**\n\n*   `2 <= n <= 1000`\n*   `1 <= k <= n-1`\n\n### 解法一\n\n这题题想了好久，最终还是妥协了，看了题解，发现有暴搜+记忆化的解法，试了下，T了\n```java\nint MOD = (int)1e9+7;\n\n//写个暴搜试试（T了）\npublic int numberOfSets2(int n, int k) {\n    Long[][] dp = new Long[n+1][k+1];\n    return dfs(n, k, dp);\n}\n\n//n个点放k条线段的方案数\npublic int dfs(int n, int k, Long[][] dp) {\n    if (dp[n][k] != null) {\n        return dp[n][k].intValue();\n    }\n    if (k == 0) {\n        return 1;\n    }\n    if (k == 1) {\n        return (n-1)*n/2;\n    }\n    long res = 0;\n    for (int i = 1; n-i >= k-2; i++) {\n        //前(i+1)个点放一条线段有i种方案（刨开之前的方案）\n        res += 1l * i * dfs(n-i, k-1, dp);\n        res = (res + MOD) % MOD;\n    }\n    dp[n][k] = res;\n    return (int)res;\n}\n```\n\n### 解法二\n\nN^3dp，`dp[i][j]`代表长度为i的节点放置j条线段有几种方案，状态的转移分两种情况\n1. 最后一条线段不覆盖右端点，那么递推就直接`dp[i][j] = dp[i-1][j]`\n2. 最后一条线段覆盖右端点，枚举最后一条线段的长度所对应的`dp[i-len][j-1]`累加起来\n\n```java\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    long[][] dp = new long[n+1][k+1];\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= Math.min(i-1, k); j++) {\n            //j没有覆盖右端点的情况\n            dp[i][j] = dp[i-1][j];\n            //枚举j覆盖区间右端点的所有情况，注意从1开始\n            for (int s = 1; s < i; s++) {\n                dp[i][j] = (dp[i][j] + dp[s][j-1]) % MOD;\n            }\n        }\n    }\n    return (int) dp[n][k];\n}\n```\n这里数据范围是1e3，显然N^3是过不了的，所以需要优化，三重循环种求的其实是前面已经计算过的累计的前缀和，所以可以通过前缀和优化成N^2\n```java\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    long[][] dp = new long[n+1][k+1];\n    long[][] sum = new long[n+1][k+1];\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        sum[i][0] = sum[i-1][0] + 1; \n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= Math.min(i-1, k); j++) {\n            //j没有覆盖右端点的情况\n            dp[i][j] = dp[i-1][j];\n            //枚举j覆盖区间右端点的所有情况，注意从1开始\n            // for (int s = 1; s < i; s++) {\n            //     dp[i][j] = (dp[i][j] + dp[s][j-1]) % MOD;\n            // }\n            dp[i][j] = (dp[i][j] + sum[i-1][j-1]) % MOD;\n            sum[i][j] = sum[i-1][j] + dp[i][j];\n        }\n    }\n    return (int) dp[n][k];\n}\n```\n\n### 解法三\n\n这种DP的方式更好理解\n- `dp[i][j][0]`: 前i个点放j条线段，第j条线段没有覆盖右端点，所以显然`dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1]`\n- `dp[i][j][1]`: 前i个点放j条线段，第j条线段覆盖右端点（可以延长），首先j位置单独成一条线段（`dp[i-1][j-1][0] + dp[i-1][j-1][1]`），然后就是j位置和前面的连成一条线段的（`dp[i-1][j]`）\n\n```java\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    //dp[i][j][0]: 前i个点放j条线段，第j条线段没有覆盖右端点\n    //dp[i][j][1]: 前i个点放j条线段，第j条线段覆盖右端点（可以延长）\n    long[][][] dp = new long[n+1][k+1][2];\n    for (int i = 0; i <= n; i++) {\n        dp[i][0][0] = 1;\n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= Math.min(i-1, k); j++) {\n            dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1];\n            dp[i][j][1] = dp[i-1][j-1][0] + dp[i-1][j-1][1] + dp[i-1][j][1];\n            dp[i][j][0] = (dp[i][j][0] + MOD) % MOD;\n            dp[i][j][1] = (dp[i][j][1] + MOD) % MOD;\n        }\n    }\n    return (int)(dp[n][k][0] + dp[n][k][1] + MOD) % MOD;\n}\n```\n### 解法四\n\n其实是上面解法的优化递推，省去了前缀和的空间，直接从状态转移方程上进行优化\n![mark](http://static.imlgw.top/blog/20201126/RxHR7Ushje0p.png?imageslim)\n列出递推中的连续两项，然后进行合并优化，直接得到递推公式\n```java\n//有一点技巧性的递推\npublic int numberOfSets(int n, int k) {\n    int MOD = (int)1e9+7;\n    //n个点，放k个线段，不重叠的方案数\n    long[][] dp = new long[n+1][k+1];\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n    }\n    \n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i-1 && j <= k; j++) {\n            //dp[2][1] = 2*dp[1][1] - dp[0][1] + dp[1][0]\n            dp[i][j] = 2*dp[i-1][j] - dp[i-2][j] + dp[i-1][j-1];\n            dp[i][j] = (dp[i][j] + MOD) % MOD;\n        }\n    }\n    return (int)dp[n][k];\n}\n```\n\n### 解法五\n\n数学法，看不懂，求C(n+k-1, 2k)","tags":["LeetCode","动态规划"],"categories":["算法"]},{"title":"PC端软件推荐","url":"/2020/11/19/pc-duan-ruan-jian-tui-jian/","content":"\n# 贾老板专属链接\n\n## 远程桌面软件\n\n### Teamviewer\n个人不是很喜欢这个软件，现在要用这个软件必须要注册了，但是没办法，市面上对个人免费的，速度比较快的也就是它了，其他的要么卡的要死，要么贵的要死（微软自带的有一个远程桌面，但是只有专业版才有，家庭版要用挺麻烦的，而且得有公网IP，懒得折腾）\n\n平常电脑要是有啥问题，可以直接开这个，然后把账号密码截图给我，我鼓捣鼓捣兴许就给鼓捣好了😁\n> QQ远程比较卡，而且很多核心的系统设置QQ远程无法修改\n\n推荐指数⭐⭐⭐\n\n下载地址 [click](https://www.teamviewer.cn/cn/)\n\n## 安全方面\n推荐就使用**电脑自带**的安全管家，比如**戴尔电脑管家**之类的，如果没有的话建议直接裸奔（win10自带的有一个windows defender），只要不乱点奇怪的链接，下载或者启动奇怪的程序就行了，如果实在是不放心可以下载一个 [火绒](https://www.huorong.cn/)，没有广告弹窗什么的，体积也比较小\n\n![](https://i.loli.net/2020/11/18/sy7Z5vQRHemuCBX.png)\n\n> 不推荐装什么360，腾讯之类的安全管家，装一个就会连带装一些全家桶，挺恶心人的，如果已经装了，可以使用我下面推荐的卸载工具卸载掉\n\n## 卸载 & 清理\n\n### Geek\n\n绿色软件（指不用安装的软件），下载后双击启动就行了，可以用来卸载第三方的一些软件，也可以卸载一些uwp应用（微软应用商店安装的软件）。没有广告，体积小，推荐指数⭐⭐⭐⭐⭐\n\n下载地址 [click](https://wws.lanzous.com/iXFAZiiuq9g)\n\n### CClean\n\n垃圾清理软件，清注册表贼舒服操作比较简单，拒绝辣鸡软件残留（也是绿软）。推荐指数⭐⭐⭐⭐\n> 我这个是破解版，打开后会提示你更新，x掉就行\n\n下载地址 [click](https://wws.lanzous.com/i9Zrejswysb)\n\n### Dism++\n\n跟上面的一样也是垃圾清理软件，但是这个不能瞎搞，有些东西不能乱清理\n推荐指数⭐⭐⭐\n\n下载地址 [click](https://www.chuyu.me/zh-Hans/index.html)\n\n## 输入法\n推荐就使用微软自带的输入法，没有弹窗，没有广告，简洁干净，也有很多表情（win + . 触发），搜狗什么的，感觉不太靠谱，之前在微软社区看到有人更新win10因为搜狗而崩溃了，[传送门](https://answers.microsoft.com/zh-hans/windows/forum/windows_10-update/systemserviceexception%E8%93%9D%E5%B1%8F/e5c0a131-a155-4cc0-a871-b6089d474313?rtAction=1553553854556)\n\n推荐指数⭐⭐⭐⭐⭐\n## 浏览器\n### Google Chrome\n首先肯定是无脑这个，PC端最好用的浏览器，没有之一，但是Chrome在查看一些老的视频网站，或者一些需要使用flash的网页时，会有点麻烦，Chrome默认会禁用flash（flash这项技术不安全，漏洞太多，目前已经被淘汰，但是某些网站仍在使用，比如4399😁）\n推荐指数⭐⭐⭐⭐⭐\n### 360极速浏览器\n注意是**360极速浏览器**，这个不会有捆绑，我在没换电脑之前也用了很长一段时间的这个浏览器，这个用的是Chrome的内核。这个浏览器是可以直接播放flash的，不需要设置，但是这个浏览器启动贼慢，冷启动要6，7秒，离谱的很\n推荐指数⭐⭐⭐\n\n下载地址 [click](https://browser.360.cn/ee/)\n### Edge\n也就是你现在电脑上自带的哪个，原本自带的是ie，但是现在新版的win10已经都换成这个了，这个用的也是Chrome的内核，也挺好用的\n推荐指数⭐⭐⭐⭐\n## 视频播放器\n\n### PotPlayer\n其实win10自带的有一个播放器，但是支持的视频格式不是很多，而且功能比较少（不能倍数，不能逐帧...），这个PotPlayer比较好用，没有广告，页面简洁，支持市面上大多数视频格式。推荐指数⭐⭐⭐⭐⭐\n下载地址 [click](https://daumpotplayer.com/wp-content/uploads/2020/10/PotPlayerSetup64.exe)\n\n## PDF阅读器\n\n### PDFread\n\n平常看一些pdf文件（电子书）时可以用这个（浏览器也可以直接打开pdf查看，但是不能保存阅读记录，每次要重新打开）\n![](https://i.loli.net/2020/11/18/yhOdHpzFXQTet1W.png)\n也是绿色软件，打开即用，无需安装。\n推荐指数⭐⭐⭐⭐⭐\n\n下载地址 [click](https://wws.lanzous.com/i8uZ6iivtij)\n\n## 解压 & 压缩\n\n### Bandzip\n简洁好用，最近在免费版本中右下角加入了一点广告，但是只有你主动去启动压缩软件才会出现，正常人应该不会主动去点击压缩软件，平常右键压缩解压是看不见广告的，还算是比较克制，目前还没有影响我使用体验（国内某数字压缩软件一边凉快去吧）。推荐指数⭐⭐⭐⭐\n\n下载地址 [click](https://www.bandisoft.com/bandizip/)\n### 7-zip\n\n这个是完全免费的绿色软件，但是感觉界面比较简陋，有一点学习成本\n推荐指数⭐⭐⭐⭐\n\n下载地址 [click](https://www.7-zip.org/a/7z1900-x64.exe)\n\n## 文件搜索\n\n### Everything\n\n文件检索的工具，第一次初始化会有点慢，后续搜索会非常迅速，体积小，绿色软件，无需安装\n推荐指数⭐⭐⭐⭐⭐\n\n下载地址 [click](https://www.voidtools.com/Everything-1.4.1.992.x64.zip)\n\n## 桌面整理\n### DeskGo\n腾讯桌面整理，tx难得的良心软件，本来是QQ安全管家里面附带的，后来被单独提取出来了，没广告，没捆绑，占用小（几十M）。用起来大概是这个样子\n![mark](http://static.imlgw.top///20190414/Ch6k6LNP3CU2.png?imageslim)\n可以整理乱糟糟的桌面，把应用程序，文件啥的分类之后摆放的整整齐齐（强迫症必备😂）推荐指数⭐⭐⭐⭐⭐\n\n> 实际上我现在已经不用这个桌面整理的软件了，我桌面上啥都没有（这样就不用整理了🤣）\n> ![](https://i.loli.net/2020/11/18/UFA2gaJ4lxCWbyN.png)\n\n\n下载地址 [click](https://dl.softmgr.qq.com/original/Office/DeskGo_3_1_1427_127_lite.exe)\n\n## 浏览器插件\n这一块可能会有一点麻烦，需要先把梯子弄好\n浏览器插件有很多挺有用的功能，很多骚操作，可以自己研究研究\n1. 无限制复制粘贴（某度文库不让复制）\n2. 一些影视网站（aiqiyi, tencent...）直接解析到盗版网站在线观看\n3. 广告拦截（ADBlock，非常强力）\n4. B站 | 知乎 | youtube | ...视频下载\n5. 划词翻译\n6. lastpass，之前给你介绍的密码管理软件的浏览器插件版本，可以自动填充密码，保存密码，随机密码\n7. ....\n\n## OCR\n### 天若OCR\n绿色软件，体积很小，无需安装，扫描也很准确（曾经用这个扫描别人手写的作业，然后copy😁）推荐指数⭐⭐⭐⭐\n\n下载地址 [click](https://wws.lanzous.com/iF9Wjiiz4af)\n## 在线画流程图网站\n[draw.io](https://app.diagrams.net/)\n在线画图工具，谁用谁知道，现在也有桌面版本的了\n![](https://i.loli.net/2020/11/18/lxbAdeE8knGtQBg.png)\n\n## 梯子\n直接看官方给的教程就ok了\n\nhttps://xcat.us/user/tutorial_v2ray\n\n## 常用的网站\n\n- http://imlgw.top/ 不多说，赶快收藏置顶\n- https://www.deepl.com/translator 专业翻译\n- https://www.gaitubao.com/ 在线改图，压图，修改格式，很好用\n- https://wallhaven.cc/ 高清壁纸，图片（很多比较大的图下载后需要手动的改图，改成1080才能适配）\n- https://wall.alphacoders.com/ 也是壁纸图片素材网站，这个可以在线的改图的分辨率，改成1080就可以直接拿来做壁纸了\n- https://www.lanzou.com/ 这个用来做小文件（小于100M）分享很好用，免费，不限速，不需要下载客户端，（某度云我基本已经抛弃了，大文件下载限速限到死，小文件下载还得下客户端，我要那么大的空间有毛用，下都下不来）","tags":["软件推荐"],"categories":["杂项"]},{"title":"DP：最长上升子序列模型","url":"/2020/11/14/dp-zui-chang-shang-sheng-zi-xu-lie-mo-xing/","content":"\n> 现在打算写一些短点的文章了，LeetCode系列不会再append了，如果写lc题会单独开一篇文章，然后写题解\n\n## 最长上升子序列模型\n\n[300. 最长上升子序列](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97)\n\n[673. 最长递增子序列的个数](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0)\n\n[1016. 使序列递增的最小交换次数（LintCode）](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#1016-%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%EF%BC%88LintCode%EF%BC%89)\n\n[354. 俄罗斯套娃信封问题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98)\n\nLIS有N^2的DP解法，也有NlogN的贪心的解法，具体用那种取决于数据范围\n\n## [1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)\n\n怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。\n\n而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。\n\n有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。\n\n不得已，怪盗基德只能操作受损的滑翔翼逃脱。\n\n假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。\n\n初始时，怪盗基德可以在任何一幢建筑的顶端。\n\n他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。\n\n因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。\n\n他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。\n\n请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？\n\n**输入格式**\n\n输入数据第一行是一个整数K，代表有K组测试数据。\n\n每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。\n\n**输出格式**\n\n对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。\n\n**数据范围**\n\n1≤K≤100, 1≤N≤100, 0<h<10000\n\n**输入样例：**\n```c\n3\n8\n300 207 155 299 298 170 158 65\n8\n65 158 170 298 299 155 207 300\n10\n2 1 3 4 5 6 7 8 9 10\n```\n**输出样例：**\n```c\n6\n6\n9\n```\n\n### 解法一\n\n常规N^2动态规划的方式 & NlogN贪心解法（NlogN的解法回忆了一会儿才推出来，如果数据范围不是很大还是N^2的dp好写）\n```java\nimport java.io.*;\nimport java.util.*;\n//AcWing 1017. 怪盗基德的滑翔翼 https://www.acwing.com/problem/content/1019/\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while (T-- > 0) {\n            int n = sc.nextInt();\n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) {\n                w[i] = sc.nextInt(); \n            }\n            System.out.println(Math.max(solve(w, n), solve(reverse(w), n))); \n        }\n    }\n\n    //DP(N^2)的解法\n    public static int solve(int[] w, int n) {\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int res = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (w[j] > w[i]) {\n                    dp[i] = Math.max(dp[j]+1, dp[i]);  \n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res; \n    }\n\n    //tail[i]: 长度为i的递减子序列最大结尾\n    public static int solve2(int[] w, int n) {\n        int[] tail = new int[n];\n        int len = 0;\n        for (int i = 0; i < n; i++) {\n            int idx = search(tail, len, w[i]);\n            if (idx == -1) {\n                tail[len++] = w[i];\n            } else {\n                tail[idx] = w[i];\n            }\n        }\n        return len;\n    }\n\n    //从左到右找第一个小于target的元素下标，替换它，使得结尾更大，长度更长\n    public static int search(int[] tail, int len, int target){\n        int left = 0, right = len-1;\n        int res = -1;\n        while (left <= right) {\n            int mid = left + (right - left)/2;\n            if (tail[mid] <= target) {\n                res = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return res;\n    }\n\n    public static int[] reverse(int[] w) {\n        for (int i = 0, j = w.length-1; i < j; i++, j--) {\n            int temp = w[i];\n            w[i] = w[j];\n            w[j] = temp;\n        }\n        return w;\n    }\n}\n```\n\n## [1014. 登山](https://www.acwing.com/problem/content/1016/)\n\n五一到了，ACM队组织大家去登山观光，队员们发现山上一个有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。\n\n同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。\n\n队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？\n\n**输入格式**\n\n第一行包含整数N，表示景点数量。\n\n第二行包含N个整数，表示每个景点的海拔。\n\n**输出格式**\n\n输出一个整数，表示最多能浏览的景点数。\n\n**数据范围**\n2≤N≤1000\n**输入样例：**\n```c\n8\n186 186 150 200 160 130 197 220\n```\n**输出样例：**\n```c\n4\n```\n\n### 解法一\n\nLIS转换了一下而已，求每个点从**左到右** 和 从**右到左**的最长上升子序列最大和就ok了\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] w = new int[N];\n        for (int i = 0; i < N; i++) {\n            w[i] = sc.nextInt();\n        }\n        System.out.println(solve(w, N));\n    }\n\n    //186 186 150 200 160 130 197 220  := 4\n    public static int solve(int[] w, int N) {\n        int[] dp1 = new int[N];\n        int[] dp2 = new int[N];\n        Arrays.fill(dp1, 1);\n        Arrays.fill(dp2, 1);\n        int res = 1;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < i; j++) {\n                if (w[j] < w[i]) {\n                    dp1[i] = Math.max(dp1[j]+1, dp1[i]);          \n                }\n            }\n        }\n        for (int i = N-1; i >= 0; i--) {\n            for (int j = N-1; j > i; j--) {\n                if (w[j] < w[i]) {\n                    dp2[i] = Math.max(dp2[j]+1, dp2[i]);          \n                }\n            }\n            res = Math.max(res, dp1[i]+dp2[i]-1);\n        }\n        return res;\n    }\n}\n```\n> [482. 合唱队形](https://www.acwing.com/problem/content/484/)和这一题一样，不重复写了\n\n## [1012. 友好城市](https://www.acwing.com/problem/content/1014/)\n\nPalmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。\n\n北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。\n\n每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。\n\n编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。\n\n**输入格式**\n\n第1行，一个整数N，表示城市数。\n\n第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。\n\n**输出格式**\n\n仅一行，输出一个整数，表示政府所能批准的最多申请数。\n\n**数据范围**\n\n1≤N≤5000,\n0≤xi≤10000\n\n**输入样例：**\n```c\n7\n22 4\n2 6\n10 3\n15 12\n9 8\n17 17\n4 2\n```\n**输出样例：**\n```c\n4\n```\n\n### 解法一\n\n和之前的[354. 俄罗斯套娃信封问题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98)一样，还简单一点，坐标都是唯一的，不需要考虑坐标重合的问题，具体可以去看看俄罗斯套娃的这个题\n\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[][] w = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            w[i][0] = sc.nextInt();\n            w[i][1] = sc.nextInt();\n        }\n        System.out.println(solve2(w, N));\n    }\n\n    //5000 * 5000 = 2500 0000，能过但是有点慢\n    public static int solve(int[][] w, int N) {\n        Arrays.sort(w, (w1, w2)->w1[0]-w2[0]);\n        int res = 1;\n        int[] dp = new int[N];\n        for (int i = 0; i < N; i++) {\n            dp[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (w[j][0] < w[i][0] && w[j][1] < w[i][1]) {\n                    dp[i] = Math.max(dp[j]+1, dp[i]);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n\n    //NlogN贪心二分的做法\n    public static int solve2(int[][] w, int N) {\n        Arrays.sort(w, (w1, w2)->w1[0]-w2[0]);\n        int[] tail = new int[N];\n        int len = 0;\n        for (int i = 0; i < N; i++) {\n            int idx = search(tail, len, w[i][1]);\n            if (idx == -1) {\n                tail[len++] = w[i][1];\n            } else {\n                tail[idx] = w[i][1];\n            }\n        }\n        return len;\n    }\n\n    //从左到右找第一个大于target的，后面替换它，使得结尾更小\n    public static int search(int[] tail, int len, int target) {\n        int left = 0, right = len-1;\n        int res = -1;\n        while (left <= right) {\n            int mid = left + (right - left)/2;\n            if (tail[mid] > target) {\n                res = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return res;\n    }\n}\n```\n\n## [1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/)\n\n一个数的序列 bi，当 b1<b2<…<bS 的时候，我们称这个序列是上升的。\n\n对于给定的一个序列(a1,a2,…,aN)，我们可以得到一些上升的子序列(ai1,ai2,…,aiK)，这里1≤i1<i2<…<iK≤N。\n\n比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。\n\n这些子序列中和最大为18，为子序列(1,3,5,9)的和。\n\n你的任务，就是对于给定的序列，求出最大上升子序列和。\n\n注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。\n\n**输入格式**\n\n输入的第一行是序列的长度N。\n\n第二行给出序列中的N个整数，这些整数的取值范围都在0到10000(可能重复)。\n\n**输出格式**\n\n输出一个整数，表示最大上升子序列和。\n\n**数据范围**\n\n1≤N≤1000\n\n**输入样例：**\n```c\n7\n1 7 3 5 9 4 8\n```\n**输出样例：**\n```\n18\n```\n\n### 解法一\n\n没啥好说的，比较简单\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] w = new int[N];\n        for (int i = 0; i < N; i++) {\n            w[i] = sc.nextInt();\n        }\n        System.out.println(solve(w, N));\n    }\n\n    public static int solve(int[] w, int N) {\n        int[] dp = new int[N];\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            dp[i] = w[i];\n            for (int j = 0; j < i; j++) {\n                if (w[j] < w[i]) {\n                    dp[i] = Math.max(dp[i], dp[j]+w[i]);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n}\n```\n## [1010. 拦截导弹](https://www.acwing.com/problem/content/description/1012/)\n\n某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。\n\n但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。\n\n某天，雷达捕捉到敌国的导弹来袭。\n\n由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n\n输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n\n**输入格式**: \n\n共一行，输入导弹依次飞来的高度。\n\n**输出格式**: \n\n第一行包含一个整数，表示最多能拦截的导弹数。\n\n第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。\n\n**输入样例：**\n```c\n389 207 155 300 299 170 158 65\n```\n**输出样例：**\n```c\n6\n2\n```\n\n### 解法一\n\nDilworth定理，双DP解法\n```java\n//300 250 275 252 200 138 245 := 5,2\n//最多击落多少就不多说了\n//最少需要的系统数量实际上就是最长上升子序列的个数，这里涉及到Dilworth定理\npublic static int[] solve(int[] w, int N){\n    int[] down = new int[N];\n    int[] up = new int[N];\n    int max = 0, count = 1;\n    for (int i = 0; i < N; i++) {\n        up[i] = down[i] = 1;\n        for (int j = 0; j < i; j++) {\n            if (w[j] >= w[i]) {\n                down[i] = Math.max(down[j]+1, down[i]);\n            } else {\n                up[i] = Math.max(up[j]+1, up[i]);\n            }\n        }\n        max = Math.max(max, down[i]);\n        count = Math.max(count, up[i]);\n    }\n    return new int[]{max, count};\n}\n```\n\n最多击落多少就不多说了，~~最少需要的系统数其实就是最长上升子序列，因为这个子序列是**必不可能在同一套系统中被击落**，当遇到这个子序列中的元素的时候，就需要增加一套系统，所以最少就是这个子序列的长度~~\n\n最少需要的系统数量（最少的覆盖整个序列的不上升序列个数）就是最长的上升子序列长度，涉及到Dilworth定理（[导弹拦截问题与Dilworth定理](https://www.cnblogs.com/flipped/p/5009943.html)），感兴趣可以去了解下，定理的定义为：_对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目_ \n\n本题中，最少需要的导弹系统数量就是**最小链划分中链的数量**，其最大反链就是**最长上升子序列长度**，所以直接求最长上升子序列的长度就ok了\n\n### 解法二\n\n双贪心解法。\n\n①求LIS的贪心做法，`tail[j]`表示长度为`j`的下降序列，每个`w[i]`作为结尾的时候优先选择大于`w[i]`的最小的`tail[j]`（也就是从左到右最第一个大于w[i]的），然后接在它后面，这样让长度为j的下降序列结尾变小，后面可以接上更多的元素，使得序列可以更长，并且这样不会影响之前已有的序列关系，最终tail的长度就是最长上升子序列的长度\n\n②求最少的覆盖全序列的下降子序列个数，`tail[j]`表示目前为止第`j`个系统的最大结尾元素，每个`w[i]`被遍历到的时候都是作为某一个系统的结尾，那么此时就会面临选择，这个时候我们就可以贪心的将其放置到**大于`w[i]`的最小的tail后面**，这样避免浪费其他较大的结尾（结尾越大，后面可以接的导弹越多），选择消耗一个最小的结尾，可能有点抽象，举个例子就明白了\n![](https://i.loli.net/2020/11/23/VY6nU9oFuaB3GkO.png)\n\n这里1就面临两个选择，要么接在2后面，要么接在4后面，很明显这里应该接在2后面，如果接在3后面那么后面的3就只能新建一个系统，会增加系统数量\n\n具体的证明可以采用微调法，证明贪心解是小于等于最优解的，这里不再展开\n```java\n//9 8 7 9 8 7 9 8 7 55 66 99 88 77 88 963 365 4561\n//双贪心写法\npublic static int[] solve2(int[] w, int N){\n    int[] res = new int[2];\n    //长度为i的最长下降子序列的最小结尾\n    int[] tail = new int[N];\n    int len = 0;\n    //最长下降子序列（不严格）\n    for (int i = 0; i < w.length; i++) {\n        //找tail中第一个小于w[i]的替换掉，这样后面可以接更多的数\n        //可以二分优化下，这里就不写了\n        int idx;\n        for (idx = 0; idx < len; idx++) {\n            if (tail[idx] < w[i]) {\n                break;\n            }\n        }\n        tail[idx] = w[i];\n        len += (idx == len) ? 1 : 0;\n    }\n    res[0] = len;\n    tail = new int[N];\n    len = 0;\n    //最少覆盖全序列的下降子序列个数\n    for (int i = 0; i < w.length; i++) {\n        //找tail中第一个大于等于w[i]的替换掉\n        //可以二分优化下，这里就不写了\n        int idx;\n        for (idx = 0; idx < len; idx++) {\n            if (tail[idx] >= w[i]) {\n                break;\n            }\n        }\n        tail[idx] = w[i];\n        len += (idx == len) ? 1 : 0;\n    }\n    res[1] = len;\n    return res;\n}\n```\n\n## [187. 导弹防御系统](https://www.acwing.com/problem/content/189/)\n\n为了对抗附近恶意国家的威胁，R国更新了他们的导弹防御系统。\n\n一套防御系统的导弹拦截高度要么一直 严格单调 上升要么一直 严格单调 下降。\n\n例如，一套系统先后拦截了高度为3和高度为4的两发导弹，那么接下来该系统就只能拦截高度大于4的导弹。\n\n给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。\n\n**输入格式**\n\n输入包含多组测试用例。\n\n对于每个测试用例，第一行包含整数n，表示来袭导弹数量。\n\n第二行包含n个不同的整数，表示每个导弹的高度。\n\n当输入测试用例n=0时，表示输入终止，且该用例无需处理。\n\n**输出格式**\n\n对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。\n\n**数据范围**： 1≤n≤50\n\n**输入样例：**\n```java\n5\n3 5 2 4 1\n0 \n```\n**输出样例：**\n\n```java\n2\n样例解释\n对于给出样例，最少需要两套防御系统。\n\n一套击落高度为3,4的导弹，另一套击落高度为5,2,1的导弹。\n```\n\n### 解法一\n\n搜索 + 贪心剪枝，搜索的复杂度是O(N*2^N)，每个位置有两种选择，每次选择都需要遍历up或者down，虽然时间复杂度很高，但是整体的结果比较小，所以很多情况都被剪掉了，整体速度还不错\n```java\nimport java.util.*;\nimport java.io.*;\n//1. 考虑每个点是在上升序列中还是下降序列中\n//2. 考虑是否需要新建一个单独的序列\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int N = sc.nextInt();\n            if (N == 0) return;\n            int[] w = new int[N];\n            up = new int[N];\n            down = new int[N];\n            res = Integer.MAX_VALUE;\n            for (int i = 0; i < N; i++) {\n                w[i] = sc.nextInt();\n            }\n            dfs(w, 0, 0, 0);\n            System.out.println(res);\n        }\n    }\n\n    static int[] up = null;\n    static int[] down = null;\n    static int res;\n\n    public static void dfs(int[] w, int c, int ul, int dl) {\n        //关键的剪枝\n        if (ul+dl >= res) return;\n        if (c == w.length) {\n            res = Math.min(ul+dl, res);\n            return;\n        }\n        //将c放在上升序列中\n        boolean flag = false;\n        for (int i = 0; i < ul; i++) {\n            if (up[i] > w[c]) {\n                flag = true;\n                int temp = up[i];\n                up[i] = w[c];\n                dfs(w, c+1, ul, dl);\n                up[i] = temp;\n                break;\n            }\n        }\n        if (!flag) {\n            up[ul] = w[c];\n            dfs(w, c+1, ul+1, dl);\n            up[ul] = 0;\n        }\n        flag = false;\n        for (int i = 0; i < dl; i++) {\n            if (down[i] < w[c]) {\n                flag = true;\n                int temp = down[i];\n                down[i] = w[c];\n                dfs(w, c+1, ul, dl);\n                down[i] = temp;\n                break;\n            }\n        }\n        if (!flag) {\n            down[dl] = w[c];\n            dfs(w, c+1, ul, dl+1);\n            down[dl] = 0;\n        }\n    }\n}\n```\n\n### 解法二\n\n迭代加深搜索，代码简化，在解比较小的时候可以使用这种搜索方式找最小值，结合了DFS和BFS的优点\n\n```java\npublic static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (sc.hasNext()) {\n        int N = sc.nextInt();\n        if (N == 0) return;\n        int[] w = new int[N];\n        up = new int[N];\n        down = new int[N];\n        res = Integer.MAX_VALUE;\n        for (int i = 0; i < N; i++) {\n            w[i] = sc.nextInt();\n        }\n        //dfs(w, 0, 0, 0);\n        int depth = 0;\n        while (!dfs(w, depth, 0, 0, 0)) {\n            depth++;\n        }\n        System.out.println(depth);\n    }\n}\n\nstatic int[] up = null;\nstatic int[] down = null;\n//迭代加深，BFS版的DFS\npublic static boolean dfs(int[] w, int depth, int c, int ul, int dl) {\n    if (ul+dl > depth) return false;\n    if (c == w.length) {\n        return true;\n    }\n    //将c放在上升序列中，那么我们应该找到小于w[i]的最大的tail\n    int i = 0;\n    for (i = 0; i < ul; i++) {\n        if (up[i] < w[c]) break;\n    }\n    int temp = up[i];\n    up[i] = w[c];\n    if (i == ul) {\n        if (dfs(w, depth, c+1, ul+1, dl)) {\n            return true;      \n        }\n    } else if (dfs(w, depth, c+1, ul, dl)) {\n        return true;\n    }\n    up[i] = temp;\n    //将c放在下降序列中，那么我们应该找到大于w[i]的最小的tail\n    for (i = 0; i < dl; i++) {\n        if (down[i] > w[c]) break;\n    }\n    temp = down[i];\n    down[i] = w[c];\n    if (i == dl) {\n        if (dfs(w, depth, c+1, ul, dl+1)) {\n            return true;\n        }\n    } else {\n        if (dfs(w, depth, c+1, ul, dl)) {\n            return true;\n        }\n    }\n    down[i] = temp;\n    return false;\n}\n```\n\n## [272. 最长公共上升子序列](https://www.acwing.com/problem/content/description/274/)\n\n熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\n\n小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\n\n小沐沐说，对于两个数列A和B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。\n\n奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\n\n不过，只要告诉奶牛它的长度就可以了。\n\n数列A和B的长度均不超过3000。\n\n**输入格式**\n\n第一行包含一个整数N，表示数列A，B的长度。\n\n第二行包含N个整数，表示数列A。\n\n第三行包含N个整数，表示数列B。\n\n**输出格式**\n\n输出一个整数，表示最长公共上升子序列的长度。\n\n**数据范围**\n\n1≤N≤3000, 序列中的数字均不超过2^31−1\n\n**输入样例：**\n```go\n4\n2 2 1 3\n2 1 2 3\n```\n**输出样例：**\n```go\n2\n```\n\n### 解法一\n\n朴素的解法应该自己想出来的，可惜，没想出来，看了解答才理解，这里`dp[i][j]` 是指**A序列的前i个字符和B的前j个字符组成的，以`B[j]`结尾的最长公共上升子序列长度**，实际上是lcs个lis的完美结合，因为状态定义指定了`B[j]`是一定要包含的，所以相比LCS的四种情况，这里只有两种情况，包含或者不包含`A[i]`\n- 不包含A[i]那么状态就是`dp[i-1][j]`; \n- 如果要包含A[i]，那么`A[i]`必须等于`B[j]`，否则就没有考虑的意义，然后我们按照LIS的方法去找一个最大值就ok了\n\n时间复杂度N^3，这里按道理是会被卡掉的，但是并没有...\n\n```java\nimport java.util.*;\nimport java.io.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        int[] B = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n        }\n        for (int i = 0; i < N; i++) {\n            B[i] = sc.nextInt();\n        }\n        System.out.println(solve(A, B, N));\n    }\n\n    public static int solve(int[] A, int[] B, int N){\n        //A前i个字符和B前j个字符并且以B[j]结尾的最长LCIS\n        int[][] dp = new int[N+1][N+1];\n        int res = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                dp[i][j] = dp[i-1][j];\n                if (A[i-1] == B[j-1]) {\n                    dp[i][j] = Math.max(dp[i][j], 1);\n                    for (int k = 1; k < j; k++) {\n                        if (B[j-1] > B[k-1]) {\n                            dp[i][j] = Math.max(dp[i][k]+1, dp[i][j]);\n                        }\n                    }\n                }\n                res = Math.max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 解法二\n对上面的解法做了等价变形，首先上面解法内循环是找`[1,j-1]`区间内`B[k]<B[j]`的最大值，同时此时的`B[j]==A[i]`，所以我们可以进行一波等价变形，动态的计算这个最大值，从而优化掉一层循环，还是很巧妙的\n\n```java\n//代码等价变形，时间复杂度N^2\npublic static int solveOpt(int[] A, int[] B, int N){\n    //A前i个字符和B前j个字符并且以B[j]结尾的最长LCIS\n    int[][] dp = new int[N+1][N+1];\n    int res = 0;\n    for (int i = 1; i <= N; i++) {\n        int maxv = 1;\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (A[i-1] == B[j-1]) {\n                dp[i][j] = Math.max(dp[i][j], maxv);\n            }\n            if (B[j-1] < A[i-1]) {\n                maxv = Math.max(maxv, dp[i][j]+1);\n            }\n            res = Math.max(res, dp[i][j]);\n        }\n    }\n    return res;\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"DP：数字三角形模型","url":"/2020/11/09/dp-shu-zi-san-jiao-xing-mo-xing/","content":"\n\n> 现在打算写一些短点的文章了，LeetCode系列不会再append了，如果写lc题会单独开一篇文章，然后写题解\n\n## 数字三角形模型\n\n[120. 三角形最小路径和](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C)\n\n[64. 最小路径和](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C)\n\n[Path sum: three ways](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#Path-sum-three-ways)\n\n之前写过题解的就不重复写了，还有很多类似的题就不一一列举出来了，详见[LeetCode动态规划](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/)\n\n> 后续如果还有类似的题会append进来\n## [1027. 方格取数](https://www.acwing.com/problem/content/1029/)\n\n设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：\n\n![](https://files.catbox.moe/hhonhx.png)\n\n某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。\n\n在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。\n\n此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。\n\n**输入格式**\n\n第一行为一个整数N，表示 N×N 的方格图。\n\n接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。\n\n行和列编号从 1 开始。\n\n一行“0 0 0”表示结束。\n\n**输出格式**\n\n输出一个整数，表示两条路径上取得的最大的和。\n\n**数据范围**\n\nN≤10\n\n**输入样例：**\n```c\n8\n2 3 13\n2 6 6\n3 5 7\n4 4 14\n5 2 21\n5 6 4\n6 3 15\n7 2 14\n0 0 0\n```\n**输出样例：**\n```c\n67\n```\n**难度：** 简单\n\n**来源：**《信息学奥赛一本通》 , NOIP2000提高组\n\n### 解法一\n\n一开始确实没想出来，主要是看着范围好小，然后不确定复杂度，以为可以搜索的，看了y总讲解了一点，然后想过来了，自己写了一个N^4的解法\n```java\n//input output省略\n//N^4 dp\npublic static int slove(int[][] w, int N) {\n    int[][][][] dp = new int[N+1][N+1][N+1][N+1];\n    for (int i1 = 1; i1 <= N; i1++) {\n        for (int j1 = 1; j1 <= N; j1++) {\n            for (int i2 = 1; i2 <= N; i2++) {\n                for (int j2 = 1; j2 <= N; j2++) {\n                    int temp = dp[i1][j1][i2][j2];\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1][i2][j2-1]);\n                    temp = Math.max(temp, dp[i1][j1-1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1][j1-1][i2][j2-1]);\n                    dp[i1][j1][i2][j2] = temp + ((i1==i2&&j1==j2) ? w[i1-1][j1-1] : (w[i1-1][j1-1] + w[i2-1][j2-1])); \n                }\n            }\n        }\n    }\n    return dp[N][N][N][N];\n}\n```\n其实如果是只有一条路径就很简单，线性DP就行了，`dp[i][j] = Max(dp[i-1][j], dp[i][j-1])`，但是这题涉及到了两条路径，所以我们可以将状态定义为`dp[i1][j1][i2][j2]`，含义为从（1，1）到（i1，j1）,(i2，j2)这两个点的最大和，到每个点有两种走法，2*2一共4种子状态，取Max就行了\n\n但是这里会有一个问题，某个点的val被取走之后就不能再被取了。也就是说，这两条路径可能会有交点，这种情况需要额外处理，而相交的情况实际上也就是`i1==i2 && j1 == j2`的时候，这种情况交点的值就只能算一次\n\n### 解法二\n\ny总讲的解法，优化了一维状态，N^3的解法，非常的巧妙，因为只能向下和向右走，所以从（1，1）到（N-1，N-1），走的总步数一定是`2*N`，那么我们就可以通过步数K计算出另一个坐标，从而省去一维状态\n\n```java\n//N^3优化，根据走的总步数计算另一个坐标位置\npublic static int slove2(int[][] w, int N) {\n    int[][][] dp = new int[2*N+1][N+1][N+1];\n    for (int k = 2; k <= 2*N; k++) {\n        for (int i1 = 1; i1 <= N; i1++) {\n            for (int i2 = 1; i2 <= N; i2++) {\n                int j1 = k-i1, j2 = k-i2;\n                if (1 <= j1 && j1 <= N && 1 <= j2 && j2 <= N) {\n                    int temp = dp[k][i1][i2]; \n                    temp = Math.max(temp, dp[k-1][i1-1][i2-1]);\n                    temp = Math.max(temp, dp[k-1][i1-1][i2]);\n                    temp = Math.max(temp, dp[k-1][i1][i2-1]);\n                    temp = Math.max(temp, dp[k-1][i1][i2]);\n                    dp[k][i1][i2] = temp + ((i1==i2&&j1==j2) ? w[i1-1][j1-1] : (w[i1-1][j1-1] + w[i2-1][j2-1]));     \n                }\n            }\n        }\n    }\n    return dp[2*N][N][N];\n}\n```\n## [275. 传纸条](https://www.acwing.com/problem/content/277/)\n\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。\n\n一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。\n\n幸运的是，他们可以通过传纸条来进行交流。\n\n纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。\n\n从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 \n\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。\n\n班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 \n\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。\n\n小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。\n\n现在，请你帮助小渊和小轩找到这样的两条路径。\n\n**输入格式**\n\n第一行有2个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。\n\n接下来的 m 行是一个 m∗n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。\n\n**输出格式**\n\n输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n\n**数据范围:**\n\n1≤n,m≤50\n\n**输入样例：**\n```c\n3 3\n0 3 9\n2 8 5\n5 7 0\n```\n**输出样例：**\n```c\n34\n```\n### 解法一\n\n和上面一题一样，虽然题目说的是一个从左上向右下，一个是从右下到左上，但是实际上依然是要求两条路径连接左上到右下，使得和最大，所以实际上直接照搬上面的代码就ok了\n\n```java\n//N^3\npublic static int solve(int[][] w, int m, int n){\n    int[][][] dp = new int[m+n+1][m+1][m+1];\n    for (int k = 2; k <= m+n; k++) {\n        for (int i1 = 1; i1 <= m; i1++) {\n            for (int i2 = 1; i2 <= m; i2++) {\n                int j1 = k - i1, j2 = k - i2;\n                if (j1 < 1 || j1 > n || j2 < 1 || j2 > n) continue;\n                int temp = dp[k][i1][i2]; \n                temp = Math.max(temp, dp[k-1][i1-1][i2]);\n                temp = Math.max(temp, dp[k-1][i1][i2-1]);\n                temp = Math.max(temp, dp[k-1][i1][i2]);\n                temp = Math.max(temp, dp[k-1][i1-1][i2-1]);\n                dp[k][i1][i2] = temp + (i1==i2 ? w[i1-1][j1-1] : (w[i1-1][j1-1] + w[i2-1][j2-1]));\n            }\n        }\n    }\n    return dp[m+n][m][m];\n}\n```\n\n## [1463. 摘樱桃 II](https://leetcode-cn.com/problems/cherry-pickup-ii/)\n\nDifficulty: **困难**\n\n给你一个 `rows x cols` 的矩阵 `grid` 来表示一块樱桃地。 `grid` 中每个格子的数字表示你能获得的樱桃数目。\n\n你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 `(0,0)` 出发，机器人 2 从右上角格子 `(0, cols-1)` 出发。\n\n请你按照如下规则，返回两个机器人能收集的最多樱桃数目：\n\n*   从格子 `(i,j)` 出发，机器人可以移动到格子 `(i+1, j-1)`，`(i+1, j)` 或者 `(i+1, j+1)` 。\n*   当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。\n*   当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。\n*   两个机器人在任意时刻都不能移动到 `grid` 外面。\n*   两个机器人最后都要到达 `grid` 最底下一行。\n\n\n给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。\n\n你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。\n\n请你按照如下规则，返回两个机器人能收集的最多樱桃数目：\n\n**示例 1：**\n\n![](https://files.catbox.moe/da5rxh.png)\n```java\n输入：grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n输出：24\n解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。\n机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。\n樱桃总数为： 12 + 12 = 24 。\n```\n\n**示例 2：**\n\n![](https://i.loli.net/2020/11/10/aSykAceXPH1snjM.png)\n```java\n输入：grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n输出：28\n解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。\n机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。\n樱桃总数为： 17 + 11 = 28 。\n```\n**示例 3：**\n\n```java\n输入：grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]\n输出：22\n```\n**示例 4：**\n\n```java\n输入：grid = [[1,1],[1,1]]\n输出：4\n```\n\n**提示：**\n\n- rows == grid.length\n- cols == grid[i].length\n- 2 <= rows, cols <= 70\n- 0 <= grid[i][j] <= 100 \n\n\n### 解法一\n\n本来只写了前两题就打算push的，y总也只讲了这几道题，但是突然想起来很久之前的一道周赛题（27th双周赛T4），大概半年前了，没想到居然能想起来😄，看了下，和上面两题是一样的，随手写了下，一开始写的有bug，调试了好一会儿，最后把状态打出来手推了下，发现有些状态没有初始化好，导致递推的时候使用了非法的状态\n\n先上暴力N^4的解法，这题范围不大，N^4勉强能扛过去\n```java\n//暴力N^4解法\npublic int cherryPickup2(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][][][] dp = new int[m+1][n+2][m+1][n+2];\n    int INF = -0x3f3f3f3f;\n    for (int i1 = 0; i1 <= m; i1++) {\n        for (int j1 = 0; j1 <= n+1; j1++) {\n            for (int i2 = 0; i2 <= m; i2++) {\n                Arrays.fill(dp[i1][j1][i2], INF);\n            }\n        }\n    }\n    dp[1][1][1][n] = grid[0][0]+grid[0][n-1];\n    for (int i1 = 2; i1 <= m; i1++) {\n        for (int j1 = 1; j1 <= n; j1++) {\n            for (int i2 = 2; i2 <= m; i2++) {\n                for (int j2 = 1; j2 <= n; j2++) {\n                    int temp = INF;\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2+1]);\n                    temp = Math.max(temp, dp[i1-1][j1][i2-1][j2-1]);\n                    \n                    temp = Math.max(temp, dp[i1-1][j1+1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1+1][i2-1][j2+1]);\n                    temp = Math.max(temp, dp[i1-1][j1+1][i2-1][j2-1]);   \n                    \n                    temp = Math.max(temp, dp[i1-1][j1-1][i2-1][j2]);\n                    temp = Math.max(temp, dp[i1-1][j1-1][i2-1][j2+1]);   \n                    temp = Math.max(temp, dp[i1-1][j1-1][i2-1][j2-1]);\n                    dp[i1][j1][i2][j2] = temp + ((i1==i2&&j1==j2) ? grid[i1-1][j1-1] : (grid[i1-1][j1-1] + grid[i2-1][j2-1]));\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int j1 = 0; j1 <= n; j1++) {\n        for (int j2 = 0; j2 <= n; j2++) {\n            res = Math.max(res, dp[m][j1][m][j2]);   \n        }\n    }\n    return res;\n}\n```\n\n### 解法二\n\n和上面两题一样，两个机器人走的层数是固定的，都是m层，所以可以优化掉一维的状态，同时上面的写法看起来也很ugly，可以用方向变量简化写法\n\n```java\n//N^3解法，优化代码写法，简化代码\npublic int cherryPickup(int[][] grid) {\n    int[] dir = {1, -1, 0};\n    int m = grid.length, n = grid[0].length;\n    //这题求最大值，在dp数组上边和左右两边各加一行作为边界\n    //这里也可以用滚动数组优化下空间\n    int[][][] dp = new int[m+1][n+2][n+2];\n    int INF = -0x3f3f3f3f;\n    //全部初始化为INF（实际上初始化两边和最上面的就ok了）\n    for (int r = 0; r <= m; r++) {\n        for (int j1 = 0; j1 <= n+1; j1++) {\n            Arrays.fill(dp[r][j1], INF);\n        }\n    }\n    dp[1][1][n] = grid[0][0] + grid[0][n-1];\n    for (int r = 2; r <= m; r++) {\n        for (int j1 = 1; j1 <= n; j1++) {\n            for (int j2 = 1; j2 <= n; j2++) {\n                //方向向量，简化写法\n                for (int d1 = 0; d1 < 3; d1++) {\n                    for (int d2 = 0; d2 < 3; d2++) {\n                        dp[r][j1][j2] = Math.max(dp[r][j1][j2], dp[r-1][j1+dir[d1]][j2+dir[d2]]);\n                    }\n                }\n                dp[r][j1][j2] += (j1==j2 ? grid[r-1][j1-1] : (grid[r-1][j1-1] + grid[r-1][j2-1]));\n            }\n        }\n    }\n    int res = 0;\n    for (int j1 = 0; j1 <= n; j1++) {\n        for (int j2 = 0; j2 <= n; j2++) {\n            res = Math.max(res, dp[m][j1][j2]);   \n        }\n    }\n    return res;\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"Fuck面试","url":"/2020/09/04/fuck-mian-shi/","content":"\n# 自我介绍\n面试官您好，我是湖北师范大学17级应届本科生李国威，大学所学专业是计算机，从入校就开始自学编程，大二加入了学校的Jplus实验室，参与了**教师工作量统计系统**的开发以及新人培训工作，后面又自学了Go语言，用Go语言写了两个练手项目，一个是模仿Google开源的GroupCache实现的一个**分布式缓存库**，并且对原项目热备功能做了增强，代码开源在Github平台，另一个是**分布式的任务调度系统**，通过分布式部署，任务保存在etcd集群中，并发的调度cron定时任务，提高整体的调度性能，代码也开源在Github平台上\n\n同时我也有一个从大一就开始维护的个人博客，平时也会将学习的过程记录在博客上与他人分享\n\n此次面试想应聘贵公司的 后端开发岗位\n# 项目\n## 湖师教师工作量统计系统\n教务处委托我们实验室实现的，为了方便全校教师统计工作量以及教务处审核，项目采用Java SpringBoot以及MyBatis编写，我主要负责项目的登录模块和本科生实践教学工作量统计模块\n\n项目本身没什么难度，但是在测试过程中发现一个有意思的bug，在登录的过程中会偶尔卡死，起初我以为是网络的问题，因为我们用的是我的云服务器上的数据库，但是当我查看了控制台的输出发现请求根本就没有到达dao层，在前端controler层就hang住了，但是由于他们测试过程中发现这个bug后就直接重启服务了，导致我过去的时候bug以及消失了！！！所以我们当时在机房搞了几小时才复现出bug，然后我马上用jvisualvm直接dump除了线程堆栈，然后发现有一条线程BLOCK在了println()的一条语句上，println()是加了锁synchronized，锁的是当前的实例PrintStream的实例，然后我继续查看堆栈信息发现占有该锁的一个tomcat的http线程正在RUNNING，但是它也并没有输出任何信息，最后去网上根据已有的关键字查了一下，然后发现这里其实windows的cmd窗口的问题，我们启动后有人点了一下cmd窗口，导致cmd的输出被中断，不再允许写入，这就导致这些write线程hang住，这个问题解决方案也很简单，换成Linux平台就可以了，**整件事给我的收获就是线上遇到这种bug不要急着重启服务，至少得先把线程堆栈dump下来再说，不然我们也不至于后面复现搞这么长时间**\n\n## Gacache缓存库\n\n模仿Google开源的GroupCache实现的分布式缓存库，项目的特点就是只支持get操作，不支持update/delete/ttl，当内存满的时候只能通过lru（LRU-K优化）去淘汰最近最少使用的，所以它适用的场景就是存储长期不会改变的数据\n\n同时正是因为舍弃了update，delete等功能，所以cache可以支持热点互备的功能，分布式的实现也更加容易，不用考虑并发读写的问题\n\n具体项目的实现，首先这是一个分布式的缓存库，所以需要考虑数据分片的问题，常规的做法可以采用取模的方法，将key的hash值与节点数量进行取模得到key映射的节点，这样就可以使得数据的分配更加均匀，但是这样做的问题是，如果节点的数量发生变化，那么所有的key都需要重新映射，扩展性较差，所以这里采用了一致性Hash算法进行数据分片和节点的选取，将所有的整数范围（2^32-1）内的hash值构成一个环，然后将节点根据ip和端口信息hash后有序的放入环中，同时为了避免数据倾斜的问题，我们同时生成多个该节点的hash值，作为虚拟节点，同时记录虚拟节点和真实节点的对应关系，然后当我计算某个key的映射时，将key的hash计算出来，然后直接在环中定位，顺时针找到离他最近的节点，然后返回其对应的真实节点就是该key的映射，这样当节点数量发生变化的时候，就只有少量的数据需要做迁移\n\n各个节点之间通过Http通信，并且使用Protobuf序列化数据，每个节点既是客户端也是服务端，当请求随机落在某一个节点上时，首先会判断本地有没有，如果没有就会通过一致性hash去选择节点，如果节点是自己就会直接从DB中拉取数据然后缓存在当前节点上，否则去一致性hash所选择的其他节点去请求数据，最后返回给调用者\n\n作为一个缓存库其实还存在一个问题就是缓存击穿的问题，如果一个热点key突然过期，那么就可能会导致大量请求直接打到DB层压垮DB，而常规的解决方案有两种：\n1. 缓存永不过期，类似[Redis中的惰性删除](#内存回收策略)，仅仅设置逻辑过期时间，这样当访问一个过期的key时，请求不会直接打到DB，然后我们通过后台异步线程去更新缓存，这样做用户延迟是最低的，但是可能会有数据的不一致，有的线程读取的仍然是老数据\n2. 互斥锁，当多个请求同时去get热点数据的时候，当第一个线程请求数据的时候进行加锁，其他线程阻塞，直到第一个请求到数据后进行热点key重建然后释放锁，其他请求就直接从缓存中get数据，不用再去DB请求数据\n\n我采用的是第二种方案，因为我的这个cache是不支持主动的删除操作的，所以你无法控制key何时会被删除，自然也就无法保护DB\n\n除此之外我针对原项目的热点互备功能也进行了简单的增强，热点互备这里主要针对就是**向某个节点请求该节点上没有的数据**，那么该节点就会频繁的通过http去向其他的节点去请求数据，而网络请求本身也是一个比较耗时的操作，这样就可能使得节点的网卡成为热点key的瓶颈，所以需要进行**热点互备**，将这些key直接备份在当前节点上\n\n但是在GroupCache的实现中，这里是采用的随机的做法，需要从其他节点获取的key有1/10的机会被缓存在当前节点上，从大样本的角度上来讲确实也是可行的，但是注意到这行代码上有一个todo的标签，并且注释中有写到，可以利用QPS去判断热点，所以我按照这个思路做了一些改动，首先封装了一个KeyStat的结构，包含了一个首次请求时间，以及一个用访问次数，并且用Atomic包实现了原子更新操作，当第一次获取的时候构建出KeyStats，记录下当前时间，后面再请求该key的时候就利用原子包对访问次数做++，当达到我们预设的QPS阈值后就会被直接存入当前节点，然后将对应的KeyStats删除，经过我自己的测试也确实达到了我想要的效果\n\n## 高性能任务调度系统\n分布式的cron定时任务调度系统，任务保存etcd集群中，多个节点可以并发的调度其中的定时任务，整个系统划分为两类节点，分别为Master节点，和Worker节点\n\n其中Master节点功能较为简单，主要就是负责和Etcd交互，对任务进行增删改查，从DB拉取任务执行日志，并且实现一个Web界面方便用户操作\n\nWorker节点就负责具体的调度和执行任务，主要分为几个模块，首先是一个**JobManager任务管理器**，这个模块内会有专门的协程去负责监听etcd对应目录的辩护，比如save目录发生了PUT事件，就说明有新增加的任务，就会将新的任务封装成一个Event然后通过channel传递到 **Schedule调度器** 模块，调度器会监听对应channel中的消息，然后根据Event的类型进行相应的处理，比如如果是PUT事件，那么就会将任务 **包装后（这里就用到了cronexpr库对cron表达式进行解析，实现精细的秒级调度）** 添加到 **任务执行计划表** 中，并且遍历任务计划表，执行到期的任务，并且统计下一次将要过期的任务的倒计时时间，然后设置定时器，进行精确的超时等待，**避免频繁的遍历任务表消耗CPU**。当任务到期时，调度器首先会对任务判重，与之对应的有一个 **任务执行表**，如果当前任务正在执行过程中那么就会跳过本次调度，原生的Linux Crontab就没有判断重复的过程，如果定时间隔小于实际执行时机就会导致任务重复执行，就可能会造成一些问题\n\n当确定任务并没有正在执行就会将任务交给 **Executor执行器** 模块，这里就涉及到一个任务并发抢占的问题，会多个节点同时去执行同一个任务的问题，所以这里借助了Etcd手动实现了分布式锁，其实这里有一个小的考虑，本来是打算直接使用EtcdV3客户端Concurrency包提供的一个分布式锁，但是在看了它的实现后发现并不适合我的业务\n\n官方的分布式锁是采用的一种 **公平等待** 的模式，创建锁的时候指定一个公共的前缀，然后拼接上当前节点的信息作为key插入etcd中，所有节点插入的key会按照revision排队，先来后到，排在前面的节点会先获取锁，其他的只能先等待，这样就达到了一个 **公平锁** 的效果，同时每个节点只需要监听他的上一个revision是否被删除就行了，如果被删除就说明上一个节点已经释放锁了，那么当前节点就会结束阻塞获取到锁，这样避免了  **惊群效应**，其实我感觉这个和**CLH锁**的实想是一致的（分布式的CLH锁），也就是Java中AQS底层的实现机制，将竞争分散到各个节点上\n\n但是这样的方式，每个节点获取不到锁会等待前一个节点释放锁，而在我的项目中，多个节点争抢的其实是 **某个任务，某个时刻的执行权** ，当该时刻过去的时候这把锁其实就没意义了，其他的节点此时不应该继续等待，而是应该转向指向其他的任务，这样才能充分利用分布式的优点，并发的调度任务，而不是在这一棵树上吊死，所以在我后面利用etcd的 **租约和事务** 机制以lock前缀以及任务名字，实现的分布式锁中枪锁失败会直接返回，不再争抢锁（偏向的问题，如果问优化可以说说）\n\n后面再实现任务强杀的过程中还发现了一个有意思的bug，就是我的任务强杀后任务并不会发生返回，仍然会继续指向，直到任务结束，然后我写了个类似的最小Demo，利用context取消任务，复现了bug，起初以为是平台的问题，切换到Linux平台上发现问题仍然存在，然后我pstree查看了进程树，发现在我强杀后我的shell进程确实被kill了，但是我的任务执行的时候shell创建了一个子进程，这个子进程并没有被杀死，而是成为了孤儿进程，被init进程收养了，其实这个时候我就意识到这应该不是我的问题，可能是Go本身的问题，然后我看了go下源码，发现在go语言在这里的实现中，会创建一些pipe用于和shell进程通信，返回out，err一些信息， **而shell进程在fork子进程的时候会复制父进程的页表** ，所以pipe的文件描述符也会被子进程持有，所以当kill父进程后，pipe仍然存在，写入端并没有关闭，而Golang的实现中对应的goroutine也会一直等待pipe写入端的信息或者pipe关闭，进而了导致无法kill任务的情况\n\n解决的方案也很直接，当强杀任务的时候，连同shell进程和所有子进程一起当作一个进程组设置pgid，然后利用systemcall，kill整个进程组，最终解决了bug，但是这种方案仅仅适用于Linux平台，Windows平台上暂时没找到好的解决方案\n\n我在官方的gihub上搜了下，也搜索到了相关的issue，这个问题已经存在很久了，可能会在Go2.0的时候修复\n\n# MySQL\n## Innodb vs MyISAM \n- MyISAM 不支持事务\n- MyISAM 只有表锁，不支持行锁\n- MyISAM 不支持外键\n- MyISAM 数据和索引分离，索引叶子节点是一个指针指向具体的数据块\n## 事务\n事务四大特性：ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）\n\n**原子性**：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n\n**隔离性**：多个事务并发的操作的时候，各个事务之间的状态不会相互影响，数据保持独立\n\n**持久性**：事务提交后对于数据库的改变是永久的，应该保存在磁盘上，即使数据库发生故障也不影响\n\n**一致性**：保证事务从一个有效的状态转移到另一个有效的状态，而有效指的其实就是我们在数据库中预先定义的规则，比如余额不能扣减为负数等，而，一致依赖AID，实际上一致性的保障更依赖于应用层也就是程序员\n### 隔离性 & 隔离级别\n隔离级别实际上就是为了应对多个事务并发执行所可能产生的问题，当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。\n> 不可重复读取侧重update，而幻读侧重insert\n\n1. **读未提交（RU）**：一个事务还没提交时，它做的变更就能被别的事务看到。\n2. **读提交是指（RC）**：一个事务提交之后，它做的变更才会被其他事务看到。\n3. **可重复读是指（RR）**：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。\n4. **串行化（SERIALIZABLE）**：，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n\n## redo log \nMySQL中的WAL（wtite-ahead logging）技术的实现，用来保障事务的**持久性**，关键点就是先写日志再写磁盘，所有的修改操作在提交之前都需要先写入log中，避免事务提交后落盘时发生故障，导致数据丢失，这样在数据库异常重启后之前提交的记录都不会丢失（crash-safe）\n> 在文件系统中WAL通常被称为：日志式文件系统（journaling ）Ext3,4都支持\n\n**为什么不在事务提交前将修改的所有页面直接刷新到磁盘？**\n1. MySQL是以页为单位进行磁盘IO的，可能只修改了一条数据，但是依然需要刷新整个数据页到磁盘，效率会比较低，而redo log只需要记录修改了那些东西（物理日志: 将第0号表空间的100号页面的偏移量为1000处的值更新为2）\n2. 刷新到磁盘是随机IO，效率比较低，redo log是按照顺序写入磁盘的，并且可以分组提交，同时还有`redo log buffer`的存在，可以进一步缓解磁盘IO缓慢的问题（log buffer中的数据会在事务提交前刷盘）\n## undo Log\n保证**原子性**，事务执行过程中可能会遇到各种错误，比如服务器突然宕机等，又或者程序员需要在执行过程中处理异常情况需要手动`ROLLBACK`，这些会导致事务执行一半就结束，所以为了保证原子性，我们需要**回滚**数据到事务执行前，让事务看起来什么都没做\n> 总结来看其实redo log是保证事务提交后的**持久性**，而undo log是保证事务执行过程中的**原子性**，所以事务提交后undo log就没用了回被系统回收\n## binlog\nredo log 是 InnoDB 引擎（引擎层次）特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。\n\nMySQL 的二进制日志 binlog 可以说是 MySQL 最重要的日志，它记录了所有的 DDL 和 DML 语句（除了数据查询语句select、show等），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。binlog 的主要目的是**复制**和**恢复**。\n\n> statement 格式下，记录到 binlog 里的是语句原文。row格式下，记录那一条记录被修改了，修改成什么样了，所以row回更占空间，但是主从复制的时候不容易出现问题，mix格式就前两者的混合\n### 两阶段提交\n由于存在redo log 和 binlog ，而他们两是相互独立的。而事务提交必须确保两者同时有效。不然会出现不一致的情形。\n![image.png](https://i.loli.net/2020/09/08/Ht3dPQTDylJqEpI.png)\n将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是\"两阶段提交\"。\n\n**一阶段**：InnoDB redo log 写盘，InnoDB 事务进入 prepare 状态\n\n**二阶段**：如果前面prepare成功，binlog 写盘，那么再继续将事务日志持久化到binlog，如果持久化成功，那么InnoDB事务则进入 commit 状态(实际是在redo log里面写上一个commit记录)\n### 主从复制：\n1. Master将数据改变记录到二进制日志(binary log)中\n2. Slave中的IO进程连接上Master，并请求从指定日志文件的指定位置之后的日志内容\n3. Master接收到来自Slave的IO进程的请求后，负责复制的IO进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置\n4. Slave的 **IO进程** 接收到信息后，将接收到的日志内容依次添加到Slave端的`relay-log`文件的最末端并将读取到的Master端的 bin-log的文件名和位置记录到`master-info`文件中，以便在下一次读取的时候能够清楚的告诉Master从某个bin-log的哪个位置开始往后的日志内容\n5. Slave的 **Sql进程** 检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行\n### 和redolog区别\n1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\n2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\n3. redo log 是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n## MVCC\nMVCC（Multi-Version Concurrency Control ，多版本并发控制），使得在RC和RR两种隔离级别下使得不同事务的**读写操作可以并发执行**从而提升性能\n> 这里指的读是 **快照读**，也就是普通的select语句，如果是update之类的依然是要加锁的 **当前读**\n\nMySQL中每条记录在更新的时候都会记录一条undo log，这些undo log会通过roll_pointer成一个单链表，称之为**版本链**，每条undo log会记录当前创建该版本的事务id\n\n在RC和RR级别下，查询需要用到`ReadView`视图，其中包含了：**当前活跃的事务m_ids**，**活跃事务id中最小的min_trx_id**，以及**下一个分配的事务id（max_trx_id）可以理解成最大事务id**，然后去**版本链**中依次找，如果\n1. 某个版本（undo log）的事务id小于`Readview`中的最小事务id（`min_trx_id`），说明该版本事务已经提交了，可以访问。\n2. 事务id大于最大id（`max_trx_id`），说明该版本的事务在`ReadView`之后才创建，所以不能访问\n3. 事务id在`ReadView`记录的当前活跃事务ids中，说明创建改版本的事务仍然活跃，不能访问，否则说明已经提交了，可以访问\n\n而RU和RC的区别就是生成ReadView的时机不同，RC在事务中每次查询都会创建ReadView，所以RC级别可以读取到其他事务提交后的版本（提交后再查询，重新生成ReadView就没有之前提交了的事务ID了）\n\n而RR只在事务开启的时候创建一个ReadView，所以无论其他事务做什么改动当前事务都读取不到（其他事务id要么在m_ids中要么就大于max_trx_id）\n### RR级别能解决幻读问题么？\n首先RR能解决**可重复读**，但是幻读呢？这个问题其实每个人看法都不同\n## 索引\n### 索引分类\n**从数据结构划分**\n1. B+ Tree 索引：内节点存放目录项，叶子节点存放数据，各个页之间以双向链表链接，页内数据以单链表连接，整个叶子节点数据都是按照**索引key**有序存放的，同时每个页还有**页目录**，可以通过页目录二分搜索快速定位记录\n   \n   （B树不支持范围查询，而B+树叶子节点内数据是由链表串起来的，范围查询较方便，而avl或者RBTree属于二叉搜索树，多在内存中使用，文件系统中由于深度过高，会导致IO效率低下）\n2. Hash 索引（Hash索引快但是不支持范围查询，也不支持排序）\n3. FULLTEXT 索引\n\n**从物理存储划分**\n1. 聚集索引\n2. 非聚集索引\n>聚集索引的叶节点就是数据节点，而非聚集索引的叶子节点仍然是索引节点，但是有一个指针指向对应的数据块。MySIAM的索引实现就是非聚集的，索引和数据是分开的，而Innodb的索引即数据，Innodb会自动利用主键帮我们创建聚集索引，一张表聚集索引只能有一个，其他的都是二级索引（非聚集索引）\n\n**从逻辑角度**\n1. 主键索引\n2. 普通索引（单列索引）\n3. 多列索引（复合索引）\n4. 唯一索引 & 非唯一索引\n### 索引优化\n1. **索引不是越多越好**：首先空间上每个索引都会建立一颗B+Tree，空间消耗不容忽视，其次时间上来说，索引太多当我做修改操作的时候设计到的B+Tree也就更多，每个相关的B+Tree都需要维护，效率可想而知\n2. **全值匹配**：搜索条件和索引列完全一致（顺序不一致也可以，会有查询优化器调整，但是最好不要这样做，没有意义）\n3. **匹配左边的列**：搜索条件和索引列左边部分一致（顺序也要一致）\n4. **匹配列前缀**：对于一些字符类型的索引列，我们可以通过只匹配前缀就能用到索引，比如我们找所有名字AB开头的人 `SELECT * FROM stu WHERE name LIKE \"AB%\"`这样也是可以用到索引的，因为字符的排序本身就是通过前缀一一对比的\n5. **匹配范围值**：如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，因为通过前面列范围查询的结果不一定是按照后面列的顺序来的\n6. **用于排序**：当使用联合索引时需要注意顺序要一致\n7. **用于分组**\n\n**建立索引的考虑：**\n1. 只为用于搜索，排序或者分组的列建立索引\n2. 为列的基数大的及案例索引（基数指列不重复数据个数，一个列只有两种值0，1就没有建立索引的必要）\n3. 索引列的类型尽可能小\n4. 让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入，因为B+Tree是按照索引列顺序插入的，如果数据很乱的话就会导致前面一个，后面一个，造成页分裂记录移位，损耗性能\n\n\n### 索引下推（ICP：index condition pushdown）\nMySQL5.6引入的优化，有的时候我们的查询语句虽然出现了索引但是确无法完全利用索引\n`SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';`\n比如这条语句，就只有第一个条件`key1 > 'z'`能用到索引，后面的条件就需要**回表**去判断了，回表就需要去主键索引重新找，并且是随机IO，效率相对低，这里MySQL做了优化，可以在索引遍历的时候就对索引列进行判断，然后过滤掉不满足条件的记录，减少回表次数，所以下推实际上是指将Server层的工作下推到引擎层处理了\n- ICP 只能用于二级索引，不能用于主索引；\n- 也不是全部 where 条件都可以用 ICP 筛选，如果某 where 条件的字段不在索引中，当然还是要读取整条记录做筛选，在这种情况下，仍然要到 server 端做 where 筛选；\n### 隐式转换导致索引失效\n参考[MySQL文档](https://dev.mysql.com/doc/refman/5.6/en/type-conversion.html)\n\n当操作符左右两边的数据类型不一致时，会发生隐式转换。\n\n1. 当where查询操作符**左边为数值类型**时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。\n`select* from test1 where int_column= '10000'`，对于这条sql `int_column`字段是整型，左边为int类型10000，转换为浮点数还是10000，右边字符串类型’10000’，转换为浮点数也是10000。两边的转换结果都是唯一确定的，所以不影响使用索引。\n\n2. 当where查询操作符左边为字符类型时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。\n`select* from test1 where str_column= 10000`,对于这条sql `str_column`是字符型，左边是字符串类型’10000’，转浮点数为10000是唯一的，右边int类型10000转换结果也是唯一的。但是，因为左边是检索条件，'10000’转到10000虽然是唯一，但是其他字符串也可以转换为10000，比如’10000a’，‘010000’，'10000’等等都能转为浮点数10000，这样的情况下，是不能用到索引的\n> 左边为数值类型影响不大，因为右边转换结果是唯一的，但是如果左边是字符类型，那么右边的值就不确定了，所以无法使用索引\n## 锁\n### 全局锁\nMySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)，加上之后所有的更新操作都会阻塞，可以用于全库逻辑备份。也就是把整库每个表都 select 出来存成文本。\n### 表级锁\n- 表锁的语法是 lock tables … read/write\n- 另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性\n\n### 行锁\n顾名思义就是锁定某一行，比如\n`select * from t where id=1 for update;` 就会锁定id=1的这一行数\n\n**两阶段锁**: 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是 **两阶段锁协议**。\n如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放（热点数据）。\n\n### 间隙锁\nRR级别下为了禁止幻读而产生的，锁的是记录之间的间隙，间隙锁之间是不互斥的，互斥的是**往间隙中插入记录**的操作，所以RR级别下，加锁就不只是加行锁，还回加间隙锁，共同形成了`next_key_lock`\n\n**间隙锁造成死锁案例**\n```sql\nbegin;\nselect * from t where id=N for update;\n/*如果行不存在*/\ninsert into t values(N,N,N); \ncommit;\n```\n![wd3VzQ.png](https://s1.ax1x.com/2020/09/12/wd3VzQ.png)\n### 死锁和死锁检测\n\n![wUwb4I.png](https://s1.ax1x.com/2020/09/12/wUwb4I.png)\n\n如上图，事务A抢占了id=1这一行的行锁，而事务B抢占了id=2这一行的行锁，接下来就陷入了循环等待，两个事务会等待对方释放锁，显然数据库是不能允许这种情况发生的，所以此时有两种解决方案\n1. 等待，直到超时，这里是通过innodb的`innodb_lock_wait_timeout`来控制的，这个值默认是50s，显然在线上服务，这样的等待是不能接收的\n2. 发起**死锁检测**，发现死锁后主动回滚死锁链条中的某一个事务（一般是比较小的事务），但是死锁检测是比较耗时的（有向图环路检测？），\n\n除了上面的方案，其实也有一些其他的方案，比如 修改MySQL的源码在进入引擎之前使相同行的更新操作排队，或者通过中间件的形式也行。或者可以通过**分散竞争**的方式来减少锁冲突，将热点数据打散，类似`LongAdder`的思想，这样竞争就会小很大\n# Redis\n## 为什么快？\nRedis所有数据都是存放在内存中，这也是Redis速度快的主要原因。[IO多路复用](#多路复用)监听多个事件，在内存中快速响应\n## 数据类型\n1. 字符串：底层封装了一个SDS结构，对比C语言字符串，记录了字符的长度，可以O(1)获取长度。主动扩容，避免缓冲区溢出。空间预分配以及惰性删除减少内存分配次数\n2. 哈希（内部编码：小于阈值ziplist，否则hashtable）\n3. 列表（内部编码：ziplist，linkedlist，quicklist）\n4. 集合（内部编码：小于阈值intset，否则hashtable）\n5. 有序集合（内部编码：ziplist或skiplist，元素个数小于阈值就是ziplist，否则就是skiplist）\n\n**ziplist**: 内部表现为排列紧凑的一块连续内存数组，新增和删除会涉及内存的重新分配和释放，读写操作涉及复杂的指针移动复杂度较高可以作为hash，list，zset小数据量的结构\n\n**intset**：集合set类型编码的一种，内部为存储有序，不重复的整数集合底层结构为数组\n\n## 持久化\n### RDB（快照）\n把当前进程数据生成快照保存到硬盘的过程，（也可以作为主从复制的媒介）\n\n**save**： 会阻塞当前Redis服务，直到RDB过程完成，对于内存较大的实例，影响会比较大，线上不推荐使用\n\n**bgsave**：Redis进程fork出子进程，由于fork会复制父进程的页表（并不会复制内存，而是采用COW，所以不会产生大量拷贝消耗），所以子进程可以共享父进程的内存数据，进而在后台进行持久化生成RDB\n\n**触发时机**\n\n- 手动执行命令触发\n- 使用save相关配置，如save m n 表示在m秒内存在n次修改自动触发bgsave（并不好，并发量不好预估，不恰当的设置会导致RDB过多）\n- 执行debug reload 重写加载Redis的时候\n- 从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点\n- 默认情况下执行shutdown的时候，如果没有开启AOF也会自动执行bgsave\n\n**优点**\n\n- RDB是一个紧凑压缩的二进制文件，代表Redis某一个时刻的数据快照，非常适合用于备份，复制\n- Redis加载RDB恢复的数据会比AOF快\n\n**缺点**\n\n- RDB无法做到 **实时/妙级** 持久化，RDB需要保存整个内存的数据，频繁的执行RDB操作消耗也比较大\n\n### AOF（日志）\n以独立日志的方式记录每次写命令，重启的时候再重新执行AOF文件中的命令达到恢复数据的目的\n\n所有的命令都会追加到`aof_buf`缓冲区中，缓冲区会根据一定的 **同步策略** 进行`fsync`刷盘，随着AOF文件的不断增大，需要定期进行 **AOF重写** ，清除进程内过期的数据，读取进程数据只保留最终数据写入命令，合并多条命令，以达到压缩空间的目的\n\n**同步策略**\n\n1. **always** : 命令写入`aof_buf`后立马`fsync`刷盘，当刷盘完成后返回，显然这种方式数据不会丢失，但是IO的开销比较大，频繁的写入会很影响性能\n2. **everysec** : 命令写入`aof_buf`后调用`write`，后台线程会每秒执行一次`fsync`，推荐的策略，即使是宕机也只会丢失1s的数据\n3. **no** ：命令写入`aof_buf`后调用`write`然后旧不管了，同步操作交给OS，不推荐，不太可靠\n\n> `write`只是将数据写入页缓存区，同步磁盘的操作会交给OS调度，如果在同步之前宕机，那么数就会丢失\n\n\n**AOF重写**\n\n1. 主进程fork从子进程，子进程进行AOF的重写\n2. 主进程继续响应客户端请求，这部分数据也不能就这样丢掉，此时产生的AOF日志会写入 **AOF重写缓冲区**\n3. 子进程完成后，父进程将AOF重写缓冲区的数据写入新的AOF文件，然后替换旧的AOF文件\n\n## 内存回收策略\n\n### 删除到达过期时间的键对象\n- **惰性删除**：当客户端读取到已经超时的键，就执行删除操作并返回空，这策略是为了节约CPU资源，不需要单独维护TTL链表来处理过期键的删除。单独使用这种方式存在内出泄露的问题，当过期键一直没有被访问将无法得到即时删除，从而导致内存无法的即时释放\n- **定时任务删除**：Redis内部维护一个定时任务，默认每秒运行10次，定时任务中删除过期键采用了自适应算法，根据过期键的比例采用快模式或者慢模式，每个数据库空间抽取20个键，判断是否有超过25%的键过期，如果超过就会一直循环直到小于25%或者超时\n\n### 内存达到max_memory的适合触发内存溢出控制\n\n- novication：不删除任务数据，拒绝任何写入操作，并且返回客户端OOM\n- volatile-lru：根据lru策略从设置了超时时间的键中剔除\n- volatile-random：随机从设置了超时时间的键中剔除\n- volatile-ttl：从设置了超时时间的键中，选择最早过期的剔除\n- allkeys-random：从所有键中随机剔除\n- allkeys-lru：从所有键中按照lru规则剔除\n\n## 缓存穿透\n指恶意攻击或者爬虫，恶意查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB就会导致宕机\n\n**解决方案**\n1. **缓存空对象**，将DB查询为空的key也存在缓存中，然后设置一段过期时间，后面相同的key就可以通过缓存获取，不用查DB，确定也显而易见，如果同时构造多个不同的key依然会导致穿透\n2. **布隆过滤器**，相比传统的HashMap，布隆过滤器更省内存查询也更快，底层是一个二进制位图，和一些Hash函数，当向布隆过滤器中存入一些key的时候，首先对key进行k次hash，然后将bitmap中对应位置设置为1，当判断一个key是否在集合中的时候，只需要将key再次hash，并判断所有对应的位置是否为1，如果都为1，说明这个key**有很大可能在集合中**，反之，如果并不是所有位置都为1，就说明这个key**一定不在集合中**，整体的误判率和插入元素的个数，以及哈希的次数，还有位图的长度都有关 ，另外布隆过滤器也不支持删除操作\n![wTW711.png](https://s1.ax1x.com/2020/09/20/wTW711.png)\n## 缓存击穿\n如果一个热点key突然过期，那么就可能会导致大量请求直接打到DB层压垮DB，而常规的解决方案有两种：\n1. 缓存永不过期，类似[Redis中的惰性删除](#内存回收策略)，仅仅设置逻辑过期时间，这样当访问一个过期的key时，请求不会直接打到DB，然后我们通过后台异步线程去更新缓存，这样做用户延迟是最低的，但是可能会有数据的不一致，有的线程读取的仍然是老数据\n2. 互斥锁，当多个请求同时去get热点数据的时候，当第一个线程请求数据的时候进行加锁，其他线程阻塞，直到第一个请求到数据后进行热点key重建然后释放锁，其他请求就直接从缓存中get数据，不用再去DB请求数据\n\n## 主从复制\n可以用于配合 **读写分离** 做 **负载均衡** ，也可以用于故障恢复，数据冗余\n1. slave启动后会先master发送SYNC的同步命令\n2. Master收到后会使用bgsave后台生成RDB文件，同时也会将主线程当前进行的命令也保存到缓冲区\n3. Master将RDB和Buffer中的都发送给Slave\n4. Slave将接收到的数据恢复到内存中\n\n**缺点**\n1. 数据一致性问题\n2. 主节点挂掉后需要人工干预，不能自动恢复\n> **部分复制** 根据节点id和offset，复制缓冲区\n## 哨兵模式\n哨兵是主从的升级版，部署sentinel监控主从的运行状态，如果发现异常就会发出警告，然后对异常情况进行处理，当Master出现故障的时候会自动选举一个slave作为master顶上去\n\n**Master下线**\n\n当sentinel启动的时候会和master建立连接，订阅master的频道，然后定期（10s）向Master和Slave发送`INFO`或者`PING`消息，用于哨兵和哨兵，哨兵和Master通信，如果哨兵发送的`PING`在指定时间内没有收到回复，发送的哨兵就会认为该Master **主观下线**，同时询问其他哨兵是否也认为下线，如果达到一定数量（quorum）就会认为该节点 **客观下线**\n\n然后会在哨兵中选取一个Leader哨兵，由它来进行故障恢复，从所有的slave中选取一个优先级最大的，如果优先级相同就会选择偏移量大，偏移量大意味着数据更加完整\n\n## Cluster（集群模式）\n\n前面哨兵可以解决主从不能自动恢复的问题，但是仍然会存在难以扩容以及读写瓶颈问题，且主从复制各个节点上都是数据冗余消耗大量存储空间\n\nredis cluster 有固定的 16384 个 hash slot，每个Master节点负责一部分slot，对key计算cyc16值然后对16348取模，获取key对应的hash slot，然后存储到对应的节点上，将 **数据和节点解耦**，并不用关系数据在那个节点，仅仅关心数据的槽在哪里就行了\n\n>无中心的架构模式，最终一致性\n\n## 对比Memcached\n- Redis支持的数据类型更多，比如Hash，Set，SortSet等，而Memcache只支持简单的k-v结构，复杂的对象需要客户端手动序列化，100k以上的对象，Memcached性能会更好\n- Redis支持[数据持久化](#持久化)，可以将内存中的数据保存到磁盘中，而Memcache不支持\n- Memcached服务器本身不支持集群，需要客户端进行一致性Hash或者代理中间件支持集群，而Redis服务器本身支持集群\n- Redis是的核心数据提交是单线程模型，保证了数据按顺序提交，Memcached使用CAS确保并发的一致性\n- 基于上一点，Redis只能利用单核，而Memcached可以利用多核，所以性能上可能会好一点\n\n# 分布式\n## Zookeeper保证CP\n\n当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。\n\n## Eureka保证AP\n\nEureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：\n1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务\n2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)\n3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中\n\n因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。\n\n# Java\n## JVM & GC\n\n### 内存区域划分\n1. 程序计数器：线程私有，指令执行的行号指示器\n2. Java虚拟机栈：每个方法执行的时候都会创建一个 **栈帧** 去存储局部变量表，操作数栈，等信息，而Java虚拟机栈就是线程内用于存放栈帧的区域，方法执行结束就对应着进栈出栈，可以通过-Xss设置栈大小\n3. 堆：JVM中最大的一块区域，所有的对象实例和数组都会分配在这里，同时也是GC最主要的区域\n4. 方法区：存放已经加载的类信息，运行时常量池，以及静态变量\n5. 直接内存：使用本地代码直接分配的堆外内存\n\n### 对象创建过程\n1. 类加载检查，检查常量池Class是否被加载\n2. 分配内存，指针碰撞和空闲列表，内存规整的话就采用指针碰撞，否则就采用空闲列表\n3. 初始化零值，将内存空间设置为零值，所以对象中的属性不手动初始化也是可以使用的\n4. 设置对象头，执行`init`方法（构造器）\n\n### 堆结构分代\n1. 新生代：新生成的对象优先放在新生代中，新生代对象朝升夕死，存活率很低，在新生代中，GC回收效率很高\n2. 老年代：在新生代经历了多次GC（具体次数要看jvm的配置）仍然存活下来的对象就会进入老年代，存活率高，大对象和长期存活的对象会直接进入老年代\n> 这样分代就可以让垃圾收集器有针对性的进行GC，避免全堆扫描，对不同的区域采用不同的回收策略，比如新生代就采用 **复制算法**，老年代则采用 **标记清除**，**标记整理**\n\n### 判断对象死亡\n1. 引用计数，每当对象被引用，对应的引用计数就+1，如果引用失效就-1，计数器为0就说明不会再被使用了，但是这种方式可能会造成循环引用的问题，主流的JVM都不是采用的这种方式（py似乎是这种方式\n2. 可达性分析，通过一系列的GC ROOT为起点向下搜索，当一个对象和GC ROOT没有引用链的话该对象就不可用了了\n\n### 强软弱虚\n1. 强引用：发送GC也不会被清理\n2. 软引用：发送GC且内存不足就会被清理\n3. 弱引用：发生GC的时候不过内存是否足够都会被清理\n4. 虚引用：对对象的GC没有影响，用于在GC的时候收到通知\n\n### 垃圾收集算法\n1. **标记-清除**：首先标记出所有 **需要回收** 的对象，标记完成后统一回收所有被标记的对象，**效率较低**，而且会产生 **内存碎片**\n2. **标记-整理**：和标记清除类似，不过在清除阶段会将存活对象都移动到一边，然后直接清除另一边，**不会产生内存碎片**，但是需要可能 **要移动大量对象** 效率仍然不高，适用于 **存活率高老年代**\n3. **复制算法**：将内存划分为两块，每次只使用其中的一块，当其中一块使用完后就将 **存活的对象** 移动另一块上面，然后将使用过的空间一次清理掉，适用于 **存活率较低的新生代**，问题是空间的利用率变低，所以一般jvm的实现都并不是划分为1/2，而是分成一块较大的`Eden`区，和两块较小的`Survivor`区，比例默认是8：1，每次只使用eden区和其中一块Survivor区，回收时将Eden和Survivor区移动到另一块Survivor，然后清理Eden和Survivor\n   > 如果存活对象太多了，一个Surivior存不下，那么就会依赖**老年代**的空间担保，借用老年代空间存储存不下的对象\n4. **分代收集**：顾名思义，对不同的代采用不同的收集算法\n\n### 垃圾收集器\n1. Serial收集器：串行，单线程，GC时候会STW\n2. Serial Old收集器：Serial收集老年代\n3. ParNew收集器：多线程，GC时也会STW，只是会有多个线程同时收集\n4. Parallel Scavenge收集器：和ParNew类似，不过 **更强调吞吐量（垃圾收集时间尽可能短）**\n5. Parallel Old收集器：Parallel Scavenge老年代版本，使用标记整理\n6. CMS收集器：强调 **低停顿**，GC线程和用户线程并行，使用 **标记清除** 的老年代收集器。①初始标记（停顿）②并发标记③重新标记（停顿）④并发清除\n7. G1收集器：实现了可预测额停顿时间，将内存划分为Region，然后按照回收时间以及回收空间维护一个优先级队列，每次根据允许的时间回收价值最大的Region ①初始标记（停顿）②并发标记③最终标记（停顿）④筛选回收\n\n### FULL GC触发\n> **Minor GC**：新生代发生的GC，Eden区域快满的时候会就会触发，Minor GC一般发生比较频繁，效率较高\n> \n> **FULL GC**: 收集整个堆，效率很低\n1. System.gc()，建议jvm执行Full GC\n2. 老年代空间不足，大对象进入老年代\n3. 老年代空间担保失败，Minor GC复制时判断存活的对象能否放进老年代\n## 类加载\n1. 加载（`loadCalss`方法，可以通过覆盖该方法实现自定义的类加载器），通过类的全限定名获取定义此类的二进制字节流，类加载的最终产物是位于堆中的Class对象\n2. 连接（验证，准备，解析）\n3. 初始化，执行 **类构造器clinit** ，类变量的赋值，静态语句块执行，虚拟机会保证`clinit`方法的线程安全（对应前文[对象的init方法](#对象创建过程)）\n\n### 双亲委派\n系统在加载类的时候会首先判断该类是否以及被加载了，如果被加载就直接返回，否则就尝试加载，在加载时候会首先委托父类去加载，如果父类加载不了，就会尝试自己加载，类似Java内部核心类就都会交给BootStrapClassLoader去加载，这样可以提高系统安全性，也能避免类重复加载\n### 线程上下文加载器(TCCL)\n## HashMap\n### 对比HashTable\n1. HashMap不是线程安全的，HashTable内方法都加了锁，线程安全，但是效率会低很多\n2. HashMap初始容量不指定就是16，之后每次扩容都会变成之前的2倍，如果给定了初始值但是并不是2的幂次，就自动转换成最接近的2的幂次。而HashTable初始容量为11，每次扩容变成原来的2n+1\n3. JDK8之后HashMap底层链表长度如果大于8就会转换成红黑树\n> 2的幂次是为了避免使用%操作，当length是2的幂的时候，hash%length = hash & (length-1) 而&操作相比%会高效很多 \n> 9 % 4 = 1001 & 0011 = 0001\n### equals和hashCode\n当向HashMap中插入元素的时候，会根据key计算得到的hash值，转换成table数组的索引，然后判断`table[i]`是不是null，如果是null，直接新建节点添加，如果不为空，通过`hashCode`和`equals`判断两个key是否相同（先判断hashcode，hashCode不同一定不同，再根据equals），相同就直接覆盖，否则就用拉链法解决冲突\n\n### ConcurrentHashMap\nJDK1.7之前采用 **分段锁**，采用Segment分段的管理键值对，当线程访问某一个Segment的时候不影响其他的Segment，这样可以分散竞争大大提高HashMap的并发度。\n> 可以引出LongAdder的分段锁\n\nput的时候先将key经过hash后定位到具体的Segment，然后再Segment中加锁进行put（拉链法），Get操作类似先定位到Segment，然后再定位到具体的元素，整个过程不用加锁\n\nJDK1.8之后抛弃了原有的分段锁，采用了CAS+synchronized，同时也引入了红黑树，当没有冲突的时候会通过CAS写入，如果发生hash冲突或者需要扩容才会加锁，并且synchronized在1.8之后也优化的很好\n## JMM\nJava内存模型主要是定义了一种规范，就是每个线程有自己独立的工作内存，所有变量存储在主内存，线程的工作内存中保存了需要使用的变量的副本，线程对变量的改变都是在工作内存中修改，修改完了之后再同步到主内存，线程不能直接对主内存的变量进行修改，不同线程之间也无法直接访问对方的工作内存的变量，只能通过主内存传递\n\n### synchnorized\n可以保证并发的三要素，原子性，可见性，有序性，早期一直被成为重量级锁，依赖底层的系统调用，消耗较大\n\n在JDK6之后，对其进行了大量的优化\n1. **偏向锁** ：当锁对象第一次被获取的时候，会把对象头的锁标志位设置位偏向模式，然后利用CAS将线程ID写入对象头，后续该线程下一次进入同步块的时候就不会进行任何同步操作（锁消除），如果有另一个线程尝试获取锁对象偏向模式就会失效，升级为轻量级锁\n2. **轻量级锁** ：将锁对象的MarkWord复制到本地线程空间，然后将对象头的MarkWord利用CAS更新为执行线程栈的复制的MarkWord，成功后就拥有该对象的锁了，更新失败就说明有多个线程在同时竞争该对象，这个时候轻量级锁就失效了，会膨胀成重量级锁，所以这种方式在多个线程交替使用锁，不存在竞争的时候性能会很高\n3. **自旋锁和自适应锁**：在重量级锁抢锁失败后并不马上阻塞挂起，而是短暂的自旋，避免线程切换，如果锁占用的时间很短，那么自旋的效果就会很好，否则长时间自旋会浪费CPU，所以后面引入了 **自适应锁**，不再固定自旋时间，而是由前一个锁的状态决定\n4. **锁消除** & **锁粗化**：锁消除是指JIT对于一些代码上要求同步，但是实际上并不会产生共享数据竞争的锁进行消除，这里就涉及到逃逸分析，而锁粗化就是将一些连续的对 **同一个锁对象** 的加锁解锁操作合并粗化，将锁的范围变大，避免频繁的加锁解锁\n### Volatile\n1. 保证内存可见性，对变量的修改能马上同步到主内存，并且读取一个volatile变量也必须从主内存读取\n2. 保证有序性，jvm可能会对我们编写的代码进行重排序以优化性能，经典的例子就是DCL单例的例子了，DCL单例之所以要在单例上加volatile就是为了放在jvm对指令的重排序，new Object的操作会分为好几步骤，可能把内存分配重排前面，就可能会导致错误\n> 可以保证Long/Double写入的原子性，早期写入这些64位的数据可能是分段写的\n\n### CAS\nCPU支持的一种并发原语指令，一般有3个参数，内存中的值M，期望的值E，以及更新的值U，如果执行执行的时候，M==E，那么就会将M改成U，这一系列的操作被CPU封装为一个系统原语，借此可以实现非阻塞的轻量级的乐观锁\n\n**缺点**\n\n1. CAS自旋消耗CPU资源\n2. ABA问题，可以使用AtomicStampedReference的版本变量机制解决\n\n## JUC\n1. **CountDownLatch**，指定一个计数count，当调用`countdown()`的时候计数器减一，`await()`会阻塞，知道计数器减为0，（Golang中的WaitGroup和这个类似）\n2. **CyclicBarrier**，控制多个线程到达某个点都再继续进行下一步，类似爬山，大家都到达某个点之后在一并前进\n3. **Semaphore**，信号量，PV操作，设置初始凭证，释放凭证，获取凭证，不够就会阻塞\n4. **ReentrantLock**，可重入显示锁（Java中不可重入的似乎就是线程池中的那个Worker），对比内部锁：\n   1. 显示锁支持公平锁 \n   2. 显示锁支持非阻塞trylock以及带超时的tryLock(long timeout, TimeUnit unit)\n   3. 显示锁可以中断请求lockInterruptibly\n   4. 显示锁需要手动的release，sync自动release \n   5. sync在优化后性能和lock差不多\n5. **Condition**，显示锁的线程通信方式，对应sync的wait和notify，但是condition可以解决 **过早唤醒** 的问题，为一个锁创建多个条件变量，比如典型的生产者消费者问题，我们就可以给消费者和生产者都创建一个condition，让生产者只会唤醒消费者，而消费者只会缓存生产者\n6. **ReadWriteLock**，读写锁，读读可并发\n7. **Atomic类**，CAS + Volatile\n8. **LongAdder**，CAS Cell[]数组 分段锁，分散竞争，sum不加锁，最终一致性，性能高于Atomic\n### 阻塞队列\n1. **ArrayBlockingQueue**，数组实现的 **有界** 阻塞队列，默认是非公平的，底层实现是ReentrantLock\n2. **LinkedBlockingQueue**，链表实现的阻塞队列，如果不设置容量，容量就会设置为`INT_MAX`变成无界队列\n3. **SynchronousQueue**，不存储元素的阻塞队列，或者说是一个容量为0的阻塞队列，put和take成对的时候才不会阻塞，和Golang中无缓冲的channel类似，发送方需要等待接收方，接收方需要等待发送方\n4. **DelayQueue**，延时获取队列，存入元素后等待一定的时间后才能获取\n\n### ThreadLocal\n每个线程Thread内部都有一个私有的ThreadLoaclMap，以threadLocal对象作为key，而对应私有变量则是val，所以各个线程通过同一个threadlocal查到的key都是不一样的，并且一个线程可以关联多个threadLocal变量\n\n**内存泄漏问题**：线程内部的ThreadLocalMap的key是threadlocal对象的弱引用，当发送GC的时候会被自动清除，但是value是强引用，所以就会产生key为null的Entry，value永远无法被GC回收，发生内存泄漏，在ThreadLocal实现中get,set的时候都会自动清理key为null的entry，但是最好还是每次使用完都手动的remove()\n\n### 线程池\n**优点**\n\n1. 减低线程资源消耗，重复利用已经创建的线程，避免频繁的创建和销毁线程\n2. 提高响应速度，不用等待线程创建\n3. 提高线程的可管理性，控制并发的数量\n\n**大致流程**\n\n1. 提交任务到线程池\n2. 线程数小于核心线程数，直接创建线程执行，否则就添加到阻塞队列中\n3. 如果阻塞队列满了就判断当前线程数是否小于最大线程数量，如果是就继续创建线程执行任务，否则就直接采用拒绝策略拒绝任务\n\n**大致原理**\n\n封装了一个Worker类，继承AQS实现了一个不可重入的独占锁，然后有一个runWorker的方法\n1. while循环不断从阻塞队列中获取任务 \n2. 获取任务成功就会加上内部实现的锁（用于shutdown的时候判断是否正在执行任务），然后执行任务\n3. 如果获取任务返回null，那么该线程就会跳出循环，结束生命周期等待GC\n4. 获取任务返回null的情况有很多，比如 ①线程池关闭了②线程数量大于最大线程数，并且任务队列为空 ③允许核心线程超时，并且任务队列为空...\n\n**核心参数**\n1. **corePoolSize**：核心线程池大小，任务数量超过核心线程池之后任务就会被放到阻塞队列\n2. **maximumPoolSize**：最大线程数，表示该线程池中最多创建多少个线程\n3. **keepAliveTime**：这个参数最终是作用在阻塞队列上，当没有任务执行的时候 **除核心线程外的线程** 最多闲置多长时间就会被回收，如果设置了allowCoreThreadTimeOut那么核心线程也会超时，与之对应的还有一个参数是`TimeUnit`，也就是keepAlive的时间单位\n4. **workerQueue**：线程池使用的阻塞队列\n5. **threadFactory**：线程工厂，根据传进来的Runnable创建线程\n6. **handler**：拒绝策略，①丢弃任务，抛异常②丢弃任务，不抛异常③丢弃最前面的任务，然后再次执行，知道可以接收④由调用线程处理该任务\n\n**工厂方法**\n- newCachedThreadPool()：不缓存任务，core为0，最大线程数INT_MAX，阻塞队列使用SynchronousQueue不缓存任务，线程数可能OOM\n- newFixedThreadPool()：核心线程和最大线程相同，不允许扩容，阻塞队列无界可能会OOM\n- newSingleThreadExecutor()：单例线程池，只有一个线程，阻塞队列无界可能会OOM\n\n### AQS\nAQS底层是基于CLH锁的，当前共享资源空闲的时候，线程可以直接获取，如果请求的资源被占用了，那么线程就会被封装成链表的节点，然后进入队列中排队阻塞，等待前一个节点的执行完成后唤醒，这样就可以分散竞争，将所有线程对同一个资源的竞争分散到各个节点，同时也避免了 **惊群效应** （etcd和zk实现的分布式锁也是和这个思路一样的）\n\nAQS中非公平锁，特征其实不是很明显，其实仍然需要排队，只不过在刚开始获取锁的时候可以插一次队列，然后进入队列的时候不判断前面有没有线程，也会尝试获取一次，如果两次都失败了那么就和公平锁无异，老老实实进队列排队等待唤醒\n# Go\n\n## CSP\n- CSP进程通常是同步的(即任务被推送进Channel就立即执行，如果任务执行的线程正忙，则发送者就暂时无法推送新任务)，Actor进程通常是异步的(消息传递给Actor后并不一定马上执行)。\n- CSP中的Channel通常是匿名的, 即任务放进Channel之后你并不需要知道是哪个Channel在执行任务，而Actor是有“身份”的，你可以明确的知道哪个Actor在执行任务。\n- 在CSP中，我们只能通过Channel在任务间传递消息, 在Actor中我们可以直接从一个Actor往另一个Actor传输数据。\n## 垃圾回收\n## 对比Java的垃圾回收\n1. 无分代，分代GC所回收的主要目标是新创建的对象（存活时间短，朝生夕死），避免频繁的检查整个堆，但是Go的编译器会通过 **逃逸分析** 将大部分的新生对象创建在栈上（栈使用完后会直接回收，不需要GC参与），只有需要长期存在的对象才会放到需要GC的堆中，所以分代对Go来说意义不大\n2. 无整理，对象整理是为了解决内存碎片的问题，而Go语言采用的是[tcmalloc](https://zhuanlan.zhihu.com/p/29216091)基本上没有内存碎片，并且顺序内存分配器在多线程场景下并不适用，对象整理对Go来说性能提升不大\n## QA\n1. Go语言中数组是具有固定长度而且拥有零个或者多个相同或相同数据类型元素的序列。由于数组长度固定，所以在Go语言比较少直接使用\n\nGo1.3之前主要是 **标记清除** 算法，标记需要扫描整个堆，需要STW，也会产生内存碎片\n>GC ROOT： 1. 全局变量 2.执行栈 3.寄存器\n### 三色标记法\n1. 将所有节点放入 **白色集合**\n2. 首先从根节点出发BFS走一轮，将遍历到的节点移入 **灰色集合**\n3. 遍历所有的灰色集合，将灰色集合能BFS一轮，访问到的节点加入灰色集合，然后将原本的 **灰色对象** 加入 **黑色集合**\n4. 重复上一步，直到 **灰色集合中没有对象**\n5. 清除所有的 **白色集合** 中的对象\n\n上面的做法看似没毛病，但是仍然存在问题，无法和用户程序并行，如果程序运行过程中 ①**灰色对象丢失了白色对象** ②**黑色对象引用了白色对象**。这个时候该 **白色对象** 因为失去了 **灰色对象** 的引用所以它就不会变成灰色，清理的时候就会将其清除，但是实际上这个对象已经被一个黑色对象引用了，这样就会导致误杀\n\n**解决办法**：读写屏障，在赋值或者读取操作前后做一些额外的处理，将目标对象保存起来，最终还是会被作为灰色对象扫描，就不会漏标\n\n\n## GPM\nGo的用户级线程（协程）的实现是N:M，内核创建出N个内核线程，M个用户线程会对应这N个线程，用户线程完全由用户来调度，而内核线程由内核去调度\n\n### 老的GM模型\n\n**M:** 代表线程，他要运行goroutine\n\n**G Queue:** Golbal G Queue，所有的goroutine都保存在这个队列中\n> M要执行goroutine或者放回都需要访问GQueue，而M有多个，所以这里需要加锁保证互斥，导致性能较低\n\n### GPM模型\n\n**G:** 代表goroutine，里面存储了goroutine的执行stack信息，goroutine状态以及任务函数等\n\n**P:** 逻辑Process，P的数量决定了系统的最大并发度（不超过CPU核数的前提下，GOMAXPROCS可设置P的数量），没有数据竞争，不用加锁\n\n**M:** 系统的计算资源，也就是 **内核线程**\n\n> 每个G想要执行首先需要分配一个P，只有将P和M绑定才有机会执行P的队列中的G\n### 特点\n1. **复用线程**，协程本身是运行在一组线程组之上，不用频繁的创建销毁线程，除此之外 ① `working stealing`，当前M没有可以的G就会从其他M绑定的P中偷取任务G，而不是消耗线程 ②`hang offf`，当发生阻塞的时候，会将当前M绑定的P释放，交给其他空闲的M去执行\n2. **抢占**，在coroutine中要等待一个协程主动让出CPU才会执行下一个任务，那么就可能会造成线程饥饿，而Go中一个goroutine最多占用10ms，防止其他协程饿死，这也是和传统协程不同的地方\n3. **全局G队列**，新的调度器模型中仍然有全局G队列，当M从其他P偷取不到任务时候也会从G Queue偷取任务\n\n# 网络\n## URL->显示主页\n1. DNS解析\n2. TCP连接\n3. 发送HTTP请求\n4. 服务器处理请求并返回HTTP报文\n5. 浏览器解析渲染页面\n连接结束\n## GET和POST区别\n1. Get方法主要用于请求，请求服务端返回资源，而POST主要用于form表单的提交，相当于把信息提交到服务器，等待服务器做出响应。\n2. GET请求是不安全的，发送请求的时候参数会拼接在url后面\n3. GET请求的URL长度有限制（浏览器和服务器的限制），POST数据放在body中一般没有限制\n4. GET请求会被浏览器主动缓冲，而POST不会\n## TCP\n### 三次握手 & 四次挥手\n**三次握手**：\n1. 客户端发送SYN同步信号，以及初始序列化 SEQ = ISN(c)\n2. 服务端返回ACK = ISN(c)+1 信号以及SYN同步信号，以及初始序列化SEQ = ISN(s) （半连接队列）\n3. 客户端回复ACK = ISN(s)+1 信号（全连接队列）\n> 确认双发收发功能正常，交换ISN序列号\n\n**SYN flood**\n\n黑客伪造本地IP地址，然后想目标IP发送大量的SYN报文，服务端回复的ACK+SYN被发送到一个未知的地址，进而造成半连接队列满载，无法处理正常请求。 SYN Cookie就是在三次握手的最后阶段才分配连接资源，收到SYN包后首先计算Cookie，在收到第三次握手ACK的时候验证Cookie，验证成功再分配资源\n\n**四次挥手**：\n1. 客户端发送FIN报文，Client：FIN-WAIT-1\n2. 服务端响应ACK信号，Server: CLOSE-WAIT，Client: FIN-WAIT-2\n3. 服务端发送FIN报文，Server: LAST-ACK\n4. 客户端响应ACK报文，Client：TIME-WAIT\n\n**TIME-WAIT**\n\n1. 一方面确保通信过程中延迟的重复包能在连接结束后自动的消亡，否则可能会造成错乱\n2. 确保主动关闭方的最后的ACK能到达对端，同时也确保ACK丢失后，被动关闭端重发的FIN能顺利到达，一来一回2MSL（msl指的是报文在网络中最长的生存时间）\n\n> 大量TIME-WAIT会造成一些浪费，会占用TCP端口，无法复用，可以通过Linux的一些设置去优化（net.ipv4.tcp_tw_reuse，tcp_tw_recycle）\n\n### TCP可靠性保证\n#### 重传机制\n1. **超时重传**，根据RTO的值重传丢失的数据，RTO的值应该略大于RTT，是一个动态值，会根据之前的RTT进行采样，然后动态变化\n2. **快速重传**，不以时间为驱动，而是以数据为驱动，当收到3个重复的ACK信号的时候就会触发重传，可能会重传所有的数据\n3. **SACK**，快重传的一种实现方式，接收方通过SACK信号告知发送端丢失的数据段，这样发送端就可以准确的重传丢失的数据\n4. D-SACK，可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了，可以知道是不是「发送方」的数据包被网络延迟了，可以知道网络中是不是把「发送方」的数据包给复制了\n\n#### 流量控制 & 滑动窗口\n窗口实际上是发送方在OS中开辟的一块缓冲区，在收到对方的应答之前，数据会被缓存在窗口内\n\n已发送并收到ACK || 已发送未ACK || **未发送且大小在窗口内** || 未发送且超出窗口\n\n这样一来，发送方就可以在不等待ACK的情况下发送多个包（不超过窗口大小），接收方进行 **累积确认（累计应答）**，当窗口耗尽，则无法发送数据，接收方ACK数据后，窗口右移，可用窗口增大\n\n>通常发送方的窗口是由接受方的窗口大小决定的，避免接收端处理不过来\n\n#### 拥塞控制\n当网络出现拥堵，如果继续发送大量的数据包，会导致数据包延迟，丢失，进而导致重传，进一步加大阻塞程度，形成恶性循环\n\n**拥塞窗口（cwnd）**\n\n发送方维护的一个变量，根据网络拥塞程度动态的变化，`swnd=Min(rwnd,cwnd)`，只要发生了超时重传其实就说明网络开始拥堵了，主要有以下算法\n1. 慢启动，发送方每接收一个ACK，拥塞窗口cwnd的大小就会+1，直至ssthresh\n2. 拥塞避免，每当收到一个 ACK 时，cwnd 增加 1/cwnd。\n3. 拥塞发生\n   1. 超时重传；ssthresh 设为 cwnd/2，cwnd 重置为 1，重新开始慢启动，反应太剧烈，突然刹车\n   2. 快速重传：ssthresh = cwnd，cwnd = cwnd/2\n4. 快速恢复\n\n### 粘包解决方案：\n1. 固定长度\n2. 分割符号，文本中可能有分割符，需要扫描文本转义\n3. 添加长度字段，先读取长度字段，再读取内容\n\n### TCP和UDP区别\n1. TCP传输前需要建立连接，UDP无连接\n2. TCP面向流，将数据看做UDP则是面向报文\n3. TCP提供可靠的服务，有超时重传，差错校验，滑动窗口，拥塞控制等机制确保可靠性能\n4. TCP只支持点对点的通信，而UDP支持一对一，多对一和多对多的交互通信\n5. TCP头部20-60字节，UDP头部8字节\n### 如何设计可靠的UDP\n1. 添加seq/ack机制，确保数据发送到对端\n2. 添加发送和接收缓冲区，主要是用户超时重传。\n3. 添加超时重传机制。\n\n\n## HTTP 1.0，1.1\n1. 长连接，Connection: keep-alive，这样可以在一个TCP连接中发送多个请求\n2. 错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n3. 缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n## HTTPS\nHTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用 **对称加密** ，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。\nhttps://zhuanlan.zhihu.com/p/57142784\n## TCP/IP网络模型\n\n1. **应用层**，（OSI细分为：应用层，表示层，会话层）面向用户，为用户提供服务，常见协议有HTTP，FTP，DNS\n2. **传输层**，为应用层提供通用的数据传输服务，主要有TCP和UDP两种协议\n3. **网络层**，提供路由和寻址的功能，确保两边的系统能互联，并选择最佳路径，网络层不提供通信服务，且网络层只对报文头部进行差错校验，协议有IP，ICMP，ARP（路由器）\n4. **链路层**，将网络层的数据封装成帧，然进行传输，并进行一些差错控制，PPP，HDLC，MAC（网桥，交换机）\n5. **物理层**，利用一些传输介质，为数据链路层提供物理连接，时间bit流的传输（集线器）\n\n# 操作系统\n\n管理计算机资源，包括CPU，内存，磁盘等，提供一些接口服务与一些第3方的软件\n\n## 进程 & 线程 & 协程\n**进程5态模型：** 1.新建（fork） 2.就绪 3.运行 4.等待 5.终止\n\n进程是操作系统**资源分配**的基本单位，当执行一个程序时候系统启动一个进程，分配给这个进程一些执行所需要的资源，包括打开的文件，虚拟内存地址空间等\n> **孤儿进程**：父进程被kill了，而子进程仍然存在就会变成孤儿进程，被init进程收养\n> \n> **僵尸进程**：父进程没有wait()子进程，进程退出的时候会释放所占用的资源，但是不会释放task_struct里一些相关的状态信息，因为这些信息父进程可能会比较关心，父进程可以通过调用wait相关方法去获取子进程的这些信息，之后系统便才会完全回收子进程，所以如果父进程不调用wait就会导致子进程变成僵尸进程，占用进程号\n\n\n线程就是进程中能够并发执行的实体，一个进程内至少有一个线程，是进程的组成部分，也是处理器**调度执行**的基本单位，一个进程内也可以有多个线程，多个线程共享进程所拥有的资源，共同完成任务\n\n> **Java线程生命周期：** 1.新建（new） 2.运行 3.阻塞 4.等待 5.限时等待 6.终止\n\n协程，英文Coroutines，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制，非抢占式的调度，创建成本更低，上下文切换成本低，当发生IO阻塞的时候调度器可以记录上下文然后主动的让出CPU执行权，实现协同式调度\n## 死锁\n1. **互斥条件**：该资源任意时刻只由一个线程占用\n2. **请求与保持条件**：一个线程因为请求资源而阻塞，其他线程获取资源保持不变\n3. **不剥夺条件**：线程已经获取的资源在未使用完成之前不能被其他线程强行剥夺\n4. **循环等待**：若干线程之前形成的一直循环的依赖，比较容易打破的就是循环等待条件，只要按照顺序申请资源，释放则反序就能打破依赖\n## 存储管理\n连续分配会产生大量内存碎片，可以通过移动来合并但是消耗比较大，所以出现了离散式的分配方式，将进程数据分散的装入不相邻的内存分区中\n### 页式\n将逻辑空间等分为页，然后将物理内存空间等分为块，与页面大小相同，分配内存时将进程数据以块为单位，存放到离散的物理内存中，页的大小固定，**不会产生外部碎片**，只会产生少量内部碎片，用户不可见，由**操作系统管理**\n### 段式\n按照程序自身的逻辑关系划分为几个段，以段为单位分配内存，每个段在内存中占连续空间，但是各个段之间可以不相邻，分段更容易实现 **信息的共享和保护**，段的长度不固定，分配较大的段**会产生外部碎片**，对用户可见，用户编程需要显式的给出段名\n### 段页式\n先分段，在每一段内再做分页，存储依然采用页式存储，增加了硬件成本，系统复杂度大\n## 进程通信\n1. 管道（pipe）\n2. 信号（signal）\n3. 消息队列（Message）\n4. 共享内存(share memory)\n5. 信号量(semaphore)\n\n## 调度算法\n### 进程调度\n1. **先来先服务**（First Come First Severd，FCFS），顾名思义，对长作业友好，短作业不友好，可能长期得不到执行\n2. **最短作业优先调度**（Short Job First，SJF），优先选择短作业运行，对短作业有利，但是可能会导致长作业饥饿\n3. **高响应比优先**（Highest Response Ratio Next，HRRN），优先执行响应比优先级高的进程，**响应比 = (等待时间+要求服务时间)/要求服务时间**，这样首先要求服务时间短的短作业会更容易被选中，同时长作业等待时间越长，相应比也会越高，兼顾长短作业\n4. **时间片轮转**（Round Robin，RR）每个进程分配一个时间片，如果时间片用完，仍然在执行就会中断该进程，切换为其他进程，如果发生了阻塞后提前结束也会进行切换。时间片设置太短会导致大量的线程切换，如果设置太长就会导致短作业饥饿，一般设置20ms-50ms\n5. **最高优先级调度**（Highest Priority First，HPF），优先级可分为 **静态优先级** 和 **动态优先级**，同时有两种调度方法， **抢占式** 和 **非抢占式**（出现优先级更高的，立马挂起当前进程，执行优先级更高的），可能会导致低优先级的永远不会执行\n6. **多级反馈队列**，结合了4和5\n\n### 内存页面调度\n也就是在产生缺页中断的时候，把磁盘中缺失的页面调度进虚拟地址映射的物理内存中时，由于物理内存空间不足所以需要选择一个物理页进行替换\n\n1. **最佳页面置换算法**（OPT），置换 **未来** 最长时间不访问的页面，无法实现，仅仅是理论方法\n2. **先进先出置换**（FIFO），直接选择内存中驻留最久的页面进行淘汰\n3. **最近最久未使用**（LRU），选择 **过去** 最长时间未访问的页面进行置换\n4. **时钟页面置换**（LOCK），将页面保存在一个环形链表中，一个表针指向最老的页面，当发生缺页中断的时候，检查指针指向的页面状态是否为0，为0就淘汰该页面，并插入这个位置，然后把表针后移，如果是1，就清除状态位为0，然后继续向前找，知道找到0\n5. **最不常用置换算法**（LFU）,根据 **过去** 页面的访问次数，选择访问次数最少的页面淘汰，给每个页面增加一个计数器，然后用链表按照大小串起来。实现起来其实消耗会比较大，成本比较高\n\n## DMA\nDMA，直接内存访问，使得IO模块在不涉及到CPU的情况下，读取或者写入内存，提高效率\n\n## 虚拟内存\n虚拟内存实际上是对主存的一种抽象，让每个进程都能 **独占** 内存，实际上进程发出的地址都是虚拟地址，通过虚拟寻址来间接的引用主存，cpu产生的虚拟地址将通过 **MMU** 利用 **页表（PTE（Page Table Entry）集合）**  翻译成主存的物理地址，同时CPU还为页表寻址提供了缓存策略 **TLB（Translation Lookaside Buffer）** 提高翻译速度\n\n虚拟地址被分为: **虚拟页号（VPN）**（高位）+ **偏移量（VPO）**（低位）\n通过虚拟页号定位页表中的`PTE`，判断是否有效，有效就拼接页表中的**物理地址（PPN）** 和虚拟地址的 **偏移量** 构成物理地址，如果无效就发生 **缺页中断** ，这里中断页分为软中断和硬中断，软中断就是指页面已经在物理内存中，只是页表中没有，这时只要重新映射一下就行了，而硬中断就是物理内存中没有，这个时候就需要从磁盘中加载页到物理内存中（**按需分页**）\n\n> fork()其实就是复制页表，父子进程共享所有数据，但是当某一方执行了**写入**操作就会触发COW，系统回为该进程申请新的内存，将要修改数据拷贝到新的区域，再进行读写\n### 好处\n1. 虚拟内存利用主存起到缓存的作用，提高进程访问磁盘的效率\n2. 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高安全性能（页表中加入保护位）\n3. 为每个进程提供了一致的地址空间，简化内存管理，内存分配，可以一次分配多个连续的虚拟地址，但是在物理上不连续，简化内存共享\n### mmap内存映射\n将文件的物理地址和进程的虚拟地址进行映射（此时仅仅是进行了映射，没有拷贝），然后当进程发起对这块虚拟内存的访问的时候就会发生**缺页**，内核就会将文件从磁盘拷贝到物理内存中，然后进程就可以直接对这块内存进行读写，系统后台会自动刷新脏页到磁盘（也可以通过`fsync`强制刷盘）\n\n常规的文件读写为了保证读写的效率和保护磁盘，提供了 **页缓存（内核缓冲区）** ，所以当我们读写某一个文件的时候会先将文件页从磁盘拷贝到 **页缓存** ，但是由于页缓存依然位于内核态，用户进程无法寻址，所以还需要将数据从 **页缓存** 拷贝到用户的进程空间，然后才能操作，相比mmap的方法多了一次拷贝操作\n## 五种IO模型\n1. 阻塞IO，调用者一直阻塞，知道内核将数据准备好，然后将数据从内核态拷贝到用户态\n2. 非阻塞IO，内核没准备好就会返回一个错误码，调用者不会阻塞，而是不断的轮询，询问内核数据是否准备好\n3. 多路复用IO，类似非阻塞，只不过轮询交给内核，减少系统调用，内核会将进程加入到对应事件的等待队列，待事件就绪时候唤醒进程，避免空轮询\n4. 异步IO，完全的非阻塞的IO方式，当数据准备好的时候会通过回调函数来处理\n5. 信号驱动IO，内核在数据准备好的时候使用信号处理程序来进行通知\n\n## 文件描述符表，文件描述符表，索引节点表\n**文件描述符表**：进程创建的时候，会在内存中开辟task_struct结构体，又叫进程表，用于存放进程运行期间的一些相关信息\n\n**文件描述符表**：记录进程打开的文件，内部有一个指针，指向 **内核中的文件表** \n\n**打开文件表（又叫做系统级的描述符表）**：所有进程共享这张表，记录了当前文件的偏移量，引用计数，以及指向`i-node`表的指针，当引用计数为0内核就会删除这个表项\n\n**i-node表**：记录文件对应的inode号，以及对应的block\n## 软链接 & 硬链接\n\n**硬链接 （ln）:** 实际上是给文件创建了一个别名，链接文件和原文件指向的其实是同一个inode，创建一个硬连接实际上对应文件表中的引用计数+1，删除任意一个只是文件表的引用计数减一，并不会影响另一个文件\n\n**软连接（ln -s）** 软连接实际上是一个快捷方式，软连接文件的inode会指向原文件本身的inode，如果删除了原文件软连接就失效了\n\n## 多路复用\n提到多路复用就不得不说一下阻塞IO，阻塞IO就是说当IO操作发起后会被阻塞直到收到数据才返回，因此当使用阻塞IO的时候通常会创建多个线程去监听描述符，但是多线程一来切换成本高，同时多线程的内存开销也会比较大\n\n所以后面引入了非阻塞IO，非阻塞IO不会挂起线程，调用后立即返回结果，所以可以在**一个线程中轮询多个文件描述符是否准备就绪**，但是非阻塞IO每次发起系统调用（`syscall`）都只能检测一个文件描述符是否就绪，系统调用成本很高，如果文件描述符很多，性能开销就会很大，同时还需要不停的去遍历所有的FD，包括没有发生读写事件的FD，这样会导致CPU的消耗非常大\n\n而IO多路复用则可以通过**一次系统调用检查多个文件描述符是否就绪**，同时也不用像 **非阻塞IO** 一样一直轮询所有的FD，而是由事件驱动，当有监听的FD准备就绪时候通知进程返回处理，否则就会挂起进程到等待队列，避免CPU空转\n### select\n```c\n// Linux\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n//位图结构\n#define __FD_SETSIZE    1024\ntypedef __kernel_fd_set     fd_set;\ntypedef struct {\n    unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];\n} __kernel_fd_set;\n\nFD_SET(int fd, fd_set *set); // Add fd to the set\nFD_CLR(int fd, fd_set *set); // Remove fd from the set\nFD_ISSET(int fd, fd_set *set); // Return true if fd is in the set\nFD_ZERO(fd_set *set); // Clear all entries from the set\n```\n#### 特点\n\n1. 输入输出都是相同的fd_set，所以每次都需要重新设置fd\n2. 将fd_set从用户态拷贝到内核态，性能损耗大\n3. 内部每次调用的时候都是无差别轮询，当描述符很多的时候消耗较大\n4. fd_set大小有限，最多1024（fd_set为长度为32的长整型数组，位图表示一个bit就是一个fd，所以能表示32*32=1024个FD）\n5. 不是线程安全的，如果正在使用的fd被其他进程关闭的话结果就未知了\n\n#### 实例\n> 有空再来写\n\n### poll\n```c\n#include <poll.h>\nint poll ( struct pollfd * fds, unsigned int nfds, int timeout);\n\nstruct pollfd {\n    int fd;               /* 文件描述符 */\n    short events;         /* 等待的事件 */\n    short revents;        /* 实际发生了的事件 */\n} ; \n```\n#### 特点\n1. poll_fd数组只需要初始化一次，通过events和revents标识关注的事件和发生的事件\n2. poll使用链表来实现，没有最大fd的限制\n3. 但是和select一样需要频繁的将pollfd从用户态拷贝到内核态\n4. poll返回后，仍然需要对pollfd中的每个元素检查其revents值，来判断事件是否发生\n5. 水平触发，当报告了某个fd后如果没有被处理，下次还会继续报告该fd\n#### 实例\n> 有空再来写\n### epoll\n\n```c\n#include <sys/epoll.h>\n//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大\nint epoll_create(int size);\n//epoll的事件注册函数\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n//等待事件的产生，类似于select()调用。\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n#### 特点\n1. 在高速缓存cache中用红黑树保存要监听的事件，同时使用了一个list链表记录准备就绪的事件，当`epoll_wait`返回的时候只需要查看list中又没有数据就行了，所以我们不需要从内核态拷贝全部的描述符到用户态，只需要拷贝少量的就绪fd就可以了，并且调用`epoll_wait`的时候并不用拷贝描述符到内核态，因为前面`epoll_ctl`已经拷贝了，相比之前selecl/poll效率很大提升\n\n#### 工作模式\n **LT模式** ：当epoll_ wait检测到描述符事件发生并将此事件通知应用程序，应用程序没有一次性把数据读/写完。下次调用epoll_wait时，会再次响应应用程序并通知此事件。\n \n **ET模式**：当epoll_ wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。\n\nET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。**epoll工作在ET模式的时候，必须使用非阻塞IO**，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n> ET模式下阻塞IO需要一次性把数据全部读完，但是实际上epoll返回可读，到真正读取是由空窗期的，可能你读取的时候数据被其他进程取走了，如果采用阻塞读取就会导致进程一直阻塞\n> \n> man 2 select 「BUGS」节：      \n> Under Linux, select() may report a socket file descriptor as \"ready for reading\", while nevertheless a subsequent read blocks.  This could for example happen when  data has arrived but upon examination has wrong checksum and is discarded.  There may be other circumstances in which a file descriptor is spuriously reported  as  ready.  Thus it may be safer to use O_NONBLOCK on sockets that should not block.\n\n#### 实例\n> 有空再来写\n\n# Linux常用命令\n## ps\n-A 列出所有进程 -au 显示详细\n\n# 海量数据处理\n## 如何从大量的 URL 中找出相同的 URL？\n1. 给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。\n    \n    64byte * 50 * 10^8 = 3000 * 10^8 byte = 300m\n    hash分治，将a,b中的url分别hash后模1000，分别存放在a(1,2,3,4..),b(1,2,3,4..)文件中，然后将a,b文件直接加载到内存中统计就行了\n2. 如何从大量数据中找出高频词？\n\n    hash分治，将所有的数据hash后取模，分散到不同的小文件中，然后统计各个小文件的词频，然后用小根堆统计TopK\n\n3. 如何在大量的数据中判断一个数是否存在？\n\n    40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4, 000, 000, 000b≈512M。我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。\n\n    \n\n# RAFT\nhttps://juejin.im/post/6844903602918522888 这个讲的不错，后面有时间根据这个再整理下\n## leader选举\nLeader选举需要某个节点首先发起投票请求，每个节点都有一个随机的election timeout，当超过这个时间没有收到Leader的心跳消息就认为Leader挂掉了，就回将自己的term+1然后发起投票请求，成为Candidate，其他节点收到请求后如果投票给该节点，那么当前节点就会成为Leader，Leader会每间隔HeartbeatTimeout向所有的Follower发送心跳包\n## 日志复制\n当一个节点被选为主节点后，它就开始对外提供服务，收到客户端请求后，主节点会先将数据加入自己的日志中，然后并行的向其他Follower节点发送消息，如果有大多数节点成功的写入了这条日志，那么Leader节点的这条日志状态就会更新为committed状态，提交该条目，同时也会将之前任期的条目，并且通过心跳包告知其他节点同步主节点的日志\n## 安全性\n1. 选主的限制，只有包含了所有提交日志的节点才有机会成为主节点，所以在选举的时候，如果发起投票节点的最后一个log的任期比自己小，那么就拒绝为该节点投票，这样选出的节点的log至少比半数以上节点要新\n2. Raft 只对自己任期内的日志计数并在复制到多数节点时进行提交，且在提交这条日志的同时提交之前的所有日志\n### 非对称网络分区\n如果不做特殊处理，会反复出现新的选举，打断正常的 IO，造成，可用性降低的问题，一般可以通过 pre-vote 解决，例如，每次发起选举之前，先发起 pre-vote 如果获得大多数 pre-vote 选票，再增大 term 发起选举 vote 投票。为了避免问题描述的情况，其他节点只需要在收到 pre-vote 请求时，判断一下 leader 是否还在，一般实现上，判断最近和 leader 是否正常通信，如果有，那么说明 leader 正常在线，直接拒绝 pre-vote 即可。\n# 网络安全\n## SQL注入\n对用户的输入控制不严，导致黑客可以通过拼接SQL的方式进行攻击\n\n```sql\n\"SELECT * FROM user WHERE username = \" + uname + \"ADN password = \" + pwd\n```\n\n类似这种如果我传入username = \" **resolmi'#** \"，这样SQL语句就变成了\n\n```sql\nSELECT * FROM user WHERE username = 'resolmi' #ADN password = ''\n```\n#后把后面的password注释掉，这样就可以不用密码直接获取到resolmi的信息\n\n解决方案就是严格过滤用户输入，但是这样会比较麻烦，目前比较好的解决方案是通过DB的预编译功能，通过占位符占位，MySQL编译的时候就会将参数转义后填充到占位符中\n> MyBatis中 # 和 $ 区别：#{}是预编译的方式，能防止SQL注入，${}是字符拼接的方式，会有SQL注入的问题\n## CSRF\nCross-site request forgery，中文名，跨站请求伪造\n\nCSRF攻击要满足两个条件\n1. 登录了受信任的网站A，比如tb\n2. 在不登出tb的情况下，访问危险网站B\n\n由于**同源策略**实际上是限制一个域名的js，在未经允许的情况下不能读取另一个域名的内容，所以ajax提交是不能跨域的，因为ajax是可以读取响应的，而Form表单提交则没有跨域的问题，因为Form提交后，原页面是无法获取新页面的内容的，同理GET请求也是允许跨域的\n> 同源：ip，协议，端口一致\n> \n> Ajax跨域请求实际上服务端是会收到请求的，但是浏览器如果接收到服务端的返回值没有`Access-Control-Allow-origin`说明不允许跨域就不会处理这条返回信息\n\n所以当访问恶意网站的时候，恶意网站会向安全网站tb发起一个恶意的get/post请求，这个请求就会携带tb的cookie去执行该操作，进而达成跨站请求攻击\n\n**解决方案**\n\n1. Http referer：根据请求的来源判断是否合法，但是这个Referer是浏览器提供的，是可以修改的\n2. csrftoken：\n   对于GET/POST请求可以在cookie中加一个csrftoken字段，当发起请求的时候将csrftoken加入url或者body中，因为同源策略，危险B网站是无法访问tb的cookie的，所以也就无法伪造csrftoken，服务端接收后验证下cookie和url中的是否一致就ok了。\n\n    但是如果该站点存在XSS，黑客可以通过XSS注入cookie，那么就失效了。所以比较保险的方式是使用session，在用户访问页面的时候生成一个Token，存放到服务端session中，当发起请求的时候将token加到url或者body中（注意不能放到cookie中），这样黑客就无法伪造token了\n3. 验证码：执行关键操作时候需要输入验证码，这样黑客同样无法伪造\n## XSS\nCross Site Scripting，跨站脚本攻击，这个其实就是对用户的输入过滤不严格，导致黑客可以向网页插入恶意的js脚本，当其他用户访问到该页面脚本就会执行，窃取用户信息，笔者之前年轻不懂事的时候还曾经挖过几个小网站的xss漏洞（都反馈给相关人员了，不过有的也没理我就是了😂）\n\n**解决方案**\n1. 输入过滤，一定程度上可以解决，这种方案整体还是不太可行，笔者之前挖过的一个网站就是使用输入过滤，但是最终还是被我绕过了\n2. 对HTML进行转义，很多模板引擎都自带转义功能\n3. Http-only Cookie，本质上并没有阻止XSS，只是防止窃取cookie\n\n## HTTP请求篡改\n1. 采用HTTPS\n2. 请求参数签名\n3. 客户端IP黑/白名单\n# 套路CODE\n## 生产者消费者\n```java\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class ProducerConsumer1{\n    /*\n    多生产者消费者\n    signal/await模型\n    */\n\n    //缓存区\n    private static List<Integer> buffer=new ArrayList<>();\n\n    //缓冲区的最大值\n    private static int MAX=3;\n\n    //当前的缓冲区大小,需要加volatile保证可见性\n    private static volatile int size=0;\n\n    //锁\n    private static final Object LOCK = new Object();\n\n    //模拟produce数据\n    private static int data=0;\n\n    public static void main(String[] args) {\n        Stream.of(\"Produce1\",\"Produce2\",\"Produce3\",\"Produce4\",\"Produce5\").forEach(name->{\n            new Thread(()->{\n                try{\n                    produce();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            },name).start();\n        });\n        Stream.of(\"Consumer1\",\"Consumer2\",\"Consumer3\",\"Consumer4\",\"Consumer5\").forEach(name->{\n            new Thread(()->{\n                try{\n                    consumer();\n                }catch(Exception e){\n                    e.printStackTrace();\n                }\n            },name).start();\n        });\n    }\n\n    public static void produce()throws InterruptedException{\n        while(true){\n            synchronized(LOCK){\n                while(size>=MAX){\n                    LOCK.wait();\n                }\n                buffer.add(++data);\n                size++;//这里不用加锁,单线程\n                System.out.println(Thread.currentThread().getName()+\" produce \"+ data);\n                Thread.sleep(1000);\n                LOCK.notifyAll();\n            }\n        }\n    }\n\n    public static void consumer () throws InterruptedException{\n        while(true){\n            synchronized(LOCK){\n                while(size==0){\n                    LOCK.wait();\n                }\n                int temp=buffer.remove(0);\n                size--;\n                System.out.println(Thread.currentThread().getName()+\" consumer \"+ temp);\n                Thread.sleep(1000);\n                LOCK.notifyAll();\n            }\n        }\n    }\n}\n```\n## 死锁\n```java\npublic class DeadLock{\n\n    private static Object resourceA = new Object();\n\n    private static Object resourceB = new Object();\n\n    public static void main(String[] args) {\n        Thread A=new Thread(()->{\n            synchronized(resourceA){\n                System.out.println(\"Thread A acquire resourceA\");\n                try{\n                    TimeUnit.SECONDS.sleep(2);\n                }catch(InterruptedException e){}\n                synchronized(resourceB){\n                    System.out.println(\"Thread A acquire resourceB\");\n                    System.out.println(\"A do some thing\");\n                }\n            }\n        });\n        \n        Thread B=new Thread(()->{\n            synchronized(resourceB){\n                System.out.println(\"Thread B acquire resourceB\");\n                try{\n                    TimeUnit.SECONDS.sleep(2);\n                }catch(InterruptedException e){}\n                synchronized(resourceA){\n                    System.out.println(\"Thread B acquire resourceA\");\n                    System.out.println(\"B do some thing\");\n                }\n            }\n        });\n        A.start();\n        B.start();\n    }\n}\n```\n## 单例\n### DCL\n```java\npublic class SingleTonDCL{\n    \n    private static volatile SingleTonDCL instance=null;\n\n    //私有化构造器\n    private SingleTonDCL(){\n        if (instance !=null){\n            throw new RuntimeException(\"实例已经存在，请通过 getInstance()方法获取\");\n        }\n    }\n    \n    //懒汉式\n    public static SingleTonDCL getInstance(){\n        if(instance==null){\n            synchronized(SingleTonDCL.class){\n                if(instance==null){\n                    //这里会有重排序的问题,instance还没有初始化完成就返回了\n                    //所以需要加volatile\n                    instance=new SingleTonDCL(); \n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n### 枚举\n```java\n//1、除枚举方式外, 其他方法都会通过反射或者序列化的方式破坏单例\npublic enum SingleTonEnum{\n    INSTANCE;\n}\n```\n### 饿汉\n```java\npublic class SingleTonHungry{\n    /*\n    线程安全,但是消耗比较大,在类第一次加载的时候就会初始化\n    但是也不一定马上会用,一般我们希望用的时候再创建\n     */\n    private static final SingleTonHungry instance=new SingleTonHungry();\n\n    //私有化构造器\n    private SingleTonHungry(){\n        if (instance !=null){\n            throw new RuntimeException(\"实例已经存在，请通过 getInstance()方法获取\");\n        }\n    }\n\n    public static SingleTonHungry getInstance(){\n        return instance;\n    }\n}\n```\n### 内部类\n```java\npublic class SingleTonInnerClass{\n\n    //私有化构造器\n    private SingleTonInnerClass(){}\n\n    private static class SingleTonHolder{\n        static{\n            //当getInctance静态方法 访问SingleTonHolder的静态变量\n            //的时候才会初始化内部类,所以也是属于懒汉式,并且是线程安全的\n            System.out.println(\"Inner class\");\n        }\n        private static SingleTonInnerClass instance=new SingleTonInnerClass();\n    }\n\n    static{\n        //先初始化外部类\n        System.out.println(\"SingleTon Outer class\");\n    }\n\n    public static SingleTonInnerClass getInstance(){\n        return SingleTonHolder.instance;\n    }\n}\n```\n## LRU\n\n```java\nclass LRUCache {\n    \n    HashMap<Integer, Node> map = null;\n        \n    int capacity = 0;\n    \n    Node head = null;\n    \n    Node tail = null;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        Node node = map.get(key);\n        if (node == null) {\n            return -1;\n        }\n        removeNode(node);\n        insert2head(node);\n        return node.val;\n    }\n    \n    public void put(int key, int value) {\n        Node node = map.get(key);\n        if (node == null) {\n            node = new Node(key, value);\n            insert2head(node);\n            map.put(key, node);\n        } else {\n            removeNode(node);\n            node.val = value;\n            insert2head(node);\n        }\n        if (map.size() > capacity) {\n            map.remove(tail.prev.key);\n            removeNode(tail.prev);\n        }\n    }\n    \n    public void insert2head(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    //移除Node节点\n    public void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        node.next = null;\n        node.prev = null;\n    }\n    \n    class Node {\n        Node prev, next;\n        int key, val;\n        public Node (int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n# P & NP\n1. P（polynominal）问题：有多项式时间算法，算得很快的问题。\n2. NP（Nondeterministic polynominal）问题：算起来不确定快不快的问题，但是我们可以 **快速验证** 这个问题的解。\n3. NP-hard问题：比NP问题都要难的问题。\n4. NP-complete问题：属于NP问题，且属于NP-hard问题。\n5. NPC类问题：首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。\n6. NP难问题：即所有的NP问题都能约化到它，但是它不一定是一个NP问题。NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP","tags":["面试"],"categories":["踩坑记录"]},{"title":"LeetCode单调栈","url":"/2020/08/28/leetcode-dan-diao-zhan/","content":"\n> 从[栈&队列专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/)中抽取出来\n## [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)\n\n给定两个**没有重复元素**的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。\n\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。\n\n**示例 1:**\n\n```java\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。\n    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。\n    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。\n```\n\n**示例 2:**\n\n```java\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n    对于num1中的数字2，第二个数组中的下一个较大数字是3。\n    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。\n```\n\n**注意:**\n\n1. `nums1`和`nums2`中所有元素是唯一的。\n2. `nums1`和`nums2` 的数组大小都不超过1000。\n\n**解法一**\n\n单调栈，很就之前在链表专题中做过一次 [链表的下一个更大节点](http://imlgw.top/2019/02/27/leetcode-lian-biao/#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9) 但是没想起来，可能当时也没留下影响\n\n这题其实还比原始的题加了一点难度，原始的题就是 num1==nums2的情况，那样就不需要HashMap记录了\n\n```java\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    Stack<Integer> stack=new Stack<>();\n    for (int i=0;i<nums2.length;i++) {\n        while(!stack.isEmpty() && nums2[stack.peek()]<nums2[i]){\n            map.put(nums2[stack.pop()],nums2[i]);\n        }\n        stack.add(i);\n    }\n    int[] res=new int[nums1.length];\n    for (int i=0;i<nums1.length;i++) {\n        res[i]=map.getOrDefault(nums1[i],-1);\n    }\n    return res;\n}\n```\n## [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n\n**示例 1:**\n\n```java\n输入: [1,2,1]\n输出: [2,-1,2]\n解释: 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n```\n\n**注意:** 输入数组的长度不会超过 10000。\n\n**解法一**\n\n```java\npublic static int[] nextGreaterElements(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return new int[]{};\n    }\n    Stack<Integer> stack=new Stack<>();\n    stack.push(0);\n    int[] res=new int[nums.length];\n    Arrays.fill(res,-1);\n    int index=1;\n    for (int i=1;i<nums.length*2;i++) {\n        index=i>=nums.length?i%nums.length:i;\n        while(!stack.isEmpty()&&nums[stack.peek()]<nums[index]) {\n            res[stack.pop()]=nums[index];\n        }\n        stack.push(index);\n    }\n    return res;\n}\n```\n和上面一样，只不过需要循环遍历一遍，我最开始的做法相当憨憨，copy了一个两倍的数组。。。还需要注意的就是 `-1`的处理\n\n## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)\n\n根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n\n**解法一**\n\n```java\npublic int[] dailyTemperatures(int[] T) {\n    int[] res=new int[T.length];\n    if(T==null || T.length<=0) return res;\n    Stack<Integer> stack=new Stack<>();\n    stack.push(0);\n    for (int i=1;i<T.length;i++) {\n        while(!stack.isEmpty()&&T[stack.peek()]<T[i]){\n            int temp=stack.pop();\n            res[temp]=i-temp;\n        }\n        stack.push(i);\n    }\n    return res;\n}\n```\n和上面两题一样，单调栈的解法，不过这题好像可以不用单调栈，可以从后向前递推\n\n## [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)\n\n编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n\n例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。\n\n**示例：**\n\n```java\n输入：[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"], [[],[100],[80],[60],[70],[60],[75],[85]]\n输出：[null,1,1,1,2,1,4,6]\n解释：\n首先，初始化 S = StockSpanner()，然后：\nS.next(100) 被调用并返回 1，\nS.next(80) 被调用并返回 1，\nS.next(60) 被调用并返回 1，\nS.next(70) 被调用并返回 2，\nS.next(60) 被调用并返回 1，\nS.next(75) 被调用并返回 4，\nS.next(85) 被调用并返回 6。\n\n注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格\n(包括今天的价格 75) 小于或等于今天的价格。\n```\n\n**提示：**\n\n- 调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5\n- 每个测试用例最多可以调用  10000 次 StockSpanner.next\n- 在所有测试用例中，最多调用 150000 次 StockSpanner.next\n- 此问题的总时间限制减少了 50%\n\n**解法一**\n\n我起了，一枪秒了，有什么好说的\n\n```java\nclass StockSpanner {\n\n    Deque<int[]> stack=new ArrayDeque<>();\n\n    public StockSpanner() {}\n    \n    public int next(int price) {\n        int res=1;\n        while(!stack.isEmpty() && price>=stack.peek()[0]){\n            res+=stack.pop()[1];\n        }\n        stack.push(new int[]{price,res});\n        return res;\n    }\n}\n```\n\n## [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n![leetCode](https://i.loli.net/2019/12/12/a7pVfNcYuIKFgwA.png)\n\n以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。\n\n![leetCode](https://i.loli.net/2019/12/12/FAvMk3zWf4RheDi.png)\n\n图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。\n\n**示例:**\n\n```java\n输入: [2,1,5,6,2,3]\n输出: 10\n```\n\n**解法一**\n\n和上面几道题一样，单调栈的解法，这里是单调递增栈，20ms，87%\n\n```java\npublic int largestRectangleArea(int[] heights) {\n    if (heights==null || heights.length<=0) {\n        return 0;\n    }\n    Stack<Integer> stack=new Stack<>();\n    int maxArea= Integer.MIN_VALUE;\n    for (int i=0;i<heights.length;i++) {\n        while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\n            //当前的柱子小于栈顶,说明当前栈顶最多向右扩展到 i-1\n            int cur=stack.pop();\n            //为空说明向左无法扩展,标为-1不影响结果（可以提前将-1压栈）\n            int left=stack.isEmpty()?-1:stack.peek();\n            //这里其实是 (i-1)-(left+1)+1\n            maxArea=Math.max(maxArea,(i-left-1)*heights[cur]);\n        }\n        stack.push(i);\n    }\n    //处理栈中剩下的元素,右边是边界，剩余栈中所有的元素实际上都可以扩展到 heights.length-1\n    //所以为了让所有的元素都能出栈,我们可以再数组的后面想象添加一个0(也可以直接在原数组中添加一个0)\n    while(!stack.isEmpty()){ \n        int cur=stack.pop();\n        int left=stack.isEmpty()?-1:stack.peek();\n        //这一步很秀,在数组后面再想象一个0出来\n        //让栈中元素向右扩张(heights.length-1)-(left+1)+1\n        maxArea=Math.max(maxArea,(heights.length-left-1)*heights[cur]);\n    }\n    return maxArea;\n}\n```\n其实就是利用单调栈遍历每一个柱子，**找到每一个柱子左边和右边第一个比它小的元素，比如左边第一个比当前柱子小的是i，那么很显然i+1肯定是大于等于当前柱子的，并且i+1是左边连续大于当前柱子的最后一个，也就是当前柱子能想左扩展的边界位置，右边同理，既然是要求左右比当前柱子小的第一个，那么很明显就要用单调递增栈**，然后就可以直接根据这两个数据计算完全包含当前柱子的最大的矩形的面积。\n\n例如: `3 4 5 4 3 6` \n\n首先`3 4 5`都顺利的存入栈中，此时栈中元素为`【0，1，2】` ，当想存入下一个元素`i=3,h[i]=4`的时候，发现4比当前栈顶小，所以我们就可以开始计算**完全包含栈中每个柱子**的最大矩形的面积\n\n1. 由于当前`i` 位置的元素是比栈顶小，那么就说明 `i-1` 位置的元素一定比当前栈顶元素大！也就是向右边最多扩展到`i-1`位置\n\n2. 由于单调栈的结构，当前栈顶的下一个栈中元素`left`，其实就是当前栈顶的左边最近的比它小的元素，所以`left+1`位置的元素一定是比当前栈顶元素大(也有可能相等)！，所以向左边最多扩展到 `left+1` 位置\n\n3. 上面其实还分析漏了一种情况，那就是栈顶和`i` 位置元素相等的情况，第一点中提到的其实是 `i` 位置元素小于栈顶的情况，如果相等，那么向右能扩展到的位置还会是`i-1`么？显然不是，至少应该是`i`甚至更大，那我们这里计算的右边界不就是错误的？那我们将 `=` 去掉可以么？去掉之后单调栈就不再是严格单调了，这样的到的右边界确实准确了，但是我们的左边界由于栈中存在相等的元素，就变的不再准确了！\n\n4. 那我们如何处理这种情况呢？其实根本就不用处理，既然栈顶能**向右**扩展到 `i-1` 那么反过来，`i-1` 一样可以**向左**扩展到**栈顶** 位置，进而还可以扩展到`left+1`位置，而向左扩展的`left+1`是准确的，不会有误差，所以我们只需要等待`i-1`位置的元素弹出，然后就可以重新计算得到最大值，这个最大值肯定是包含之前的哪个最大当然这里其实那个 `heights[i]<=heights[stack.peek()]` 中的等号也可以去掉，这样栈就不是严格单调的了，`left+1`也不再准确，但是此时 `i-1` 就准确了，所以我们可以等待`left+1` 弹栈之后再重新计算，总而言之，就是相等的情况是不用做额外的处理\n\n   ![mark](http://static.imlgw.top/blog/20200129/gJPOkfEPDxwg.png?imageslim)\n\n   可以看到按照代码中的逻辑在计算完全包含当前绿色的栈顶元素的最大矩形的时候其实只计算到一部分，当计算到后面的相等的柱子的时候会完全包含之前的柱子的值，这样就不会有问题\n\n​       \n\n经过上面的分析，代码就好写多了，不过这里还有一个地方值得注意，就是处理栈中剩余的元素，其实比较好的方法是在数组的末尾加一个0，这样确保栈中所有的元素都可以出栈，不用额外的处理，java中没法直接向数组中push元素，所以我们就想象末尾有一个0，那么所有元素向左能扩展到的最远位置就是 `heights.length-1`\n\n**解法二**\n\n分治，480ms，27%\n\n```java\n//分治 480ms\npublic int largestRectangleArea(int[] heights) {\n    if (heights==null || heights.length<=0) {\n        return 0;\n    }\n    largestRectangleArea(heights,0,heights.length-1);\n    return maxArea;\n}\n\nprivate int maxArea=Integer.MIN_VALUE;\n\npublic void largestRectangleArea(int[] heights,int left,int right) {\n    if (left>right) {\n        return;\n    }\n    int minIndex=left;\n    for (int i=left;i<=right;i++) {\n        minIndex=heights[i]<heights[minIndex]?i:minIndex;\n    }\n    maxArea=Math.max(heights[minIndex]*(right-left+1),maxArea);\n    largestRectangleArea(heights,left,minIndex-1);\n    largestRectangleArea(heights,minIndex+1,right);\n}\n```\n将数组区间以`minIndex`为分界线，分别求左边和右边的最大面积，时间复杂度`O(NlogN)`\n\n**解法三**\n\n优化的分治 1ms，100%，没想到比单调栈还快。。\n\n```java\npublic int largestRectangleArea(int[] heights) {\n    if (heights==null || heights.length<=0) {\n        return 0;\n    }\n    return largestRectangleArea(heights,0,heights.length-1);\n}\n\npublic int largestRectangleArea(int[] heights,int left,int right) {\n    if (left>right) {\n        return 0;\n    }\n    int minIndex=left;\n    boolean up=true;\n    boolean down=true;\n    for (int i=left+1;i<=right;i++) {\n        if (heights[i]<heights[i-1]) {\n            up=false;\n        }\n        if (heights[i]>heights[i-1]) {\n            down=false;\n        }\n        minIndex=heights[i]<heights[minIndex]?i:minIndex;\n    }\n    if (up) {\n        int maxArea=-1;\n        for (int i=left;i<=right;i++) {\n            maxArea=Math.max(maxArea,(right-i+1)*heights[i]);\n        }\n        return maxArea;\n    }\n    if (down) {\n        int maxArea=-1;\n        for (int i=right;i>=left;i--) {\n            maxArea=Math.max(maxArea,(i-left+1)*heights[i]);\n        }\n        return maxArea;\n    }\n    return Math.max(heights[minIndex]*(right-left+1),Math.max(largestRectangleArea(heights,minIndex+1,right),largestRectangleArea(heights,left,minIndex-1)));\n}\n```\n其实相比于上面的分治，就是多了一步判断当前区间是否有序，因为有序的话就可以直接遍历得到区间的最大矩形，不用再递归做分治，我这里做了两个有序的判断，不知道是不是有的多余，我看的评论都只有一个\n\n## [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)\n\n给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n**示例:**\n\n```java\n输入:\n[\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\n]\n输出: 6\n```\n\n**解法一**\n\n特意在做了上面一题后没有马上做这一题，下面的是第二天下午做的，还行，没忘记😂，就是写的有点难看\n\n```java\n//update: 2020.4.12\npublic int maximalRectangle(char[][] matrix) {\n    if(matrix==null || matrix.length<=0) return 0;\n    int M=matrix.length,N=matrix[0].length;\n    int[][] height=new int[M][N+1]; //每一层多加一个0,方便后面出栈\n    int res=0;\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++){\n            if(matrix[i][j]=='1'){\n                height[i][j]=i-1>=0?height[i-1][j]+1:1;\n            }\n        }\n        res=Math.max(maxRectangle(height[i]),res);\n    }\n    return res;\n}\n\npublic int maxRectangle(int[] height){\n    Deque<Integer> stack=new ArrayDeque<>();\n    int max=0;\n    for(int i=0;i<height.length;i++){\n        while(!stack.isEmpty() && height[i]<height[stack.peek()]){\n            int cur=stack.pop();\n            //栈为空的时候说明左边的全部是比当前栈顶大的元素,可以直接扩展到0,所以这里应该是-1\n            int left=stack.isEmpty()?-1:stack.peek();\n            //left+1 ~ i-1 = i-1-left\n            max=Math.max((i-1-left)*height[cur],max);\n        }\n        stack.push(i);\n    }\n    return max;\n}\n```\n\n其实计算height有一点动态规划的意思，我上面相当于写了个二维的动态规划\n\n> 2020.4.12重写了一遍，然后更新了代码，之前的代码不够简洁\n\n**解法二**\n\n```java\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix==null || matrix.length<=0) {\n        return 0;\n    }\n    //初始化height数组,在末尾添加一个元素(默认0)让所有元素可以出栈\n    int[] height=new int[matrix[0].length+1];\n    int max=0;\n    //记录每一层的height\n    for (int i=0;i<matrix.length;i++) {\n        for (int j=0;j<matrix[0].length;j++) {\n            height[j]=matrix[i][j]=='1'?height[j]+1:0;\n        }\n        max=Math.max(max,maxArea(height));\n    }\n    return max;\n}\n```\n\n`maxArea`可以直接采用上面84题的分治\n\n## [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)\n\n给定一个整数数组，你需要寻找一个**连续的子数组**，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n\n你找到的子数组应是**最短**的，请输出它的长度。\n\n**示例 1:**\n\n```java\n输入: [2, 6, 4, 8, 10, 9, 15]\n输出: 5\n解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n```\n\n**说明 :**\n\n1. 输入的数组长度范围在 [1, 10,000]。\n2. 输入的数组可能包含**重复**元素 ，所以**升序**的意思是**<=。**\n\n**解法一**\n\n~~单调栈的解法明天再写~~\n\n鸽了挺长时间，单调栈的解法还是挺好的\n\n```java\npublic int findUnsortedSubarray(int[] nums) {\n    Stack<Integer> stack=new Stack<>();\n    int left=Integer.MAX_VALUE,right=Integer.MIN_VALUE;\n    for (int i=0;i<nums.length;i++) {\n        while(!stack.isEmpty() && nums[stack.peek()]>nums[i]){\n            left=Math.min(stack.pop(),left); //左边界正确位置(最小值)\n        }\n        stack.push(i);\n    }\n    stack.clear();\n    for (int i=nums.length-1;i>=0;i--) {\n        while(!stack.isEmpty() && nums[stack.peek()]<nums[i]){\n            right=Math.max(stack.pop(),right); //右边界正确位置(最大值)\n        }\n        stack.push(i);\n    }\n    return left>right?0:right-left+1;\n}\n```\n\n第一个单调栈中存的是从左到右递增的序列，当遇到`nums[i]`小于栈顶时，说明这个位置是错位的，正确的位置应该是**栈顶的元素**的位置，我们这里求的就是一个**最小的错位的索引**\n\n第二个单调栈中存的是从右向左递减的序列，当遇到`nums[i]`大于栈顶时，说明这个位置是错位的，正确的位置应该是**栈顶的元素**，这里求的就是一个**最大的错位的索引** ，两者之间的距离其实就是我们最终要求的最短无序子数组长度\n\n**解法二**\n\n其实和上面的单调栈的思路是一样的，都是找第一个（最小）和最后一个（最大）错位的元素，但是这里我们求出错位的元素后还需要再遍历找到原本正确的位置，\n\n```java\n//O(1)空间的解法\npublic int findUnsortedSubarray(int[] nums) {\n    if (nums[0]>nums[nums.length-1]) {\n        return nums.length;\n    }\n    int max=Integer.MIN_VALUE,min=Integer.MAX_VALUE;\n    for (int i=1;i<nums.length;i++) {\n        if (nums[i]<nums[i-1]) {\n            min=Math.min(min,nums[i]); //无序序列中的最小值\n        }\n    }\n\n    for (int i=nums.length-1;i>0;i--) {\n        if (nums[i]<nums[i-1]) {\n            max=Math.max(max,nums[i-1]); //无序序列中的最大值\n        }\n    }\n    int left=0,right=nums.length-1;\n    while(left<nums.length){\n        if (nums[left]>min) {\n            break;\n        }\n        left++; //左边界正确位置\n    }\n    while(right>=0){\n        if (nums[right]<max) {\n            break;\n        }\n        right--; //右边界正确位置\n    }\n    return right<left?0:right-left+1;\n}\n```\n\n## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![rainwatertrap.png](https://i.loli.net/2019/05/14/5cda71129045d93180.png)\n\n\n\n\n上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n**示例:**\n\n```java\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n```\n\n**解法三**\n\n单调栈解法，双指针的解法放在[数组专题](http://imlgw.top/2019/05/04/leetcode-shu-zu/#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4)中，其实我感觉熟悉单调栈的话，单调栈的解法会比其他方法更好理解\n\n```java\npublic static int trap6(int[] height) {\n    if (height == null || height.length == 0) return 0;\n    Deque<Integer> stack = new ArrayDeque<>(); //栈里面维护一个递减序列\n    int res = 0;\n    for (int i = 0; i < height.length; i++){\n        while ( ! stack.isEmpty() && height[stack.peek()] < height[i]) { //当遍历的元素大于栈顶元素\n            int tmp = stack.pop(); //栈顶弹出来\n            if (stack.isEmpty()) break;\n            res += (Math.min(height[i],height[stack.peek()]) - height[tmp]) * (i - stack.peek() - 1);\n        }\n        //维护递减序列\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n单调递减栈，栈中存柱子的索引，当遇到大于栈顶的元素的时候就开始弹栈，计算**栈顶元素和左右首个大于栈顶元素的所能构成的那一层的接水量**，对应下面的图理解就是\n\n**`(Math.min(height[i],height[stack.peek()])-curTop) * (i-stack.peek()-1)`**\n\n![mark](http://static.imlgw.top/blog/20200129/f0b4lo2Xk5Q3.png?imageslim)\n\n依次计算①②③位置的面积，这样的思路感觉会更加的自然\n\n## [面试题33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n\n参考以下这颗二叉搜索树：\n\n```java\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n```\n**示例 1：**\n\n```java\n输入: [1,6,3,2,5]\n输出: false\n```\n\n**示例 2：**\n\n```java\n输入: [1,3,2,6,5]\n输出: true\n```\n\n**提示：**\n\n1. `数组长度 <= 1000`\n\n**解法一**\n\n单调栈的解法\n\n```java\npublic boolean verifyPostorder(int[] postorder) {\n    if(postorder==null || postorder.length<=0) return true;\n    Deque<Integer> stack=new ArrayDeque<>();\n    //1 2 | 4 5 | 3\n    int curRoot=Integer.MAX_VALUE;\n    for(int i=postorder.length-1;i>=0;i--){\n        if(postorder[i]>curRoot){\n            return false;\n        }\n        while(!stack.isEmpty() && postorder[i]<postorder[stack.peek()]){\n            curRoot=postorder[stack.pop()];\n        }\n        stack.push(i);\n    }\n    return true;\n}\n```\n\n逆序遍历这个序列，就是 `root -- root.right -- root.left` ，用一个单调递增栈，当遇到减小的值就说明进入了左子树，我们需要找到这颗树的根节点，也就是不停出栈，直到找到根节点，然后继续向后判断左子树是不是都小于这个根节点的\n\n## [面试题59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。\n\n若队列为空，`pop_front` 和 `max_value` 需要返回 -1\n\n**示例 1：**\n\n```java\n输入: \n[\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"]\n[[],[1],[2],[],[],[]]\n输出: [null,null,null,2,1,2]\n```\n\n**示例 2：**\n\n```java\n输入: \n[\"MaxQueue\",\"pop_front\",\"max_value\"]\n[[],[],[]]\n输出: [null,-1,-1]\n```\n\n**限制：**\n\n- `1 <= push_back,pop_front,max_value的总操作数 <= 10000`\n- `1 <= value <= 10^5`\n\n**解法一**\n\n```java\npublic MaxQueue() {\n\n}\n\nDeque<Integer> queue=new LinkedList<>();\n\nDeque<Integer> maxQueue=new ArrayDeque<>();\n\npublic int max_value() {\n    return maxQueue.isEmpty()?-1:maxQueue.getFirst();\n}\n\npublic void push_back(int value) {\n    queue.addLast(value);\n    while(!maxQueue.isEmpty() && value>maxQueue.getLast()){\n        maxQueue.removeLast();\n    }\n    maxQueue.addLast(value);\n}\n\npublic int pop_front() {\n    if(queue.isEmpty()) return -1;\n    int temp=queue.removeFirst();\n    if(temp==maxQueue.getFirst()){\n        maxQueue.removeFirst();\n    }\n    return temp;\n}\n```\n\n一直以为是和最小栈一样，结果WA了两发才意识到搞错了。。。这里是一个队列，进出方向是不一样的\n\n其实这题和之前的一道 [滑动窗口最大值](http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC) 一样，维护一个单调递减的单调栈然后维护这个单调栈就行了\n\n## [5402. 绝对差不超过限制的最长连续子数组](https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) \n\n给你一个整数数组 `nums` ，和一个表示限制的整数 `limit`，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 `limit` *。*\n\n如果不存在满足条件的子数组，则返回 `0` 。\n\n**示例 1：**\n\n```java\n输入：nums = [8,2,4,7], limit = 4\n输出：2 \n解释：所有子数组如下：\n[8] 最大绝对差 |8-8| = 0 <= 4.\n[8,2] 最大绝对差 |8-2| = 6 > 4. \n[8,2,4] 最大绝对差 |8-2| = 6 > 4.\n[8,2,4,7] 最大绝对差 |8-2| = 6 > 4.\n[2] 最大绝对差 |2-2| = 0 <= 4.\n[2,4] 最大绝对差 |2-4| = 2 <= 4.\n[2,4,7] 最大绝对差 |2-7| = 5 > 4.\n[4] 最大绝对差 |4-4| = 0 <= 4.\n[4,7] 最大绝对差 |4-7| = 3 <= 4.\n[7] 最大绝对差 |7-7| = 0 <= 4. \n因此，满足题意的最长子数组的长度为 2 。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [10,1,2,4,7,2], limit = 5\n输出：4 \n解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。\n```\n\n**示例 3：**\n\n```java\n输入：nums = [4,2,2,2,4,4,2,2], limit = 0\n输出：3\n```\n\n**提示：**\n\n- `1 <= nums.length <= 10^5`\n- `1 <= nums[i] <= 10^9`\n- `0 <= limit <= 10^9`\n\n187th周赛t3，时隔这么久又回头打一次周赛，可惜，又只做了两题，前两题10分钟不到就写完了，心想这回怎么说也得做个3题，结果。。。\n\n**解法一**\n\n```java\npublic int longestSubarray2(int[] nums, int limit) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int left=0,right=0;\n    int min=0,max=0;\n    int res=1;\n    PriorityQueue<Integer> minpq=new PriorityQueue<>();\n    minpq.add(nums[0]);\n    PriorityQueue<Integer> maxpq=new PriorityQueue<>((a,b)->b-a);\n    maxpq.add(nums[0]);\n    //7 2\n    while(left<=right && right<nums.length){\n        while (right< nums.length && maxpq.peek()-minpq.peek()<=limit) {\n            res=Math.max(right-left+1,res);\n            right++;\n            if (right<nums.length) {\n                maxpq.add(nums[right]);\n                minpq.add(nums[right]);   \n            }\n        }\n        maxpq.remove(nums[left]);\n        minpq.remove(nums[left]);\n        left++;\n    }\n    return res;\n}\n```\n这个是当时比赛调了半天没调出来，结束之后调出来的代码，用两优先队列维护区间最值，然后滑窗就行了，我这里就是调滑窗的时候调了半天，之前写滑窗就是乱写的，没什么章法，边WA边改，看来最近得好好总结下滑窗的题了，得搞个板子出来\n\n**解法二**\n\n最优解，O(N)单调队列\n```java\n//UPDATE: 2020/6/29 改成最近总结的for-while滑窗模板\n//上面的解法一的滑窗也写的不好，有时间改改\npublic int longestSubarray(int[] nums, int limit) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int left=0;\n    int min=0,max=0;\n    int res=1;\n    //单调队列记录区间最值索引\n    LinkedList<Integer> maxQue=new LinkedList<>();\n    LinkedList<Integer> minQue=new LinkedList<>();\n    for(int right=0;right<nums.length;right++){\n        while(!maxQue.isEmpty() && nums[maxQue.getLast()]<nums[right]){\n            maxQue.removeLast();\n        }\n        maxQue.addLast(right);\n        while(!minQue.isEmpty() && nums[minQue.getLast()]>nums[right]){\n            minQue.removeLast();\n        }\n        minQue.addLast(right);\n        while(nums[maxQue.getFirst()]-nums[minQue.getFirst()]>limit) {\n            //不符合要求，左边界左移，当左边界是最值的时候que弹出\n            if (left==maxQue.getFirst()) maxQue.removeFirst();\n            if (left==minQue.getFirst()) minQue.removeFirst();\n            left++;\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n其实当时我确实也尝试去用两个单调队列维护最值，但是！！！还是被滑窗的边界给搞得不知道这么写了，然后就没又然后了，上面的代码也是比赛完之后自己写出来的，说到底还是菜啊！😭\n\n## [962. 最大宽度坡](https://leetcode-cn.com/problems/maximum-width-ramp/) \n\n给定一个整数数组 `A`，*坡*是元组 `(i, j)`，其中  `i < j` 且 `A[i] <= A[j]`。这样的坡的宽度为 `j - i`。\n\n找出 `A` 中的坡的最大宽度，如果不存在，返回 0 。\n\n**示例 1：**\n\n```java\n输入：[6,0,8,2,1,5]\n输出：4\n解释：\n最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.\n```\n\n**示例 2：**\n\n```java\n输入：[9,8,1,0,1,9,4,0,4,1]\n输出：7\n解释：\n最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.\n```\n\n**提示：**\n\n1. `2 <= A.length <= 50000`\n2. `0 <= A[i] <= 50000`\n\n**解法一**\n\n想不到，着实想不到，这个单调栈的用法确实没见过\n\n```java\npublic int maxWidthRamp(int[] A) {\n    Deque<Integer> stack=new ArrayDeque<>();\n    int res=0;\n    for(int i=0;i<A.length;i++){\n        if(stack.isEmpty() || A[stack.peek()]>A[i]){\n            stack.push(i);\n        }\n    }\n    for(int i=A.length-1;i>=0;i--){\n        while(!stack.isEmpty() && A[stack.peek()]<=A[i]){\n            int cur=stack.pop();\n            res=Math.max(res,i-cur);\n        }\n    }\n    return res;\n}\n```\n\n首先把A数组中的以`A[0]`开头的递减序列抽取出来，我们最后要求的最大的宽度坡一定是以这个序列中的某一个`i`为**坡底**的，我们反证一下\n\n假设存在某个元素位置`k`不存在于上面的递减序列中，且有最大宽度`j-k`，这也就说明`k`位置的元素**一定是小于等于k前面所有的元素的**，否则就会有更长的宽度，但是既然`k`小于等于前面所有的元素，那么k就一定会被加入到序列中，与假设矛盾，所以不存在k，解一定存在递减序列中\n\n这样的话我们可以逆向遍历数组，每次遇到元素大于栈顶的就可以计算宽度，然后将栈顶弹出，因为是逆序遍历的，所以这个宽度一定是栈顶这个**坡底i**能形成的最大宽度了， 逆序遍历再往前的话即使大于这个栈顶，形成的宽度也只会减小，所以这个栈顶是可以直接`pop`出去的，我们遍历所有的坡底求最大值就行了，时间复杂度`O(N)`\n\n**解法二**\n\n二分的思路，和上面一样，先构建一个以`A[0]`开头的递减序列，这里面就是我们所有的坡底，然后我们可以遍历所有的元素，然后在这个单调序列中寻找第一个小于等于当前元素的`index`，这两个构成的宽度就是**当前元素**所能形成的最大宽度，我们求出所有的最大宽度取一个最值就可以了，时间复杂度`O(NlogN)`\n\n```go\nfunc maxWidthRamp(A []int) int {\n    var order [][]int\n    order = append(order, []int{0, A[0]})\n    //构建递减序列\n    for i := 1; i < len(A); i++ {\n        if A[i] < order[len(order)-1][1] {\n            order = append(order, []int{i, A[i]})\n        }\n    }\n    res := 0\n    for j, target := range A {\n        i := binarySearch(order, target)\n        res = Max(res, j-i)\n    }\n    return res\n}\n\n//找第一个小于等于target的值\nfunc binarySearch(num [][]int, target int) int {\n    left := 0\n    right := len(num) - 1\n    for left < right {\n        mid := left + (right-left)/2\n        if num[mid][1] > target {\n            left = mid + 1 //注意是递减序列\n        } else {\n            right = mid\n        }\n    }\n    return num[left][0]\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n> 在lc写的 [题解](https://leetcode-cn.com/problems/maximum-width-ramp/solution/java-dan-diao-zhan-er-fen-jie-fa-chang-shi-jie-shi/)欢迎前来纠错\n\n## [1124. 表现良好的最长时间段](https://leetcode-cn.com/problems/longest-well-performing-interval/)\n\n给你一份工作时间表 `hours`，上面记录着某一位员工每天的工作小时数。\n\n我们认为当员工一天中的工作小时数大于 `8` 小时的时候，那么这一天就是「**劳累的一天**」。\n\n所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 **大于**「不劳累的天数」。\n\n请你返回「表现良好时间段」的最大长度。\n\n**示例 1：**\n\n```java\n输入：hours = [9,9,6,0,6,6,9]\n输出：3\n解释：最长的表现良好时间段是 [9,9,6]。\n```\n\n**提示：**\n\n- `1 <= hours.length <= 10000`\n- `0 <= hours[i] <= 16`\n\n**解法一**\n\n惭愧，这题还是看的题解，这题还是挺巧妙的，我们把大于8小时的时间段看作`+1`，小于8小时的看作`-1`，这样问题就转换成了求**区间和大于0的最长长度**，而区间和我们又可以联想到用前缀和，这样我们将题目的例子转换一下就变成了\n\n```java\nhours:    9 9  6  0  6  6  9\nhours:  0 1 1 -1 -1 -1 -1  1\n  pre:  0 1 2  1  0 -1 -2 -1\n```\n\n只要`pre`中两点的前缀`pre[j]-pre[i]>0`就说明区间`[i+1，j]`是满足条件的，我们要求的就是满足条件的最长宽度，这样一来问题其实就转换成了和上面[962.最大宽度坡](#962-最大宽度坡)一样了，我们按照上面的步骤求解就ok了\n\n```java\npublic int longestWPI(int[] hours) {\n    int[] pre=new int[hours.length+1];\n    for(int i=1;i<=hours.length;i++){\n        pre[i]=pre[i-1]+(hours[i-1]>8?1:-1);\n    }\n    Deque<Integer> stack=new ArrayDeque<>();\n    for(int i=0;i<pre.length;i++){\n        if(stack.isEmpty() || pre[i]<pre[stack.peek()]){\n            stack.push(i);\n        }\n    }\n    int res=0;\n    for(int i=pre.length-1;i>=0;i--){\n        while(!stack.isEmpty() && pre[i]-pre[stack.peek()]>0){\n            res=Math.max(res,i-stack.pop()); //不用+1\n        }\n    }\n    return res;\n}\n```\n\n## [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)\n\n给定一个整数数组 `A`，找到 `min(B)` 的总和，其中 `B` 的范围为 `A` 的每个（连续）子数组。\n\n由于答案可能很大，因此**返回答案模 10^9 + 7**。\n\n**示例：**\n\n```java\n输入：[3,1,2,4]\n输出：17\n解释：\n子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 \n最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。\n```\n\n**提示：**\n\n1. `1 <= A <= 30000`\n2. `1 <= A[i] <= 30000`\n\n**解法一**\n\n虽然花了挺长时间好歹还是自己做出来了，开心😁\n\n```java\npublic int sumSubarrayMins(int[] A) {\n    Deque<Integer> stack=new ArrayDeque<>();\n    int N=A.length;\n    int mod=(int)1e9+7;\n    int res=0;\n    int[] temp=new int[N+1];\n    System.arraycopy(A,0,temp,0,N);\n    //末尾加0使所有元素都可以出栈\n    temp[N]=0;A=temp; \n    for(int i=0;i<N+1;i++){\n        while(!stack.isEmpty() && A[stack.peek()]>A[i]){\n            int cur=stack.pop();\n            int left=stack.isEmpty()?-1:stack.peek();\n            //右边大于cur的个数(i之前)： i-cur-1      \n            //左边大于cur的个数(left之后)： cur-(left+1) \n            //res=(res+A[cur]*((i-cur-1)*(cur-left-1)+i-1-left))%mod;\n            //(a+1)*(b+1)=ab+a+b+1\n            res=(res+A[cur]*(i-cur)*(cur-left))%mod;\n        }\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n核心思想就是维护单调递增栈，在每个元素出栈的时候考虑如何计算**以该元素为区间最小值**的区间个数\n\n 比如`[9,8,7,6,1,5,3,4,2]`这个区间，我们要求以`1`为区间最小值的区间个数。\n\n我们分开来求，先求左右两边的，很明显仅包含`1`左边或右边元素的子区间个数是4+4=8个，也就是[6,1] , [7,6,1] ...和[1,5], [1,5,3]....这些区间\n\n然后再看同时包含`1`左右两边的元素的子区间，一边选一个区间和另一边都会有4种组合，所以就是4*4=16种\n\n最后再加上`1`本身就行了，所以以`1`为区间最小值的区间个数就是8+16+1=25\n\n> 在看了大佬的做法后发现上面的是可以化简的：`a*b+a+b+1=(a+1)*(b+1)`\n\n\n## [5454. 统计全 1 子矩形](https://leetcode-cn.com/problems/count-submatrices-with-all-ones/)\n\nDifficulty: **中等**\n\n\n给你一个只包含 0 和 1 的 `rows * columns` 矩阵 `mat` ，请你返回有多少个 **子矩形** 的元素全部都是 1 。\n\n**示例 1：**\n\n```\n输入：mat = [[1,0,1],\n            [1,1,0],\n            [1,1,0]]\n输出：13\n解释：\n有 6 个 1x1 的矩形。\n有 2 个 1x2 的矩形。\n有 3 个 2x1 的矩形。\n有 1 个 2x2 的矩形。\n有 1 个 3x1 的矩形。\n矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。\n```\n\n**示例 2：**\n\n```\n输入：mat = [[0,1,1,0],\n            [0,1,1,1],\n            [1,1,1,0]]\n输出：24\n解释：\n有 8 个 1x1 的子矩形。\n有 5 个 1x2 的子矩形。\n有 2 个 1x3 的子矩形。\n有 4 个 2x1 的子矩形。\n有 2 个 2x2 的子矩形。\n有 2 个 3x1 的子矩形。\n有 1 个 3x2 的子矩形。\n矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。\n```\n\n**示例 3：**\n\n```go\n输入：mat = [[1,1,1,1,1,1]]\n输出：21\n```\n\n**示例 4：**\n\n```go\n输入：mat = [[1,0,1],[0,1,0],[1,0,1]]\n输出：5\n```\n\n**提示：**\n\n*   `1 <= rows <= 150`\n*   `1 <= columns <= 150`\n*   `0 <= mat[i][j] <= 1`\n\n**解法一**\n\n196周赛T3，感觉还是挺难的，不过数据量比较小，只有150，所以暴力其实就可以\n\n```java\n//解法一: N3\npublic int numSubmat(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    //预处理mat[i][j]上边有多少个连续的1\n    int[][] upCnt= new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                upCnt[i][j] = i==0 ? mat[i][j]&1 : upCnt[i-1][j]+1;\n            }\n        }\n    }\n    int res = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                int k = j;\n                int rowCnt = upCnt[i][j];\n                while(k>=0){\n                    rowCnt = Math.min(rowCnt, upCnt[i][k]);\n                    res += rowCnt;\n                    k--;\n                }\n            }\n        }\n    }\n    return res;\n}\n```\n\n**解法二**\n\n单调栈，参考了网上的题解，虽然自己搞懂了，但是想写题解的时候感觉有点不好描述啊，要写好多东西，有点抽象，但是思路还是非常好的，也是个很经典的题了\n```java\npublic int numSubmat(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    //预处理mat[i][j]上边有多少个连续的1\n    int[][] upCnt= new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                upCnt[i][j] = i==0 ? mat[i][j]&1 : upCnt[i-1][j]+1;\n            }\n        }\n    }\n    //单调递增栈维护列的长度\n    Deque<Integer> stack = new ArrayDeque<>();\n    int res = 0;\n    for (int i = 0; i < m; i++) {\n        stack.clear();\n        int ijCnt = 0; //以i,j为右下角的矩形的cnt\n        for (int j = 0; j < n; j++) {\n            ijCnt += upCnt[i][j];\n            while(!stack.isEmpty() && upCnt[i][stack.peek()] > upCnt[i][j]){\n                int cur = stack.pop();\n                //栈中的索引是从0开始的，所以这里如果栈为空，left应该为-1\n                int left = stack.isEmpty() ? -1 : stack.peek();\n                //减去多的部分\n                ijCnt -= (cur-left) * (upCnt[i][cur] - upCnt[i][j]);\n            }\n            stack.push(j);\n            res += ijCnt;\n        }\n    }\n    return res;\n}\n```\n为了方便回顾，简单的画了个图\n![mark](http://static.imlgw.top/blog/20200705/BDIQmVW7vEuT.png?imageslim)\n> 这题好像是个很经典的题，我在网上搜索的的时候发现和[ICPC的一道题](https://blog.csdn.net/qq_40774175/article/details/82354072)一样\n\n**解法三**\n\n在刷了几遍评论区，看见了大佬们写的比较好解法，发现了一个比较容易理解的单调栈的思路\n\n（1）第一步预处理和上面是一样的，统计每个元素向上延申的最大值\n（2）然后我们同样使用单调递增栈维护这个高度，但是同时我们额外的维护另一个值：**以当前`mat[i][j]`为右下角所形成的矩形个数也存入单调栈** ，然后我们在每个元素进栈的时候统计个数，统计一共分为两部分：\n\n![mark](http://static.imlgw.top/blog/20200828/x8M127uqudmS.png?imageslim)\n（2020.8.28更新了一下，之前的图有点抽象）\n\n```java\npublic int numSubmat(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    //预处理mat[i][j]上边有多少个连续的1\n    int[][] upCnt= new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if(mat[i][j] == 1){\n                upCnt[i][j] = i==0 ? mat[i][j]&1 : upCnt[i-1][j]+1;\n            }\n        }\n    }\n    //单调递增栈维护列的长度\n    Deque<int[]> stack = new ArrayDeque<>();\n    int res = 0;\n    for(int i = 0;i < m; i++){\n        stack.clear();\n        for (int j = 0; j < n; j++) {\n            while(!stack.isEmpty() && upCnt[i][stack.peek()[0]] > upCnt[i][j]){\n                stack.pop();\n            }\n            int[] pair = stack.isEmpty() ? new int[]{-1,0} : stack.peek();\n            //以当前栈顶元素mat[i][pair[0]]为右下角能形成矩形个数\n            int cur = (j-pair[0]) * upCnt[i][j] + pair[1];\n            res += cur;\n            //将mat[i][j]的索引j和以其为右下角形成的矩阵个数cur也存入单调栈\n            stack.push(new int[]{j, cur});\n        }\n    }\n    return res;\n}\n```\n这个思路比上面要容易理解多了\n\n## [面试题 03.05. 栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)\n\nDifficulty: **中等**\n\n栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。\n\n**示例1:**\n\n```go\n 输入：\n[\"SortedStack\", \"push\", \"push\", \"peek\", \"pop\", \"peek\"]\n[[], [1], [2], [], [], []]\n 输出：\n[null,null,null,1,null,2]\n```\n\n**示例2:**\n\n```go\n 输入： \n[\"SortedStack\", \"pop\", \"pop\", \"push\", \"pop\", \"isEmpty\"]\n[[], [], [], [1], [], []]\n 输出：\n[null,null,null,null,null,true]\n```\n\n**说明:**\n\n1.  栈中的元素数目在[0, 5000]范围内。\n\n\n**解法一**\n\n之前在书上看到过这一题，但是时间久了忘了咋做了，只记得是单调栈，思考了下还是写出来了\n\n单调栈，主栈单调递减（自顶向下），当遇到大于栈顶的元素就弹栈，并将弹出的元素用辅助栈接收，完事了再将元素push进去，最后将辅助栈中的元素再倒回去就ok了，时间复杂度N^2\n```java\nclass SortedStack {\n    \n    Deque<Integer> stack = null;\n    \n    Deque<Integer> help = null;\n    //单调栈排序\n    //4 3 2 1 3 4 2\n    public SortedStack() {\n        stack = new ArrayDeque<>();\n        help = new ArrayDeque<>();\n    }\n    \n    public void push(int val) {\n        //一开始写成pop了找半天的错\n        while(!stack.isEmpty() && stack.peek() < val) {\n            help.push(stack.pop());\n        }\n        stack.push(val);\n        //再装回去\n        while(!help.isEmpty()) {\n            stack.push(help.pop());\n        }\n    }\n    \n    public void pop() {\n        if (!stack.isEmpty()) {\n            stack.pop();\n        }\n    }\n    \n    public int peek() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        return stack.peek();\n    }\n    \n    public boolean isEmpty() {\n        return stack.isEmpty();\n    }\n}\n```\n## [NC580. 抢打出头鸟](https://www.nowcoder.com/practice/1504075c856248748ca444c8c093d638)\n现在有n个人站成一列，第i个人的身高为`a[i]`他们人手一把玩具枪，并且他们喜欢把枪举在头顶上。\n每一次练习射击，他们都会朝正前方发射一发水弹。\n这个时候，第i个人射击的水弹，就会击中在他前面第一个比他高的人。\n牛牛认为这样的练习十分的荒唐，完全就是对长得高的人的伤害。\n于是它定义了一个荒唐度，初始为0。\n对于第i个人，如中他击中了第j个人，则荒唐度加j，如果没有击中任何人，则荒唐度加0.\n牛牛想问你，你能计算出荒唐度是多少吗？\n\n**输入**\n\n一个整数n（1 ≤ n ≤ 10^7），一个数组a (1 ≤ a[i] ≤ 10^7)\na下标从0开始，`a[i]` 代表第i个人身高\n\n**示例1**\n```go\n输入: 5,[1,2,3,4,5]\n输出: 0\n说明: 没有一个人击中任何一个人\n```\n**示例2**\n```go\n输入: 5,[5,4,3,2,1]\n输出: 10\n说明: 第二个人击中第一个人，第三个人击中第二个人，第四个人击中第三个人，第五个人击中第四个人； 1+2+3+4=10\n```\n\n**解法一**\n\n很直白的单调栈，但是一开始被题目的case误导了下，搞了一个单调递增栈，这里很很明显应该是递减栈，递增栈会把原本大的值给pop出去\n```java\n//5 4 3 4 1\n//一开始被例子给误导了，搞了一手单调递增栈....\npublic long solve (int n, int[] a) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    long res = 0l;\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && a[stack.peek()] <= a[i]) {\n            stack.pop();\n        }\n        if (!stack.isEmpty()) {\n            res += stack.peek()+1;\n        }\n        stack.push(i);\n    }\n    return res;\n}\n```","tags":["LeetCode"],"categories":["算法"]},{"title":"Golang踩坑：exec取消后不退出","url":"/2020/08/25/golang-cai-keng-exec-qu-xiao-bu-tui-chu/","content":"\n## 背景\n在做[Scheduler项目](https://github.com/imlgw/scheduler)的过程中利用os/exec包执行一些shell脚本，调试过程中发现我取消了context后go进程仍然阻塞不退出\n## 分析\n> go version go1.13.6 linux/amd64\n\n在实现kill强杀功能时候发现的问题，无法杀死任务，即使kill了还是会等到任务执行完才会返回，在查资料的过程中发现这应该也算是golang本身的一个坑了，参考[issue23019](https://github.com/golang/go/issues/23019)\n\n一开始是在Windows平台上运行测试的，以为是平台的原因但是在切换了Linux后问题依然存在，如下poc既可复现\n\n```golang\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os/exec\"\n    \"time\"\n)\n\nfunc main() {\n    ctx, cancelFn := context.WithTimeout(context.Background(), time.Second*5)\n    defer cancelFn()\n    cmd := exec.CommandContext(ctx, \"/bin/bash\", \"-c\", \"sleep 120; echo hello\")\n    output, err := cmd.CombinedOutput()\n    fmt.Printf(\"output：【%s】err:【%s】\", string(output), err)\n}\n```\n在linux平台上通过go run执行上面的代码，然后`pstree -p`查看进程树\n```golang\n//由于进程树比较庞大，所以省略了一些无关的部分\nsystemd(1)─┬─...\n           ├─sshd(17395)─┬─sshd(18450)───sftp-server(18453)\n           │             ├─sshd(28684)───zsh(28687)───go(2661)─┬─demo3_cmdPit(2680)─┬─bash(2683)───sleep(2684)\n           │             │                                     │                    ├─{demo3_cmdPit}(2681)\n           │             │                                     │                    ├─{demo3_cmdPit}(2682)\n           │             │                                     │                    └─{demo3_cmdPit}(2686)\n           │             │                                     ├─{go}(2662)\n           │             │                                     ├─{go}(2663)\n           │             │                                     ├─{go}(2664)\n           │             │                                     ├─{go}(2665)\n           │             │                                     ├─{go}(2672)\n           │             │                                     ├─{go}(2679)\n           │             │                                     └─{go}(2685)\n           │             └─sshd(29042)───zsh(29044)───pstree(2688)\n```\n可以看到这里我们的go进程`demo3_cmdPit(2680)`创建了`bash(2683)`进程去执行具体的shell指令，但是这里由于我们执行的命令是【`sleep 50; echo hello`】属于一组多条命令，所以这里shell会fork出子进程去执行这些命令，所以上面显示`sleep(2684)`是`bash(2683)`的子进程\n>补充：除了多条命令会产生子进程外，还有一些情况会产生子进程，比如`&`后台运行，`pipe`管道，外部shell脚本等等，具体可以参考这篇文章[子shell以及什么时候进入子shell](https://www.cnblogs.com/f-ck-need-u/p/7446194.html)\n\n然后再5s后ctx到期cancel后我们再次查看进程树\n```golang\nsystemd(1)─┬─...\n           ├─sleep(2684)\n           ├─sshd(17395)─┬─sshd(18450)───sftp-server(18453)\n           │             ├─sshd(28684)───zsh(28687)───go(2661)─┬─demo3_cmdPit(2680)─┬─{demo3_cmdPit}(2681)\n           │             │                                     │                    ├─{demo3_cmdPit}(2682)\n           │             │                                     │                    └─{demo3_cmdPit}(2686)\n           │             │                                     ├─{go}(2662)\n           │             │                                     ├─{go}(2663)\n           │             │                                     ├─{go}(2664)\n           │             │                                     ├─{go}(2665)\n           │             │                                     ├─{go}(2672)\n           │             │                                     ├─{go}(2679)\n           │             │                                     └─{go}(2685)\n           │             └─sshd(29042)───zsh(29044)───pstree(2708)\n```\n可以看到`bash(2683)`进程确实被kill了，但是它的子进程确并没有结束，而是变成了**孤儿进程**，被`init 1(systemd)`收养，但是我们看到这时进程`demo3_cmdPit(2680)`还没有退出，符合之前的预测，这里该进程仍然还有3条线程（协程）没有退出，直到sleep命令执行完才会返回，这里通过pstack是无法查看这几条线程的堆栈的，因为操作系统并不认识协程，而且G会在P上切换，所以我们暂时也不知道这几条线程在干嘛\n\n>孤儿进程：父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。\n>\n>僵尸进程：父进程使用fork创建子进程，如果子进程退出，而父进程并没有调用`wait`或`waitpid`获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。\n\n当sleep执行完成后，程序会正常返回如下信息\n```go\noutput：【】err:【signal: killed】#\n```\n因为是在Linux环境下没有IDE而且不太熟悉`gdb`所以这里我们用`pprof`查看了一下堆栈\n```golang\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n    _ \"net/http/pprof\"\n    \"os/exec\"\n    \"time\"\n)\n\nfunc main() {\n    go func() {\n        err := http.ListenAndServe(\":6060\", nil)\n        if err != nil {\n            fmt.Printf(\"failed to start pprof monitor:%s\", err)\n        }\n    }()\n    ctx, cancelFn := context.WithTimeout(context.Background(), time.Second*5)\n    defer cancelFn()\n    cmd := exec.CommandContext(ctx, \"/bin/bash\", \"-c\", \"sleep 50; echo hello\")\n    output, err := cmd.CombinedOutput()\n    fmt.Printf(\"output：【%s】err:【%s】\", string(output), err)\n}\n```\n> 后面了解到其实直接发送`SIGQUIT`信号也可以看到堆栈，如 `kill -SIGQUIT <pid>`，go的工具链还是非常完善的，除了这些还有很多方法看堆栈\n\n\n```go\ncurl http://127.0.0.1:6060/debug/pprof/goroutine\\?debug\\=2\n...\ngoroutine 1 [chan receive]:\nos/exec.(*Cmd).Wait(0xc000098580, 0x0, 0x0)\n        /usr/lib/golang/src/os/exec/exec.go:509 +0x125\nos/exec.(*Cmd).Run(0xc000098580, 0xc00006d710, 0xc000098580)\n        /usr/lib/golang/src/os/exec/exec.go:341 +0x5c\nos/exec.(*Cmd).CombinedOutput(0xc000098580, 0x9, 0xc0000bff30, 0x2, 0x2, 0xc000098580)\n        /usr/lib/golang/src/os/exec/exec.go:561 +0x91\nmain.main()\n\t\t/usr/local/gotest/cmd/demo3_cmdPit/main.go:22 +0x176\n...\ngoroutine 9 [IO wait]:\ninternal/poll.runtime_pollWait(0x7fa96a0f5f08, 0x72, 0xffffffffffffffff)\n        /usr/lib/golang/src/runtime/netpoll.go:184 +0x55\ninternal/poll.(*pollDesc).wait(0xc000058678, 0x72, 0x201, 0x200, 0xffffffffffffffff)\n        /usr/lib/golang/src/internal/poll/fd_poll_runtime.go:87 +0x45\ninternal/poll.(*pollDesc).waitRead(...)\n        /usr/lib/golang/src/internal/poll/fd_poll_runtime.go:92\ninternal/poll.(*FD).Read(0xc000058660, 0xc0000e2000, 0x200, 0x200, 0x0, 0x0, 0x0)\n        /usr/lib/golang/src/internal/poll/fd_unix.go:169 +0x1cf\nos.(*File).read(...)\n        /usr/lib/golang/src/os/file_unix.go:259\nos.(*File).Read(0xc000010088, 0xc0000e2000, 0x200, 0x200, 0x7fa96a0f5ff8, 0x0, 0xc000039ea0)\n        /usr/lib/golang/src/os/file.go:116 +0x71\nbytes.(*Buffer).ReadFrom(0xc00006d710, 0x8b6120, 0xc000010088, 0x7fa96a0f5ff8, 0xc00006d710, 0x1)\n        /usr/lib/golang/src/bytes/buffer.go:204 +0xb4\nio.copyBuffer(0x8b5a20, 0xc00006d710, 0x8b6120, 0xc000010088, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)\n        /usr/lib/golang/src/io/io.go:388 +0x2ed\nio.Copy(...)\n        /usr/lib/golang/src/io/io.go:364\nos/exec.(*Cmd).writerDescriptor.func1(0x0, 0x0)\n        /usr/lib/golang/src/os/exec/exec.go:311 +0x63\nos/exec.(*Cmd).Start.func1(0xc000098580, 0xc00000e3a0)\n        /usr/lib/golang/src/os/exec/exec.go:435 +0x27\ncreated by os/exec.(*Cmd).Start\n        /usr/lib/golang/src/os/exec/exec.go:434 +0x608\n```\n这里我忽略了一些无关的协程，留下了这两条的堆栈信息\n\n首先我们看一下第一条的堆栈信息，很明显这条就是我们的主`goroutine`，可以看到它正处于`[chan receive]`状态，也就是在等待某个chan传递信息，根据堆栈信息可以看到问题出在\n\n `/usr/lib/golang/src/os/exec/exec.go:509`\n\n我们去看一下这里发生了什么\n\n![mark](http://static.imlgw.top/blog/20200821/l2wEHHBXyTTh.png?imageslim)\n果然这里在等待`c.errch`，那么这个errch是谁负责推送的呢？\n\n我们再来看看另一条`goroutine`，这条`goroutine`处于`【IO wait】`状态，说明IO发生阻塞了，我们从下往上看堆栈，首先看一下是在哪里启动了这个协程\n```go\ncreated by os/exec.(*Cmd).Start\n        /usr/lib/golang/src/os/exec/exec.go:434 +0x608\n```\n![mark](http://static.imlgw.top/blog/20200822/sh8qmlcDeD64.png?imageslim)\n可以看到这个协程的作用就是向我们上面的主`goroutine`在等待的`c.errch`推送消息，那么这里`fn()`为什么没有返回呢？这个fn是在干嘛？继续翻一翻源码，发现这些函数`fn()`是在cmd.Start的时候创建的，用于处理shell的标准输入，输出和错误输出，而我们的程序就是卡在了这里，继续跟进上面的堆栈信息\n```go\nos/exec.(*Cmd).writerDescriptor.func1(0x0, 0x0)\n        /usr/lib/golang/src/os/exec/exec.go:311 +0x63\n```\n![mark](http://static.imlgw.top/blog/20200826/Boqz6oWej6HA.png?imageslim)\n可以看到这里就是具体协程执行的任务，这里有一个IO操作，可想而知程序就是阻塞在了这里，再往下分析就是内部epoll的代码了，就不往下了，我们分析下这段代码的意义，首先创建了管道`Pipe`，然后在协程中将读端`pr`的数据copy到`w`中，很明显这里就是`goroutine`通过pipe读取子进程的输出，但是由于某些原因`Pipe`阻塞了，无法从读端获取数据\n\n我们用`lsof -p`看一下该进程打开的资源\n```go\n$ lsof -p 27301\nCOMMAND   PID USER   FD      TYPE    DEVICE SIZE/OFF      NODE NAME\nmain    27301 root  cwd       DIR     253,1     4096   1323417 /usr/local/gotest/cmd/demo3_cmdPit\nmain    27301 root  rtd       DIR     253,1     4096         2 /\nmain    27301 root  txt       REG     253,1  7647232    401334 /tmp/go-build043247660/b001/exe/main\nmain    27301 root  mem       REG     253,1  2151672   1050229 /usr/lib64/libc-2.17.so\nmain    27301 root  mem       REG     253,1   141968   1050255 /usr/lib64/libpthread-2.17.so\nmain    27301 root  mem       REG     253,1   163400   1050214 /usr/lib64/ld-2.17.so\nmain    27301 root    0u      CHR     136,0      0t0         3 /dev/pts/0\nmain    27301 root    1u      CHR     136,0      0t0         3 /dev/pts/0\nmain    27301 root    2u      CHR     136,0      0t0         3 /dev/pts/0\nmain    27301 root    3u     IPv6 170355813      0t0       TCP *:6060 (LISTEN)\nmain    27301 root    4u  a_inode      0,10        0      5074 [eventpoll]\nmain    27301 root    5r     FIFO       0,9      0t0 170355794 pipe\n```\n可以看到确实打开了一个inode为170355794的管道，结合前面的分析，我们的shell在执行的时候`fork()`创建了子进程，但是kill的时候只kill了shell进程，而在`fork()`的时候会同时将当前进程的`pipe`的`fd[2]`描述符也复制过去，这就造成了`pipe`的写入端`fd[1]`被子进程继续持有（文件表引用计数不为0），而`goroutine`也会继续等待pipe写入端写入或者关闭，直到`sleep 50`执行完后才返回\n## 原因总结\n`golang`的`os/exec`包在和shell做交互的时候会和shell之间建立pipe，用于输入输出，获取shell返回值，但是在某些情况下，我们的shell会fork出子进程去执行命令，比如多条语句，&后台执行，sh脚本等，然而这里ctx过期后，仅仅kill了shell进程，并没有kill它所创建的子进程，这就导致了pipe的fd仍然被子进程持有无法关闭，而在`os/exec`的实现中`goroutine`会一直等待pipe关闭后才返回，进而导致了该问题的产生\n## 解决方案\n问题搞清楚了，就好解决了。在go的实现中只kill了shell进程，并不会kill子进程，进而引发了上面的问题\n```golang\n// Kill causes the Process to exit immediately. Kill does not wait until\n// the Process has actually exited. This only kills the Process itself,\n// not any other processes it may have started.\nfunc (p *Process) Kill() error {\n\treturn p.kill()\n}\n```\n这里我们可以通过kill`进程组`的方式来解决，所谓进程组也就是父进程和其创建的子进程的集合，`PGID`就是进程组的ID，每个进程组都有进程组ID，这里我们可以通过`ps -axjf`命令查看一下\n```go\nPPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND\n17395 20937 20937 20937 ?           -1 Ss       0   0:00  \\_ sshd: root@pts/0\n20937 20939 20939 20939 pts/0    25879 Ss       0   0:00  |   \\_ -zsh\n20939 25879 25879 20939 pts/0    25879 Sl+      0   0:00  |       \\_ go run main.go\n25879 25902 25879 20939 pts/0    25879 Sl+      0   0:00  |           \\_ /tmp/go-build486839449/b001/exe/main\n25902 25906 25879 20939 pts/0    25879 S+       0   0:00  |               \\_ /bin/bash -c sleep 50; echo hello\n25906 25907 25879 20939 pts/0    25879 S+       0   0:00  |                   \\_ sleep 50\n```\n在知道`PGID`后可以根据这个ID直接Kill掉所有相关的进程，但是这里注意看上面，我们的`Shell`进程和它的子进程，以及我们`go进程`都是在一个进程组内的，直接kill会把我们的go进程也杀死，所以这里我们要让`Shell`进程和它的子进程额外开辟一个新的进程组，然后再kill\n\n> 下面的代码中使用到了一些`syscall`包的方法，这个包的实现平台之间是有差异的，下面的代码只适用于Linux环境下\n\n```golang\nfunc RunCmd(ctx context.Context, cmd *exec.Cmd) ([]byte, error) {\n    var (\n        b   bytes.Buffer\n        err error\n    )\n    //开辟新的线程组（Linux平台特有的属性）\n    cmd.SysProcAttr = &syscall.SysProcAttr{\n        Setpgid: true, //使得Shell进程开辟新的PGID,即Shell进程的PID,它后面创建的所有子进程都属于该进程组\n    }\n    cmd.Stdout = &b\n    cmd.Stderr = &b\n    if err = cmd.Start(); err != nil {\n        return nil, err\n    }\n    var finish = make(chan struct{})\n    defer close(finish)\n    go func() {\n        select {\n        case <-ctx.Done(): //超时/被cancel 结束\n            //kill -(-PGID)杀死整个进程组\n            syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)\n        case <-finish: //正常结束\n        }\n    }()\n    //wait等待goroutine执行完，然后释放FD资源\n    //这个时候再kill掉shell进程就不会再等待了，会直接返回\n    if err = cmd.Wait(); err != nil {\n        return nil, err\n    }\n    return b.Bytes(), err\n}\n```\n**效果演示**\n![mark](http://static.imlgw.top/blog/20200825/gfz2xQ7nnKKg.gif)","tags":["开源项目","Golang"],"categories":["踩坑记录"]},{"title":"LeetCode位运算","url":"/2020/07/03/leetcode-wei-yun-suan/","content":"\n> 从[数组专题](http://imlgw.top/2019/05/04/leetcode-shu-zu/)抽离出来的，时间就不做矫正了，我也不知道啥时候开始做的\n\n##  _LeetCode二进制_\n\n## [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n给定一个**非空整数**数组，除了某个元素只出现一次以外，**其余每个元素均出现两次**。找出那个只出现了一次的元素。\n\n**说明：**\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**示例 1:**\n\n```java\n输入: [2,2,1]\n输出: 1\n```\n\n\n**示例 2:**\n\n```java\n输入: [4,1,2,1,2]\n输出: 4\n```\n\n**解法一**\n\n很可惜，想到了位运算，但是没试，瞄了一眼评论区，看见异或两个字马上就滚回来写了这个😂\n\n```java\npublic int singleNumber(int[] nums) {\n    for(int i=1;i<nums.length;i++){\n        nums[i]^=nums[i-1];\n    }\n    return nums[nums.length-1];\n}\n```\n## [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。\n\n**示例 :**\n\n```java\n输入: [1,2,1,3,2,5]\n输出: [3,5]\n```\n\n\n**注意：**\n\n1. 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。\n2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？\n\n**解法一**\n\n根据异或的结果`xor`，讲整个数组划分为两组，分别包含a，b这两个唯一的元素\n\n```java\npublic int[] singleNumber(int[] nums) {\n    if(nums==null || nums.length<=0) return new int[0];\n    int xor=nums[0];\n    for (int i=1;i<nums.length;i++) {\n        xor^=nums[i];\n    }\n    int index=0; //ab二进制不同的index\n    while((xor&1)==0){\n        xor>>>=1;\n        index++;\n    }\n    //a,b在index位置的二进制位不同，异或结果为1，然后我们就可以根据这个不同点，将整个数组按照这个划分为两部分\n    //这样相同的数肯定会被分配到同一组，问题就转换成了136，这样我们再分别异或就能得到最终的a,b\n    int a=0,b=0;\n    for (int i=0;i<nums.length;i++) {\n        if(((nums[i]>>>index)&1)==1){ //根据index位置的元素0，1来划分为两个数组\n            a^=nums[i];\n        }else{\n            b^=nums[i];\n        }\n    }\n    return new int[]{a,b};\n}\n```\n> 为啥没有 只出现一次的数字Ⅱ？ 别问，问就是不会🤣\n>\n\n## [268. 缺失数字](https://leetcode-cn.com/problems/missing-number/)\n\n给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。\n\n**示例 1:**\n\n```java\n输入: [3,0,1]\n输出: 2\n```\n\n**示例 2:**\n\n```java\n输入: [9,6,4,2,3,5,7,0,1]\n输出: 8\n```\n\n**说明:**\n你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?\n\n**解法一**\n\n比较直接的思路，求全序列的和然后相减就ok\n\n```java\npublic int missingNumber(int[] nums) {\n    int N=nums.length;\n    int sum=0;\n    for (int i=0;i<N;i++) {\n        sum+=nums[i];\n    }\n    return N*(N+1)/2-sum; //可能会溢出\n}\n```\n**解法二**\n\n位运算，异或，和上面一样的思路\n\n```java\npublic int missingNumber(int[] nums) {\n    int res=0;\n    //3 0 1 \n    for (int i=0;i<nums.length;i++) {\n        res^=nums[i];\n        res^=i;\n    }\n    //3^0^1^0^1^2^3=2\n    return res^nums.length;\n}\n```\n异或每个数和下标索引，结果就是缺失的数，因为缺失的只有一个，这样就和上面那一题一样了\n\n## [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n\n**注意：**\n`0 ≤ x, y < 2^31.`\n\n**示例:**\n\n```java\n输入: x = 1, y = 4\n\n输出: 2\n\n解释:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n```\n\n**解法一**\n\n```java\npublic int hammingDistance(int x, int y) {\n    int i=x^y;\n    int count=0;\n    while(i!=0){\n        if ((i&1)==1) { //括号不能掉\n            count++;\n        }\n        i=i>>1;\n    }\n    return count;\n}\n```\n\n一行`Integer.bitCount(x^y)`\n\n## [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)\n\n编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）\n\n**示例 1：**\n\n```java\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n```\n\n\n**示例 2：**\n\n```java\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n```\n\n\n**示例 3：**\n\n```java\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n```\n\n**提示：**\n\n- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n**进阶:**\n如果多次调用这个函数，你将如何优化你的算法？ \n\n**解法一**\n\n比较精妙的解法，`n&(n-1)` 就是将二进制最右边的1变为0，这样逐步的&最后数组就会变为0，我们统计下次数就是1的数量\n\n```java\npublic int hammingWeight(int n) {\n    int count=0;\n    while(n!=0){\n        //while(n>0){\n        n&=(n-1);\n        count++;\n    }\n    return count;\n}\n```\n\n**解法二**\n\n移位操作，相比上面会慢一些，没有那么精妙\n\n```java\npublic int hammingWeight(int n) {\n    int count=0;\n    while(n!=0){\n        if((n&1)==1)//判断末位是不是1\n            count++;\n        n>>>=1; //无符号右移,避免添高位添1死循环\n    }\n    return count;\n}\n```\n\n> 注意右移的操作，都需要使用无符号右移，不然负数右移高位补1后就错了\n\n## [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)\n\n给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n\n**示例 1:**\n\n```java\n输入: 2\n输出: [0,1,1]\n```\n\n\n**示例 2:**\n\n```java\n输入: 5\n输出: [0,1,1,2,1,2]\n```\n\n\n**进阶:**\n\n- 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？\n- 要求算法的空间复杂度为O(n)。\n- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 \n\n**解法一**\n\n这样的题肯定是直接上进阶的啦，有动态规划的意思\n\n```java\npublic int[] countBits(int num) {\n    int[] res=new int[num+1];\n    for (int i=1;i<=num;i++) {\n        //如果i二进制以0结尾,那么i>>1的countBit和i一样,i&1=0（>>1就是/2）\n        //反之,那么i>>1的比i会少1个,i&1=1\n        res[i]=res[i>>1]+(i&1); //注意括号\n    }\n    return res;\n}\n```\n\n**解法二**\n\n和上面类似，不过手法有点不一样\n\n```java\npublic int[] countBits(int num) {\n    int[] res=new int[num+1];\n    for (int i=1;i<=num;i++) {\n        //i&(i-1)会去掉最右边的1\n        res[i]=res[i&(i-1)]+1;\n    }\n    return res;\n}\n```\n\n## [231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\n**示例 1:**\n\n```java\n输入: 1\n输出: true\n解释: 20 = 1\n```\n\n\n**示例 2:**\n\n```java\n输入: 16\n输出: true\n解释: 24 = 16\n```\n\n\n**示例 3:**\n\n```java\n输入: 218\n输出: false\n```\n\n**解法一**\n\n应该是最快AC的题吧hahaha\n\n```java\npublic boolean isPowerOfTwo(int n) {\n    return n>0 && (n&(n-1))==0;\n}\n```\n\n## [458. 可怜的小猪](https://leetcode-cn.com/problems/poor-pigs/)\n\n有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。\n\n问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？\n\n回答这个问题，并为下列的进阶问题编写一个通用算法。\n\n**进阶:**\n\n假设有 `n` 只水桶，猪饮水中毒后会在 `m` 分钟内死亡，你需要多少猪（`x`）就能在 `p` 分钟内找出 “**有毒**” 水桶？这 `n` 只水桶里有且仅有一只有毒的桶。\n\n**提示：**\n\n1. 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。\n2. 小猪喝完水后，必须有 *m* 分钟的**冷却时间**。在这段时间里，只允许观察，而不允许继续饮水。\n3. 任何给定的桶都可以无限次采样（无限数量的猪）。\n\n**解法一**\n\n[参考题解区](https://leetcode-cn.com/problems/poor-pigs/solution/hua-jie-suan-fa-458-ke-lian-de-xiao-zhu-by-guanpen/) 我就不搬运了，简单来说就是看每个小猪能表示几进制的状态，比如题目中说的是15分钟死亡，一个小时时间，那么每只小猪可以吃4次药，可以检测出5瓶药，所以`x`只猪就能检测`state^x`个桶\n\n```java\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int state=minutesToTest/minutesToDie+1;\n    return (int)Math.ceil(Math.log(buckets)/Math.log(state));\n}\n```\n\n具体的做法：x只🐖，每只🐖都和对应......\n\n> 两只猪二维的表格可以解决，三只猪三维的坐标可以解决，如果是4只猪，5只猪呢？具体的如何测量，这里我还没有点没想清楚😐\n\n## [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)\n\n**不使用**运算符 `+` 和 `-` ，计算两整数 `a` 、`b` 之和。\n\n**示例 1:**\n\n```java\n输入: a = 1, b = 2\n输出: 3\n```\n\n**示例 2:**\n\n```java\n输入: a = -2, b = 3\n输出: 1\n```\n\n**解法一**\n\n两数之和 = 两数不进位和+两数进位和 ，一开始也没搞懂这个式子，后来在10进制上想了下就明白了\n\n比如 998 + 99 = 987+110 = 97 + 1000 = 1097 ，其实就是把加法拆开来看，把进位的数和对应的数位和分开计算，而进位的数和两数的不进位和都可以通过位运算算出来，进而不使用`+/-`计算两数之和\n\n```go\nfunc getSum(a int, b int) int {\n    if b==0{\n        return a\n    }\n    //a^b:不进位和 a&b<<1: 进位数和(进位是进到前一位，所以需要左移，类比十进制就清楚了)\n    return getSum(a^b,(a&b)<<1) \n}\n```\n\n## [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)\n\nDifficulty: **简单**\n\n\n颠倒给定的 32 位无符号整数的二进制位。\n\n**示例 1：**\n\n```\n输入: 00000010100101000001111010011100\n输出: 00111001011110000010100101000000\n解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n```\n\n**示例 2：**\n\n```\n输入：11111111111111111111111111111101\n输出：10111111111111111111111111111111\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n```\n\n**提示：**\n\n*   请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n*   在 Java 中，编译器使用记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。\n\n**进阶**:  \n如果多次调用这个函数，你将如何优化你的算法？\n\n\n**解法一**\n\n利用移位运算从后往前计算二进制的值就可以了\n```java\npublic int reverseBits(int n) {\n    int res = 0;\n    int count = 32;\n    while(n != 0){ //Java中没有无符号数，所以这里不能写大于0\n        //Java移位运算优先级低于+-\n        res = (res << 1) + (n & 1);\n        n >>>= 1; //无符号右移，避免高位补1\n        count--;\n    }\n    while(count > 0){\n        res <<= 1;\n        count--;\n    }\n    return res;\n}\n```\n上面的解法还是不够简洁，第二个循环没有必要，不过中间有几个小知识点挺有意思的，回顾了下\n\n**解法二**\n\n简洁的解法\n```golang\nfunc reverseBits(num uint32) uint32 {\n    var res uint32 = 0\n    for i := 32; i > 0; i-- {\n        //go中移位运算符优先级高于于+-\n        res = (res << 1) + (num & 1)\n        num >>= 1\n    }\n    return res\n}\n```\n> golang和java的位运算优先级居然不一样，一开始写的go，该成java的时候发现不对，调试了下才发现😂，所以任何时候能加括号的尽量加括号，即使你知道不加也可以，最好还是要加上括号！！！\n\n## [201. 数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)\n\nDifficulty: **中等**\n\n\n给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。\n\n**示例 1:**\n\n```golang\n输入: [5,7]\n输出: 4\n```\n\n**示例 2:**\n\n```golang\n输入: [0,1]\n输出: 0\n```\n\n**解法一**\n最长公共前缀\n```golang\n//最长公共前缀\n//1011 011 m\n//1011 100\n//1011 101\n//1011 110 n\nfunc rangeBitwiseAnd(m int, n int) int {\n    var tlen = 0\n    for m != n {\n        m >>= 1\n        n >>= 1\n        tlen++\n    }\n    return m << tlen\n}\n```\n**解法二**\n```golang\nfunc rangeBitwiseAnd(m int, n int) int {\n    for n > m {\n        n &= (n-1)\n    }\n    return n\n}\n```\n\n## [1018. 可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/)\n\nDifficulty: **简单**\n\n\n给定由若干 `0` 和 `1` 组成的数组 `A`。我们定义 `N_i`：从 `A[0]` 到 `A[i]` 的第 `i` 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。\n\n返回布尔值列表 `answer`，只有当 `N_i` 可以被 `5` 整除时，答案 `answer[i]` 为 `true`，否则为 `false`。\n\n\n**示例 1：**\n\n```c\n输入：[0,1,1]\n输出：[true,false,false]\n解释：\n输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。\n```\n\n**示例 2：**\n\n```c\n输入：[1,1,1]\n输出：[false,false,false]\n```\n\n**示例 3：**\n\n```c\n输入：[0,1,1,1,1,1]\n输出：[true,false,false,false,true,false]\n```\n\n**示例 4：**\n\n```c\n输入：[1,1,1,0,1]\n输出：[false,false,false,false,false]\n```\n\n**提示：**\n\n1.  1 <= A.length <= 30000\n2.  `A[i]` 为 `0` 或 `1`\n\n\n\n**解法一**\n\n一开始没考虑溢出的问题，用的是py所以也没报错，看了评论区才意识到会有溢出的问题，不过这里也很好处理，因为我们每次都只需要知道这个值模5的值就行了，所以我们只需要保留当前值模5的余数就行了\n$$\n(a * b+c) \\bmod \\ p=((\\underbrace{(a \\bmod \\ p)} * (b \\bmod \\ p))+(c \\bmod p))\\bmod p\n$$\n这里的$a$就是上次计算的结果，根据取模运算的性质，我们只需要保存上次计算的结果模5后的值就行了，这样就能避免溢出的问题\n```python\n​class Solution:\n    def prefixesDivBy5(self, A: List[int]) -> List[bool]:\n        res = []\n        v = 0\n        # 1110(14) --> 11101 (29)\n        for i in range(0, len(A)):\n            v = (v*2 + A[i]) % 5\n            res.append(v==0)\n        return res\n```","tags":["LeetCode","位运算"],"categories":["算法"]},{"title":"Rabin-Karp算法","url":"/2020/07/01/rabinkarp-suan-fa/","content":" > 见到好几次了，感觉不是很难，学一手，本来想详细的写一下完整的Rabin-Karp解析的，但是目前确实时间有点紧，加上自己也没做几题，理解的可能还不到位，等后面有时间再来补吧\n ## [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)\n\nDifficulty: **困难**\n\n\n给出一个字符串 `S`，考虑其所有**重复子串**（`S` 的连续子串，出现两次或多次，可能会有重叠）。\n\n返回**任何**具有最长可能长度的重复子串。（如果 `S` 不含重复子串，那么答案为 `\"\"`。）\n\n**示例 1：**\n\n```\n输入：\"banana\"\n输出：\"ana\"\n```\n\n**示例 2：**\n\n```\n输入：\"abcd\"\n输出：\"\"\n```\n\n**提示：**\n\n1.  `2 <= S.length <= 10^5`\n2.  `S` 由小写英文字母组成。\n\n\n**解法一**\n\n看题解区学习了一下，整体的思路倒是不难，主要就是一个`rolling hash`的过程，然后就是关于MOD的选取，到现在也不是很清楚怎么选MOD。。。\n```java\npublic String longestDupSubstring(String S) {\n    int n = S.length();\n    int [] nums =new int[n];\n    for (int i = 0; i < S.length(); i++) {\n        nums[i] =  S.charAt(i) - 'a';\n    }\n    long MOD =  1L<<32;\n    int B = 26; \n    int left = 1;\n    int right = n - 1;\n    int start = -1, mlen = 0;\n    while (left <= right){\n        int mid = left + (right - left)/2;\n        int temp = RabinKarp(mid, B, nums, MOD);\n        if (temp != -1){\n            if (mid > mlen){\n                mlen = mid;\n                start = temp;\n            }\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return start == -1 ? \"\" : S.substring(start, start + mlen);\n}\n\npublic int RabinKarp(int len, int B, int[] nums, long MOD){\n    //hash(S) = s[0] * B^(len-1) + s[1] * B^(len-2) + ... + s[n-1] *1\n    //B^(len-1) (移除左端点时需要的值)\n    long BL = 1;\n    for (int i = 0; i < len - 1; i++){\n        BL = (BL * B) % MOD;\n    }\n    //[0,len-1]的hash值\n    long h = 0;\n    for (int i = 0; i < len; i++){\n        h = (h * B + nums[i]) % MOD;\n    }\n    HashSet<Long> set = new HashSet<>();\n    set.add(h);\n    //rolling hash\n    for (int i = 1; i <= nums.length - len; i++){\n        //+MOD是为了负数取模\n        h = (h - nums[i - 1] * BL % MOD + MOD) % MOD;\n        h = (h * B + nums[i + len - 1]) % MOD;\n        if (set.contains(h)){\n            return i;\n        }\n        set.add(h);\n    }\n    return -1;\n}\n```\n\n**解法二**\n\n补充一下冲突检测，猜mod也太玄学了😂\n> 这个冲突检测的方法有问题，留下做个印证，正确的检测请直接看 解法三\n\n```java\n//写一波检测冲突的\npublic String longestDupSubstring(String S) {\n    int n = S.length();\n    long MOD = (long) 1e9+7;\n    int B = 26; \n    int left = 1;\n    int right = n - 1;\n    int start = -1, mlen = 0;\n    while (left <= right){\n        int mid = left + (right - left)/2;\n        int temp = RabinKarp(mid, B, S, MOD);\n        if (temp != -1){\n            if (mid > mlen){\n                mlen = mid;\n                start = temp;\n            }\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return start == -1 ? \"\" : S.substring(start, start + mlen);\n}\n\npublic int RabinKarp(int len, int B, String S, long MOD){\n    //hash(S) = s[0] * B^(len-1) + s[1] * B^(len-2) + ... + s[n-1] *1\n    //B^(len-1) (移除左端点时需要的值)\n    long BL = 1;\n    for (int i = 0; i < len - 1; i++){\n        BL = (BL * B) % MOD;\n    }\n    //[0,len-1]的hash值\n    long h = 0;\n    for (int i = 0; i < len; i++){\n        h = (h * B + S.charAt(i) - 'a') % MOD;\n    }\n    //这里肯定不能直接存字符串做冲突检测，太大了会MLE\n    //存一个起始地址就可以了len已知\n    HashMap<Long,Integer> map = new HashMap<>();\n    map.put(h, 0);\n    //rolling hash\n    for (int i = 1; i <= S.length() - len; i++){\n        //+MOD是为了负数取模\n        h = (h - (S.charAt(i-1) - 'a') * BL % MOD + MOD) % MOD;\n        h = (h * B + (S.charAt(len + i -1) - 'a')) % MOD;\n        Integer start = map.get(h);\n        if (start != null && S.substring(start, start + len).equals(S.substring(i, i + len))){\n            return i;\n        }\n        map.put(h, i);\n    }\n    return -1;\n}\n```\n\n> 关于这个冲突检测有一个小问题，我尝试减小了`MOD`的大小，比如101，这样计算出来的结果在数据量较大的就不对了，得到的字符虽然确实是重复了，但是并不是最长的，按道理写了冲突检测后即使我MOD取1应该都是可以找出来的啊？======>\n> 在写上面这段话的时候突然想明白了，因为`MOD`取的太小，导致冲突的概率大大增加，而这里我做冲突检测的时候只保存了一个值，也就是说会有很多值被舍弃掉，也许你舍弃的值可能恰好就是最后的答案，字符越长，发生这种情况的概率就越高，所以说我这里冲突检测做的并不完全，能过也纯属运气，正确的冲突检测应该保存一个`List`链表，然后在发生冲突的时候在List中找有没有和当前字符相等的，这样一来，时间复杂度就会上去（其实这个过程就是设计Hash表的过程，链地址法解决冲突）\n\n**解法三**\n\n下面的应该就没什么问题了，链地址法，时间复杂度会增大，耗时增加到了500ms+，但是确保了100%的正确率，这是值得的，这次把mod调小也不会出错了（但是可能会TLE，冲突变大了），总体来说，这几番折腾收获还是挺大的，好事还是要多磨啊\n```java\n//再写一波检测冲突。。。\n//上面的写的有问题，检测不完全\npublic String longestDupSubstring(String S) {\n    int n = S.length();\n    long MOD = (long) 1e9+7;\n    int B = 26; \n    int left = 1;\n    int right = n - 1;\n    int start = -1, mlen = 0;\n    while (left <= right){\n        int mid = left + (right - left)/2;\n        int temp = RabinKarp(mid, B, S, MOD);\n        if (temp != -1){\n            if (mid > mlen){\n                mlen = mid;\n                start = temp;\n            }\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return start == -1 ? \"\" : S.substring(start, start + mlen);\n}\n\npublic int RabinKarp(int len, int B, String S, long MOD){\n    //hash(S) = s[0] * B^(len-1) + s[1] * B^(len-2) + ... + s[n-1] *1\n    //B^(len-1) (移除左端点时需要的值)\n    long BL = 1;\n    for (int i = 0; i < len - 1; i++){\n        BL = (BL * B) % MOD;\n    }\n    //[0,len-1]的hash值\n    long h = 0;\n    for (int i = 0; i < len; i++){\n        h = (h * B + S.charAt(i) - 'a') % MOD;\n    }\n    //这里肯定不能直接存字符串做冲突检测，太大了会MLE\n    //存一个起始地址就可以了len已知\n    HashMap<Long,List<Integer>> map = new HashMap<>();\n    map.put(h, new ArrayList(){{add(0);}});\n    //rolling hash\n    for (int i = 1; i <= S.length() - len; i++){\n        //+MOD是为了负数取模\n        h = (h - (S.charAt(i-1) - 'a') * BL % MOD + MOD) % MOD;\n        h = (h * B + (S.charAt(len + i -1) - 'a')) % MOD;\n        List<Integer> starts = map.get(h);\n        if (check(starts, i, S, len)){\n            return i;\n        }\n        if (starts == null){\n            List<Integer> lis = new ArrayList<>();\n            lis.add(i);\n            map.put(h, lis);\n        }else{\n            starts.add(i);\n        }\n    }\n    return -1;\n}\n\npublic boolean check(List<Integer> starts, int i, String s, int len){\n    if(starts == null || starts.size() <= 0){\n        return false;\n    }\n    for (int left : starts) {\n        if(s.substring(left, left + len).equals(s.substring(i, i + len))){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n\n## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n**示例 1:**\n\n```java\n输入:\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n输出: 3\n解释: \n长度最长的公共子数组是 [3, 2, 1]。\n```\n\n**说明:**\n\n1. 1 <= len(A), len(B) <= 1000\n2. 0 <= A[i], B[i] < 100\n\n**解法一**\n\ndp的解法是O(N^2)的，略显暴力，动态规划的解法放在[dp专题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84)中，这里要介绍的是二分+字符串Hash的`O(NlogN)`的解法\n\n这里直接莽过了，且效率极高（16ms），就不写冲突检测了\n```java\npublic int findLength(int[] A, int[] B) {\n    int lenA = A.length, lenB = B.length;\n    int left = 1;\n    int right = Math.min(lenA, lenB);\n    int res = 0;\n    while (left <= right){\n        int mid = left +(right - left) / 2;\n        if(RabinKarp(A, B, mid)){\n            res = Math.max(res, mid);\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n\npublic boolean RabinKarp(int[] A,int[] B, int L){\n    int MOD = (int) 1e9+7, BASE = 101;\n    long BL = 1;\n    for(int i = 0; i < L-1; i++){\n        BL = (BL * BASE) % MOD;\n    }\n    //hash(A[0,L-1]),hash(B[0,L-1])\n    long hA = 0, hB = 0;\n    for(int i = 0; i < L; i++){\n        hA = (hA * BASE + A[i]) % MOD;\n        hB = (hB * BASE + B[i]) % MOD;\n    }\n    HashSet<Long> set =new HashSet<>();\n    set.add(hA);\n    //rolling hash A\n    for(int i = 1; i <= A.length - L; i++){\n        hA = (hA - A[i-1] * BL % MOD + MOD) % MOD;\n        hA = (hA * BASE + A[L + i -1]) % MOD;\n        set.add(hA);\n    }\n    if(set.contains(hB)) return true;\n    //rolling hash B\n    for(int i = 1; i <= B.length - L; i++){\n        hB = (hB - B[i-1] * BL % MOD + MOD) % MOD;\n        hB = (hB * BASE + B[L + i -1]) % MOD;\n        //这里还可以做一下冲突检测，set中需要多存一些信息\n        if(set.contains(hB)){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## [面试题 17.13. 恢复空格](https://leetcode-cn.com/problems/re-space-lcci/)\n\nDifficulty: **中等**\n\n哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子`\"I reset the computer. It still didn’t boot!\"`已经变成了`\"iresetthecomputeritstilldidntboot\"`。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典`dictionary`，不过，有些词没在词典里。假设文章用`sentence`表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n\n**注意:** 本题相对原题稍作改动，只需返回未识别的字符数\n\n**示例：**\n\n```go\n输入：\ndictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\nsentence = \"jesslookedjustliketimherbrother\"\n输出： 7\n解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。\n```\n\n**提示：**\n\n*   `0 <= len(sentence) <= 1000`\n*   `dictionary`中总字符数不超过 150000。\n*   你可以认为`dictionary`和`sentence`中只包含小写字母。\n\n\n**解法一**\n\n动态规划和Trie的解法左转[动态规划](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/)专题，这里记录下字符串Hash的做法，其实字符串Hash的做法相比字典树的做法会慢一点点，不过思路还是很值得学习的\n\n这里看官方题解又学到了一点东西，这里在计算hash的时候加了一个1，这样我猜测就是为了避免0的出现，使得后面的base失效，使得冲突的概率变大，比如`aba`和`ba`可能就会被判成一样的字符，我下面的做法没有做减`a`的操作，而是取了更大的BASE，这里就不写冲突检测了，可以直接莽过，上面的第一题确实太离谱了，不按照官方题解的数据来就过不了\n```java\npublic int respace(String[] dictionary, String s) {\n    int BASE = 131;\n    long MOD = Integer.MAX_VALUE;\n    HashSet<Long> set = new HashSet<>();\n    for (String word : dictionary ) {\n        set.add(hash(word, BASE, MOD));\n    }\n    int n = s.length();\n    int[] dp = new int[n+1];\n    for (int i = 1; i <=n ; i++) {\n        dp[i] = dp[i-1] + 1;\n        long rollhash = 0;\n        for (int j = i; j >= 1; j--) {\n            rollhash = (rollhash * BASE + s.charAt(j-1)) % MOD;\n            if(set.contains(rollhash)){\n                //注意这里是dp[j-1]，对应s.charAt(j-1)的前一个字符\n                dp[i] = Math.min(dp[i], dp[j-1]);\n            }\n            if(dp[i] == 0){\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\n//注意需要逆向hash，上面计算的时候是j--，是逆向的\npublic long hash(String s, int BASE, long MOD){\n    long h = 0;\n    for (int i = s.length()-1; i >=0 ; i--) {\n        h = (h * BASE + s.charAt(i)) % MOD;\n    }\n    return h;\n}\n```\n> 这个解法也用到了Hash表，但是相比用Hash表存字符，存数字的时间复杂度会低很多，其实字符串Hash也就是为了避免在Hash表中存大量的字符，一来空间占用会非常大，二来对于字符串来说计算字符的`hashCode()`的时间复杂度也是O(N)不可忽略的，而数字长度固定，`hashCode()`直接返回值就行了\n\n## [1316. 不同的循环子字符串](https://leetcode-cn.com/problems/distinct-echo-substrings/)\n\nDifficulty: **困难**\n\n\n给你一个字符串 `text` ，请你返回满足下述条件的 **不同** 非空子字符串的数目：\n\n*   可以写成某个字符串与其自身相连接的形式（即，可以写为 `a + a`，其中 `a` 是某个字符串）。\n\n例如，`abcabc` 就是 `abc` 和它自身连接形成的。\n\n**示例 1：**\n\n```go\n输入：text = \"abcabcabc\"\n输出：3\n解释：3 个子字符串分别为 \"abcabc\"，\"bcabca\" 和 \"cabcab\" 。\n```\n\n**示例 2：**\n\n```go\n输入：text = \"leetcodeleetcode\"\n输出：2\n解释：2 个子字符串为 \"ee\" 和 \"leetcodeleetcode\" 。\n```\n\n**提示：**\n\n*   `1 <= text.length <= 2000`\n*   `text` 只包含小写英文字母。\n\n\n**解法一**\n\n哭了，看着KMP的tag进来的，结果发现KMP的不太会写，学习了题解的前缀和Hash的思路，还是有点收获\n```java\nint BASE = 131;\n\nlong MOD = (long)1e9+7;\n\npublic int distinctEchoSubstrings(String s) {\n    int n = s.length();\n    //前缀hash和(前i个元素的hash值)\n    long[] hashSum = new long[n+1];\n    //BASE的所有幂乘\n    long[] pow = new long[n+1];\n    pow[0] = 1;\n    hashSum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        hashSum[i] = (hashSum[i-1]*BASE + s.charAt(i-1)) % MOD;\n        pow[i] = (pow[i-1]*BASE) % MOD;\n    }\n    HashSet<Long> set = new HashSet<>();\n    //枚举所有偶数长度的子串\n    for (int len = 2; len <= n; len+=2) {\n        for (int i = 0 ; i+len-1 < n; i++) {\n            int j = i + len - 1; //右边界\n            int mid = i + (j-i)/2; //中点\n            //0,3\n            long hleft = getHash(hashSum, pow, s, i, mid);\n            long hright = getHash(hashSum, pow, s, mid+1, j);\n            if(hleft == hright && !set.contains(hleft)){\n                set.add(hleft);\n            }\n        }\n    }\n    return set.size();\n}\n\n// 求s[i,j]区间的哈希值: s[i]*B^j-i + s[i+1]*B^j-i-1 + ... + s[j]\n// \n// hashSum[i] = s[0]*B^i-1 + s[1]*B^i-2 +...+ s[i-1]\n// hashSum[j+1] = s[0]*B^j + s[1]*B^j-1 +...+ s[j]\n// hashSum[i]*B^j-i+1 = s[0]*B^j + s[1]*B^j-1 +...+ s[i-1]*B^j-i+1\n// hash[i,j] = hashSum[j+1] - hashSum[i] * B^j-i+1\n//           = s[i]*B^j-i + s[i+1]*B^j-i-1 +...+s[j]\npublic long getHash(long[] hashSum, long[] pow, String s, int i, int j){\n    //j-i+1是[i,j]区间的长度，包含i和j，而hashSum[k]是不包含k的\n    //所以这里需要转换下，j需要+1使得hashSum包含j\n    return (hashSum[j+1] - (hashSum[i] * pow[j-i+1]) % MOD + MOD) % MOD;\n}\n```\n\n**解法二**\n\nKMP的做法肯定就是参考KMP的[459. 重复的子字符串](http://imlgw.top/2020/05/13/kmp-suan-fa/#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2)的做法，我看了外网的discuss，只看见了一个这样写的，而且看不太懂，我自己尝试了下，感觉好多地方都会有坑，主要就是去重很麻烦，代码如下\n\n下面为错误解法，无法通过OJ，懒得改了，感觉不是个很好的做法\n```java\n//KMP的做法\npublic int distinctEchoSubstrings(String s) {\n    for (int i = 0; i < s.length(); i++) {\n        getNext(s.substring(i));\n    }\n    return set.size();\n}\n\nHashSet<String> set = new HashSet<>();\n\npublic void getNext(String s){\n    if(s.length() < 2){\n        return;\n    }\n    int n = s.length();\n    int[] next = new int[n+1];\n    next[0] = -1;\n    next[1] = 0;\n    int left = 0, right = 2;\n    while(right <= n){\n        if(s.charAt(left) == s.charAt(right-1)){\n            left++;\n            next[right] = left;\n            int replen = right-next[right];\n            String rs = s.substring(0,replen);\n            if (right%2==0 && replen!=right && right%replen==0 && !set.contains(rs)) {\n                set.add(rs);\n            }\n            right++;\n        }else if(next[left] == -1){\n            right++;\n        }else{\n            left = next[left];\n        }\n    }\n}\n```","tags":["数据结构","算法"],"categories":["算法"]},{"title":"Linux磁盘与文件系统","url":"/2020/06/20/linux-ci-pan-yu-wen-jian-xi-tong/","content":"\n> 要点摘抄，全文摘抄自《鸟叔的Linux私房菜》，对小部分词语进行转换，对部分内容进行批注，方便以后查阅\n\n## Linux磁盘与文件系统\n- 一个可以被挂载的数据通常称为 “ 文件系统 , filesystem” 而不是分区 （ partition ） \n- 基本上 `Linux` 的传统文件系统为 Ext2 ，该文件系统内的信息主要有：\n  - `superblock` ：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；\n  - `inode` ：记录文件的属性，一个文件占用一个 inode ，同时记录此文件的数据所在的 block 号码；\n  - `block` ：实际记录文件的内容，若文件太大时，会占用多个 block 。\n- `Ext2` 文件系统的数据存取为**索引式文件系统**（ `indexed allocation` ）每个文件由一个inode和多个block组成，与之对应的是FAT，FAT这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中，是一种链表的结构，磁盘重组也主要是针对的这种文件系统\n- 需要**磁盘重组**的原因就是文件写入的 block 太过于离散了，我们的磁头将无法在磁盘转一圈就读到所有的数据，因此磁盘就会多转好几圈才能完整的读取到这个文件的内容此时文件读取的性能将会变的很差所致。 这个时候可以通过磁盘重组将同一个文件所属的 blocks 汇整在一起。\n- Ext2 文件系统主要有： boot sector, superblock, `inode bitmap`, `block bitmap`, `inode table`,`data block `等六大部分。\n- data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已\n- inode 记录文件的属性 / 权限等数据，其他重要项目为： 每个 inode 大小均为固定，有 128/256Bytes 两种基本容量。每个文件都仅会占用\n  一个 inode 而已； 因此文件系统能够创建的文件数量与 inode 的数量有关；\n  ![NMhIY9.png](https://s1.ax1x.com/2020/06/20/NMhIY9.png)\n  > inode 要记录的数据非常多，但偏偏又只有 128Bytes 而已， 而inode 记录一个 block 号码要花掉 4Byte ，假设我一个文件有 400MB 且每个 block 为 4K 时， 那么至少也要十万笔 block 号码的记录 inode哪有这么多可记录的信息？为此我们的系统很聪明的将 inode 记录 block 号码的区域定义为 12 个直接，一个间接 , 一个双间接与一个三间接记录区。（双间接，三间接其实就是多级指针，inode指向block，block又指向另一个block）\n- 文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录下面文件名与其 inode 号码的对照表；\n- 日志式文件系统 （ `journal` ） 会多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；（ext2之后的ext3,4支持）\n    1. 预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；\n    2. 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；\n    3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。\n  > 这种方式在很多的应用软件中也有类似的体现，比如`mysql`的`redo log`，`redis`的`aof`\n- Linux 文件系统为增加性能，会让内存作为大量的磁盘高速缓存；（这里看了原文也不是很懂，这里意思应该是让内存作为磁盘的缓存，也就是数据不直接写入磁盘，先写入内存，再同步到磁盘）\n  - 系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读 / 写；\n  - 承上，因此 Linux 的实体内存最后都会被用光！这是正常的情况！可加速系统性能；\n  - 你可以手动使用 `sync` 来强迫内存中设置为 Dirty 的文件回写到磁盘中；\n  - 若正常关机时，关机指令会主动调用 `sync` 来将内存的数据回写入磁盘内；\n  - 但若不正常关机（如跳电、死机或其他不明原因），由于数据尚未回写到磁盘内， 因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损毁）。\n- 实体链接只是多了一个文件名对该 `inode` 号码的链接而已(ln)\n  ![UTOOLS1592753917172.png](https://upload.cc/i1/2020/06/21/xuFwlq.png)\n- 符号链接就类似 Windows 的捷径功能。(ln -s)\n  ![UTOOLS1592753775172.png](https://upload.cc/i1/2020/06/21/qmB46s.png)\n- 磁盘的使用必需要经过：分区、格式化与挂载，分别惯用的指令为： gdisk, mkfs, mount 三个指令\n- 分区时，应使用 parted 检查分区表格式，再判断使用 fdisk/gdisk 来分区，或直接使用 parted 分区\n- 为了考虑性能， XFS 文件系统格式化时，可以考虑加上 agcount/su/sw/extsize 等参数较佳\n- 如果磁盘已无未分区的容量，可以考虑使用大型文件取代磁盘设备的处理方式，通过 dd 与格式化功能。\n- 挂载点的意义：每个 filesystem 都有独立的 inode / block / superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。 将文件系统与目录树结合的动作我们称为 “ 挂载 ” 。 重点是：挂载点一定是目录，该目录为进入该文件系统的入口。因此并不是你有任何文件系统都能使用，必须要 “ 挂载 ” 到目录树的某个目录后，才能够使用该文件系统的。\n  - 单一文件系统不应该被重复挂载在不同的挂载点（目录）中；\n  - 单一目录不应该重复挂载多个文件系统；\n  - 要作为挂载点的目录，理论上应该都是空目录才是。\n  - 挂载了文件系统之后，原目录下的东西就会暂时的消失\n- 开机自动挂载可参考 /etc/fstab 之设置，设置完毕务必使用 mount -a 测试语法正确否；","tags":["Linux","操作系统","读书笔记"],"categories":["Linux"]},{"title":"Gacache分布式缓存","url":"/2020/06/02/gacache-fen-bu-shi-huan-cun/","content":"\n## TOC\n\n\n- [TOC](#toc)\n- [简介](#简介)\n- [整体流程](#整体流程)\n- [LRU队列](#lru队列)\n- [并发控制](#并发控制)\n- [一致性Hash](#一致性hash)\n  - [实现](#实现)\n- [分布式节点通信](#分布式节点通信)\n  - [Client端](#client端)\n  - [Server端](#server端)\n- [缓存击穿](#缓存击穿)\n  - [复现](#复现)\n  - [解决方案](#解决方案)\n  - [测试](#测试)\n- [热点互备](#热点互备)\n  - [思路](#思路)\n  - [测试](#测试-1)\n- [缓存穿透](#缓存穿透)\n  - [复现](#复现-1)\n  - [解决方案](#解决方案-1)\n- [TODO](#todo)\n\n\n## 简介\n\n本项目是模仿[groupcache](https://github.com/golang/groupcache)实现的一个分布式缓存库，其可以作为单独服务部署，亦可以作为一个`lib`来用，使用一致性Hash进行节点的选取和数据的分片，节点之间采用http协议进行通信，使用[Protobuf](https://github.com/protocolbuffers/protobuf)序列化数据进行传输，提高传输效率，节点之间支持热点数据互备，减少网络开销，同时还实现了并发访问控制机制，防止缓存击穿，相比于原项目，对热点互备的功能进行了增强\n\n> 本项目为练手项目，不可用于生产\n\n## 整体流程\n\n![mark](http://static.imlgw.top/blog/20200602/Glc7aMrySiqF.png?imageslim)\n\n## LRU队列\n\n因为缓存的数据都是在内存中的，内存资源是有限的，所以我们需要选择一种合适的策略，在内存快要满的时候剔除部分数据，这里选择了较为平衡且实现简单的方案LRU（最近最少使用）可以参考我之前的一篇博文 [LRU队列的实现（Java）](http://imlgw.top/2019/11/16/lrucache/) 这里为了方便，以及避免重复造轮子，直接使用`container` 包中的`List`双向链表和`map`来实现，具体代码见 [gacache/lru/lru.go](https://github.com/imlgw/gacache/blob/master/gacache/lru/lru.go)\n\n## 并发控制\n\ngolang中的map并不是并发安全的容器，并发的访问可能会出现错误，所以我们需要加锁来控制并发的读写\n\n```go\ntype cache struct {\n    mu         sync.Mutex //互斥锁\n    lru        *lru.Cache\n    cacheBytes int64\n}\n\nfunc (c *cache) put(key string, value ByteView) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    if c.lru == nil { //尚未初始化,lazyinit\n        c.lru = lru.New(c.cacheBytes, nil)\n    }\n    c.lru.Put(key, value)\n}\n\nfunc (c *cache) get(key string) (value ByteView, ok bool) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    if c.lru == nil {\n        return\n    }\n    if v, ok := c.lru.Get(key); ok {\n        return v.(ByteView), ok\n    }\n    return\n}\n```\n\n## 一致性Hash\n\n对于一个**分布式缓存**来讲，客户端在向某一个节点请求数据的时候，该节点应该如何去获取数据呢？是自己拿，还是去其他节点拿？如果这里不做处理，让当前节点自己去数据源取数据，那么最终可能每个节点都会缓存一份数据源的数据，这样不仅效率低下（需要和DB交互），而且浪费了很多空间，严格来说这就称不上是**分布式缓存**了，只能称之为**缓存集群**\n\n所以我们需要一个方案能够将`key`和节点对应起来，有一种比较简单的方案就是将`key`哈希后对节点数量取余，这样每次请求都会打到同一个节点，但是这样的方案扩展性和容错性比较差，如果节点的数量发生变化可能会导致大量缓存的迁移，一瞬间大量缓存都失效了，这就可能导致缓存雪崩，所以这里我采用**一致性Hash算法**\n\n### 实现\n\n- 构造一个 `0 ~ 2^32-1` 大小的环\n- 服务节点经过 hash 之后将定位到环中\n- 将`key`哈希之后也定位到这个环中\n- 顺时针找到离`hash(key)`最近的一个节点，也就是最终选择的缓存节点\n- 考虑到服务节点的个数以及 hash 算法的问题导致环中的数据分布不均匀时引入了虚拟节点\n\n**一致性Hash的Map**\n\n```go\ntype Map struct {\n    hash     Hash           //hash函数\n    replicas int            //虚拟节点倍数\n    keys     []int          //节点的地址,完整的协议/ip/port [eg. http://localhost:8001]\n    hashMap  map[int]string //虚拟节点和真实节点映射关系\n}\n```\n\n**添加机器/节点的方法**\n\n```go\n//添加机器/节点\nfunc (m *Map) Add(keys ...string) {\n    //hashMap := make(map[string][]int, len(keys))\n    for _, key := range keys {\n        //每台机器copy指定倍数的虚拟节点\n        for i := 0; i < m.replicas; i++ {\n            //计算虚拟节点的 hash值\n            hash := int(m.hash([]byte(strconv.Itoa(i) + key)))\n            //添加到环上\n            m.keys = append(m.keys, hash)\n            //hashMap[key] = append(hashMap[key], hash)\n            //记录映射关系\n            m.hashMap[hash] = key\n        }\n    }\n    //fmt.Println(hashMap)\n    //环上hash值进行排序\n    sort.Ints(m.keys)\n}\n```\n\n**Get获取节点**\n\n因为整个环是有序的，所以可以直接通过二分去找第一个大于等于`hash(key)`的节点\n\n```go\nfunc (m *Map) Get(key string) string {\n    if len(m.keys) == 0 {\n        return \"\"\n    }\n    hash := int(m.hash([]byte(key)))\n    //二分找第一个大于等于hash的节点idx\n    idx := sort.Search(len(m.keys), func(i int) bool {\n        return m.keys[i] >= hash\n    })\n    return m.hashMap[m.keys[idx%len(m.keys)]]\n}\n```\n\n## 分布式节点通信\n\n集群之间的通信通过Http协议，同时采用[Protobuf](https://github.com/protocolbuffers/protobuf)序列化数据提高传输效率\n\n### Client端\n\n通过节点地址和`groupName`以及`key`构成的地址请求数据，通过`protobuf`解码数据\n\n```go\nfunc (h *httpGetter) Get(in *pb.Request, out *pb.Response) error {\n    u := fmt.Sprintf(\n        \"%v%v/%v\",\n        h.baseURL,\n        url.QueryEscape(in.GetGroup()),\n        url.QueryEscape(in.GetKey()),\n    )\n    //通过http请求远程节点的数据\n    res, err := http.Get(u)\n    if err != nil {\n        return err\n    }\n    defer res.Body.Close()\n    if res.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"server returned: %v\", res.Status)\n    }\n    //转换成[]byte\n    bytes, err := ioutil.ReadAll(res.Body)\n    if err != nil {\n        return fmt.Errorf(\"reading response body: %v\", err)\n    }\n    //解码proto并将结果存到out中\n    if err != proto.Unmarshal(bytes, out) {\n        return fmt.Errorf(\"decoding response body : %v\", err)\n    }\n    return nil\n}\n```\n\n### Server端\n\n实现`http.Handler`接口，对缓存中其他节点暴露地址，提供服务\n\n```go\nfunc (p *HTTPPool) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    if !strings.HasPrefix(req.URL.Path, p.basePath) {\n        panic(\"HTTPPool serving unexpect path\")\n    }\n    p.Log(\"%s %s\", req.Method, req.URL.Path)\n    // basePath/groupName/key\n    // 以‘/’为界限将groupName和key划分为2个part\n    parts := strings.SplitN(req.URL.Path[len(p.basePath):], \"/\", 2)\n    if len(parts) != 2 {\n        http.Error(w, \"bad request\", http.StatusBadRequest)\n        return\n    }\n    groupName := parts[0]\n    key := parts[1]\n    group := GetGroup(groupName)\n    if group == nil {\n        http.Error(w, \"no such group: \"+groupName, http.StatusNotFound)\n        return\n    }\n    view, err := group.Get(key)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    //使用proto编码Http响应\n    body, err := proto.Marshal(&pb.Response{Value: view.ByteSlice()})\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/octet-stream\")\n    w.Write(body)\n}\n```\n\n## 缓存击穿\n\n一个存在的`key`突然失效，在失效的同时有大量的请求来请求这个`key`，这个时候大量请求就会直接打到DB，导致DB压力变大，甚至宕机\n\n### 复现\n\n这里简单的演示缓存击穿的效果，我们用下面的脚本启动4个`cache server` 并且在端口号为`8004`的`server`上启动一个前端服务，用于和客户端交互\n\n```bash\nstart go run .  -port=8001\nstart go run .  -port=8002\nstart go run .  -port=8003\nstart go run .  -port=8004 -api=1\n```\n\n(windows平台的bat，其他平台可以用这个 [test.sh](https://github.com/imlgw/gacache/blob/master/test.sh))\n\n尝试了用window的批处理写并发访问的脚本，但是效果不是很好，所以直接用`go`写了个小脚本测试并发请求\n\n```go\nfunc main() {\n    for i := 0; i < 5; i++ {\n        wg.Add(1)\n        go curl(\"resolmi\")\n    }\n    wg.Wait()\n    fmt.Println(\"Done!\")\n}\n\nfunc curl(key string) {\n    res, _ := http.Get(\"http://localhost:9999/api?key=\" + key)\n    bytes, _ := ioutil.ReadAll(res.Body)\n    fmt.Println(string(bytes))\n    wg.Done()\n}\n```\n\n开启5个`goroutine`，并发的去请求`resolmi`，此时`cache`肯定是没有这个key的，所以需要到DB中去取\n\n然后就可以看到如下的情况：\n\n![mark](http://static.imlgw.top/blog/20200529/pU2omvLdDqyQ.png?imageslim)\n\n前台`Server`收到了Get \"resolmi\"请求，通过一致性Hash选择了远程节点`port:8003`\n\n![mark](http://static.imlgw.top/blog/20200529/uovtpKufQME4.png?imageslim)\n\n可以看到，5次请求全部打到了`SlowDB`中！！这就说明发生了缓存穿透！请求穿过了缓存层，打到DB\n\n> 这里如果效果不明显可以尝试在`load`函数执行前加上一个`time.Sleep`，这样并发缓存击穿效果会更明显\n\n### 解决方案\n\n其实常见的方案就两种：\n\n**1. 缓存永不过期**\n\n缓存值不设置`ttl`，而是在`value`中添加一个逻辑的过期时间，这样请求就不会直接穿透到DB，同时我们可以通过当前时间判断该key是否过期，如果过期了就启动一个异步线程去更新缓存，这种方式用户延迟是最低的，但是可能会造成缓存的不一致\n\n**2. 互斥锁**\n\n在第一个请求获取数据的时候设置一个`mutex`互斥锁，让其他请求阻塞，当前第一个请求请求到数据返回之后释放`mutex`锁，其他请求停止阻塞，然后直接从缓存中获取数据\n\n因为我们的项目本身是不支持`ttl`和删除操作的，所以第一种方案不太适合，所以采用第二种互斥锁的方案，实现了一个`singleflight`结构来处理缓存击穿\n\n**封装请求call**\n\n```go\n//封装每个请求/调用\ntype call struct {\n    wg  sync.WaitGroup\n    val interface{} //请求的值\n    err error       //err\n}\n\n//singleflight核心结构\ntype Group struct {\n    mu sync.Mutex\n    m  map[string]*call //key与call的映射\n}\n```\n\n**并发控制核心代码**\n\n```go\n//并发请求控制\nfunc (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {\n    g.mu.Lock()\n    if g.m == nil {\n        g.m = make(map[string]*call)\n    }\n    if c, ok := g.m[key]; ok {\n        g.mu.Unlock() //释放锁,按顺序进来\n        c.wg.Wait()   //等着,等第一个请求完成\n        return c.val, c.err\n    }\n    c := new(call)\n    c.wg.Add(1)\n    g.m[key] = c\n    g.mu.Unlock()       //这里释放锁，让其他请求进入上面的分支中wait(其实只有并发量大的时候才会进入上面的分支)\n    c.val, c.err = fn() //请求数据\n    c.wg.Done()         //获取到值,第一个请求结束,其他请求可以获取到值了\n    //删除m中的key,避免key发生变化,而取到的还是旧值\n    g.mu.Lock()\n    delete(g.m, key)\n    g.mu.Unlock()\n    return c.val, c.err\n}\n```\n\n当多个并发的请求来请求同一个`key`的时候，只有**第一个请求**能拿到锁去DB中取数据，其他的请求就只能在方法外阻塞，当第一个请求构造好`call`就释放锁，这个时候其他并发的请求获取锁，进入阻塞的分支释放锁，然后再次阻塞，等待**第一个请求**获取到数据并封装进与`key`对应的`call`中，然后直接返回，不再向数据库请求，从而避免了缓存击穿\n\n### 测试\n用`singleFlight`包装一下我们的`load`方法\n\n```go\nview, err := g.loader.Do(key, func() (interface{}, error) {\n    if g.peers != nil {\n        //根据一致性Hash选择节点Peer\n        if peer, ok := g.peers.PickPeer(key); ok {\n            //从上面的Peer中获取数据\n            if value, err = g.getFromPeer(peer, key); err == nil {\n                return value, nil\n            }\n            log.Println(\"[Gacache] Fail to get from remote peer!!!\", err)\n        }\n    }\n    return g.getLocally(key)\n})\n```\n\n再次使用上面同样的脚本进行测试\n\n![mark](http://static.imlgw.top/blog/20200530/OThgxtFJrFIG.png?imageslim)\n\n可以看到5个请求都成功了，我们再看看`log`\n\n![mark](http://static.imlgw.top/blog/20200530/fsgxPPXNeVoo.png?imageslim)\n\n可以看到，我请求了5次，但是实际上`getFromPeer`从远程节点取数据只执行了一次\n\n![mark](http://static.imlgw.top/blog/20200530/ChE0FxjwlYbl.png?imageslim)\n\n从`SlowDB`的查询也只执行了一次，说明我们的`singleFlight`并发控制生效了！\n\n## 热点互备\n\n热点互备也是`groupcache`的特点之一，在源码注释中写到\n\n> hotCache contains keys/values for which this peer is not authoritative (otherwise they would be in **mainCache**), but are popular enough to warrant mirroring in this process to avoid going over the network to fetch from a peer.  Having a hotCache avoids network hotspotting, where a peer's network card could become the bottleneck on a popular key. This cache is used sparingly to maximize the total number of key/value pairs that can be stored globally.\n\n大致意思就是，`hotCache`中存储的主要是该节点没有的键值对（否则就在`mainCache`中了），但是这些键值对请求的非常频繁，所以需要保证在此过程中进行热点备份，避免通过网络从远程节点去获取，`hotCache`避免了网络热点，使节点的网卡成为热点`key`的瓶颈\n\n但是在`groupcache`中对`hotCache`的处理只是随机的存储，每次从远程节点获取数据的时候有1/10的概率存储到`hotCache`中（[code](https://github.com/golang/groupcache/blob/master/groupcache.go#L318)）\n\n![mark](http://static.imlgw.top/blog/20200601/A0oPStJGqht3.png?imageslim)\n\n可以看到这是一个TODO，注释中也提到了可以使用QPS来判断是否是热点`key`，所以我按照这个想法写了一个简单的统计\n\n### 思路\n\n首先我们需要添加一个`hotCache`的结构，这个cache和`mainCache`一样，都是并发安全的`lru`队列，然后我们在向某个节点请求数据的时候就可以先从`mainCache`中请求如果没有就从`hotCache`中请求 ，如下\n\n```go\nfunc (g *Group) Get(key string) (ByteView, error) {\n    if key == \"\" {\n        return ByteView{}, fmt.Errorf(\"key nil\")\n    }\n    if v, ok := g.mainCache.get(key); ok {\n        log.Printf(\"[GaCache (mainCache)] hit\")\n        return v, nil\n    }\n    //add: hotCache\n    if v, ok := g.hotCache.get(key); ok {\n        log.Printf(\"[GaCache (hotCache)] hit\")\n        return v, nil\n    }\n    //当前节点没有数据,去其他地方加载\n    return g.load(key)\n}\n```\n\n然后封装了一个`KeyStats`的结构，用于统计`key`的请求信息\n\n```go\n//Key的统计信息\ntype KeyStats struct {\n    firstGetTime time.Time //第一次请求的时间\n    remoteCnt    AtomicInt //请求的次数（利用atomic包封装的原子类）\n}\n```\n\n除此之外，还需要将`key`和`KeyStats`对应，所以需要在cache的核心结构`Group`中加入映射关系\n\n```go\ntype Group struct {\n    //...\n    keys map[string]*KeyStats\n}\n```\n\n然后在节点请求远程节点的时候统计请求的信息，也就是`getFromPeer`函数中\n\n```go\n//从远程节点获取数据\nfunc (g *Group) getFromPeer(peer PeerGetter, key string) (ByteView, error) {\n    //构建proto的message\n    req := &pb.Request{\n        Group: g.name,\n        Key:   key,\n    }\n    res := &pb.Response{}\n    err := peer.Get(req, res)\n\n    fmt.Println(\"getFromPeer\", key)\n    if err != nil {\n        return ByteView{}, err\n    }\n    //远程获取cnt++\n    if stat, ok := g.keys[key]; ok {\n        stat.remoteCnt.Add(1)\n        //计算QPS\n        interval := float64(time.Now().Unix()-stat.firstGetTime.Unix()) / 60\n        qps := stat.remoteCnt.Get() / int64(math.Max(1, math.Round(interval)))\n        if qps >= maxMinuteRemoteQPS {\n            //存入hotCache\n            g.populateCache(key, ByteView{b: res.Value}, &g.hotCache)\n            //删除映射关系,节省内存\n            mu.Lock()\n            delete(g.keys, key)\n            mu.Unlock()\n        }\n    } else {\n        //第一次获取\n        g.keys[key] = &KeyStats{\n            firstGetTime: time.Now(),\n            remoteCnt:    1,\n        }\n    }\n    return ByteView{b: res.Value}, nil\n}\n```\n\n`maxMinuteRemoteQPS`是一个常量，每个key每分钟远程请求最大的QPS，每次向远程节点请求数据的时候计算当前`key`第一次获取的时间到目前为止的QPS，如果大于阈值`maxMinuteRemoteQPS`，就会将其存入`hotCache`中，之后就可以直接从`hotCache`中获取数据，而不用在通过网络去获取\n\n### 测试\n\n同样使用前面的go脚本来测试\n\n```go\nfunc main() {\n    for i := 0; i < 20; i++ {\n        wg.Add(1)\n        //go curl(\"resolmi\")\n        //i not exist\n        //go curl(strconv.Itoa(i))\n        time.Sleep(500 * time.Millisecond)\n        curl(\"resolmi\")\n    }\n    wg.Wait()\n    fmt.Println(\"Done!\")\n}\n\nfunc curl(key string) {\n    res, _ := http.Get(\"http://localhost:9999/api?key=\" + key)\n    bytes, _ := ioutil.ReadAll(res.Body)\n    fmt.Println(string(bytes))\n    wg.Done()\n}\n```\n\n> 注意这里请求不要请求太快，如果一个key请求的太快会被`singleFlight`并发控制组件拦截，多数请求不会走网络（这个组件作用还是挺大的），所以并没有使用`goroutine`，而是正常的调用，并且中间停顿0.5s\n\n这里为了方便模拟，我设置了 `maxMinuteRemoteQPS = 10` ，上面的脚本一分钟之内会请求`“resolmi”` 20次，这个`key`的分片已知是远程节点（8003）的，所以会在第10次的时候触发`hotCache`，将数据存入当前节点（8004）的`hotCache`中，后续的请求就会直接从`hotCache`中取，如下图所演示\n\n![mark](http://static.imlgw.top/blog/20200602/hKH8u6E1gpcA.gif)\n\n可以看到效果确实达到了，但是这样做有一个比较大的缺点就是内存耗费会比原来大，需要额外维护一个map，不过这部分信息并不大，仅仅需要存储`key`和对应`keyStats` ，key的长度一般不会很长，`keyStats` 的长度是固定的，一个`time`和一个`int64`，所以一定程度上还是可行的。\n\n> 这种方案只是我能想到的一种比较简单的处理方法，肯定会有更好的处理方式。但是截至目前（2020.6.2）`groupcache`中没有对这里进行改进，如果以后有更新可以再学习下\n\n## 缓存穿透\n\n查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB就会导致宕机\n\n### 复现\n\n使用上面的脚本再次启动`Cache Server`，然后用下面的go代码测试\n\n```go\nfunc main() {\n    for i := 0; i < 5; i++ {\n        wg.Add(1)\n        //go curl(\"resolmi\")\n        //i not exist\n        go  curl(strconv.Itoa(i))\n    }\n    wg.Wait()\n    fmt.Println(\"Done!\")\n}\n\nfunc curl(key string) {\n    res, _ := http.Get(\"http://localhost:9999/api?key=\" + key)\n    bytes, _ := ioutil.ReadAll(res.Body)\n    fmt.Println(string(bytes))\n    wg.Done()\n}\n```\n\n> 注意这里需要构造不同的key，相同的key会被前面的`singleFlight`组件拦截\n\n结果如下：\n\n```go\n[ `go run .` | done: 1.8734423s ]\n  1 not exist\n  2 not exist\n  0 not exist\n  4 not exist\n  3 not exist\n  Done!\n```\n\n然后我们看看`Server`的情况\n\n![mark](http://static.imlgw.top/blog/20200531/kV5ojfIeddm4.png?imageslim)\n\n可以看到，5个`key`通过一致性Hash分散到不同的节点，但是由于`DB`中根本就没有这些数据，所以这些数据并不会缓存，每次查询都会到`DB`中去重新查询，如果短时间内有大量请求查询这些根本不存在的数据，那么这些请求都会直接打到DB层，将DB层压垮！\n\n### 解决方案\n\n**1.缓存空对象**\n\n之所以发生缓存穿透，是因为缓存中没有存储这些空数据的key，导致这些请求全都打到数据库上。那么，我们可以稍微修改一下业务层的代码，将数据库查询结果为空的key也存储在缓存中。当后续又出现该key的查询请求时，缓存直接返回null，而无需查询数据库。\n\n**2.布隆过滤器**\n\n当业务层有查询请求的时候，首先去`BloomFilter`中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。\n\n这里第一个种方案可以直接排除，一方面因为我们这个cache是不能删除数据的，只能被动的淘汰数据，缓存大量的空对象且得不到及时的删除会浪费大量内存，另一方面，缓存空对象的做法，如果每次查询的不存在的`key`都不一样，那么这种方案也就起不到作用了\n\n至于第二种方案，可行，但是不应该在缓存层来做，应该在业务层处理，也就是在上层处理，因为这是一个分布式的缓存组件，每个节点的数据都是不一样的，用布隆过滤器你只能判断在**当前节点**有没有，无法判断**远程节点**有没有，所以一开始就要将所有数据预热到布隆过滤器中，但是这样每一个节点都会需要一个布隆过滤器，这样做没有任何意义，所以缓存穿透的问题应该放到应用层去处理\n\n## TODO\n\n- [x] 分布式节点通信\n- [x] 一致性Hash\n- [x] 缓存击穿\n- [x] 热点互备\n- [ ] 配置解耦\n- [ ] 集群管理","tags":["开源项目","Gacache"],"categories":["Web"]},{"title":"Linux文件权限和目录配置","url":"/2020/05/27/linux-de-wen-jian-quan-xian-yu-mu-lu-pei-zhi/","content":"\n> 本文全文摘抄自《鸟叔的LInux私房菜》，对部分用词做了转换，仅保留了我感兴趣的部分，便于以后查找\n\n## Linux文件属性\n\n`ls -al：` ls 是 “list” 的意思，重点在显示文件的文件名与相关属性。而选项 “-al” 则表示列出所有的文件详细的权限与属性 （包含隐藏文件，就是文件名第一个字符为 “ . ” 的文件）\n\n![YIhreU.png](https://s1.ax1x.com/2020/05/19/YIhreU.png)\n\n- 第一栏代表这个文件的类型与权限（ permission ）\n    - 第一个字符代表这个文件是 “ 目录、文件或链接文件等等 ” ：\n      - 当为 `[ d ]` 则是目录，例如上表文件名为 “boot” 的那一行；\n      - 当为 `[ - ]` 则是文件，例如上表文件名为 “.autorelabel” 那一行；\n      - 若是 `[ l ]` 则表示为链接文件（ link file ）；\n      - 若是 `[ b ]` 则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；\n      - 若是 `[ c ]` 则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。\n\n    - 接下来的字符中，以三个为一组，且均为 “`rwx`” 的三个参数的组合。其中， [ r ] 代表可读（ read ）、 [ w ] 代表可写（ write ）、 [ x ] 代表可执行（ execute ）。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 [ - ] 而已。\n\n      - 第一组为 “ 文件拥有者可具备的权限 ” ，以 “.autorelabel” 那个文件为例， 该文件的拥有者可以读-\n\n        写，但不可执行；\n\n      - 第二组为 “ 加入此群组之后帐号的权限 ” ；\n\n      - 第三组为 “ 非本人且没有加入本群组之其他帐号的权限 ” 。\n\n- 第二栏表示有多少文件名链接到此节点（ i-node ）\n\n- 第三栏表示这个文件（或目录）的 “ 拥有者帐号 ”\n\n- 第四栏表示这个文件的所属群组\n\n- 第五栏为这个文件的容量大小，默认单位为 Bytes \n\n- 第六栏为这个文件的创建日期或者是最近的修改日期：\n\n    > 有的年代过于久远的可能只会显示年份，如果想要显示完整的时间格式，可以利用 ls 的选项，亦即： “ls -l --full-time” 就能够显示出完整的时间格式了！包括年、月、日、时间\n\n- 第七栏为这个文件的文件名\n\n  这个字段就是文件名了。比较特殊的是：如果文件名之前多一个 “ . ” ，则代表这个文件为 “ 隐藏文件 ” ，例如上表中的 .autorelabel那一行，该文件就是隐藏文件，使用 `-a`可以查看到\n\n### 改变文件属性\n\n#### 改变所属群组 , chgrp\n\n改变一个文件的群组真是很简单的，直接以 chgrp 来改变即可，咦！这个指令就是 change group 的缩写嘛！这样就很好记了吧！ ^_^ 。不过，请记得，要被改变的群组名称必须要在 /etc/group 文件内存在才行，否则就会显示错误， -R可以递归更改权限\n\n#### 改变文件拥有者 , chown\n\n如何改变一个文件的拥有者呢？很简单呀！既然改变群组是 change group ，那么改变拥有者就是 change owner 啰！ BINGO ！那就是chown 这个指令的用途，要注意的是， 使用者必须是已经存在系统中的帐号，也就是在 /etc/passwd 这个文件中有纪录的使用者名称才能改变。-R可以递归更改权限\n\nchown 还可以顺便直接修改群组的名称 ：“ `chown user.group file`”，亦即在拥有者与群组间加上小数点\n\n> 知道如何改变文件的群组与拥有者了，那么什么时候要使用 chown 或 chgrp 呢？或许你会觉得奇怪吧？ 是的，确实有时候需要变更文件的拥有者的，最常见的例子就是在复制文件给你之外的其他人时，cp复制了文件但是属性并没有变，这个时候别人仍然看不见，所以需要修改文件属性\n\n#### 改变权限 , chmod\n\n- 数字类型改变文件权限\n\n  Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己的 read/write/execute 权限， 先复习一下刚刚上面提到的数据：文件的权限字符为： “-rwxrwxrwx” ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n\n  | r    | 4    |\n  | ---- | ---- |\n  | w    | 2    |\n  | x    | 1    |\n\n  每种身份（ owner/group/others ）各自的三个权限（ r/w/x ）分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：\n  owner = rwx = 4+2+1 = 7\n  group = rwx = 4+2+1 = 7\n  others= --- = 0+0+0 = 0\n  所以等一下我们设置权限的变更时，该文件的权限数字就是 770 啦\n\n  命令：`chmod [-R] xyz 文件或目录`\n\n- 符号类型改变文件权限\n\n  还有一个改变权限的方法呦！从之前的介绍中我们可以发现，基本上就九个权限分别是（ 1 ） user （ 2 ） group （ 3 ） others 三种身份啦！那么我们就可以借由 u, g, o 来代表三种身份的权限！此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成 r, w, x 啰！+ (加入)，-(除去) ，=(设置)\n\n  > '+'与'–'的状态下，只要是没有指定到的项目，则该权限 “ 不会被变动 ” ，而=是直接设置\n\n  命令：`chmod u+x file` ，`chmod u=x,g=rw file`\n\n#### 权限的意义\n\n**文件的权限**\n\n- r （ read ）：可读取此一文件的实际内容，如读取文本文件的文字内容等\n- w （ write ）：可以编辑、新增或者是修改该文件的内容（**但不含删除该文件**）\n- x （ execute ）：该文件具有可以被系统执行的权限\n\n**目录的权限**\n\n- r （ read contents in directory ）：表示具有读取目录结构清单的权限，所以当你具有读取（ r ）一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来\n\n- w （ modify contents of directory ）：这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有改变该目录结构的权限，也就是下面这些权限：创建新的文件与目录；**删除已经存在的文件与目录**（不论该文件的权限为何！）将已存在的文件或目录进行更名；搬移该目录内的文件、目录位置。总之，目录的 w 权限就与该目录下面的文件名改变有关就对了啦！\n\n  > 自己测试了一下，开了w还是不能删也不能加也不能改，实际上这里书上没有介绍清楚，这个w权限只有在x权限打开之后才有用（其实想一下就知道了，如果w有这么多权限，那还要x干嘛）\n\n- x （ access directory ）：能否进入目录（cd）\n\n## FHS\n\n### 根目录 （ / ） 的意义与内容：\n\n因此 FHS 定义出根目录（ / ）下面应该要有下面这些次目录的存在才好，即使没有实体目录， FHS 也希望至少有链接文件存在才好\n**FHS 要求必须要存在的目录**\n\n- `/bin:` 系统有很多放置可执行文件的目录，但 /bin 比较特殊。因为 /bin 放置的是在单人维护模式下还能够被操作的指令。 在 /bin 下面的指令可以被 root 与一般帐号所使用，主要有： cat, chmod, chown, date, mv, mkdir, cp, bash 等等常用的指令。\n- `/boot:` 这个目录主要在放置开机会使用到的文件，包括 Linux 核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel 常用的文件名为： vmlinuz ，如果使用的是 grub2 这个开机管理程序， 则还会存在 /boot/grub2/ 这个目录\n- `/dev:` 在 Linux 系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件，就等于存取某个设备啰～ 比要重要的文件有 /dev/null, /dev/zero, /dev/tty, /dev/loop, /dev/sd 等等\n- `/etc:` 系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码、 各种服务的配置等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有 root 有权力修改。 FHS 建议不要放置可可执行文件（ binary ）在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab等等\n- `/lib:`系统的函数库非常的多，而 /lib 放置的则是在开机时会用到的函数库， 以及在 /bin 或 /sbin 下面的指令会调用的函数库而已。什么是函数库呢？你可以将他想成是 “ 外挂 ” ，某些指令必须要有这些 “ 外挂 ” 才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在：/lib/modules/ ：这个目录主要放置可抽换式的核心相关模块（驱动程序）喔！\n- `/media: `media 是 “ 媒体 ” 的英文，顾名思义，这个 /media 下面放置的就是可移除的设备啦！ 包括软盘、光盘、 DVD 等等设备都暂时挂载于此。常见的文件名有： /media/floppy, /media/cdrom 等等。\n- `/mnt:` 如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与 /media 相同，只是有了 /media 之后，这个目录就用来暂时挂载用了\n- `/opt:` 这个是给第三方软件放置的目录。什么是第三方软件啊？ 举例来说， KDE 这个桌面管理系统是一个独立的软件，不过他可以安装到 Linux 系统中，因此 KDE 的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的 distribution 提供的），那么也能够将你的软件安装到这里来。 不过，以前的 Linux 系统中，我们还是习惯放置在 /usr/local 目录下\n- `/run:`早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！\n- `/sbin:` Linux 有非常多指令是用来设置系统环境的，这些指令只有 root 才能够利用来 “ 设置 ” 系统，其他使用者最多只能用来 “ 查询 ” 而已。 放在 /sbin 下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到 /usr/sbin/ 当中。至于本机自行安装的软件所产生的系统可执行文件（ system binary ）， 则放置到 /usr/local/sbin/ 当中了。常见的指令包括： fdisk, fsck, ifconfig, mkfs 等等。\n- `/srv:` srv 可以视为 “service” 的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如 WWW, FTP 等等。举例来说， WWW 服务器需要的网页数据就可以放置在 /srv/www/ 里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。\n- `/tmp:` 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为 FHS 甚至建议在开机时，应该要将 /tmp 下的数据都删除\n\n**FHS 建议可以存在的目录**\n\n- `/home:`这是系统默认的使用者主文件夹（ home directory ）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来。比较重要的是，主文件夹有两种代号喔：\n  ~ ：代表目前这个使用者的主文件夹\n  ~dmtsai ：则代表 dmtsai 的主文件夹！\n- `/root:`系统管理员（ root ）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root 的主文件夹，所以我们会希望 root 的主文件夹与根目录放置在同一个分区中。\n  事实上 FHS 针对根目录所定义的标准就仅有上面的，不过我们的 Linux 下面还有许多目录你也需要了解一下\n- `/lost+found:` 这个目录是使用标准的 ext2/ext3/ext4 文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！\n- `/proc:` 这个目录本身是一个 “ 虚拟文件系统（ virtual filesystem ） ” 喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（ process ）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！\n  比较重要的文件例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。\n- `/sys:` 这个目录其实跟 /proc 非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！\n\n早期 Linux 在设计的时候，若发生问题时，救援模式通常仅挂载根目录而已，因此有五个重要的目录被要求一定要与根目录放置在一起， 那就是 `/etc`, `/bin`, `/dev`, `/lib`, `/sbin` 这五个重要目录。现在许多的 Linux distributions 由于已经将许多非必要的文件移出 /usr 之外了， 所以 /usr 也是越来越精简，同时因为 /usr 被建议为 “ 即使挂载成为只读，系统还是可以正常运行 ” 的模样，所以救援模式也能同时挂载 /usr 喔！ 例如，我们的这个 CentOS 7.x 版本在救援模式的情况下就是这样。因此那个五大目录的限制已经被打破了呦！例如 CentOS 7.x 就已经将 /sbin, /bin,  /lib 通通移动到 /usr 下面了\n\n### /usr 的意义与内容：\n\n​\t依据 FHS 的基本定义， /usr 里面放置的数据属于可分享的与不可变动的（ shareable, static ）， 如果你知道如何通过网络进行分区的挂载（例如在服务器篇会谈到的 NFS 服务器），那么 /usr 确实可以分享给区域网络内的其他主机来使用\n​\t很多读者都会误会 /usr 为 user 的缩写，其实 usr 是 Unix Software Resource 的缩写， 也就是 “Unix 操作系统软件资源 ” 所放置的目录，而不是使用者的数据，这点要注意。 FHS 建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。\n因为是所有系统默认的软件（ distribution 发布者提供的软件）都会放置到 /usr 下面，因此这个目录有点类似 Windows 系统的 “C:\\Windows\\ （当中的一部份） + C:\\Program files\\” 这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说， /usr 的次目录建议有下面这些：\n\n **FHS 要求必须要存在的目录**\n\n- `/usr/bin/:`所有一般用户能够使用的指令都放在这里！目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此！ 也就是说， /usr/bin 与 /bin 是一模一样了！另外， FHS 要求在此目录下不应该有子目录！\n- `/usr/lib/:`  基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！/usr/local/\n  系统管理员在本机自行安装自己下载的软件（非 distribution 默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的 distribution 提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于 /usr/local/ 目录下，可与原先的旧版软件有分别啦！ 你可以自行到 /usr/local 去看看，该目录下也是具有 bin, etc, include,lib... 的次目录喔！\n- `/usr/sbin/:` 非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（ daemon ）啰！不过基本功能与 /sbin也差不多， 因此目前 /sbin 就是链接到此目录中的。\n- `/usr/share/:`主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据，因为几乎都是文字文件\n\n**FHS 建议可以存在的目录**\n\n- `/usr/games/:` 与游戏比较相关的数据放置处\n- `/usr/include/:` c/c++ 等程序语言的文件开始（ header ）与包含档（ include ）放置处，当我们以 tarball 方式 （ *.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！\n- `/usr/libexec/:` 某些不被一般使用者惯用的可执行文件或脚本（ script ）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。\n- `/usr/lib<qual>/` 与 `/lib<qual>/` 功能相同，因此目前 `/lib<qual>` 就是链接到此目录中\n- `/usr/src/:`  一般源代码建议放置到这里， src 有 source 的意思。至于核心源代码则建议放置到 /usr/src/linux/ 目录下\n\n### /var 的意义与内容：\n\n如果 /usr 是安装时会占用较大硬盘容量的目录，那么 /var 就是在系统运行后才会渐渐占用硬盘容量的目录。 因为 /var 目录主要针对常态性变动的文件，包括高速缓存（ cache ）、登录文件（ log file ）以及某些软件运行所产生的文件， 包括程序文件（ lock file, run file ），或者例如MySQL 数据库的文件等等。常见的次目录有：\n\n **FHS 要求必须要存在的目录**\n\n- `/var/cache/:` 应用程序本身运行过程中会产生的一些暂存盘；\n- `/var/lib/:` 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说， MySQL 的数据库放置到 /var/lib/mysql/ 而 rpm 的数据库则放到 /var/lib/rpm 去！\n- `/var/lock/:` 某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（ lock ），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在\n  烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！\n- `/var/log/:` 重要到不行！这是登录文件放置的目录！里面比较重要的文件如 /var/log/messages, /var/log/wtmp （记录登陆者的信息）等。\n- `/var/mail/:` 放置个人电子邮件信箱的目录，不过这个目录也被放置到 /var/spool/mail/ 目录中！ 通常这两个目录是互为链接文件啦！\n- `/var/run/:`某些程序或者是服务启动后，会将他们的 PID 放置在这个目录下喔！至于 PID 的意义我们会在后续章节提到的。 与 /run 相同，这个目录链接到 /run 去了！\n- `/var/spool/:` 这个目录通常放置一些队列数据，所谓的 “ 队列 ” 就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到 /var/spool/mail/ 中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到 /var/spool/mqueue/ 中， 等到被送出后就被删除。如果是工作调度数据（ crontab ），就会被放置\n  到 /var/spool/cron/ 目录中！\n\n## 参考\n\n[FHS3.0](https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf)\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"KMP算法","url":"/2020/05/13/kmp-suan-fa/","content":"\n## 前言\n\n之前大一的时候写过一篇关于KMP的博客，写的也是乱七八糟的，自己看着都费劲，最近看左神的书《程序员代码面试指南》有讲，重新学了一遍，感觉写的还是挺好的，这篇就不从0开始讲解`KMP`了，简单说一些要点，方便以后回顾\n\n> 我记得大一为了搞懂kmp好像花了挺长时间的，网上翻各种博客，搞了大半天吧，结果还是没咋搞清楚，前几天看书大概只花了一个小时左右就都搞清楚了，可能是左神写的比较好吧😂\n\n## next数组是什么？\n\n`kmp`最关键的地方就是这个`next`数组了，`next`数组就是各个子串的前缀后缀最大匹配（相等）长度，具体一点就是`next[i]`代表的就是子串`i`位置前字符（不包括`i`位置）的前后缀最大匹配长度\n\n举个例子： 子串`abababc`  \n\nnext[3] = \"aba\" 的前后缀最大匹配长度 = 1 (开头的a和结尾的a匹配)\n\nnext[6]= \"ababab\" 的前后缀最大匹配长度 = 4 （开头的abab和结尾的abab匹配）\n\n## next数组的作用？\n\n他的作用其实就是在两个字符串比较失配的时候避免目标串回溯，常规的暴力匹配在字符失配的时候就会回退到首字符重新匹配，整体时间复杂度就是`O(m*n)`，而next数组就是为了避免回退，简单举一个例子\n\n![mark](http://static.imlgw.top/blog/20200513/ugvgLhmyaeBr.png?imageslim)\n\n用PPT简单的画了个图（PPT真好用），当匹配到**母串和子串**`index=6`的位置时，发现两者的字符不相同，按照暴力匹配，下一步就是母串回溯到`index=1`也就是b字符位置，子串回溯到首字符，重新开始匹配，直到匹配到子串，或者匹配完母串所有子串，但是当我们有了`next`数组，我们的母串就不必再回退了，而子串也不必再回退到首字符了，图中的黄色下划线和绿色下划线代表的就是**子串index=6**位置前的最长前后缀匹配长度，也就是`ababab`的**最长前后缀匹配字符**，当子串index=6位置的字符匹配不上的时候我们我们就可以直接将`index`跳到`next[6]`，也就是将子串索引移动到index=4的位置，就变成下面这样\n\n![mark](http://static.imlgw.top/blog/20200513/6sBvml0hXrr6.png?imageslim)\n\n母串并没有回退，继续匹配`母串index=6`和子串`index=4`位置的元素，然后重复上面的过程\n\n## 为什么子串可以直接滑动next[i]步？\n\n前面我们知道了如何使用`next`数组，但是为什么子串可以一下子从滑动到`next[i]`位置呢？万一中间有能匹配的字符不就滑过了么？\n\n我们假设在母串中间存在某一个位置能匹配出子串，且该位置在**子串最长匹配后缀之前**，也就是说这部分**比当前的最长前后缀匹配长度还要长**对应到下图就是黑色虚线框框出来的部分\n\n![mark](http://static.imlgw.top/blog/20200513/EbC0E1JvbkHh.png?imageslim)\n\n既然能从这个位置匹配出子串，那么说明我的**子串的前缀**和这一部分相等，同时，由于失配前子串和母串是完全匹配的，所以我**子串的后缀**和这一部分肯定也是相等的，诶？我子串前后缀都和这部分相等，那它肯定是我的匹配前后缀啊，但是这部分又比我的最长前后缀长度要长，是不是矛盾了？所以原假设是不成立的，不存在这样的位置！所以子串可以放心的滑到`next[i]`位置\n\n## next数组如何求？\n\n说了这么多next数组，那么next数组究竟怎么求呢？其实整个的求解过程有点像动态规划，有一些细节需要注意下\n\n> 想起来了再写\n\n## 时间复杂度为什么是线性的？\n\n> 想起来了再写\n\n## 例题\n\n### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)\n\n实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  **-1**。\n\n**示例 1:**\n\n```java\n输入: haystack = \"hello\", needle = \"ll\"\n输出: 2\n```\n\n**示例 2:**\n\n```java\n输入: haystack = \"aaaaa\", needle = \"bba\"\n输出: -1\n```\n\n**说明:**\n\n当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。\n\n**解法一**\n\n标注的是简单，很多人都是直接调的API，但是我感觉没啥意义，所以这题应该直接上kmp\n\n```java\npublic int strStr(String haystack, String needle) {\n    if(needle==null || needle.length()<=0) return 0;\n    if(haystack==null ||haystack.length()<=0) return -1;\n    int[] next=getNext(needle);\n    int tidx=0,sidx=0;\n    while (sidx<haystack.length() && tidx<needle.length()) {\n        if(needle.charAt(tidx) == haystack.charAt(sidx)){\n            tidx++;sidx++;\n            if(tidx==needle.length()){\n                return sidx-tidx;\n            }\n        }else if(next[tidx]==-1){\n            //完全失配sidx需要后移\n            sidx++;\n        }else{\n            tidx=next[tidx];\n        }\n    }\n    return -1;\n}\n\n//求t的next\n//abadabac\n//ac\npublic int[] getNext(String t){\n    int[] next= new int[t.length()];\n    next[0]=-1;\n    if(t.length()<=1) return next;\n    next[1]=0;\n    int left=0,right=2;\n    while(right<t.length()){\n        if(t.charAt(left)==t.charAt(right-1)){\n            left++;\n            next[right++]=left;\n        }else if(next[left]==-1){ //无法匹配了\n            right++; //next[right]=0\n        }else{\n            left=next[left];\n        }\n    }\n    return next;\n}\n```\n没啥好说的，裸kmp\n\n### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)\n\n给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。\n\n**示例 1:**\n\n```java\n输入: \"abab\"\n\n输出: True\n\n解释: 可由子字符串 \"ab\" 重复两次构成。\n```\n\n**示例 2:**\n\n```java\n输入: \"aba\"\n\n输出: False\n```\n\n**示例 3:**\n\n```java\n输入: \"abcabcabcabc\"\n\n输出: True\n\n解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。)\n```\n\n**解法一**\n\n这题标注的也是简单，确实暴力的解法不难想到，但是复杂度比较高，所以就直接上kmp\n\n```java\n//20ms，做复杂了，构造了一个s+s然后去掉头，再在里面kmp找\npublic boolean repeatedSubstringPattern(String s) {\n    if(s==null || s.length()<=0) return false;\n    String t=s+s;\n    int[] next=getNext(s);\n    int i=0,j=1; //去掉头\n    while(i<s.length() && j<t.length()){\n        if(s.charAt(i)==t.charAt(j)){\n            i++;j++;\n        }else if(next[i]==-1){\n            j++;\n        }else{\n            i=next[i];\n        }\n    }\n    return j-i!=s.length();\n}\n\npublic int[] getNext(String s){\n    if(s.length()==1){\n        return new int[]{-1};\n    }\n    int[] next=new int[s.length()];\n    next[0]=-1;\n    next[1]=0;\n    int left=0,right=2; \n    while(right<s.length()){\n        if(s.charAt(left)==s.charAt(right-1)){\n            next[right++]=++left;\n        }else if(next[left]==-1){\n            next[right++]=0;\n        }else{\n            left=next[left];\n        }\n    }\n    return next;\n}\n```\n这个解法其实构造了一个`s+s`的字符`t`，然后去掉头，在`t[1:]`中找原`s`，最后找到的位置只要不是`s+s`连接处，也就是`s.length()`位置，那么就肯定是重复的有循环的，其实这个结论在写的时候并没有证明，完全是猜的😂，简单证明下，一图胜前言\n\n![mark](http://static.imlgw.top/blog/20200513/O4Nmz343e9Li.png?imageslim)\n\n**解法二**\n\n其实只需要构造next数组，根据next数组就可以判断是不是重复的，我们看几组数据\n\n```java\n   s:  a b c a b c a b c a b c \\0\nnext: -1 0 0 0 1 2 3 4 5 6 7 8  9\n   s:  a a b a b d \\0\nnext: -1 0 1 0 1 0  0\n   s:  a b c d a b \\0\nnext: -1 0 0 0 0 1 2 \n```\n\n相比常规的KMP算法，我们在字符最后最后也加了`next`位，其实是为了区别下面的情况\n\n```\n   s:  a b a b \\0\nnext: -1 0 0 1 2\n   s:  a b a c \\0\nnext: -1 0 0 1 0\n```\n\n然后我们就可以发现，next数组在过了一定的范围后就开始逐渐递增了，而这个递增的拐点就是在第一个循环节结束的时候，至于为什么我就不详细证明了，其实也很好想因为过了循环节，后面的都是和前面重复的，所以每多一个字符`next[i]=next[i-1]+1`，所以我们用字符的长度减去`next[slen]`就可以得到循环结的长度，我们只需要验证这个循环节能否被`s`字符串长度整除就可以了，同时需要防止循环节长度等于字符串长度的情况\n\n```java\npublic boolean repeatedSubstringPattern(String s) {\n    if(s==null || s.length()<=1) return false;\n    int[] next=getNext(s);\n    int replen=s.length()-next[s.length()];\n    //循环结长度等于字符长度\n    return replen!=s.length() && s.length()%replen==0;\n}\n\npublic int[] getNext(String s){\n    if(s.length()==1){\n        return new int[]{-1};\n    }\n    int[] next=new int[s.length()+1];\n    next[0]=-1;\n    next[1]=0;\n    int left=0,right=2; \n    while(right<=s.length()){\n        if(s.charAt(left)==s.charAt(right-1)){\n            next[right++]=++left;\n        }else if(next[left]==-1){\n            next[right++]=0;\n        }else{\n            left=next[left];\n        }\n    }\n    return next;\n}\n```\n\n实在不行把这个记住就行了，反正我是记住了😂（过几天就忘了\n\n### [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)\n\n给定一个字符串 ***s***，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n\n**示例 1:**\n\n```java\n输入: \"aacecaaa\"\n输出: \"aaacecaaa\"\n```\n\n**示例 2:**\n\n```java\n输入: \"abcd\"\n输出: \"dcbabcd\"\n```\n\n**解法一**\n\n这题很关键的一个点就是最短回文串其实就是原字符`s`，减去`s[0]`开头的最长回文串，剩下的部分再放到`s`前，这就是最短回文串\n\n所以问题就变成了如何求`s[0]`开头的最长回文串，朴素的思路可以使用中心扩散法，枚举所有的字符和间隙，或者使用\"马拉车\"，等高效算法，这里不多介绍，主要介绍kmp的做法\n\n我们把`s`串翻转变成`rs`，然后将两部分拼接起来变为`s+rs`，这个时候我们要求`s[0]`开头的最长回文子串，实际上就变成了求`s+rs`的最长公共前后缀\n\n![mark](http://static.imlgw.top/blog/20200518/CtFIYht31mIL.png?imageslim)\n\n这里还有一点需要注意，就是`s+rs`的中间应该加分隔符，这是为了避免公共前后缀过长，甚至比原字符`s`还要长，这肯定是不对的，就比如`aaaaaaa`这样的case，加了分割符之后最长的前后缀就不会超过`s`了，\n\n```java\npublic String shortestPalindrome(String s) {\n    String rs=new StringBuilder(s).reverse().toString();\n    //#是为了避免前后缀过长超过原字符s的长度，比如aaaaaaa这种\n    String t=s+\"#\"+rs; \n    int[] next=new int[t.length()+1];\n    next[0]=-1;\n    next[1]=0;\n    int left=0;\n    int i=2;\n    while(i<=t.length()){\n        if(t.charAt(i-1)==t.charAt(left)){\n            next[i++]=++left;\n        }else if(next[left]==-1){\n            next[i++]=0;\n        }else{\n            left=next[left];\n        }\n    }\n    //System.out.println(next[t.length()]);\n    return rs.substring(0,s.length()-next[t.length()])+s;\n}\n```\n\n### [1392. 最长快乐前缀](https://leetcode-cn.com/problems/longest-happy-prefix/)\n\n「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。\n\n给你一个字符串 s，请你返回它的**最长快乐前缀**。\n\n如果不存在满足题意的前缀，则返回一个空字符串。\n\n**示例 1：**\n\n```java\n输入：s = \"level\"\n输出：\"l\"\n解释：不包括 s 自己，一共有 4 个前缀（\"l\", \"le\", \"lev\", \"leve\"）和 4 个后缀（\"l\", \"el\", \"vel\", \"evel\"）。最长的既是前缀也是后缀的字符串是 \"l\" 。\n\n```\n**示例 2：**\n\n```java\n输入：s = \"ababab\"\n输出：\"abab\"\n解释：\"abab\" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。\n```\n**示例 3：**\n\n```java\n输入：s = \"leetcodeleet\"\n输出：\"leet\"\n```\n**示例 4：**\n\n```java\n输入：s = \"a\"\n输出：\"\"\n```\n\n**提示：**\n- 1 <= s.length <= 10^5\n- s 只含有小写英文字母\n\n**解法一**\n\n最近某次周赛的T4，没参加，今天看见群里有人提到了，看了下发现是裸KMP...正好复习下，结果写出bug了。。。\n\n```golang\nfunc longestPrefix(s string) string {\n    if len(s) == 1 {\n        return \"\"\n    }\n    //裸KMP\n    next := make([]int, len(s)+1)\n    next[0] = -1\n    next[1] = 0\n    var left = 0\n    var i = 2\n    for i <= len(s) {\n        if s[i-1] == s[left] {\n            left++\n            next[i] = left\n            i++\n        } else if next[left] == -1 {\n            i++\n        } else {\n            left = next[left]\n        }\n    }\n    return s[0:next[len(s)]]\n}\n```\n确实也长时间没有复习kmp了，kmp的细节几乎都忘了，上面的都是凭借着一点理解和记忆写的\n> 检查了前面kmp的写法，稍微改进了一下，目前统一了写法\n\n### [796.旋转字符串](https://leetcode-cn.com/problems/rotate-string/)\n\n给定两个字符串, `A` 和 `B`。\n\n`A` 的旋转操作就是将 `A` 最左边的字符移动到最右边。 例如, 若 `A = 'abcde'`，在移动一次之后结果就是`'bcdea'` 。如果在若干次旋转操作之后，`A` 能变成`B`，那么返回`True`。\n\n```java\n示例 1:\n输入: A = 'abcde', B = 'cdeab'\n输出: true\n```\n```java\n示例 2:\n输入: A = 'abcde', B = 'abced'\n输出: false\n```\n\n**注意：**\n\n*   `A` 和 `B` 长度不超过 `100`。\n\n**解法一**\n\n经典easy题当hard做，这个题数据量很小，直接暴力就行了，但是我们还是要追求更好的解法\n\n一开始是在一篇文章中看到了这个题，里面说了这个题是kmp，我看了下没想到什么好的思路，只想到了一个NlogN的做法，二分+kmp找旋转点，然后kmp判断旋转点后时候也存在于A字符中（类似二分答案）\n```golang\n//不够聪明的做法: 二分+KMP 时间复杂度O(NlogN)\nfunc rotateString(A string, B string) bool {\n    if len(A) != len(B) {\n        return false\n    }\n    if A == B {\n        return true\n    }\n    var left = 0\n    var right = len(B) - 1\n    var rotate = -1\n    //二分找旋转点\n    for left <= right {\n        mid := left + (right-left)/2\n        if kmp(A, B[:mid+1]) != -1 {\n            rotate = mid\n            left++\n        } else {\n            right--\n        }\n    }\n    if rotate == -1 {\n        return false\n    }\n    return kmp(A, B[rotate+1:]) != -1\n}\n\nfunc kmp(A string, t string) int {\n    var next = getNext(t)\n    var Ai = 0\n    var ti = 0\n    for Ai < len(A) && ti < len(t) {\n        if A[Ai] == t[ti] {\n            Ai++\n            ti++\n        } else if next[ti] == -1 {\n            Ai++\n        } else {\n            ti = next[ti]\n        }\n    }\n    if ti == len(t) {\n        return Ai - 1\n    }\n    return -1\n}\n\nfunc getNext(t string) []int {\n    if len(t) < 2 {\n        return []int{-1}\n    }\n    var next = make([]int, len(t))\n    var left = 0\n    next[0] = -1\n    next[1] = 0\n    var i = 2\n    for i < len(t) {\n        if t[left] == t[i-1] {\n            left++\n            next[i] = left\n            i++\n        } else if next[left] == -1 {\n            i++\n        } else {\n            left = next[left]\n        }\n    }\n    return next\n}\n```\n\n**解法二**\n\n看了评论区的大佬的做法，实际上`A+A`就包含了所有的旋转`A`的结果子串，`A+A`就相当于首位相连，所以我们可以直接在`A+A`中kmp找`B`就可以了，时间复杂度`O(N)`\n\n```golang\n//聪明的解法: A+A包含了所有可能的旋转情况，直接对A+A和B做kmp就行了\n//abcdeabcde\nfunc rotateString(A string, B string) bool {\n    if len(A) != len(B) {\n        return false\n    }\n    if A == B {\n        return true\n    }\n    return kmp(A+A, B) != -1\n}\n```","tags":["数据结构","算法"],"categories":["算法"]},{"title":"并查集","url":"/2020/02/02/bing-cha-ji/","content":"\n## 并查集\n\n在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：\n\n### UF接口\n\n```java\npublic interface UF{\n    int getSize(); //获取并查集的大小\n    boolean isConnected(int p,int q); //是否连接\n    void unionElement(int p,int q); //合并两个集合\n}\n```\n\n### UnionFind1-QuickFind\n\n按照朴素的思路写出的并查集\n\n```java\npublic class UnionFind1 implements UF{\n\n    private int[] id; //集合ids\n\n    public UnionFind1(int size){\n        id=new int[size];\n        for (int i=0;i<size;i++) {\n            id[i]=i;\n        }\n    }\n\n    public int getSize(){\n        return id.length;\n    }\n\n    //p所属的集合ID\n    private int find(int p){\n        if (p<0 && p>=id.length) {\n            throw new IllegalArgumentException(\"p is out....\");\n        }\n        return id[p];\n    }\n    \n    //判断集合ID是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        for (int i=0;i<id.length;i++) {\n            if (id[i]==qID) {\n                id[i]=pID;\n            }\n        }\n    }\n}\n```\n\n初始化的时候每个元素都是不同的集合ID\n\n`find`操作会返回他们所属集合ID，时间复杂度`O(1)`\n\n`isConnected`会判断两个元素的集合ID是不是相同的，时间复杂度也是`O(1)`\n\n而`unionElement` 合并操作就是遍历整个集合，将集合ID等于其中一个的改成另一个，时间复杂度`O(N)`\n\n> 这种方式属于快速查找，但是合并的效率太低了，我们还可以继续优化下\n\n### UnionFind2-QuickUnion\n\n这一次我们不记录每个元素所属的集合ID，我们记录每个元素的父元素的ID，根节点一样的元素就是一个集合，这样就形成了一颗奇怪的树，由子节点指向父节点的树（森林）\n\n```java\npublic class UnionFind2 implements UF{\n\n    private int[] parent; //父ID\n\n    public UnionFind2(int size){\n        parent=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p所属的集合ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            index=parent[index];\n        }\n        return index;\n    }\n    \n    //判断集合ID是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        parent[pID]=qID;\n    }\n}\n```\n\n初始化的时候每个元素的父节点都指向自己\n\n`find`操作的时候就不停的向上爬，找到每个元素的根节点，就是它的集合ID，时间复杂度就是`O(h)` h是树的高度，注意这里并不是`logN`，因为这课树并一定是一棵二叉树\n\n`isConnected` 和上面一样，判断两个元素的根节点时候一样就ok\n\n`unionElement` 合并两个元素的集合，我们只需要将其中一个`parentID`变为另一个的`parentID`就Ok了，时间复杂度`O(hq)+O(hp)` (hp，hq代表p和q形成的树的高度)\n\n> 相比上面的`UnionFInd1`我们牺牲了一点查找的效率获得了更高的合并效率，但是仍然还有可以优化的点，我们这里在合并两个集合的时候，并没有考虑两颗树的形状，直接将一颗树加在了另一颗的后面，而这样很有可能会增加合并后的树的高度，甚至可能会形成一个链表的结构，这将极大的影响我们的时间复杂度，所以我们可以考虑更好的合并方式\n>\n> ![mark](http://static.imlgw.top/blog/20200101/ifSkJmMWNB2U.png?imageslim)\n\n\n\n### UnionFind3-size优化\n\n这里我们添加一个sz数组用来记录每个集合的元素个数\n\n```java\npublic class UnionFind3 implements UF{\n\n    private int[] parent; //父ID\n\n    private int[] sz; //记录每颗树的节点数量\n\n    public UnionFind3(int size){\n        parent=new int[size];\n        sz=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n            sz[i]=1;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p所属的集合ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            index=parent[index];\n        }\n        return index;\n    }\n    \n    //判断集合ID是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        if (sz[pID]>sz[qID]) {\n            parent[qID]=pID;\n            sz[pID]+=sz[qID];    \n        }else{\n            parent[pID]=qID;\n            sz[qID]+=sz[pID];\n        }\n    }\n}\n```\n\n初始化的时候额外的将每个元素的sz置为1\n\n`find`操作和`isConnected`没有变化\n\n`unionElement` 的时候我们不在是盲目的随意合并，而是将size小的集合加在size大的集合下\n\n![mark](http://static.imlgw.top/blog/20200101/ifSkJmMWNB2U.png?imageslim)\n\n类似这样的情况下就不会将1接在5下面，而是将5接在1下面，这样合并后的集合的高度就不会增大\n\n> 但是根据size判断一定能准确判断么？很显然是不行的\n\n![mark](http://static.imlgw.top/blog/20200101/SdfeawuEf9Qz.png?imageslim)\n\n类似这样的，如果按照之前的按照size合并的方案可能反而会导致树的高度增加，所以更加合理的方案应该是根据树的高度来合并\n\n### UnionFind4-hight优化\n\n```java\npublic class UnionFind4 implements UF{\n\n    private int[] parent; //父ID\n\n    private int[] hight; //每个集合形成的树的高度\n\n    public UnionFind4(int size){\n        parent=new int[size];\n        hight=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n            hight[i]=1;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p所属的集合ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            index=parent[index];\n        }\n        return index;\n    }\n    \n    //判断集合ID是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        if (hight[pID]>hight[qID]) {\n            parent[qID]=pID;    \n        }else if(hight[pID]<hight[qID]){\n            parent[pID]=qID;\n        }else{ //高度相等情况,才会增大树的高度\n            parent[pID]=qID; \n            hight[qID]++;\n        }\n    }\n}\n```\n\n初始化的时候仍然将每个元素的高度设置为1\n\n合并的时候我们根据树的高度来合并，将高度小的集合添加到高度大的集合上，这样整体的高度并不会变化，仍然是高度较大的集合的高度，只有在两颗树的高度相同的时候才会使集合高度增加，这个时候就无所谓谁添加到谁上了\n\n> 回头想一想，其实我们查找或者合并的时候并不会去关系每个元素的父节点又或者爷节点是啥，我们只关心的是这个元素的祖宗节点是啥，也就是根节点是啥，也就是我们希望每个集合的高度越小越好\n\n![mark](http://static.imlgw.top/blog/20200101/D84lWwYGlVag.png?imageslim)\n\n### UnionFind5-路径压缩\n\n在find过程中增加了路径压缩的功能\n\n```java\npublic class UnionFind5 implements UF{\n\n    private int[] parent; //父ID\n\n    private int[] rank;\n\n    public UnionFind5(int size){\n        parent=new int[size];\n        rank=new int[size];\n        for (int i=0;i<size;i++) {\n            parent[i]=i;\n            rank[i]=1;\n        }\n    }\n\n    public int getSize(){\n        return parent.length;\n    }\n\n    //p所属的集合ID\n    private int find(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        while(parent[index]!=index){\n            parent[index]=parent[parent[index]]; //路径压缩\n            index=parent[index];\n        }\n        return index;\n    }\n\t\n    //递归的方式进行路径压缩，可以压得更低\n    private int find2(int index){\n        if (index<0 && index>=parent.length) {\n            throw new IllegalArgumentException(\"index is out....\");\n        }\n        if(parent[index]!=index){\n            parent[index]=find2(parent[index]);\n        }\n        return parent[index];\n    }\n    \n    //判断集合ID是不是一样的\n    public boolean isConnected(int p,int q){\n        return find(q)==find(p);\n    }\n\n    public void unionElement(int p,int q){\n        int pID=find(p);\n        int qID=find(q);\n        if (qID==pID) {\n            return;\n        }\n        if (rank[pID]>rank[qID]) {\n            parent[qID]=pID;    \n        }else if(rank[pID]<rank[qID]){\n            parent[pID]=qID;\n        }else{ //高度相等情况,才会增大树的Rank\n            parent[pID]=qID; \n            rank[qID]++;\n        }\n    }\n}\n```\n\nfind操作本身就是一个向上遍历的过程，所以我们可以直接再find得过程中去进行路径的压缩\n\n核心的语句就是 `parent[index]=parent[parent[index]];`\n\n如果父节点不是要找的根节点就将父节点设置为父节点的父节点\n\n当然这里还有一种压缩的方式，可以将树压缩的更短，也就是上面的`find2`，核心语句就是\n\n `parent[index]=find2(parent[index])` \n\n![mark](http://static.imlgw.top/blog/20200101/D84lWwYGlVag.png?imageslim)\n\n如果是这样的树执行 `find2(5)` 可以直接将树压缩成左边的样子，而`find1(5)` 并不能一次就压缩成这样，两者各有优缺点，这里不过多阐述\n\n> 细心的朋友肯定发现了，我这里将`hight`改成了`rank`，为什么要改成rank?\n>\n> 其实原因很简单，在加入了路径压缩后，这里的hight不再能表示高度的含义，所以我们改成了Rank\n>\n> 那我们为什么不继续维护这个高度了？这样不是就无法准确的判断如何合并了嘛？\n>\n> 其实这里如果想要继续维护这个树的高度是一种不太明智的选择，成本太大了，难以维护，并不是简单的`--` 就可以完成的，会有很多的情况，所以我们索性直接将其改成Rank作为一个参考量，表示这个集合的排名，其实仔细想一想，我们进行路径压缩带来的优化明显会大于维护hight带来的优化\n\n### 时间复杂度\n\n这里经过科学家们的计算证明得到最终的时间复杂度是 `O(log*N)`我也是第一次听说这个复杂度，\n\n![mark](http://static.imlgw.top/blog/20200101/iXPijTwciz0b.png?imageslim)\n\n**迭代对数**\n\n| n                | lg* n |\n| ---------------- | ----- |\n| (−∞, 1]          | 0     |\n| (1, 2]           | 1     |\n| (2, 4]           | 2     |\n| (4, 16]          | 3     |\n| (16, 65536]      | 4     |\n| (65536, 2^65536] | 5     |\n\n可以看到，时间复杂度是相当低，可以近似的认为就是一个`O(1)` 常数的复杂度\n\n## 练手例题\n\n### [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)\n\n班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。\n\n给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果`M[i][j] = 1`，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。\n\n**示例 1:**\n\n```java\n输入: \n[[1,1,0],\n [1,1,0],\n [0,0,1]]\n输出: 2 \n说明：已知学生0和学生1互为朋友，他们在一个朋友圈。\n第2个学生自己在一个朋友圈。所以返回2。\n```\n\n**示例 2:**\n\n```java\n输入: \n[[1,1,0],\n [1,1,1],\n [0,1,1]]\n输出: 1\n说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。\n```\n\n**注意：**\n\n1. N 在`[1,200]`的范围内。\n2. 对于所有学生，有`M[i][i] = 1`。\n3. 如果有`M[i][j] = 1`，则有`M[j][i] = 1`。\n\n**解法二**\n\n这题很久之前做过 [LeetCode回溯&递归](http://imlgw.top/2019/10/10/leetcode-hui-su/#547-%E6%9C%8B%E5%8F%8B%E5%9C%88) 当时DFS做的，其实这题应该属于最经典的并查集的题目了\n\n```java\nprivate int[] parent; //父ID\n\nprivate int[] rank;\n\n//p所属的集合ID\nprivate int find(int index){\n    if (index<0 && index>=parent.length) {\n        throw new IllegalArgumentException(\"index is out....\");\n    }\n    while(parent[index]!=index){\n        parent[index]=parent[parent[index]];\n        index=parent[index];\n    }\n    return index;\n}\n\npublic void unionElement(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (qID==pID) {\n        return;\n    }\n    if (rank[pID]>rank[qID]) {\n        parent[qID]=pID;    \n    }else if(rank[pID]<rank[qID]){\n        parent[pID]=qID;\n    }else{ //高度相等情况,才会增大树的高度\n        parent[pID]=qID; \n        rank[qID]++;\n    }\n}\n\npublic int findCircleNum(int[][] M) {\n    parent=new int[M.length];\n    rank=new int[M.length];\n    //初始化\n    for (int i=0;i<M.length;i++) {\n        parent[i]=i;\n        rank[i]=1;\n    }\n    //union\n    for (int i=0;i<M.length;i++) {\n        for (int j=0;j<M.length;j++) {\n            if (M[i][j]==1) {\n                unionElement(i,j);\n            }\n        }\n    }\n    int res=0;\n    for (int i=0;i<parent.length;i++) {\n        if (parent[i]==i) {\n            res++;\n        }\n    }\n    return res;\n}\n```\n\n代码还是很简单的，合并之后统计一下数量就ok了\n\n### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n给定一个未排序的整数数组，找出最长连续序列的长度。\n\n要求算法的时间复杂度为 `O(n)`。\n\n**示例:**\n\n```java\n输入: [100, 4, 200, 1, 3, 2]\n输出: 4\n解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。\n```\n\n**并查集解法**\n\n```java\n//并查集\nHashMap<Integer,Integer> parent;\n\nHashMap<Integer,Integer> size;\n\nint max=1;\n\npublic int find(int index){\n    while(parent.get(index)!=index){\n        //parent[index]=parent[parent[index]];\n        parent.put(index,parent.get(index));\n        index=parent.get(index);\n    }\n    return index;\n}\n\npublic void union(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (pID==qID) {\n        return;\n    }\n    int pSize=size.get(pID);\n    int qSize=size.get(qID);\n    if (pSize > qSize) {\n        //parent[qID]=pID;\n        parent.put(qID,pID);\n        //size[pID]+=size[qID];\n        size.put(pID,pSize+qSize);\n    }else{\n        //parent[pID]=qID;\n        parent.put(pID,qID);\n        //size[qID]+=size[pID];\n        size.put(qID,pSize+qSize);\n    }\n    max=Math.max(max,pSize+qSize); //统计最大值\n}\n\npublic void initUnionFind(int[]nums){\n    parent=new HashMap<>();\n    size=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        parent.put(nums[i],nums[i]);\n        size.put(nums[i],1);\n    }\n}\n\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int i=0;i<nums.length;i++) {\n        set.add(nums[i]);\n    }\n    initUnionFind(nums);\n    for (int i=0;i<nums.length;i++) {\n        if (set.contains(nums[i]-1)) { //判断-1或者+1都可以\n            union(nums[i],nums[i]-1);\n        }\n    }\n    return max;\n}\n```\n\n这里用并查集其实并不是最优解，直接循环用HashSet感觉会更好更简洁  [详见 LeetCode查找](http://imlgw.top/2019/09/15/leetcode-cha-zhao/) 不过熟悉一下并查集还是不错的，这里因为是根据num的数值判断的，code所以用数组索引合并是行不通的，需要改成Hash表\n\n### [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)\n\n用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。\n\n网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。\n\n给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 \n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/01/4HfDievqKpbswNh.png)\n\n```java\n输入：n = 4, connections = [[0,1],[0,2],[1,2]]\n输出：1\n解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/02/01/mDjJCSHwOrZoa9g.png)\n\n```java\n输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n输出：2\n```\n\n**示例 3：**\n\n```java\n输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n输出：-1\n解释：线缆数量不足。\n```\n\n\n**示例 4：**\n\n```java\n输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]\n输出：0\n```\n\n**提示：**\n\n- 1 <= n <= 10^5\n- 1 <= connections.length <= min(n*(n-1)/2, 10^5)\n- connections[i].length == 2\n- 0 <= connections[i][0], connections[i][1] < n\n- connections[i][0] != connections[i][1]\n- 没有重复的连接。\n- 两台计算机不会通过多条线缆连接。\n\n**解法一**\n\n1.12周赛的第三题，挺有意思的，当时想了一会儿，然后就直接想到了并查集\n\n```java\nprivate int[] parent; //父ID\n\nprivate int[] rank;\n\n//p所属的集合ID\nprivate int find(int index){\n    if (index<0 && index>=parent.length) {\n        throw new IllegalArgumentException(\"index is out....\");\n    }\n    while(parent[index]!=index){\n        parent[index]=parent[parent[index]];\n        index=parent[index];\n    }\n    return index;\n}\n\npublic void union(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (qID==pID) {\n        return;\n    }\n    if (rank[pID]>rank[qID]) {\n        parent[qID]=pID;    \n    }else if(rank[pID]<rank[qID]){\n        parent[pID]=qID;\n    }else{ //高度相等情况,才会增大树的高度\n        parent[pID]=qID; \n        rank[qID]++;\n    }\n}\n\n//判断集合ID是不是一样的\npublic boolean isConnected(int p,int q){\n    return find(q)==find(p);\n}\n\npublic void initUF(int n){\n    parent=new int[n];\n    rank=new int[n];\n    for (int i=0;i<n;i++) {\n        parent[i]=i;\n        rank[i]=1;\n    }\n}\n\npublic int makeConnected(int n, int[][] connections) {\n    initUF(n);\n    int more=0;\n    for (int i=0;i<connections.length;i++) {\n        if (isConnected(connections[i][0],connections[i][1])) {\n            more++; //多出来的边个数\n        }else{\n            union(connections[i][0],connections[i][1]);\n        }\n    }\n    int count=0;\n    for (int i=0;i<n;i++) {\n        if (parent[i]==i) {\n            count++; //集合个数\n        }\n    }\n    return count-1<=more?count-1:-1;\n}\n```\n\n核心思路就是将元素合并，然后中间求出多出的边，最后判断多出来的边能不能将所有的集合聚合成一个大集合，也就是`count-1<=more`的时候才可以联通，否则就无法联通\n\n### [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)\n\n给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。\n\n示例 :\n\n```java\n给定 a / b = 2.0, b / c = 3.0\n问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \n返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]\n```\n\n输入为: `vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries(方程式，方程式结果，问题方程式)`， 其中 `equations.size() == values.size()`，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回`vector<double>`类型。\n\n基于上述例子，输入如下：\n\n```java\nequations(方程式) = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\nvalues(方程式结果) = [2.0, 3.0],\nqueries(问题方程式) = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \n```\n\n\n输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。\n\n**解法一**\n\n首先弄清楚题目的意思，这题LeetCode上只是mid，其实我感觉如果用并查集做的话就不是mid题了，今天搞了好长时间并查集的解法\n\n首先来一版不带路径压缩的\n\n```java\nprivate HashMap<String,String> parent=new HashMap<>();\n\nprivate HashMap<String,Double> quotient=new HashMap<>();\n\n//不带路径压缩\npublic String find(String p){\n    while (parent.get(p)!=p) {\n        p=parent.get(p);\n    }\n    return p;\n}\n\npublic void init(String s){\n    if (!parent.containsKey(s)) {\n        parent.put(s,s);\n        quotient.put(s,1.0);   \n    }\n}\n\npublic void merge(String a,String b,Double value){\n    init(a);init(b);\n    String fa=find(a); // a/fa=val[a], b/fb=val[b]\n    String fb=find(b);\n    if (fa.equals(fb)) {\n        return;\n    }\n    parent.put(fa,fb);\n    quotient.put(fa,value*(cal(b)/cal(a))); //cal(a)和cal(b)代表a和b到根节点的总值\n}\n\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n    for (int i=0;i<equations.size();i++) {\n        List<String> equation=equations.get(i);\n        merge(equation.get(0),equation.get(1),values[i]);\n    }\n    double[] res=new double[queries.size()];\n    int index=0;\n    for (List<String> query:queries) {\n        String a=find(query.get(0));\n        String b=find(query.get(1));\n        System.out.println(a+\" \"+b);\n        if (!parent.containsKey(query.get(0)) || !parent.containsKey(query.get(1)) || !a.equals(b)) {\n            res[index++]=-1;\n        }else{\n            //没有路劲压缩,需要遍历整个路劲求积\n            res[index++]=cal(query.get(0))/cal(query.get(1));\n        }\n    }\n    return res;\n}\n\n\n//计算当前节点到根节点的路径乘积\npublic double cal(String index){\n    double res=quotient.get(index);\n    while(parent.get(index)!=index){\n        index=parent.get(index);\n        res*=quotient.get(index);\n    }\n    return res;\n}\n```\n\n其实这题我开始想到就是建图然后BFS，并查集我是真没想到，看来还是不够敏锐，不过有一说一并查集的方法确实比较麻烦，特别是带了路径压缩的。\n\n这里我的并查集的方向是\n\n```java\na/b=2 , b/c=3\n    \n        c  1\n        ^\n        |\n        b  3\n        ^\n        |\n        a  2\n```\n\n`quotient`代表的是**当前节点**是**直接父节点**的多少倍，也就是 `A/fatherA`  ，重点就是合并两个集合的时候需要注意：\n\n```java\n已知\na / fa = val[a]\nb / fb = val[b]\n现在我们要合并a，b且 a / b=value\n所以我们需要设置 parent[fa]=fb\n由于fa父节点发生了变化所以它的值也需要变化,也就是要求 fa/fb的值\nval[fa] = fa/fb = a/b * b/fb * fa/a = value * (val[b] / val[a])\n```\n\n**解法二**\n\n```java\nprivate HashMap<String,String> parent=new HashMap<>();\n\nprivate HashMap<String,Double> quotient=new HashMap<>();\n\n//带路径压缩的\npublic String find(String p){\n    if (parent.get(p)!=p) {\n        //需要先保存父亲的值,因为后面压缩后树只有两层,后面*的就是根节点的权值1,是不对的\n        //这里可以看看上面的并茶几的方向和值来判断\n        String f=parent.get(p); \n        parent.put(p,find(f));\n        //这样压缩后的子节点才是正确的\n        quotient.put(p,quotient.get(p)*quotient.get(f));\n    }\n    return parent.get(p);\n}\n\npublic void init(String s){\n    if (!parent.containsKey(s)) {\n        parent.put(s,s);\n        quotient.put(s,1.0);   \n    }\n}\n\npublic void merge(String a,String b,Double value){\n    init(a);init(b);\n    String fa=find(a); // fa/a=val[a], fb/b=val[b]\n    String fb=find(b);\n    if (fa.equals(fb)) {\n        return;\n    }\n    parent.put(fa,fb);\n    quotient.put(fa,value*(quotient.get(b)/quotient.get(a))); \n}\n\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n    for (int i=0;i<equations.size();i++) {\n        List<String> equation=equations.get(i);\n        merge(equation.get(0),equation.get(1),values[i]);\n    }\n    double[] res=new double[queries.size()];\n    int index=0;\n    for (List<String> query:queries) {\n        String a=query.get(0);\n        String b=query.get(1);\n        if (!parent.containsKey(a) || !parent.containsKey(b)) {\n            res[index++]=-1;\n        }else{\n            //先做路径压缩\n            res[index++]=find(a).equals(find(b))?quotient.get(a)/quotient.get(b):-1;\n        }\n    }\n    return res;\n}\n```\n\n这里可以看到已经省略了`cal` 函数计算从当前节点到根节点的总权值积，因为这里路径压缩已经将树压缩到只有两层了，所以并不需要了，既然要压缩到只有两层，这里就只能使用递归来压缩，循环的版本没办法压到只有两层，这里需要注意压缩中值的变化。\n\n**解法三**\n\n图的解法放到了 [栈和队列专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/) 中了\n\n### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)\n\n给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。\n\n找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)\n\n**示例 1:**\n\n```java\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n```\n\n\n对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。\n\n**示例 2:**\n\n```java\n[[0,0,0,0,0,0,0,0]]\n```\n\n\n对于上面这个给定的矩阵, 返回 0。\n\n**注意:** 给定的矩阵grid 的长度和宽度都不超过 50\n\n**解法一**\n\nlc打卡题选了这题，之前用的dfs，这次用并查集实现下\n\n```java\n//补充一个并查集的解法\nint[] parent=null;\n\nint[] size=null;\n\nint max=0;\n\npublic void merge(int a,int b){\n    int fa=find(a);\n    int fb=find(b);\n    if(fa==fb) return;\n    if(size[fa]>size[fb]){\n        parent[fb]=fa;\n        size[fa]+=size[fb];\n        max=Math.max(max,size[fa]);\n    }else{\n        parent[fa]=fb;\n        size[fb]+=size[fa];\n        max=Math.max(max,size[fb]);\n    }\n}\n\npublic int find(int p){\n    if(parent[p]==p) return p;\n    parent[p]=find(parent[p]);\n    return parent[p];\n}\n\npublic int maxAreaOfIsland(int[][] grid) {\n    int m=grid.length;\n    int n=grid[0].length;\n    //init\n    parent=new int[m*n];\n    size=new int[m*n];\n    for (int i=0;i<m*n;i++){\n        parent[i]=i;\n        size[i]=1;\n    }\n    //1 1 1 1 \n    //1 1 1 1\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]==1){\n                //特判一下 hahaha~ 感觉如果不是lc有wacase我还挺难发现这个\n                max=Math.max(max,1);\n                //和前面,上面的合并\n                if(i>0 && grid[i-1][j]==1) merge(i*n+j,(i-1)*n+j);\n                if(j>0 && grid[i][j-1]==1) merge(i*n+j,i*n+j-1);  \n            }\n        }\n    }\n    return max;\n}\n```\n\n### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)\n\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n**示例 1:**\n\n```java\n输入:\n11110\n11010\n11000\n00000\n输出: 1\n```\n\n\n**示例 2:**\n\n```java\n输入:\n11000\n11000\n00100\n00011\n输出: 3\n解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n```\n\n**解法一**\n\n补充一个并查集的写法，手写出来了，但是逻辑出了一点小问题，卡了一会儿\n\n```java\n//复习下并查集\nint[] rank=null;\n\nint[] parent=null;\n\npublic int find(int a){\n    if(parent[a]==a) return a;\n    return parent[a]=find(parent[a]);\n}\n\npublic void merge(int a,int b){\n    int fa=find(a);\n    int fb=find(b);\n    if(fa==fb) return;\n    if(rank[fa]>rank[fb]){\n        parent[fb]=fa;\n        rank[fa]+=rank[fb];\n    }else{\n        parent[fa]=fb;\n        rank[fb]+=rank[fa];\n    }\n}\n\npublic int numIslands2(char[][] grid) {\n    if(grid==null || grid.length<=0) return 0;\n    int m=grid.length,n=grid[0].length;\n    rank=new int[m*n];\n    parent=new int[m*n];\n    //init\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]=='1'){\n                parent[i*n+j]=i*n+j;\n                rank[i*n+j]=1;\n            }\n        }\n    }\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]=='1'){\n                //和上/左合并\n                if(i>0 && grid[i-1][j]=='1') merge(i*n+j,(i-1)*n+j);\n                if(j>0 && grid[i][j-1]=='1') merge(i*n+j,i*n+(j-1));\n            }\n        }\n    }\n    int res=0;\n    //直接循环parent会有问题,还是老老实实遍历矩阵\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(grid[i][j]=='1' && parent[i*n+j]==i*n+j){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)\n\n给出一个二维数组 `A`，每个单元格为 0（代表海）或 1（代表陆地）。\n\n移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。\n\n返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。\n\n**示例 1：**\n\n```java\n输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n输出：3\n解释： \n有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n```\n\n**示例 2：**\n\n```java\n输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n输出：0\n解释：\n所有 1 都在边界上或可以到达边界。\n```\n\n**提示：**\n\n1. `1 <= A.length <= 500`\n2. `1 <= A[i].length <= 500`\n3. `0 <= A[i][j] <= 1`\n4. 所有行的大小都相同\n\n**解法一**\n\n```java\n//并查集\nint[] rank=null;\n\nint[] parent=null;\n\npublic int find(int a){\n    if(parent[a]==a) return a;\n    return parent[a]=find(parent[a]); //路径压缩\n}\n\npublic void merge(int a,int b){\n    int fa=find(a);\n    int fb=find(b);\n    if(fa==fb) return;\n    if(rank[fa]>rank[fb]){\n        parent[fb]=fa;\n        rank[fa]+=rank[fb];\n    }else{\n        parent[fa]=fb;\n        rank[fb]+=rank[fa];\n    }\n}\n\npublic int numEnclaves2(int[][] A) {\n    if(A==null || A.length<=0) return 0;\n    int m=A.length,n=A[0].length;\n    rank=new int[m*n+1];\n    parent=new int[m*n+1];\n    //init\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(A[i][j]==1){\n                parent[i*n+j]=i*n+j;\n                rank[i*n+j]=1;\n            }\n        }\n    }\n    //将边界和虚拟节点合并\n    int dummyNode=m*n;\n    parent[dummyNode]=dummyNode;\n    rank[dummyNode]=1;\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            if(A[i][j]==1){\n                if(i==0 || j==0 || i==m-1 || j==n-1){\n                    merge(dummyNode,i*n+j);\n                }else{ \n                    //和周围节点合并(一开始复制的上面的，只和左上的合并，结果出bug了hahaha\n                    if(A[i][j-1]==1) merge(i*n+j,i*n+j-1);\n                    if(A[i-1][j]==1) merge(i*n+j,(i-1)*n+j);\n                    if(A[i][j+1]==1) merge(i*n+j,i*n+j+1);\n                    if(A[i+1][j]==1) merge(i*n+j,(i+1)*n+j);\n                }\n            }\n        }\n    }\n    int res=0;\n    int dump=find(dummyNode);\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            //判断和虚节点是否连接\n            if(A[i][j]==1 && find(i*n+j)!=dump){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n### [990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)\n\n给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]` 的长度为 `4`，并采用两种不同的形式之一：`\"a==b\"` 或 `\"a!=b\"`。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。\n\n只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 `true`，否则返回 `false`。 \n\n**示例 1：**\n\n```java\n输入：[\"a==b\",\"b!=a\"]\n输出：false\n解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\n```\n\n**示例 2：**\n\n```java\n输出：[\"b==a\",\"a==b\"]\n输入：true\n解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。\n```\n\n**示例 3：**\n\n```java\n输入：[\"a==b\",\"b==c\",\"a==c\"]\n输出：true\n```\n\n**示例 4：**\n\n```java\n输入：[\"a==b\",\"b!=c\",\"c==a\"]\n输出：false\n```\n\n**示例 5：**\n\n```java\n输入：[\"c==c\",\"b==d\",\"x!=z\"]\n输出：true\n```\n\n**提示：**\n\n1. `1 <= equations.length <= 500`\n2. `equations[i].length == 4`\n3. `equations[i][0]` 和 `equations[i][3]` 是小写字母\n4. `equations[i][1]` 要么是 `'='`，要么是 `'!'`\n5. `equations[i][2]` 是 `'='`\n\n**解法一**\n\n2020.6.8打卡题，在群里看见了讨论说并查集，所以直接就想到了并查集的做法，自己想的话emmm，感觉也能想到，也不是很复杂的并查集\n\n```java\n//路径压缩+按秩合并\nint[] parent;\n\nint[] rank;\n\npublic int find(int p){\n    if(parent[p]==p) return p;\n    return parent[p]=find(parent[p]);\n}\n\npublic void merge(int a,int b){\n    int af=find(a);\n    int bf=find(b);\n    if(af==bf) return;\n    if(rank[af]>rank[bf]){\n        parent[bf]=af;\n    }else if(rank[af]<rank[bf]){\n        parent[af]=bf;\n    }else{\n        parent[af]=bf;\n        rank[bf]++;\n    }\n}\n\npublic boolean equationsPossible(String[] equations) {\n    parent=new int[128]; //-'a'减来减去太麻烦了,直接设个128完事\n    rank=new int[128];\n    //排序后先合并==,再判断!= 偷懒的做法\n    //Arrays.sort(equations,(s1,s2)->s2.charAt(1)-s1.charAt(1));\n    for (String eq:equations) {\n        parent[eq.charAt(0)]=eq.charAt(0);\n        rank[eq.charAt(0)]=1;\n        parent[eq.charAt(3)]=eq.charAt(3);\n        rank[eq.charAt(3)]=1;\n    }\n    for (String eq:equations) {\n        if(eq.charAt(1)=='='){\n            merge(eq.charAt(0),eq.charAt(3));\n        }\n    }\n    for (String eq:equations) {\n        if(eq.charAt(1)=='!' && find(eq.charAt(0))==find(eq.charAt(3))){\n            return false;\n        }\n    }\n    return true;\n}\n```\n### [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)\n\nDifficulty: **中等**\n\n\n在本问题中, 树指的是一个连通且无环的**无向**图。\n\n输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。\n\n返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。\n\n**示例 1：**\n\n```\n输入: [[1,2], [1,3], [2,3]]\n输出: [2,3]\n解释: 给定的无向图为:\n  1\n / \\\n2 - 3\n```\n\n**示例 2：**\n\n```\n输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]\n输出: [1,4]\n解释: 给定的无向图为:\n5 - 1 - 2\n    |   |\n    4 - 3\n```\n\n**注意:**\n\n*   输入的二维数组大小在 3 到 1000。\n*   二维数组中的整数在1到N之间，其中N是输入数组的大小。\n\n**更新(2017-09-26):**  \n我们已经重新检查了问题描述及测试用例，明确图是_**无向 **_图。对于有向图详见**。**对于造成任何不便，我们深感歉意。\n\n**解法一**\n\n没啥好说的，题目意思读懂就行了\n```golang\nvar parent []int\n​\nfunc union(a int, b int) bool {\n    pa := find(a)\n    pb := find(b)\n    if pa == pb {\n        return false\n    }\n    parent[pa] = pb\n    return true\n}\n​\nfunc find(a int) int {\n    if parent[a] == a {\n        return a\n    }\n    parent[a] = find(parent[a])\n    return parent[a]\n}\n​\nfunc findRedundantConnection(edges [][]int) []int {\n    var n = len(edges)\n    parent = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        parent[i] = i\n    }\n    for i := 0; i < n; i++ {\n        if !union(edges[i][0], edges[i][1]) {\n            return edges[i]\n        }\n    }\n    return []int{}\n}\n```\n\n### [685. 冗余连接 II](https://leetcode-cn.com/problems/redundant-connection-ii/)\n\nDifficulty: **困难**\n\n\n在本问题中，有根树指满足以下条件的**有向**图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。\n\n输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以`边`组成的二维数组。 每一个`边` 的元素是一对 `[u, v]`，用以表示**有向**图中连接顶点 `u` 和顶点 `v` 的边，其中 `u` 是 `v` 的一个父节点。\n\n返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n\n**示例 1:**\n\n```go\n输入: [[1,2], [1,3], [2,3]]\n输出: [2,3]\n解释: 给定的有向图如下:\n  1\n / \\\nv   v\n2-->3\n```\n\n**示例 2:**\n\n```go\n输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]\n输出: [4,1]\n解释: 给定的有向图如下:\n5 <- 1 -> 2\n     ^    |\n     |    v\n     4 <- 3\n```\n\n**注意:**\n\n*   二维数组大小的在3到1000范围内。\n*   二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。\n\n\n**解法一**\n\n没做出来，看的题解，感觉怪怪的\n\n```golang\nvar parent []int\n\nfunc union(a int, b int) bool {\n    pa := find(a)\n    pb := find(b)\n    if pa == pb {\n        return false\n    }\n    parent[pa] = pb\n    return true\n}\n\nfunc find(a int) int {\n    if parent[a] == a {\n        return a\n    }\n    parent[a] = find(parent[a])\n    return parent[a]\n}\n\nfunc judge(edges [][]int, k int) bool {\n    parent = make([]int, len(edges)+1)\n    for i := 1; i <= len(edges); i++ {\n        parent[i] = i\n    }\n    for i := 0; i < len(edges); i++ {\n        if i == k {\n            continue\n        }\n        if !union(edges[i][0], edges[i][1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc findRedundantDirectedConnection(edges [][]int) []int {\n    var n = len(edges)\n    var indegree = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        indegree[edges[i-1][1]]++\n    }\n    for i := n-1; i >= 0; i-- {\n        if indegree[edges[i][1]] == 2 {\n            //删除该边\n            if judge(edges, i) {\n                return edges[i]\n            }\n        }\n    }\n    for i := n-1; i >= 0; i-- {\n        if indegree[edges[i][1]] == 1 {\n            if judge(edges, i) {\n                return edges[i]\n            }\n        }\n    }\n    return []int{}\n}\n```\n\n###  未完待续\n\n其实之前做的一些题都可以用并查集做，像[岛屿数量]()，[岛屿最大面积]()啥的，这里就不多写了，都差不多","tags":["数据结构","算法"],"categories":["数据结构"]},{"title":"LeetCode贪心","url":"/2020/01/21/leetcode-tan-xin/","content":"\n\n## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n**注意：**\n\n你可以假设胃口值为正。\n一个小朋友最多只能拥有一块饼干\n\n**示例 1:**\n\n```java\n输入: [1,2,3], [1,1]\n\n输出: 1\n\n解释: \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1。\n```\n\n\n**示例 2:**\n\n```java\n输入: [1,2], [1,2,3]\n\n输出: 2\n\n解释: \n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出2.\n```\n\n**解法一**\n\n贪就完事儿了\n\n```java\npublic int findContentChildren(int[] g, int[] s) {\n    if (g==null || s==null) {\n        return 0;\n    }\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int res=0,index=0;\n    for (int i=0;i<g.length;i++) {\n        while(index<s.length){\n            if (g[i]<=s[index]) {\n                res++;\n                index++;\n                break;\n            }\n            index++;\n        }\n    }\n    return res;\n}\n```\n\n## [274. H指数](https://leetcode-cn.com/problems/h-index/)\n\n给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。\n\nh 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）~~至多~~有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”\n\n**示例:**\n\n```java\n输入: citations = [3,0,6,1,5]\n输出: 3 \n解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。\n     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。\n```\n\n**说明:** 如果 h 有多种可能的值，h 指数是其中最大的那个。\n\n**解法一**\n\n题目意思搞懂就ok\n\n```java\npublic int hIndex(int[] citations) {\n    int len=citations.length;\n    Arrays.sort(citations);\n    int count=0;\n    for (int i=len-1;i>=0;i--) {\n        if (citations[i]<=len-(i+1)) {\n            return len-(i+1);\n        }\n    }\n    return len;\n}\n```\n\n## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`\"ace\"`是`\"abcde\"`的一个子序列，而`\"aec\"`不是）。\n\n**示例 1:**\n\n```java\ns = \"abc\", t = \"ahbgdc\"\n返回 true.\n```\n\n**示例 2:**\n\n```java\ns = \"axc\", t = \"ahbgdc\"\n返回 false.\n```\n\n**后续挑战 :**\n\n如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n**解法一**\n\n```java\npublic boolean isSubsequence(String s, String t) {\n    if (s==null || t==null) {\n        return false;\n    }\n    int sindex=0,tindex=0;\n    while(sindex<s.length()) {\n        while(tindex<t.length() && sindex<s.length()){\n            if (s.charAt(sindex)==t.charAt(tindex)) {\n                sindex++;\n            }\n            tindex++;\n        }\n        if (tindex==t.length()) {\n            break; \n        }\n    }\n    return sindex==s.length();\n}\n```\n可以改成递归（多练习递归）\n\n```java\npublic boolean isSubsequence(String s,String t){\n    return subsequence(s,t,0,0);\n}\n\npublic boolean subsequence(String s,String t,int sindex,int tindex){\n    if (sindex == s.length()) {\n        return true;\n    }\n    //上下if不能交换,可能最后一个才相等\n    if (tindex == t.length()) {\n        return false;\n    }\n    return s.charAt(sindex)==t.charAt(tindex)?subsequence(s,t,sindex+1,tindex+1):subsequence(s,t,sindex,tindex+1);\n}\n```\n**解法二**\n\n```java\n//大量的s字符串 处理\npublic boolean isSubsequence3(String s, String t) {\n    //预处理\n    ArrayList<ArrayList<Integer>> hash=new ArrayList<>();\n    for (int i=0;i<26;i++) {\n        hash.add(new ArrayList());\n    }\n    for (int i=0;i<t.length();i++) {\n        hash.get(t.charAt(i)-'a').add(i);\n    }\n    //经过上面的预处理,后面的处理就会很快,不用再遍历t字符串\n    int lastIndex=-1;\n    for (int i=0;i<s.length();i++) {\n        List<Integer> indexList=hash.get(s.charAt(i)-'a');\n        int temp=binarySearch(indexList,lastIndex);\n        if (temp==indexList.size()) {\n            return false;\n        }\n        lastIndex=indexList.get(temp);\n    }\n    return true;\n}\n\n//找到第一个比target大的元素\npublic int binarySearch(List<Integer> list,int target){\n    int left=0,right=list.size()-1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if (list.get(mid)>target) {\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return left;\n}\n```\n\n## [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)\n\n给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。\n\n然而，两个**相同种类**的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。\n\n你需要计算完成所有任务所需要的**最短时间**\n\n**示例 1：**\n\n```java\n输入: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n输出: 8\n执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.\n```\n\n**注：**\n\n- 任务的总个数为 `[1, 10000]`\n- n 的取值范围为 `[0, 100]`\n\n**解法一**\n\n```java\npublic int leastInterval(char[] tasks, int n) {\n    int[] map=new int[26];\n    for (int i=0;i<tasks.length;i++) {\n        map[tasks[i]-'A']++;\n    }\n    //找最大值\n    int max=-1;\n    for (int i=0;i<map.length;i++) {\n        max=Math.max(map[i],max);\n    }\n    int maxCount=0;\n    for (int i=0;i<map.length;i++) {\n        if (map[i]==max) {\n            maxCount++;\n        }\n    }\n    //比如 a b c d e f g,n=1\n    return Math.max((n+1)*(max-1)+maxCount,tasks.length);\n}\n```\n核心思想就是将出现次数最多的任务优先执行并且尽可能的分散，比如  `A A A B B C n=2` 最短的时间就是`A X X A X X A` ，最终的时间就是`(n+1)*(max-1)+1` 也就是 `(2+1) *(3-1)+1=7`， 但是可能会有多个最多次数的任务，所以我们还需要加上最多的相同的个数，最后就是 `(n+1)*(max-1)+maxCount` ，但是还不够，还是有可能会出现代码中的例子，也就是最后得到的结果比我们的任务列表还有短，所以我们需要取一个最大值\n\n## [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个位置。\n\n**示例 1:**\n\n```java\n输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n```\n\n**示例 2:**\n\n```java\n输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n```\n\n**解法一**\n\n回溯，勉强能过。。。太蠢了，为啥想不到简单的方法，就非得往复杂了想？就这么傻么？\n\n```java\nBoolean[] cache=null;\n\npublic boolean canJump(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    cache=new Boolean[nums.length];\n    return jump(nums,0);\n}\n\npublic boolean jump(int[] nums,int index) {\n    if (nums[index] >= nums.length-1 -index) {\n        return true;\n    }\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    for (int i=nums[index];i>=1;i--) {\n        if (index+i<nums.length && jump(nums,index+i)) {\n            return cache[index]=true;\n        }\n    }\n    return cache[index]=false;\n}\n```\n**解法二**\n\n不用多说了，遍历数组，不断更新能到达的最远距离，如果**某个位置的index大于当前能到达的最远距离就直接返回false**\n\n```java\n//MDZZ\npublic boolean canJump(int[] nums) {\n    int maxIndex=nums[0];\n    for (int i=1;i<nums.length-1;i++) {\n        if(maxIndex >= nums.length-1) return true;\n        if (i>maxIndex) {\n            return false;\n        }\n        maxIndex=Math.max(maxIndex,i+nums[i]);\n    }\n    return true;\n}\n```\n\n## [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n**示例:**\n\n```java\n输入: [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n```\n\n**说明:**\n\n假设你总是可以到达数组的最后一个位置。\n\n**解法一**\n\n兴致勃勃写了个dp\n\n```java\npublic int jump(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[nums.length];\n    for (int i=1;i<nums.length;i++) {\n        dp[i]=Integer.MAX_VALUE;\n        for (int j=0;j<i;j++) {\n            if (nums[j]>=i-j) {\n                dp[i]=Math.min(dp[j]+1,dp[i]);    \n            }\n        }\n    }\n    return dp[nums.length-1];\n}\n```\n\n如果这就过了那你也太小瞧这题了😂人家可是hard题，那能这么容易就让你过了？\n\n没错，这里直接TLE了，最后一个CASE过不去\n\n**解法二**\n\n贪心，核心思想不是每次都跳到最远的地方，**而是跳到当前位置能跳到的最远的位置**\n\n```java\n//每次选能跳的位置中跳的最远的\npublic int jump(int[] nums){\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int max=0;//最大边界\n    int step=0,curMaxIndex=0;\n    for (int i=0;i<nums.length-1;i++) {\n        curMaxIndex=Math.max(curMaxIndex,nums[i]+i); //i能跳的位置中,跳的最远的\n        if (i==max) {//走到边界就++\n            step++;\n            max=curMaxIndex;\n        }\n    }\n    return step;\n}\n```\n\n代码需要细细品，一下可能看不太明白\n\n**解法三**\n\n回顾的时候这道题始终是没搞清楚，[看了一个大佬的题解](https://leetcode-cn.com/problems/jump-game-ii/solution/xun-huan-bu-bian-shi-fen-xi-cban-by-huai-an-2/) （这个大佬好像是个初中的妹子）后明白了\n\n```java\n//参考了一个大佬循环不变表达式的分析\npublic int jump(int[] nums){\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    //当前这一跳能选择的最远距离\n    int left=0;\n    //目前能达到的最远距离\n    int right=0;\n    int ptr=0,step=0;\n    while (right<nums.length-1) {\n        left=right;\n        while(ptr<nums.length && ptr<=left) {\n            right=Math.max(right,nums[ptr]+ptr);\n            ptr++;\n        }\n        step++;\n    }\n    return step;\n}\n```\n## [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)\n\n给出一个区间的集合，请合并所有重叠的区间。\n\n**示例 1:**\n\n```java\n输入: [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n```\n\n\n**示例 2:**\n\n```java\n输入: [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n```\n\n**解法一**\n\n思路也没啥好说的，类似贪心吧\n\n```java\npublic int[][] merge(int[][] intervals) {\n    if (intervals ==null || intervals.length<=0) {\n        return new int[][]{};\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    LinkedList<int[]> list=new LinkedList<>();\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]<=intervals[i-1][1]) {\n            if (intervals[i][1]>intervals[i-1][1]) {\n                intervals[i][0]=intervals[i-1][0];   \n            }else{\n                intervals[i][0]=intervals[i-1][0];\n                intervals[i][1]=intervals[i-1][1];\n            }\n        }else{\n            list.add(intervals[i-1]);\n        }\n    }\n    list.add(intervals[intervals.length-1]);\n    /*  int[][] res=new int[list.size()][2];\n        for (int i=0;i<list.size();i++) {\n            res[i][0]=list.get(i)[0];\n            res[i][1]=list.get(i)[1];\n        }*/\n    return list.toArray(new int[0][0]); //题解哪里学到一招\n}\n```\n\n最大的收获就是学到了一招list转array的方法😁\n\n偶然看到，简化下代码\n\n```java\n//update：2020.4.16\n//偶然看到,简化下代码\npublic int[][] merge(int[][] intervals) {\n    if (intervals ==null || intervals.length<=0) {\n        return new int[][]{};\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    LinkedList<int[]> list=new LinkedList<>();\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]<=intervals[i-1][1]) {\n            intervals[i][0]=intervals[i-1][0];\n            intervals[i][1]=Math.max(intervals[i-1][1],intervals[i][1]);\n        }else{\n            list.add(intervals[i-1]);\n        }\n    }\n    list.add(intervals[intervals.length-1]);\n    return list.toArray(new int[0][0]);\n}\n```\n一开始还没注意这个解法，现在回头看看这个方法挺妙的，当无法覆盖的时候将`intervals[i-1]` 入栈，当可以覆盖的时候修改当前元素值，在下一轮继续添加或覆盖，其实还是有一点点不好理解，刚刚又重写了一个，思路很直白\n\n```java\npublic int[][] merge(int[][] intervals) {\n    if(intervals==null || intervals.length<=0) return intervals;\n    Arrays.sort(intervals,(a,b)->a[0]!=b[0]?a[0]-b[0]:a[1]-b[1]);\n    List<int[]> res=new ArrayList<>();\n    res.add(intervals[0]);\n    for(int i=1;i<intervals.length;i++){\n        int[] pre=res.get(res.size()-1);\n        if(intervals[i][0]<=pre[1]){\n            if(intervals[i][1]>=pre[1]){\n                pre[1]=intervals[i][1];\n            }\n        }else{\n            res.add(intervals[i]);\n        }\n    }\n    return res.toArray(new int[0][0]);\n}\n```\n## [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)\n\nDifficulty: **中等**\n\n\n字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。\n\n**示例 1：**\n\n```go\n输入：S = \"ababcbacadefegdehijhklij\"\n输出：[9,7,8]\n解释：\n划分结果为 \"ababcbaca\", \"defegde\", \"hijhklij\"。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 的划分是错误的，因为划分的片段数较少。\n```\n\n**提示：**\n\n*   `S`的长度在`[1, 500]`之间。\n*   `S`只包含小写字母 `'a'` 到 `'z'` 。\n\n\n**解法一**\n\n我一开始的想法就是先统计出所有26个字母出现的首位置和末位置，然后题目就变成了[合并区间](#56-合并区间)，但是其实不需要真正的合并，这里只需要求长度就行了\n```golang\nfunc partitionLabels(S string) []int {\n    var m = make(map[byte]int)\n    var Max = func(a, b int) int {if a>b{return a};return b}\n    for i := 0; i < len(S); i++ {\n        m[S[i]] = i\n    }\n    var start, end = 0, 0\n    var res []int\n    for i := 0; i < len(S); i++ {\n        //更新当前区间结尾最大值\n        end = Max(end, m[S[i]])\n        //走到当前区间结尾，当前区间结束\n        if i==end {\n            res = append(res, end-start+1)\n            start = i+1\n        }\n    }\n    return res\n}\n```\n代码意思很明确，多看看就明白了\n\n## [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)\n\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n注意:\n\n- 可以认为区间的终点总是大于它的起点。\n- 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n**示例 1:**\n\n```java\n输入: [ [1,2], [2,3], [3,4], [1,3] ]\n\n输出: 1\n\n解释: 移除 [1,3] 后，剩下的区间没有重叠。\n```\n\n**示例 2:**\n\n```java\n输入: [ [1,2], [1,2], [1,2] ]\n\n输出: 2\n\n解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n```\n\n**示例 3:**\n\n```java\n输入: [ [1,2], [2,3] ]\n\n输出: 0\n\n解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n```\n\n**解法一**\n\n动态规划，其实和最长递增子序列是一样的\n\n> 和[最长数对链](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE)一摸一样\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    int[]dp=new int[intervals.length];\n    int max=-1;\n    for (int i=0;i<intervals.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if(intervals[i][0]>=intervals[j][1]){\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n        max=Math.max(max,dp[i]);\n    }\n    return intervals.length-max;\n}\n```\n先根据左边界排个序，保证后面的不会覆盖前面的，然后反手求一下最长的无重叠区间长度，和最长递增子序列一样，最后用总长度减去这个最长的区间长度结果就是答案\n\n171ms，8%，感觉快要过不了了。。。本来是是写的记忆化递归的，结果过不了。。。卡在倒数第二个case上\n\n**记忆化递归写法**\n\n```java\nHashMap<Pair,Integer> cache=new HashMap<>();//TLE\n\npublic int eraseOverlapIntervals2(int[][] intervals) {\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    return intervals.length-dfs(intervals,0,Integer.MIN_VALUE);\n}\n\n//背包问题,返回最多可以留下的区间\npublic int dfs(int[][] intervals,int index,int prev) {\n    if (index==intervals.length) {\n        return 0;\n    }\n    Pair key=new Pair(index,prev);\n    if (cache.containsKey(key)) {\n        return cache.get(key);\n    }\n    int res=dfs(intervals,index+1,prev);\n    if (intervals[index][0]>=prev) {\n        res=Math.max(res,dfs(intervals,index+1,intervals[index][1])+1);\n    }\n    cache.put(key,res);\n    return res;\n}\n```\n**解法二**\n\n贪心，时间复杂度降低为线性\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    //按照起点排序,重叠的时候选择保留结尾小的那一个\n    //Arrays.sort(intervals,(a,b)->a[0]-b[0]); lambda初始化效率会低一点\n    Arrays.sort(intervals,new Comparator<int[]>(){\n        @Override\n        public int compare(int[] a,int[] b){\n            return a[0]-b[0];\n        }\n    });\n    int res=1;\n    int prev=0;\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]>=intervals[prev][1]) {\n            res++;\n            prev=i;\n        }else if(intervals[i][1]<intervals[prev][1]){\n            prev=i; //选择结尾小的那一个\n        }\n    }\n    return intervals.length-res;\n}\n```\n按照起点排序，在重叠的时候优先选择结尾小的哪一个，这样就可能得到更多的区间组合\n\n## [1288. 删除被覆盖区间](https://leetcode-cn.com/problems/remove-covered-intervals/)\n\nDifficulty: **中等**\n\n\n给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。\n\n只有当 `c <= a` 且 `b <= d` 时，我们才认为区间 `[a,b)` 被区间 `[c,d)` 覆盖。\n\n在完成所有删除操作后，请你返回列表中剩余区间的数目。\n\n**示例：**\n\n```go\n输入：intervals = [[1,4],[3,6],[2,8]]\n输出：2\n解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。\n```\n\n**提示：**​​​​​​\n\n*   `1 <= intervals.length <= 1000`\n*   `0 <= intervals[i][0] < intervals[i][1] <= 10^5`\n*   对于所有的 `i != j`：`intervals[i] != intervals[j]`\n\n\n**解法一**\n\n思路比较直白\n```golang\nfunc removeCoveredIntervals(intervals [][]int) int {\n    sort.Slice(intervals, func (i int, j int) bool {\n        if intervals[i][0] == intervals[j][0] {\n            return intervals[i][1] > intervals[j][1]\n        }\n        return intervals[i][0] < intervals[j][0]\n    })\n    var Max = func(a, b int) int {if a>b {return a};return b}\n    var count = 0\n    var maxRight = intervals[0][1]\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i][1] <= maxRight {\n            count++\n        }\n        maxRight = Max(maxRight, intervals[i][1])\n    }\n    return len(intervals)-count\n}\n```\n\n## [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)\n\nDifficulty: **中等**\n\n\n在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在10<sup>4</sup>个气球。\n\n一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 x<sub style=\"display: inline;\">start，</sub>x<sub style=\"display: inline;\">end，</sub> 且满足  x<sub style=\"display: inline;\">start</sub> ≤ x ≤ x<sub style=\"display: inline;\">end，</sub>则该气球会被引爆<sub style=\"display: inline;\">。</sub>可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。\n\n**Example:**\n\n```go\n输入:\n[[10,16], [2,8], [1,6], [7,12]]\n\n输出:\n2\n\n解释:\n对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。\n```\n\n**解法一**\n\n和前面几题一样，按照起点排序，发生重叠时记录小的Xend，实际上end的含义就是当前这一箭能射穿前面所有气球的最远距离，后面的气球如果大于这个距离就需要加一箭，否则就可以一并射穿\n```golang\nfunc findMinArrowShots(points [][]int) int {\n    if len(points) <= 0 {\n        return 0\n    }\n    sort.Slice(points, func(i int, j int) bool {\n        return points[i][0] < points[j][0]\n    })\n    var end = points[0][1]\n    var res = 1\n    for i := 1; i < len(points); i++ {\n        if points[i][0] > end {\n            res++\n            end = points[i][1]\n        }else{\n            end = Min(end, points[i][1])\n        }\n    }\n    return res\n}\n​\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n**解法二**\n\n按照终点排序\n```golang\nfunc findMinArrowShots(points [][]int) int {\n    if len(points) <= 0 {\n        return 0\n    }\n    sort.Slice(points, func(i int, j int) bool {\n        return points[i][1] < points[j][1]\n    })\n    var end = points[0][1]\n    var res = 1\n    for i := 1; i < len(points); i++ {\n        if points[i][0] > end {\n            res++\n            end = points[i][1]\n        }\n    }\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n```\n\n## [1024. 视频拼接](https://leetcode-cn.com/problems/video-stitching/)\n\n你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。\n\n视频片段 `clips[i]` 都用区间进行表示：开始于 `clips[i][0]` 并于 `clips[i][1]` 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 `[0, 1] + [1, 3] + [3, 7]` 三部分。\n\n我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。\n\n**示例 1：**\n\n```java\n输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10\n输出：3\n解释：\n我们选中 [0,2], [8,10], [1,9] 这三个片段。\n然后，按下面的方案重制比赛片段：\n将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。\n现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。\n```\n\n**示例 2：**\n\n```java\n输入：clips = [[0,1],[1,2]], T = 5\n输出：-1\n解释：\n我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。\n```\n\n**示例 3：**\n\n```java\n输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9\n输出：3\n解释： \n我们选取片段 [0,4], [4,7] 和 [6,9] 。\n```\n\n**示例 4：**\n\n```java\n输入：clips = [[0,4],[2,8]], T = 5\n输出：2\n解释：\n注意，你可能录制超过比赛结束时间的视频。\n```\n\n**提示：**\n\n- `1 <= clips.length <= 100`\n- `0 <= clips[i][0], clips[i][1] <= 100`\n- `0 <= T <= 100`\n\n**解法一**\n\n感觉这个贪心还是很经典的，很多题都是这个思路，上面的 跳跃游戏2，包括172周赛的最后一题，都是这个类似的区间覆盖问题\n\n```java\npublic int videoStitching(int[][] clips, int T) {\n    Arrays.sort(clips,(a,b)->a[0]-b[0]);\n    int i=0,res=0,last=0;\n    while(i<clips.length) {\n        int temp=last;\n        while(i<clips.length&&clips[i][0]<=temp) {\n            last=Math.max(last,clips[i][1]);\n            i++;\n        }\n        if (last==temp) { //没有找到能覆盖的\n            return -1;\n        }\n        res++;\n        if (last>=T) {\n            return res;\n        }\n    }\n    return -1;\n}\n```\n\n首先按照左边界排序，然后找的时候**每次都在序列中找能覆盖`overlap`上一次右边界的最长区间** ，第一次覆盖其实就是找的左边界能覆盖0的最长的区间，然后下一次就要找能覆盖这个区间右边界的最长的区间。最终的结果就是最少的区间数目，正确性这里其实思考一下就知道了，每次都选择最优区间，对后面的选择没有负面影响，具体如何证明还是留给大佬们吧\n\n## [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)\n\n假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对` (h, k) `表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。\n\n注意：\n总人数少于1100人。\n\n**示例**\n\n```java\n输入:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\n输出:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n```\n\n**解法一**\n\n贪心，没想出来\n\n```java\npublic int[][] reconstructQueue(int[][] people) {\n    if (people==null ||people.length<=0) {\n        return new int[0][0];\n    }\n    List<int[]> res=new LinkedList<>();\n    Arrays.sort(people,(p1,p2)->p1[0]!=p2[0]?p2[0]-p1[0]:p1[1]-p2[1]);\n    for (int i=0;i<people.length;i++) {\n        res.add(people[i][1],people[i]);\n    }\n    return res.toArray(new int[0][0]);\n}\n```\n\n首先对身高h降序，k升序进行排列得到，然后将元素`（h，k）`插入前面比它大的元素中的第k个位置，保证该元素前面有k个比当前元素大的，使之合法，**后面的比它矮的元素的移动对前面其实的没有任何影响**，这个算法的正确性很容易想到，身高高的人是看不到身高矮的人的~，也就是身高矮的人在身高高的人前或后对身高高的人是没有任何影响的\n\n```java\n[7,0] [7,1] [6,1] [5,0] [5,2] [4,4]\n\n[]                (7,0) -> []\n0                 (7,1) -> [7,0]\n0 1               (6,1) -> [7,0] [7,1]\n0 1 2             (5,0) -> [7,0] [6,1] [7,1]\n0 1 2 3           (5,2) -> [5,0] [7,0] [6,1] [7,1]\n0 1 2 3 4         (4,4) -> [5,0] [7,0] [5,2] [6,1] [7,1]\n0 1 2 3 4 5                [5,0] [7,0] [5,2] [6,1] [4,4] [7,1]\n```\n\n## [1262. 可被三整除的最大和](https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/)\n\n给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。\n\n**示例 1：**\n\n```java\n输入：nums = [3,6,5,1,8]\n输出：18\n解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。\n```\n\n\n**示例 2：**\n\n```java\n输入：nums = [4]\n输出：0\n解释：4 不能被 3 整除，所以无法选出数字，返回 0。\n```\n\n**示例 3：**\n\n```java\n输入：nums = [1,2,3,4,4]\n输出：12\n解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 4 * 10^4`\n- `1 <= nums[i] <= 10^4`\n\n**解法三**\n\nO(NlogN)贪心，最优解法应该是dp，放在dp[专题中](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/)\n\n```java\npublic int maxSumDivThree3(int[] nums) {\n    int sum=0;\n    List<Integer> one=new ArrayList<>();\n    List<Integer> two=new ArrayList<>();\n    for (int n:nums) {\n        sum+=n;\n        if (n%3==1) one.add(n);\n        if (n%3==2) two.add(n);\n    }\n    Collections.sort(one);\n    Collections.sort(two);\n    if (sum%3==1) { //移除一个余数为1的 或者两个余数为2的\n        return Math.max(one.size()>=1?sum-one.get(0):0,two.size()>=2?sum-two.get(0)-two.get(1):0);\n    }\n    if (sum%3==2) { //移除一个余数为2 或者两个余数为1的\n        return Math.max(two.size()>=1?sum-two.get(0):0,one.size()>=2?sum-one.get(0)-one.get(1):0);   \n    }\n    return sum;\n}\n```\n\n如果总和%3=1我们就可以移除数组中%3=1的最小那个或者移除两个%3=2的最小的，同理，总和%3=2，我们可以移除一个最小的%2=0的元素，或者移除两个%2=1的最小元素\n\n这里我们需要记录的仅仅是数组中%3=1和%3=2的最小的4个值就ok，其实不用排序就可以，直接O(N)遍历就行，嫌麻烦没改，后面有时间来改改\n\n**解法二**\n\n履行上面的承诺，改好了一版O(N)的贪心解法\n\n```java\npublic int maxSumDivThree(int[] nums) {\n    int M=0x3f3f3f3f;\n    //余1最小值\n    int min1_0=M,min1_1=M;\n    //余2最小值\n    int min2_0=M,min2_1=M;\n    int sum=0;\n    for(int i=0;i<nums.length;i++){\n        sum+=nums[i];\n        if(nums[i]%3==1){\n            if(nums[i]<=min1_0){\n                min1_1=min1_0; //更新次小值\n                min1_0=nums[i]; //更新最小值\n            }else if(nums[i]<=min1_1){\n                min1_1=nums[i]; //更新次小值\n            }\n        }\n        if(nums[i]%3==2){\n            if(nums[i]<=min2_0){\n                min2_1=min2_0;\n                min2_0=nums[i];\n            }else if(nums[i]<=min2_1){\n                min2_1=nums[i];\n            }\n        }\n    }\n    if(sum%3==1) return sum-Math.min(min2_0+min2_1,min1_0);\n    if(sum%3==2) return sum-Math.min(min1_0+min1_1,min2_0);\n    return sum;\n}\n```\n\n## [5172. 形成三的最大倍数](https://leetcode-cn.com/problems/largest-multiple-of-three/)\n\n给你一个整数数组 `digits`，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。\n\n由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。\n\n如果无法得到答案，请返回一个空字符串。\n\n**示例 1：**\n\n```java\n输入：digits = [8,1,9]\n输出：\"981\"\n```\n\n\n**示例 2：**\n\n```java\n输入：digits = [8,6,7,1,0]\n输出：\"8760\"\n```\n\n\n**示例 3：**\n\n```java\n输入：digits = [1]\n输出：\"\"\n```\n\n\n**示例 4：**\n\n```java\n输入：digits = [0,0,0,0,0,0]\n输出：\"0\"\n```\n\n**提示：**\n\n- 1 <= digits.length <= 10^4\n- 0 <= digits[i] <= 9\n- 返回的结果不应包含不必要的前导零。\n\n**解法一**\n\n177周赛的T4，时隔多日，周赛又出了这一题，和上面一样，思路差不多的，需要优先考虑只删除一个的情况\n\n```java\npublic String largestMultipleOfThree(int[] digits) {\n    int sum=0;\n    int[] freq=new int[10];\n    for(int i=0;i<digits.length;i++) {\n        sum+=digits[i];\n        freq[digits[i]]++;\n    }\n    if(sum==0) return \"0\";\n    //删除一个余1的或者两个余2的,优先删除一个余1的\n    //删除1个得到的结果肯定比删除2个大\n    if(sum%3==1){ \n        if(!deleteMin(freq,1)){ \n            deleteMin(freq,2);\n            deleteMin(freq,2);\n        }\n    }\n    if(sum%3==2){ //删除一个余2的或者两个余1的\n        if(!deleteMin(freq,2)){\n            deleteMin(freq,1);\n            deleteMin(freq,1);\n        }   \n    }\n    StringBuilder res=new StringBuilder();\n    //逆序构建结果\n    for(int i=9;i>=0;i--){\n        int count=freq[i];\n        while(count-- >0){\n            res.append(i);\n        }\n    }\n    return res.toString();\n}\n\npublic boolean deleteMin(int[] freq,int y){\n    for (int i=y;i<9;i+=3) {\n        if (freq[i]!=0) {\n            freq[i]--;\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## [1111. 有效括号的嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)\n\n迷惑题，不想粘题目了\n\n**解法一**\n\n按照深度的奇偶划分两个子串。。。。\n\n```java\npublic int[] maxDepthAfterSplit(String seq) {\n    //Deque<Character> stack=new ArrayDeque<>();\n    int depth=0;\n    int[] res=new int[seq.length()];\n    for (int i=0;i<seq.length();i++) {\n        if(seq.charAt(i)=='('){\n            res[i]=depth++%2;\n        }else{\n            //根据左括号奇偶判断\n            res[i]=--depth%2;\n        }\n    }\n    return res;\n}\n```\n\n## [1353. 最多可以参加的会议数目](https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/) \n\n给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。\n\n你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。\n\n请你返回你可以参加的 最大 会议数目。\n\n**示例 1：**\n\n![JELWN9.png](https://s1.ax1x.com/2020/04/17/JELWN9.png)\n\n```java\n输入：events = [[1,2],[2,3],[3,4]]\n输出：3\n解释：你可以参加所有的三个会议。\n安排会议的一种方案如上图。\n第 1 天参加第一个会议。\n第 2 天参加第二个会议。\n第 3 天参加第三个会议。\n```\n\n**示例 2：**\n\n```java\n输入：events= [[1,2],[2,3],[3,4],[1,2]]\n输出：4\n```\n\n**示例 3：**\n\n```java\n输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]]\n输出：4\n```\n\n**示例 4：**\n\n```java\n输入：events = [[1,100000]]\n输出：1\n```\n\n**示例 5：**\n\n```java\n输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]\n输出：7\n```\n\n**提示：**\n\n- `1 <= events.length <= 10^5`\n- `events[i].length == 2`\n- `1 <= events[i][0] <= events[i][1] <= 10^5`\n\n**解法一**\n\n暴力贪心\n\n```java\n//[[1,4],[4,4],[2,2],[3,4],[1,1]]\n// 1,1  2,2  1,4  3,4  4,4\n// 暴力贪心，按结束时间排序，优先安排结束时间短的，O(N^2)\npublic int maxEvents(int[][] events) {\n    if(events==null || events.length<=0) return 0;\n    Arrays.sort(events,(e1,e2)->e1[1]-e2[1]);\n    //当天有没有安排会议\n    HashSet<Integer> set=new HashSet<>();\n    int count=0;\n    for(int i=0;i<events.length;i++){\n        int start=events[i][0];\n        int end=events[i][1];\n        for(int j=start;j<=end;j++){ //在对应时间段内进行安排\n            if(!set.contains(j)){\n                set.add(j);\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n**解法二**\n\n```java\n//优先队列优化，NlogN\npublic int maxEvents(int[][] events) {\n    if(events==null || events.length<=0) return 0;\n    Arrays.sort(events,(e1,e2)->e1[0]-e2[0]);\n    //结束时间构建小根堆\n    PriorityQueue<Integer> pq=new PriorityQueue<>();\n    int index=0,res=0,n=events.length;\n    int curDay=1;\n    while(index<n || !pq.isEmpty()){\n        //将当天开始的会议的结束时间加入小根堆\n        while(index<n && curDay==events[index][0]){\n            pq.add(events[index++][1]);\n        }\n        //将过期会议的移除\n        while(!pq.isEmpty() && pq.peek()<curDay){\n            pq.poll();\n        }\n        //优先选择结束时间最短的\n        if(!pq.isEmpty()){\n            pq.poll();\n            res++;\n        }\n        curDay++; //安排下一天\n    }\n    return res;\n}\n```\n\n## [134. 加油站](https://leetcode-cn.com/problems/gas-station/)\n\n在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n\n如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\n\n**说明:** \n\n- 如果题目有解，该答案即为唯一答案。\n- 输入数组均为非空数组，且长度相同。\n- 输入数组中的元素均为非负数。\n\n**示例 1:**\n\n```java\n输入: \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\n输出: 3\n\n解释:\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。\n```\n\n**示例 2:**\n\n```java\n输入: \ngas  = [2,3,4]\ncost = [3,4,3]\n\n输出: -1\n\n解释:\n你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。\n```\n\n**解法一**\n\n```go\nfunc canCompleteCircuit(gas []int, cost []int) int {\n    n:=len(gas)\n    curGas:=0 //当前油量\n    start:=0 //起点\n    total:=0 //gas和cost之差,小于0的话肯定无法绕圈\n    for i:=start;i<n;i++{\n        curGas+=(gas[i]-cost[i])\n        total+=(gas[i]-cost[i])\n        //油量不够，i无法继续前进到i+1,说明从start~i无法绕环\n        if curGas<0{ \n            start=i+1\n            curGas=0\n        }\n    }\n    if total<0{\n        return -1\n    }\n    return start\n}\n```\n\n## [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n- 如果 `x == y`，那么两块石头都会被完全粉碎；\n- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n\n最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。\n\n**示例：**\n\n```java\n输入：[2,7,4,1,8,1]\n输出：1\n解释：\n先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，\n再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，\n接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，\n最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。\n```\n\n**提示：**\n\n1. `1 <= stones.length <= 30`\n2. `1 <= stones[i] <= 1000`\n\n**解法一**\n\n虽然tag有贪心，但是并不是贪心。。。直接模拟就行了，反而是这题的[进阶版本](https://leetcode-cn.com/problems/last-stone-weight-ii/)，我以为可以这样贪心过，结果发现不对\n\n```java\npublic int lastStoneWeight(int[] stones) {\n    if(stones==null ||stones.length<=0){\n        return 0;\n    }\n    PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a);\n    for(int i=0;i<stones.length;i++){\n        pq.add(stones[i]);\n    }\n    //NlogN\n    while(pq.size()>1){\n        int y=pq.poll();\n        int x=pq.poll();\n        pq.add(y-x);\n    }\n    return pq.poll();\n}\n```\n## [920. 会议室(LintCode)](https://www.lintcode.com/problem/meeting-rooms/description)\n\n给定一系列的会议时间间隔，包括起始和结束时间[[s1,e1]，[s2,e2]，…(si < ei)，确定一个人是否可以参加所有会议。\n- (0,8),(8,10)在8这这一时刻不冲突\n\n**样例1**\n\n```go\n输入: intervals = [(0,30),(5,10),(15,20)]\n输出: false\n解释:\n(0,30), (5,10) 和 (0,30),(15,20) 这两对会议会冲突\n```\n**样例2**\n```go\n输入: intervals = [(5,8),(9,15)]\n输出: true\n解释:\n这两个时间段不会冲突\n```\n\n**解法一**\n\n这个比较简单，排序后判断相邻的区间是否会覆盖就行了\n```golang\nimport \"sort\"\n\nfunc canAttendMeetings (intervals []*Interval) bool {\n    // Write your code here\n    sort.Slice(intervals, func(i int, j int) bool {\n        return intervals[i].Start < intervals[j].Start\n    })\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i].Start < intervals[i-1].End {\n            return false\n        }\n    }\n    return true\n}\n```\n\n## [919. 会议室 II(LintCode)](https://www.lintcode.com/problem/meeting-rooms-ii/description)\n\n给定一系列的会议时间间隔intervals，包括起始和结束时间[[s1,e1],[s2,e2],...] (si < ei)，找到所需的最小的会议室数量。\n\n**样例1**\n```go\n输入: intervals = [(0,30),(5,10),(15,20)]\n输出: 2\n解释:\n需要两个会议室\n会议室1:(0,30)\n会议室2:(5,10),(15,20)\n```\n\n**样例2**\n```go\n输入: intervals = [(2,7)]\n输出: 1\n解释:\n只需要1个会议室就够了\n```\n\n**解法一**\n\n扫描线的做法，感觉比较简单，也比较好理解（这应该属于最简单的扫描线吧，我看了其他的一些扫描线啥的都是acm里面的内容）\n![mark](http://static.imlgw.top/blog/20200810/nQveo3X6eKxI.png?imageslim)\n类似就是上图样子，求一个最大的有重合的区间数量，先将起点终点打散后排序，扫描的时候就按照排序后的节点来一个个扫描，然后根据节点的属性来判断是应该+1还是-1，如果是起点就+1，如果遇到终点就-1，整个过程就像是一条线从左往右扫描过去一样\n```golang\n/**\n * Definition of Interval:\n * type Interval struct {\n *     Start, End int\n * }\n */\n\n/**\n * @param intervals: an array of meeting time intervals\n * @return: the minimum number of conference rooms required\n */\nimport \"sort\"\n\ntype Pair struct{\n    time int\n    isEnd bool\n}\n\nfunc minMeetingRooms (intervals []*Interval) int {\n    var n = len(intervals)\n    var list []*Pair\n    var Max = func (a,b int) int {if a>b {return a};return b}\n    for i := 0; i < n; i++ {\n        list = append(list, &Pair{intervals[i].Start,false})\n        list = append(list, &Pair{intervals[i].End,true})\n    }\n    sort.Slice(list, func (i int, j int) bool {\n        return list[i].time < list[j].time\n    })\n    var res = 0\n    var count = 0\n    for _, p := range list {\n        if p.isEnd{\n            count--\n        }else{\n            count++\n        }\n        res = Max(count, res)\n    }\n    return res\n}\n```\n**解法二**\n\n排序+小根堆，按起点排序，然后遍历所有区间，如果某个区间的start大于堆顶的结束时间，说明这两个会议可以公用一个会议室，所以将堆顶弹出，然后将当前会议加入堆中，所以最后堆的大小就是会议室的数量\n```java\n//小根堆的思路\npublic int minMeetingRooms(List<Interval> intervals) {\n    // Write your code here\n    Collections.sort(intervals,(i1,i2)->i1.start-i2.start);\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    pq.add(intervals.get(0).end);\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals.get(i).start > pq.peek()) {\n            pq.poll();\n        }\n        pq.add(intervals.get(i).end);\n    }\n    return pq.size();\n}\n```\n个人感觉这个思路还是没有上面扫描线简单好理解\n\n## [391. 数飞机(LintCode)](https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/description)\n\n给出飞机的起飞和降落时间的列表，用序列 interval 表示. 请计算出天上同时最多有多少架飞机？\n\n**样例 1:**\n```go\n输入: [(1, 10), (2, 3), (5, 8), (4, 7)]\n输出: 3\n解释: \n第一架飞机在1时刻起飞, 10时刻降落.\n第二架飞机在2时刻起飞, 3时刻降落.\n第三架飞机在5时刻起飞, 8时刻降落.\n第四架飞机在4时刻起飞, 7时刻降落.\n在5时刻到6时刻之间, 天空中有三架飞机.\n```\n**样例 2:**\n```go\n输入: [(1, 2), (2, 3), (3, 4)]\n输出: 1\n解释: 降落优先于起飞.\n```\n\n**解法一**\n\n和会议室一摸一样，代码稍微改动一点，排序规则需要遵循降落有限\n```golang\n/**\n * Definition of Interval:\n * type Interval struct {\n *     Start, End int\n * }\n */\n\n/**\n * @param airplanes: An interval array\n * @return: Count of airplanes are in the sky.\n */\nimport \"sort\"\n\ntype Pair struct {\n    time  int\n    isEnd bool\n}\n\nfunc countOfAirplanes(airplanes []*Interval) int {\n    var n = len(airplanes)\n    var list []*Pair\n    var Max = func(a, b int) int {\n        if a > b {\n            return a\n        }\n        return b\n    }\n    for i := 0; i < n; i++ {\n        list = append(list, &Pair{airplanes[i].Start, false})\n        list = append(list, &Pair{airplanes[i].End, true})\n    }\n    //[(1, 2), (2, 3), (3, 4)]\n    //随意排序： 1 2start 2end 3start 3end 4 这样最大值就是2，不对\n    //所以应该降落优先，将降落时间点的排在前面\n    sort.Slice(list, func(i int, j int) bool {\n        if list[i].time == list[j].time {\n            //将end放在前面\n            return list[i].isEnd\n        }\n        return list[i].time < list[j].time\n    })\n    var res = 0\n    var count = 0\n    for _, p := range list {\n        if p.isEnd {\n            count--\n        } else {\n            count++\n        }\n        res = Max(count, res)\n    }\n    return res\n}\n```\n当然同样可以使用堆，这里就不多写了\n\n## [NC531.递增数组](https://www.nowcoder.com/practice/d0907f3982874b489edde5071c96754a)\n\n牛牛有一个数组array，牛牛可以每次选择一个连续的区间，让区间的数都加1，他想知道把这个数组变为严格单调递增，最少需要操作多少次？\n- 1 <= array.size <= 2*10^5\n- 1 <= array[i] <= 1*10^9\n\n**示例1**\n```go\n输入: [1,2,1]\n输出: 2\n说明: 把第三个数字+2可以构成1，2，3\n```\n**解法一**\n\n```java\npublic long IncreasingArray (int[] array) {\n    // write code here\n    long res = 0;\n    for (int i = 1; i < array.length; i++){\n        if (array[i] <= array[i-1]) {\n            res += array[i-1]-array[i]+1;\n        }\n    }\n    return res;\n}\n```\n虽然是easy，还是想了一会儿，我的想法就是当增加一个数的时候就连同**后面的所有数**一起增加，而增加一个数肯定是增加到前一个数+1的次数是最少的（当然我们也不用真的去加，因为后面的区间是整体++，而我们要求的操作次数只是个差值）\n其实很详细的证明我也给不出来，我只考虑了几种情况\n1. `i`后面的部分是单调递增的 3 1(i)  2  3，那么很明显这里和后面一起增加是最优选择\n2. `i`后面是部分是单调递减的 3 3(i)  2  1，那么同样，和后面的一起增加是最优选择，单独选择某一个区间都会导致整体的落差变大，使得后面没增加的部分需要增加的次数增加\n3. `i`后面先递增后递减 3 1(i)  2  1 同上 相当于 递增+递减 看做两部分，（1 2）同增，那么（2，1）也应该随之同增\n4. `i`后面先递减后递增 5 4(i) 3 5  递减+递增 也分成两部分\n\n## [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)\n\nDifficulty: **中等**\n\n给定一个非负整数&amp;nbsp;<code>N</code>，找出小于或等于&amp;nbsp;<code>N</code>&amp;nbsp;的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>\n\n<p>（当且仅当每个相邻位数上的数字&amp;nbsp;<code>x</code>&amp;nbsp;和&amp;nbsp;<code>y</code>&amp;nbsp;满足&amp;nbsp;<code>x &amp;lt;= y</code>&amp;nbsp;时，我们称这个整数是单调递增的。）</p>\n\n<p>\n\n给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。\n\n（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）\n\n**示例 1:**\n\n```go\n输入: N = 10\n输出: 9\n```\n\n**示例 2:**\n\n```go\n输入: N = 1234\n输出: 1234\n```\n\n**示例 3:**\n\n```go\n输入: N = 332\n输出: 299\n```\n\n**说明:** `N` 是在 `[0, 10^9]` 范围内的一个整数。\n\n<strong>示例 1:</strong></p>\n\n```go\n输入: N = 10\n输出: 9\n```\n\n<p><strong>示例 2:</strong></p>\n\n```go\n输入: N = 1234\n输出: 1234\n```\n\n<p><strong>示例 3:</strong></p>\n\n```go\n输入: N = 332\n输出: 299\n```\n\n<p><strong>说明:</strong> N是在<code>[0, 10^9]</code>范围内的一个整数。</p>\n\n**解法一**\n\n这题写了好几版，总感觉很简单，但是总是有case能把我卡住，最终的思路就是，**逆向遍历**这个数，如果某个数小于前面（左边）的数，那么将前面的数减一，然后记录下当前的下标，最终这个下标后面的数都要变成9\n```golang\n//322 -> 299\n//243 -> 239\n//3524 -> 499\n//332 -> 299\n//235854 235799\nfunc monotoneIncreasingDigits(N int) int {\n    var nums []int\n    //123\n    for N > 0 {\n        nums = append(nums, N%10)\n        N /= 10\n    }\n    var res = 0\n    var idx = -1\n    //213\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] < nums[i+1] {\n            idx = i\n            nums[i+1]--\n        }\n    }\n    for i := len(nums) - 1; i >= 0; i-- {\n        if i <= idx {\n            res = res*10 + 9\n        } else {\n            res = res*10 + nums[i]\n        }\n    }\n    return res\n}\n```","tags":["LeetCode","贪心"],"categories":["算法"]},{"title":"常用的一些工具和网站","url":"/2019/12/23/wo-chang-yong-de-yi-xie-gong-ju-he-wang-zhan/","content":"\n> 整理下我常用的一些工具和网站\n\n## 工具\n\n### PDFread\n\n一个pdf阅读器，绿色软件体积很小只有10M，很久之前在一个公共号上看见的，链接：https://pan.baidu.com/s/15MSlABLZkJHChako1GEGdA\n提取码：7a5i \n\n### BandZip\n\n解压缩的软件，比某`数字`压缩软件好用，比`7z`功能多而且好看(7z也不错)，挺良心的，至少没广告 [官网下载地址](https://www.bandisoft.com/bandizip/)(可能被Q)\n\n### MPic\n\n 图床神器，贼方便，会检测剪切板里的图片包括QQ截图，自动上传一键获取外链贼爽，不过`可惜`只能配合七牛云。[官网地址](http://mpic.lzhaofu.cn/)\n\n### Everything\n\n文件检索神器，速度很快体积很小。[下载地址](https://www.voidtools.com/zh-cn/)\n\n### FSCaptrue\n\n 截图工具，截长屏很方便，体积很小。[下载地址](https://www.appcgn.com/faststone-capture.html)\n\n### Typora\n\n 也是我现在编辑这篇文章用的编辑器，我也换了很多的`markdown`编辑器，最开始的_Yu writer_(一直没更新，bug挺多，更新后收费了)，然后 _markeditor_(这个还可以，但是在win上界面我有点看不习惯。。2.0不支持win,而且时不时弹窗授权)，中间还试过很多像什么小书匠，markpad，都是装完就卸了。。。现在换到Typora(之前也试过)越用越喜欢。\n\n### CCleaner\n\n垃圾清理软件，清注册表贼舒服操作比较简单，拒绝辣鸡软件残留（也是绿软）。链接：https://pan.baidu.com/s/1TrOYF2893FYHKjTlQbFykA 提取码：ql42 \n\n### Dism++\n\n跟上面的一样也是垃圾清理软件，但是这个不能瞎搞😀  [下载地址](https://www.chuyu.me/zh-Hans/index.html)\n\n### SwitchHosts\n\n快速修改hosts文件，我用这个主要是博客在本地跑的时候，因为图片加了防盗链加载不出来，用这个改了hosts。\n\n### TeamViewer\n\n远程帮人调试，改bug的时候用到，比QQ好用的多，QQ很卡而且一些关键操作不允许。\n\n### 夜神模拟器\n\nPC端模拟安卓手机，可以用来调试安卓。\n\n### DeskGo : \n\n[腾讯桌面整理](https://pc.qq.com/detail/5/detail_23125.html)，tx难得的良心软件，本来是QQ安全管家里面附带的，后来被单独提取出来了，没广告，没捆绑，占用小（几十M）。\n\n![mark](http://static.imlgw.top///20190414/Ch6k6LNP3CU2.png?imageslim)\n\n### 油猴： \n\n`tampermonkey`这个是要配合浏览器来使用的(谷歌或者极速360吧)，如果可以科学上网的话直接引用商城就搜得到\n\n![mark](http://static.imlgw.top///20190414/5ioOotVWEqJO.png?imageslim)\n\n它的骚操作可太多了：) [右转bi乎](https://zhuanlan.zhihu.com/p/32155254)![mark](http://static.imlgw.top///20190414/QIORRorFVAah.png?imageslim)\n\n\n\n没法科学上网可以去[这里](http://chromecj.com/web-development/2018-07/1468/download.html)下载\n\n###  天若OCR\n\n也是很良心的软件，没广告，绿软，体积小，5M，识别准确度也挺好的。\n\n链接：https://pan.baidu.com/s/198PUMdtLU-huU5U1oN9tMw \n提取码：vces \n\n### 微软输入法\n\nwin10平台上最好的输入法没有之一（Google输入法好像也可以），别用垃圾sg，前几天[社区](https://answers.microsoft.com/zh-hans/windows/forum/windows_10-update/systemserviceexception%E8%93%9D%E5%B1%8F/e5c0a131-a155-4cc0-a871-b6089d474313?rtAction=1553553854556)看到有人更新win10因为sg崩溃了。流氓软件贼他妈难卸载，经历过的人都知道。想不通为啥不用原生的输入法？\n\n### PotPlayer\n\n最好用，无广告，页面简洁，强大的解码器，能播放所有视频的播放器。（前身是KMPlayer）占用小，(微软自带的那个不能倍数播放。。。不然我也不会用这个)\n\n### MobaXterm\n\n(19-5-2)炒鸡好用的SSH客户端，功能强大，界面好看，也是个绿软，再也不用到处找Xshell的注册码了（而且我也不喜欢Xshell，我一直用的putty+winscp，现在发现这个可以直接结合putty和sinscp👍）\n\n![mark](http://static.imlgw.top///20190502/rKdNPEwUmstf.png?imageslim)\n\n### Multrin\n\ngithub上偶然发现的一个 [小项目](https://github.com/sentialx/multrin) ，将所有的tab聚合到一起让后提供一个快捷键快速切换，挺不错的。\n\n相比**alt+tab**，这个软件的优势就是会让桌面显得更加整洁\n\n### [UTools](https://u.tools/)\n\n也是挺不错的一款工具，一开始感觉占用比较大，后来想想其实没啥影响，然后用了一段时间，有一个图床的插件相当方便啊！\n\n### Navicat\n\n不用多说了吧\n\n链接：https://pan.baidu.com/s/1L7XgRnLAinUcAqx6oeNt0w \n提取码：9z54 \n\n## 网站\n\n### [改图宝](http://www.gaitubao.com/#) \n\n最开始时为了裁剪图片，后来发现还可以按照 指定大小压缩图片，也是个神器啊~\n\n### [CodeToImage](https://carbon.now.sh) \n\n可以把代码美化为好看的图片然后导出\n\n![c](http://static.imlgw.top///20190407/sAP81lBQEv3Q.png?imageslim)\n\n### [draw.io](https://www.draw.io/) \n\n在线画图工具，谁用谁知道，现在有离线版本的了\n\n### [在线免费抠图](https://www.gaoding.com/koutu)\n\n 很方便操作也很简单\n\n### [高清图片素材](https://alpha.wallhaven.cc/)\n\n  免费，高清，素材多，用来做壁纸什么的都挺不错\n\n### [unsplash](https://unsplash.com)\n\n 也是图片素材站\n\n### [img9无限图床](https://img9.top)\n\n  我现在都是用的七牛云，第三方的还是不放心（目前还正常，我博客的前几篇都是在这个上面），除此之外还有 `微博` 也是个好图床，\n\n### [SM.MS](https://sm.ms)\n\n 也是图床，比上面那个更专业，有api\n\n> 后续如果还有好的工具和网站会继续添加进来 😀","tags":["工具"],"categories":["工具"]},{"title":"字典树初探","url":"/2019/12/17/zi-dian-shu/","content":"\n## 字典树\n\n在计算机科学中，**trie**，又称**前缀树**或**字典树**，字典树设计的核心思想是空间换时间，所以数据结构本身比较消耗空间。但它利用了字符串的**共同前缀（Common Prefix）**作为存储依据，以此来节省存储空间，并加速搜索时间。Trie 的字符串搜索时间复杂度为 **O(m)**，m 为最长的字符串的长度，其查询性能与集合中的字符串的数量无关。其在搜索字符串时表现出的高效，使得特别适用于构建文本搜索和词频统计等应用\n\n### 性质\n\n与二分搜索树不同，**键不是直接保存在节点中，而是由节点在树中的位置决定**。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有**叶子节点**和部分内部节点所对应的键才有相关的值\n\n## 实现\n\n### 使用TreeMap实现\n\n```java\nimport java.util.*;\npublic class Trie{\n    private class Node{\n        public boolean isWord; //是否是一个完整单词\n        public TreeMap<Character,Node> next;\n\n        public Node(boolean isWord){\n            this.isWord = isWord;\n            next = new TreeMap<>();\n        }\n\n        public Node(){\n            this(false);\n        }\n    }\n\n    private Node root;\n\n    private int size;\n\n    public Trie(){\n        root=new Node();\n        size=0;\n    }\n\n    public int getSize(){\n        return size;\n    }\n\n    //向Trie中添加word\n    public void addLoop(String word){\n        Node cur=root;\n        for (int i=0;i<word.length();i++) {\n            char c=word.charAt(i);\n            if (cur.next.get(c)==null) {\n                cur.next.put(c,new Node());\n            }\n            cur=cur.next.get(c);\n        }\n        if (!cur.isWord) {\n            size++;\n            cur.isWord=true;\n        }\n    }\n\n    //递归的添加\n    public void add(String word){\n        add(root,word,0);\n    }\n\n    public void add(Node cur,String word,int index){\n        if (index==word.length()) {\n            if (!cur.isWord) {\n                size++;\n                cur.isWord=true;\n            }\n            return;\n        }\n        char c=word.charAt(index);\n        if (cur.next.get(c)==null) {\n            cur.next.put(c,new Node());\n        }\n        add(cur.next.get(c),word,index+1); //尾递归\n    }\n\n    //查询word是否在Trie中\n    public boolean contains(String word){\n        return contains(root,word,0);\n    }\n\n    public boolean contains(Node cur,String word,int index){\n        if (index==word.length()) {\n            return cur.isWord;\n        }\n        char c=word.charAt(index);\n        return cur.next.containsKey(c) && contains(cur.next.get(c),word,index+1);\n    }\n\n    //循环\n    public boolean containsLoop(String word){\n        Node cur=root;\n        for (int i=0;i<word.length();i++) {\n            Character c=word.charAt(i);\n            if (!cur.next.containsKey(c)) {\n                return false;   \n            }\n            cur=cur.next.get(c);\n        }\n        return cur.isWord;\n    }\n\n    //是否有某个前缀\n    public boolean hasPerfix(String perfix){\n        return hasPerfix(root,perfix,0);\n    }\n\n    public boolean hasPerfix(Node cur,String perfix,int index){\n        if (index==perfix.length()) {\n            return true;\n        }\n        char c=perfix.charAt(index);\n        return cur.next.containsKey(c) && hasPerfix(cur.next.get(c),perfix,index+1);\n    }\n\n    //懒得写循环了。。。\n}\n```\n\n整体上来说其实很简单，这里用的是TreeMap来存储当前节点的下一层节点，可以看到，在Node中并没有直接存储某个字符，而是对应了TreeMap的Key，但是由于TreeMap底层是红黑树，其实在数据量比较小的时候并没有优势，所以在某些情况下，我们也可以直接使用数组来存储节点，比如下面这道题\n\n## LeetCode练手例题\n\n### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n\n实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。\n\n**示例:**\n\n```java\nTrie trie = new Trie();\n\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 true\ntrie.search(\"app\");     // 返回 false\ntrie.startsWith(\"app\"); // 返回 true\ntrie.insert(\"app\");   \ntrie.search(\"app\");     // 返回 true\n```\n\n**说明:**\n\n- 你可以假设所有的输入都是由小写字母 a-z 构成的。\n- 保证所有输入均为非空字符串\n\n**解法一**\n\n```java\nclass Trie {\n    private class Node{\n        public boolean isWord; //是否是一个完整单词\n        public Node[] next;\n\n        public Node(boolean isWord){\n            this.isWord = isWord;\n            next = new Node[26];\n        }\n\n        public Node(){\n            this(false);\n        }\n    }\n\n    private Node root;\n\n    /** Initialize your data structure here. */\n    public Trie() {\n        root=new Node();\n    }\n    \n    /** Inserts a word into the trie. */\n    public void insert(String word) {\n        insert(root,word,0);\n    }\n    \n    public void insert(Node cur,String word,int index){\n        if (index==word.length()) {\n            if (!cur.isWord) {\n                cur.isWord=true;\n            }\n            return;\n        }\n        char c=word.charAt(index);\n        if (cur.next[c-'a']==null) {\n            cur.next[c-'a']=new Node();\n        }\n        insert(cur.next[c-'a'],word,index+1); //尾递归\n    }\n\n    /** Returns if the word is in the trie. */\n    public boolean search(String word) {\n        return search(root,word,0);\n    }\n    \n    public boolean search(Node cur,String word,int index){\n        if (index==word.length()) {\n            return cur.isWord;\n        }\n        char c=word.charAt(index);\n        return cur.next[c-'a']!=null&& search(cur.next[c-'a'],word,index+1);\n    }\n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    public boolean startsWith(String prefix) {\n        return startsWith(root,prefix,0);\n    }\n    \n    public boolean startsWith(Node cur,String prefix,int index){\n        if (index==prefix.length()) {\n            return true;\n        }\n        char c=prefix.charAt(index);\n        return cur.next[c-'a']!=null && startsWith(cur.next[c-'a'],prefix,index+1);\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n```\n\n这里题目说明了所有的输入都是小写字符，所以可以直接使用固定大小的Node数组来实现，相比于上面的TreeMap时间空间上都会有很大的提升\n\n### [211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/)\n\n设计一个支持以下两种操作的数据结构：\n\n```java\nvoid addWord(word)\nbool search(word)\n```\n\n`search(word)` 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 `.` 可以表示任何一个字母。\n\n**示例:**\n\n```java\naddWord(\"bad\")\naddWord(\"dad\")\naddWord(\"mad\")\nsearch(\"pad\") -> false\nsearch(\"bad\") -> true\nsearch(\".ad\") -> true\nsearch(\"b..\") -> true\n```\n\n\n**说明:**\n\n你可以假设所有单词都是由小写字母 `a-z` 组成的。\n\n**解法一**\n\n```java\nprivate class Node{\n    public boolean isWord; //是否找到了一个单词\n    public Node[] next;\n\n    public Node(boolean isWord){\n        this.isWord = isWord;\n        next = new Node[26];\n    }\n\n    public Node(){\n        this(false);\n    }\n}\n\nprivate Node root;\n\n/** Initialize your data structure here. */\npublic WordDictionary() {\n    root=new Node();\n}\n\n/** Adds a word into the data structure. */\npublic void addWord(String word) {\n    addWord(root,word,0);\n}\n\npublic void addWord(Node cur,String word,int index) {\n    if (index == word.length()) {\n        cur.isWord=true;\n        return;\n    }\n    char c=word.charAt(index);\n    if (cur.next[c-'a']==null) {\n        cur.next[c-'a']= new Node();\n    }\n    addWord(cur.next[c-'a'],word,index+1);\n}\n\n/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\npublic boolean search(String word) {\n    return search(root,word,0);\n}\n\npublic boolean search(Node cur,String word,int index) {\n    if (index == word.length()) {\n        return cur.isWord;\n    }\n    char c=word.charAt(index);\n    if (c=='.') {\n        for (int i=0;i<cur.next.length;i++) {\n            if(cur.next[i]!=null && search(cur.next[i],word,index+1)){\n                return true;\n            }\n        }\n        return false;\n    }\n    return cur.next[c-'a']!=null && search(cur.next[c-'a'],word,index+1);\n}\n```\n没啥好说的，遇到点就循环判断每个子节点就ok\n\n### [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)\n\n实现一个 MapSum 类里的两个方法，`insert` 和 `sum`。\n\n对于方法 `insert`，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。\n\n对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。\n\n**示例 1:**\n\n```java\n输入: insert(\"apple\", 3), 输出: Null\n输入: sum(\"ap\"), 输出: 3\n输入: insert(\"app\", 2), 输出: Null\n输入: sum(\"ap\"), 输出: 5\n```\n\n**解法一**\n\n有了前面的铺垫，其实这个也很简单\n\n```java\nclass MapSum {\n\n    private class Node{\n        public boolean isWord; //是否找到了一个单词\n        public Node[] next;\n        public int value;\n\n        public Node(boolean isWord,int value){\n            this.isWord = isWord;\n            this.value=value;\n            next = new Node[26];\n        }\n\n        public Node(int value){\n            this(false,value);\n        }\n    }\n    \n    private Node root;\n\n    public MapSum() {\n        root=new Node(0);\n    }\n    \n    public void insert(String key, int val) {\n        insert(root,key,val,0);\n    }\n\n    //a p p l e\n    public void insert(Node cur,String key, int val,int index) {\n        if (index==key.length()) {\n            cur.isWord=true;\n            cur.value=val;\n            return;\n        }\n        char c=key.charAt(index);\n        if (cur.next[c-'a']==null) {\n            cur.next[c-'a']=new Node(0);\n        }\n        insert(cur.next[c-'a'],key,val,index+1);\n    }\n    \n    public int sum(String prefix) {\n        return sum(root,prefix,0);\n    }\n\n    public int sum(Node cur,String prefix,int index) {\n        if (index == prefix.length()) {\n            return tireSum(cur);\n        }\n        char c=prefix.charAt(index);\n        if (cur.next[c-'a']==null) {\n        \treturn 0;\n        }\n        return sum(cur.next[c-'a'],prefix,index+1);\n    }\n\n    public int tireSum(Node cur){\n    \tint sum=0;\n    \tif (cur.isWord) {\n    \t\tsum+=cur.value;\n    \t}\n    \tfor (int i=0;i<26;i++) {\n    \t\tsum+=cur.next[i]!=null?tireSum(cur.next[i]):0;\n    \t}\n    \treturn sum;\n    }\n}\n```\n\n还是和上面一样，利用前缀树，不过要在上面的基础上做一些改动添加一个value字段用来保存值，先在树中找到要求的前缀的最后一个单词所在的节点，然后就直接求这个节点所有的子节点中isWord的单词的value累加和就ok了，我上面的实现并不好，都是写的递归，而且是尾递归，很鸡肋其实\n\n### [820. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/)\n\n给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。\n\n例如，如果这个列表是 `[\"time\", \"me\", \"bell\"]`，我们就可以将其表示为 S = `\"time#bell#\"` 和 `indexes = [0, 2, 5]`。\n\n对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 \"#\" 结束，来恢复我们之前的单词列表。\n\n那么成功对给定单词列表进行编码的最小字符串长度是多少呢？\n\n**示例：**\n\n```java\n输入: words = [\"time\", \"me\", \"bell\"]\n输出: 10\n说明: S = \"time#bell#\" ， indexes = [0, 2, 5] 。\n```\n\n**提示：**\n\n- `1 <= words.length <= 2000`\n- `1 <= words[i].length <= 7`\n- 每个单词都是小写字母 。\n\n**解法一**\n\n`2020.3.28` 打卡题，简单写了个Trie，纠结了半天要不要排序\n\n```java\npublic int res=0;\n\nprivate Node root;\n\npublic int minimumLengthEncoding(String[] words) {\n    root=new Node();\n    //纠结了半天要不要排序\n    Arrays.sort(words,(a,b)->b.length()-a.length());\n    for (int i=0;i<words.length;i++) {\n        if(!hasPrefix(words[i])){\n            add(words[i]);\n            res+=(words[i].length()+1);\n        }\n    }\n    return res;\n}\n\nprivate class Node{\n    \n    public Node[] next;\n    \n    public Node(){\n        next = new Node[26];\n    }\n}\n\n//递归的添加\npublic void add(String word){\n    //后缀树\n    add(root,word,word.length()-1);\n}\n\npublic void add(Node cur,String word,int index){\n    if (index==-1) {\n        return;\n    }\n    char c=word.charAt(index);\n    if (cur.next[c-'a']==null) {\n        cur.next[c-'a']=new Node();\n    }\n    add(cur.next[c-'a'],word,index-1); //尾递归\n}\n\npublic boolean hasPrefix(String word){\n    return hasPrefix(root,word,word.length()-1);\n}\n\npublic boolean hasPrefix(Node cur,String word,int index){\n    if(index==-1){\n        return true;\n    }\n    char c=word.charAt(index);\n    return cur.next[c-'a']!=null && hasPrefix(cur.next[c-'a'],word,index-1);\n}\n```\n\n**解法二**\n\n直接**逆序**后按**字典序**排序，这样单词的前缀包含关系就排好了，比如 time , me, bell, 最后就会变为 em emit lleb\n\n然后遍历所有单词，如果前面的单词是后面的前缀，就把前面的单词丢掉，否则就需要加上当前字符长度，代码后面有时间再补","tags":["数据结构","树"],"categories":["数据结构"]},{"title":"线段树初探","url":"/2019/12/09/xian-duan-shu/","content":"\n## 前言\n\n线段树其实属于比较高级的数据结构了，本人并不是竞赛选手，这里的代码也是借鉴的bobo老师的视频课来实现的，面试什么的一般是不会考的，这里主要是出于兴趣练练手\n\n## 问题引入\n\n[307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)\n\n给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。\n\nupdate(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。\n\n**示例:**\n\n```java\nGiven nums = [1, 3, 5]\n\nsumRange(0, 2) -> 9\nupdate(1, 2)\nsumRange(0, 2) -> 8\n```\n\n\n**说明:**\n\n1. 数组仅可以在 update 函数下进行修改。\n2. 你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。\n\n> 这题如果数组不能修改的话就好说了，可以直接利用数组的前缀和，但是这里数组是会变化的，难道没更新一次都要重新遍历么？那也太慢了吧，有没有一种结构能高效的插入同时也能高效的查询？\n\n## 线段树\n\n线段树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性（它是一颗平衡二叉树），它基本能保持每个操作的复杂度为`O(logN)`\n\n线段树的每个节点表示一个区间，父区间为`[a,b]` 则左子区间为`[a,(a+b)/2]`右子区间为`[(a+b)/2+1,b]` 最底层的叶子节点就是对应的一个个具体的元素值，这里我们采用数组来实现线段树\n\n```java\nimport java.util.function.*;\npublic class SegmentTree<E>{\n    \n    private E[] data;\n\n    private E[] tree;\n\n    private BiFunction<E,E,E> function;\n\n    public SegmentTree(E[] arr,BiFunction<E,E,E> function){\n        data = (E[]) new Object[arr.length];\n        this.function=function;\n        System.arraycopy(arr,0,data,0,arr.length);\n        //值得思考为什么是4n\n        tree = (E[]) new Object[4*arr.length];\n        buildSegmentTree(0,0,arr.length-1);\n    }\n\n    //根据传入的BiFuction构建线段树\n    private void buildSegmentTree(int index,int left,int right){\n        if (left==right) {\n            tree[index] =data[right];\n            return;\n        }\n        int leftIndex=leftChild(index);\n        int rightIndex=rightChild(index);\n        int mid=left+(right-left)/2;\n        buildSegmentTree(leftIndex,left,mid);\n        buildSegmentTree(rightIndex,mid+1,right);\n        //根据业务需求传入BiFunction\n        tree[index]=function.apply(tree[leftIndex],tree[rightIndex]);\n    }\n\n    //范围搜索\n    public E searchRange(int left,int right){\n        return searchRange(0,0,data.length-1,left,right);\n    }\n\n    private E searchRange(int rootIndex,int left,int right,int targetLeft,int targetRight){\n        if (targetLeft == left && targetRight == right) {\n            return tree[rootIndex];\n        }\n        int mid=left+(right-left)/2;\n        if (targetLeft>mid) {\n            return searchRange(rightChild(rootIndex),mid+1,right,targetLeft,targetRight);\n        }\n        if (targetRight<=mid) {\n            return searchRange(leftChild(rootIndex),left,mid,targetLeft,targetRight);\n        }\n        return function.apply(searchRange(leftChild(rootIndex),left,mid,targetLeft,mid),searchRange(rightChild(rootIndex),mid+1,right,mid+1,targetRight));\n    }\n\n\n    public void update(int index,E e){\n        if (index<0 || index>=data.length) {\n            throw new IllegalArgumentException(\"index illegal\");\n        }\n        update(0,0,data.length-1,index,e);\n    }\n\n    public void update(int rootIndex,int left,int right,int targetIndex,E e){\n        if (left == right) {\n            tree[rootIndex]=e;\n            return;\n        }\n        int mid=left+(right-left)/2;\n        if (targetIndex<=mid) {\n            update(leftChild(rootIndex),left,mid,targetIndex,e);\n        }else{\n            update(rightChild(rootIndex),mid+1,right,targetIndex,e);\n        }\n        tree[rootIndex]=function.apply(tree[leftChild(rootIndex)],tree[rightChild(rootIndex)]);\n    }\n\n\n    public int getSize(){\n        return data.length;\n    }\n\n    public E get(int index){\n        if (index<0 || index>=data.length) {\n            throw new IllegalArgumentException(\"index is illegal!\");\n        }\n        return data[index];\n    }\n\n    //左孩子\n    private int leftChild(int index){\n        return index*2+1;\n    }\n\n    //右孩子\n    private int rightChild(int index){\n        return index*2+2;\n    }\n}\n```\n\n没啥好说的，整体还是挺简单的，代码中用到了Java8的函数式接口，确实挺方便的\n\n其实我觉得有一个比较关键的点就是线段树需要多大的数组空间？\n\n首先一颗H层（H从1开始）的满二叉树一共有 `2^H-1`  个节点，我们忽略那一个节点，约为`2^H`个节点，而最后一层（h-1层）有 `2^(h-1)`个节点，也就是说最后一层的节点树大致等于前面所有层节点的和，所以我们可以得出一个结论，在线段树中如果需要表示的区间大小为n，并且n刚好等于2的k次幂的话（也就是放好构成一颗满二叉树），那么就只需要2n的节点个数，但是如果是`n=2^k+c` 那么当前层就存不下这n个元素，需要存到下一层，也就是空间还需要*2，所以最后我们就需要 4n 的空间去存储这颗线段树。\n\n这个时候再回头去做上面的题就会很简单了😁\n\n> 线段树其实还有很多的扩展，上面的是最最最基本的最简单的线段树结构，我还根本就没摸到线段树的门😂，只是知道了有这么个结构\n>\n> 由于我实在是太菜了，也没有时间去了解那些结构了\n>\n> 当然面试的时候并不会考线段树这些玩意儿，我也只是为了练练手，真正的竞赛的题目也不会像上面那么简单，了解即可😅\n\n\n\n","tags":["数据结构","树"],"categories":["数据结构"]},{"title":"由于cmd引发的血案","url":"/2019/12/08/you-yu-cmd-yin-fa-de-xie-an/","content":"\n## 前言\n\n给教务处做一个工作量审核的web项目，前几天完成后部署在机房电脑上进行测试，但是测试的时候出现了Bug，会存在一个用户登录的时候，整个应用卡死，所有人都无法登陆，因为登陆模块是我写的，我当时就慌了（并不），然后赶紧去机房看看到底是啥情况\n\n## FixBug\n\n其实我首先想到的就是网络或者数据库的问题，但是看了我控制台的输出，发现代码其实根本就还没到数据库层！所以先排除了数据库的问题\n\n然后我就想会不会是GC的问题，然后我打开了 `jvisualvm`，准备查看当前的堆占用和GC情况，但是他们之前重启了服务，现在是正常的，看不出来什么，所以我们需要复现这个Bug，结果我们几个人在哪里搞了半天死活复现不了😂\n\n> 在经过我们一个小时多小时坚持不懈的尝试下，终于复现了！\n\n页面hang住，所有人都无法登陆，后台也并没有任何的错误信息，然后我赶紧去看了下 `jvisualvm` 发现堆并没有任何变化，GC也并没有发生！而且更诡异的是其他的已经登陆的人是可以正常的操作的！只是卡住了登陆的人，所以GC的问题也排除了\n\n在dump出线程快照后终于发现了问题所在\n\n![mark](http://static.imlgw.top/blog/20191208/XKUriuCE9nTb.png?imageslim)\n\n图中的这条线程卡在了 `PrintStream.println()` 上，而这个是我在Service打印的log信息，为什么会在这里卡住？？？这不科学啊，然后我看了 其他 tomcat的工作线程，发现还有好几个都是`BLOCK` 状态，都在等 `[0x0000004df8afd000]`这把锁，这个锁被另一个tomcat的工作线程 `http-bio-80-exec[2]` 所持有，而且它并不是`BLOCK`状态，而是 `RUNNABLE` 状态，这个线程正在执行 `java.io.FileOutputStream.writeBytes()` 方法，我们去看看`println`的源码\n\n```java\n/**\n * Prints a String and then terminate the line.  This method behaves as\n * though it invokes <code>{@link #print(String)}</code> and then\n * <code>{@link #println()}</code>.\n *\n * @param x  The <code>String</code> to be printed.\n */\npublic void println(String x) {\n    synchronized (this) {\n        print(x);\n        newLine();\n    }\n}\n```\n\n可以看出在println方法确实是加了锁的，锁的对象就是当前的PrintStream实例对象，而占用这个锁的对象的线程则正在执行下面这个方法，是个本地方法我们看不到底层的细节\n\n```java\n/**\n * Writes a sub array as a sequence of bytes.\n * @param b the data to be written\n * @param off the start offset in the data\n * @param len the number of bytes that are written\n * @param append {@code true} to first advance the position to the\n *     end of file\n * @exception IOException If an I/O error has occurred.\n */\nprivate native void writeBytes(byte b[], int off, int len, boolean append)\n    throws IOException;\n```\n\n无奈，借助搜索引擎，果然查到了同样的问题 \n\n[一个RUNNABLE状态的线程hang在了java.io.FileOutputStream.writeBytes方法上](https://my.oschina.net/u/1030459/blog/908007)\n\n当然原问题是来自[StackOverflow](https://stackoverflow.com/questions/634102/log4j-is-hanging-my-application-what-am-i-doing-wrong) \n\n问题的根本原因：在CMD窗口点击了黑框之后，控制台就会被暂停![mark](http://static.imlgw.top/blog/20191208/1em5YGsoGyxT.png?imageslim)\n\n，进入编辑模式，之后向控制台的输入缓冲区会被很快填满，然后正在输出的线程就会hang住，但是正在输出的线程也并不会`BLOCK`，状态仍然是`RUNNABLE`所以就很诡异，也就是上面所描述的情况，当你这个时候在CMD状态下按一下回车或者其他的键释放console，退出编辑模式![mark](http://static.imlgw.top/blog/20191208/4RXkNizHfNsP.png?imageslim)\n\n这个线程又会继续往下执行，要解决这个问题可以调整cmd的设置，我这里其实无所谓，因为后面并不会在win上运行\n\n至此问题就基本解决了（其实都不算问题），没想到还会被cmd给坑一把，不过增长了一点排查问题的能力也还是不错的😁\n\n## 总结\n\n最大的收获就是： 遇到bug不要先急着重启逃避问题，得面对它，因为有些bug完全就是偶然性的，一旦放过，要想复现可能会极其困难，这次还算运气好，最终复现了，不过当时如果他们保护了现场后面就不会花几个小时去复现问题（确实大家也都经验不太足），也算是吃一堑长一智了 hahaha ~~","tags":["Bug"],"categories":["踩坑记录"]},{"title":"LeetCode二分查找","url":"/2019/12/06/leetcode-er-fen-cha-zhao/","content":"\n>  从 [数组专题](http://imlgw.top/2019/05/04/leetcode-shu-zu/) 中抽取出来的 \n\n## _二分搜索_\n\n## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n**示例 1:**\n\n```java\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n```\n\n\n**示例 2:**\n\n```java\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n```\n\n**提示：**\n\n- 你可以假设 nums 中的所有元素是不重复的\n- n 将在 [1, 10000]之间\n- nums 的每个元素都将在 [-9999, 9999]之间\n\n**解法一**\n\n比较经典的二分\n\n```java\npublic int search(int[] nums, int target) {\n    int left=0,right=nums.length;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<target){\n            left=mid+1;\n        }else if(nums[mid] > target){\n            right=mid;\n        }else{\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n**解法二**\n\n按照板子来的二分，最后需要后处理一下不存在的情况\n\n```java\n//模板二分\npublic int search(int[] nums, int target) {\n    int left=0,right=nums.length;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<target){ //排除mid\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left!=nums.length&&nums[left]==target?left:-1;\n}\n```\n## [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)\n\n实现 `int sqrt(int x)` 函数。\n\n计算并返回 *x* 的平方根，其中 *x* 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n**示例 1:**\n\n```java\n输入: 4\n输出: 2\n```\n\n**示例 2:**\n\n```java\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n```\n\n**解法一**\n\n二分解法\n\n```go\nfunc mySqrt(x int) int {\n    lx := int64(x)\n    var left int64 = 0\n    var right int64 = lx/2 + 1\n    for left < right {\n        mid := left + (right-left)/2\n        if mid*mid < lx {\n            left = mid + 1\n            //向下取整的，所以需要额外判断或者取右中位数\n            if left*left > lx {\n                return int(mid)\n            }\n        } else {\n            right = mid\n        }\n    }\n    return int(left)\n}\n```\n\n还有一种比较好的解法，更加贴合模板\n\n```go\n//这个其实更能体现模板的好处\nfunc mySqrt(x int) int {\n    lx := int64(x)\n    var left int64 = 0\n    var right int64 = lx/2 + 1\n    for left < right {\n        mid := left + (right-left)/2 + 1\n        //大于lx的一定不是res可以排除，但是小于的不一定不是，题目是向下取整的\n        if mid*mid > lx { \n            right = mid - 1\n        } else {\n            left = mid\n        }\n    }\n    return int(left)\n}\n```\n\n**解法二**\n\n> 牛顿迭代法，还没时间仔细去研究，后面有时间再看看\n\n## [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n**示例 1:**\n\n```java\n输入: [1,3,5,6], 5\n输出: 2\n```\n\n**示例 2:**\n\n```java\n输入: [1,3,5,6], 2\n输出: 1\n```\n\n**示例 3:**\n\n```java\n输入: [1,3,5,6], 7\n输出: 4\n```\n\n**示例 4:**\n\n```java\n输入: [1,3,5,6], 0\n输出: 0\n```\n\n**解法一**\n\n跟谁学笔试现场写的，上面的都是dd（删除了之前的解法）\n\n```java\npublic int searchInsert(int[] nums, int target) {\n    int len=nums.length;\n    int lo=0,hi=len; //和模板不一样，因为这里是搜索插入位置是可以到达right的\n    while(lo< hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){\n            lo=mid+1;\n        }else {\n            hi=mid;\n        }\n    }\n    return lo;\n}\n```\n**解法二**\n\n```java\n//update: 2020.5.18\npublic int searchInsert(int[] nums, int target) {\n    int len=nums.length;\n    int lo=0,hi=len-1;\n    int res=hi;\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]>=target){\n            res=mid;\n            hi=mid-1;\n        }else {\n            lo=mid+1;\n        }\n    }\n    return nums[res]<target?len:res;\n}\n```\n\n## [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。\n\n请找出其中最小的元素。\n\n你可以假设数组中不存在重复元素。\n\n**示例 1:**\n\n```java\n输入: [3,4,5,1,2]\n输出: 1\n```\n\n\n**示例 2:**\n\n```java\n输入: [4,5,6,7,0,1,2]\n输出: 0\n```\n\n**解法一**\n\n把最开始写的拉跨解法也放上来吧\n\n```java\npublic int findMin(int[] nums) {\n    if (nums==null||nums.length<=0) {\n        return 0;\n    }\n    if (nums.length==1||nums[0]<nums[nums.length-1]) {\n        return nums[0];\n    }\n    int left=1,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2+1;\n        if (nums[mid]>nums[mid-1]) {\n            if (nums[mid]>nums[0]) {\n                left=mid;\n            }else{\n                right=mid-1;\n            }\n        }else{\n            return nums[mid];\n        }\n    }\n    return nums[left];\n}\n```\n说实话，我都不知道咋对的。。。\n\n**解法二**\n\n模板解法，还是模板写起来清晰舒服\n> 建议直接看UPDATE\n```java\npublic int findMin(int[] nums) {\n    if (nums==null||nums.length<=0) {\n        return 0;\n    }\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if (nums[mid]>nums[right]) { //排除mid的分支\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return nums[left];\n}\n```\n需要注意要和右边界比较，和左边界比较不一定正确\n\n比如 `1 2 3 4 5` 和`2 3 4 5 1` 两个的中点都大于左边界，但是你无法确定此时应该如果缩短区间，除非做特判，但是那样就麻烦了\n\n**UPDATE: 2020.7.22**\n\n最小值的特点就是肯定是小于等于nums的最后一个元素，这里没有重复的元素，所以最小值肯定是小于最后一个元素的，除非最后一个就是最小的元素，这种情况我们设置为res的初始值，这样我重写后我感觉更好理解了，进阶版的只需要在这个的基础上稍加改动就行了\n```golang\nfunc findMin(nums []int) int {\n    var n = len(nums)\n    var left, right = 0, n - 1\n    var res = right//对nums[n-1]就是最小值做兜底\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] < nums[n-1] {\n            res = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return nums[res]\n}\n```\n同理也可以和左边界比较，最小值一定是小于等于nums[0]的\n```golang\nfunc findMin(nums []int) int {\n    var n = len(nums)\n    var left, right = 0, n - 1\n    var res = left //对nums[0]就是最小值做兜底\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] < nums[0] {\n            res = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return nums[res]\n}\n```\n\n## [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/) \n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。\n\n请找出其中最小的元素。\n\n注意数组中可能存在重复的元素。\n\n**示例 1：**\n\n```java\n输入: [1,3,5]\n输出: 1\n```\n\n**示例 2：**\n\n```java\n输入: [2,2,2,0,1]\n输出: 0\n```\n\n\n**说明：**\n\n- 这道题是 寻找旋转排序数组中的最小值 的延伸题目。\n- 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？  \n\n**解法一**\n> 建议直接参考解法2\n\n相比上一题有了重复的元素，在跳转的时候需要分清楚情况，在mid和中点相等的时候只排除右边界一个元素\n\n```java\npublic int findMin(int[] nums) {\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid] > nums[right]){\n            left=mid+1;\n        }else if(nums[mid] < nums[right]){\n            right=mid;\n        }else{\n            right--; //和右边界相等,无法判断,只缩减一步\n        }\n    }\n    return nums[left];\n}\n```\n\n**解法二**\n\n(UPDATE: 2020.7.22)\n\n相比[寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)，仅仅只是加了一个尾部去重的操作，去重后就和上面的情况一样了，这样就比前面的解法更加清晰了，时间复杂度也还是一样的\n```golang\n//先对尾部去重，再二分会清晰很多\nfunc minArray(numbers []int) int {\n    var n = len(numbers)\n    var left = 0\n    var right = n - 1\n    //尾部去重\n    for right >= 1 && numbers[right] == numbers[right-1] {\n        right--\n    }\n    //兜底最小值就是最后一个元素\n    var res = right\n    for left <= right {\n        mid := left + (right-left)/2\n        //去重后min一定是小于numbers[n-1]的\n        if numbers[mid] < numbers[n-1] {\n            res = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return numbers[res]\n}\n\n```\n\n## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。\n\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。\n\n你可以假设数组中不存在重复的元素。\n\n你的算法时间复杂度必须是 *O*(log *n*) 级别。\n\n**示例 1:**\n\n```java\n输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4\n```\n\n**示例 2:**\n\n```java\n输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1\n```\n\n**解法一**\n\n题目明确要求了时间复杂度O(logn)，所以肯定还是要二分，先上代码吧\n\n```java\npublic static int search2(int[] nums, int target) {\n    int len = nums.length;\n\n    if ((nums == null) || (len <= 0)) {\n        return -1;\n    }\n\n    int lo = 0;\n    int hi = len - 1;\n\n    while (lo <= hi) {\n        int mid = lo + ((hi - lo) / 2);\n        // 左, 右 指的是旋转点左右\n        if (nums[mid] > target) { //首先是大于target的情况\n\n            if (target < nums[lo]) {\n                //target在右边\n                //mid未知还需要判断下 画一个折线图就很清楚了\n                if (nums[mid] <= nums[hi]) { //mid也在右边\n                    hi = mid - 1;\n                } else {\n                    //mid在左边\n                    lo = mid + 1;\n                }\n            } else if (target > nums[lo]) {\n                //说明mid在左边, target也在左边\n                hi = mid - 1;\n            } else {\n                return lo;\n            }\n        } else if (nums[mid] < target) { //小于target的情况\n\n            if (target < nums[hi]) {\n                //mid在右边，target在右边\n                lo = mid + 1;\n            } else if (target > nums[hi]) {\n                //target在左边\n                //mid未知还需要判断下\n                if (nums[mid] > nums[hi]) { //mid在左边\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            } else {\n                return hi;\n            }\n        } else {\n            return mid;\n        }\n\n        /*if(hi>=0&&lo<len&&nums[lo]<nums[hi]){\n                   //切换成有序的二分\n                   while(lo<=hi){\n                         mid=lo+(hi-lo)/2;\n                         if(nums[mid]>target){\n                                    hi=mid-1;\n                         }else if(nums[mid]<target){\n                                    lo=mid+1;\n                       }else return mid;\n                   }\n            }*/\n    }\n    return -1;\n}\n\n```\n\n1ms，99% 纯if判断**target**和**mid**的位置，然后选择移动**lo**还是**hi**，一开始我随便找了几组数然后就开始写，写到后面发现都是bug😂，这里画个图很方便\n\n![mark](http://static.imlgw.top///20190507/vQgFb8yle0FH.png?imageslim)\n\n在里面找点会很清晰\n\n**解法二**\n\n当然还有一种更加简单也不用这么复杂的方法\n\n```java\npublic static int search(int[] nums, int target) {\n    int lo=0,hi=nums.length-1;\n    if(nums==null||nums.length<=0){\n        return  -1;\n    }\n    int index=-1;\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]>=nums[lo]){\n            //左半部分有序\n            index=binarySearch(nums,target,lo,mid);\n            //对右半部分二分\n            if(index==-1){\n                lo=mid+1;\n                //lo-->mid 没找到就对右半部分继续划分\n            } else return index;\n        } else if(nums[mid]<nums[lo]){\n            //右半部分有序\n            index=binarySearch(nums,target,mid,hi);\n            if(index==-1){\n                hi=mid-1;\n            } else return index;\n        }\n    }\n    return  index;\n}\n\npublic static int binarySearch(int []nums,int target,int lo,int hi){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]>target){\n            hi=mid-1;\n        } else if(nums[mid]<target){\n            lo=mid+1;\n        } else return mid;\n    }\n    return -1;\n}\n```\n\n这个应该比上一个慢一点，最好情况下是_**O(logN)**_直接将**target**划分到有序的那一边，如果没划分到有序的那一边就会花费时间去二分尝试切割数组，时间复杂度应该是`logN+log(N/2)+log(N/4)+...log(N/N)` 最后整体复杂度应该是`O(logN*logN)` ，虽然比 `logN` 好很多，但是并不是我们想要的算法\n\n**解法三**\n\n相当巧妙的解法！参考 [lcus](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple)，通过判断 `target`和`mid`的位置，如果`target`和`mid`不在同一段就将 `【4，5，6，7，0，1，2】 `转换成 `【4，5，6，7，INT_MAX，INT_MAX，INT_MAX】`或者`【INT_MIN，INT_MIN，INT_MIN，INT_MIN，0，1，2】` 然后再进行二分\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if(nums==null || nums.length<=0) return -1;\n        int left=0,right=nums.length-1;\n        while(left<right){\n            int mid=left+(right-left)/2;\n            //这一步 (nums[mid]>=nums[0])==(target>=nums[0]) 很巧秒，其实用异或也可以\n            int midNum=(nums[mid]>=nums[0])==(target>=nums[0])?nums[mid]:\n                        nums[mid]>=nums[0]?Integer.MIN_VALUE:Integer.MAX_VALUE;\n            if(midNum<target){\n                left=mid+1;\n            }else{\n                right=mid;\n            }\n        }\n        return nums[left]!=target?-1:left;\n    }\n}\n```\n\n`(nums[mid]>=nums[0])==(target>=nums[0])` 这一步很巧妙，满足这个关系就说明mid和target在同一段，不用变化，可以直接求，否则就根据mid的位置考虑如何变化\n\n## [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。\n\n编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。\n\n**示例 1:**\n\n```go\n输入: nums = [2,5,6,0,0,1,2], target = 0\n输出: true\n```\n\n**示例 2:**\n\n```go\n输入: nums = [2,5,6,0,0,1,2], target = 3\n输出: false\n```\n\n**进阶:**\n\n- 这是 [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/) 的延伸题目，本题中的 `nums`  可能包含重复元素。\n- 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？\n\n**解法一**\n\nWA哭了，好难搞，要是在工程上我肯定直接遍历了，太细节了这波\n\n```go\nfunc search(nums []int, target int) bool {\n    n:=len(nums)\n    if n==0{\n        return false\n    }\n    left:=0\n    right:=n-1\n    for left<right {\n        mid:=left+(right-left)/2+1\n        if nums[mid]>nums[right] { //左半边\n            //target在[left,mid)的有序区间内\n            if nums[left]<=target && target<nums[mid]{\n                right=mid-1\n            }else{\n                left=mid\n            }\n        }else if nums[mid]<nums[right]{\n            //target在[mid,right]\n            if nums[mid]<=target && target<=nums[right]{\n                left=mid\n            }else{\n                right=mid-1\n            }\n        }else{\n            //mid==right看right是不是target\n            if nums[right]==target{\n                return true\n            }\n            right--\n        }\n    }\n    return nums[left]==target\n}\n```\n\n看着别人的题解写都WA了5，6次。。。。这个其实就不能按照上一题的思路来了，因为有重复的，不好判断mid和target是不是在同一边\n\n## [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)\n\n给你一个排序后的字符列表 `letters` ，列表中只包含小写英文字母。另给出一个目标字母 `target`，请你寻找在这一有序列表里比目标字母大的最小字母。\n\n在比较时，字母是依序循环出现的。举个例子：\n\n- 如果目标字母 `target = 'z'` 并且字符列表为 `letters = ['a', 'b']`，则答案返回 `'a'`\n\n**示例：**\n\n```java\n输入:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\n输出: \"c\"\n\n输入:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\n输出: \"f\"\n\n输入:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\n输出: \"f\"\n\n输入:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"g\"\n输出: \"j\"\n\n输入:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"j\"\n输出: \"c\"\n\n输入:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"k\"\n输出: \"c\"\n```\n\n**提示：**\n\n1. `letters`长度范围在`[2, 10000]`区间内。\n2. `letters` 仅由小写字母组成，最少包含两个不同的字母。\n3. 目标字母`target` 是一个小写字母。\n\n**解法一**\n\n按照新模板写的，题解区很多人讨论`['z'，'a'，'b']`这样的case，其实我觉得没必要，纠结这没啥意义，可能还是题目描述有点问题，我们就直接当普通二分写就行了\n\n```java\npublic char nextGreatestLetter(char[] letters, char target) {\n    int left=0,right=letters.length-1;\n    int res=0; //注意找不到的情况\n    while(left<=right){\n        int mid=(left+right)/2;\n        if(letters[mid]>target){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return letters[res];\n}\n```\n\n## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 *O*(log *n*) 级别。\n\n如果数组中不存在目标值，返回 `[-1, -1]`。\n\n**示例 1:**\n\n```java\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n```\n\n**示例 2:**\n\n```java\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n```\n\n**解法一**\n\n时间复杂度O(logN)，肯定还是要二分\n\n```java\n//两次二分\npublic int[] searchRange(int[] nums, int target) {\n    if(nums.length<=0){\n        return new int[]{-1,-1};\n    }\n    return new int[]{left(nums,target,0,nums.length-1),right(nums,target,0,nums.length-1)};\n}\n\n//5,7,7,8,8,8,8,10,10\npublic int left(int []nums,int target,int lo,int hi){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        //System.out.println(\"lo: \"+nums[lo]+\"mid: \"+nums[mid] +\"hi: \"+nums[hi]);\n        if(nums[mid]<target){\n            lo=mid+1;\n        }else if(nums[mid]>target){\n            hi=mid-1;\n        }else if(mid>0){ //nums[mid]=target\n            if(nums[mid-1]!=target){\n                return mid;\n            }else{\n                //控制向左找\n                hi=mid-1;\n            }\n        }else{\n            return mid; //0\n        }\n    }\n    return -1;\n}\n\npublic int right(int []nums,int target,int lo,int hi){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){\n            lo=mid+1;\n        }else if(nums[mid]>target){\n            hi=mid-1;\n        }else if(mid<nums.length-1){\n            if(nums[mid+1]!=target){\n                return mid;\n            }else{\n                //控制向右找\n                lo=mid+1;\n            }\n        }else{\n            return mid; //nums.length\n        }\n    }\n    return -1;\n}\n```\n\n1ms ，99% 核心就是两次二分，分别向左和向后二分整个数组， 在相等的时候并不返回，多判断一下，左边的就控制hi向左边继续找，右边就控制lo向右边继续找，直到下一个不等于target就返回，和上面一题一样都是二分的变种\n\n**解法二**\n\n统一的解法，上面的做法虽然直白，但是没有通用性，这里借鉴评论区大佬 [liweiwei1419](https://www.liwei.party/)的[讲解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)写一个通用的解法，之前写二分一直都是凭感觉，不注意细节，有错误就debug，东改一改，西改一改，然后就过了。。。毫无章法，以后要统一写法了\n\n```java\n//两次二分\npublic int[] searchRange(int[] nums, int target) {\n    if(nums.length<=0){\n        return new int[]{-1,-1};\n    }\n    return new int[]{left(nums,target,0,nums.length-1),right(nums,target,0,nums.length-1)};\n}\n\n//找大于等于target的第一个元素,小于肯定不符合\npublic int left(int []nums,int target,int lo,int hi){\n    while(lo<hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){ //排除小于target的,剩下【lo,hi】都是大于等于的\n            lo=mid+1;\n        }else{\n            hi=mid;\n        }\n    }\n    return nums[hi]==target?hi:-1;\n}\n\n//找小于等于target的最后一个元素,大于肯定不符合\npublic int right(int []nums,int target,int lo,int hi){\n    while(lo<hi){\n        //选取右中值\n        int mid=lo+(hi-lo)/2+1;\n        if(nums[mid]>target){ //排除大于target,剩下[lo,hi]都是小于等于的\n            hi=mid-1;\n        }else{\n            //根据这个判断需要选取右中值\n            lo=mid;\n        }\n    }\n    return nums[hi]==target?hi:-1;\n}\n```\n\n**新模板**\n\n新模板比较好写\n\n```java\npublic int[] searchRange(int[] nums, int target) {\n    if(nums==null || nums.length<=0) return new int[]{-1,-1};\n    return new int[]{leftSearch(nums,target),rightSearch(nums,target)};\n}\n\npublic int leftSearch(int[] nums,int target){\n    int left=0,right=nums.length-1;\n    int res=right;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]>=target){\n            res=mid;\n            right=mid-1; \n        }else{\n            left=mid+1;\n        }\n    }\n    return nums[res]==target?res:-1;\n}\n\npublic int rightSearch(int[] nums,int target){\n    int left=0,right=nums.length-1;\n    int res=left;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<=target){\n            res=mid;\n            left=mid+1; \n        }else{\n            right=mid-1;\n        }\n    }\n    return nums[res]==target?res:-1;\n}\n```\n\n\n\n## [面试题53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)\n\n一个长度为 ~~n-1~~ n 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围~~0～n-1~~ 0~n 之内。在范围~~0～n-1~~ 0~n内的~~n~~ n+1 个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n**示例 1:**\n\n```java\n输入: [0,1,3]\n输出: 2\n```\n\n\n**示例 2:**\n\n```java\n输入: [0,1,2,3,4,5,6,7,9]\n输出: 8\n```\n\n**限制：**\n\n`1 <= 数组长度 <= 10000`\n\n**解法一**\n\n这题的题目描述感觉有点问题我稍微改了下\n\n```java\npublic int missingNumber(int[] nums) {\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]==mid){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    if(nums[left]==left) return left+1; //只有一个数\n    return left;\n}\n```\n\n二分找那个索引不对的元素就ok了，按照模板写的，排除法，排除相等的，最后返回的索引`left`就是缺失的数字\n\n\n\n## [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)\n\n我们把符合下列属性的数组 A 称作山脉：\n\n- A.length >= 3\n- 存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]\n\n\n给定一个确定为山脉的数组，返回任何满足 `A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]` 的 i 的值。\n\n **示例 1：**\n\n```java\n输入：[0,1,0]\n输出：1\n```\n\n\n**示例 2：**\n\n```java\n输入：[0,2,1,0]\n输出：1\n```\n\n**解法一**\n\n其实还是上面的模板，只不过做了一点点改动而已，很傻逼的WA了一发，我也是服了自己了\n\n```java\npublic static int peakIndexInMountainArray(int[] A) {\n    int left=0,right=A.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        //System.out.println(mid);\n        if (mid>0 && mid<A.length && A[mid] > A[mid-1] && A[mid]<A[mid+1]) {\n            left=mid+1;\n        }else if (mid>0 && mid<A.length && A[mid]< A[mid-1] && A[mid]>A[mid+1]){\n            right=mid-1;\n        }else{\n            return mid;\n        }\n    }\n    return left;\n}\n```\n\n代码优化 `2020.4.9` 不知道为啥之前写成哪个鬼样子。。。\n\n```java\npublic static int peakIndexInMountainArray(int[] A) {\n    int left=0,right=A.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if (A[mid]<A[mid+1]) {\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n\n## [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)\n\n（这是一个 **交互式问题** ）\n\n给你一个 **山脉数组** `mountainArr`，请你返回能够使得 `mountainArr.get(index)` **等于** `target` **最小** 的下标 `index` 值。\n\n如果不存在这样的下标 `index`，就请返回 `-1`。\n\n何为山脉数组？如果数组 `A` 是一个山脉数组的话，那它满足如下条件：\n\n**首先**，`A.length >= 3`\n\n**其次**，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：\n\n- `A[0] < A[1] < ... A[i-1] < A[i]`\n- `A[i] > A[i+1] > ... > A[A.length - 1]`\n\n你将 **不能直接访问该山脉数组**，必须通过 `MountainArray` 接口来获取数据：\n\n- `MountainArray.get(k)` - 会返回数组中索引为`k` 的元素（下标从 0 开始）\n- `MountainArray.length()` - 会返回该数组的长度\n\n**注意：**\n\n对 `MountainArray.get` 发起超过 `100` 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。\n\n为了帮助大家更好地理解交互式问题，我们准备了一个样例 “**答案**”：<https://leetcode-cn.com/playground/RKhe3ave>，请注意这 **不是一个正确答案**。\n\n**示例 1：**\n\n```java\n输入：array = [1,2,3,4,5,3,1], target = 3\n输出：2\n解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。\n```\n\n**示例 2：**\n\n```java\n输入：array = [0,1,2,4,2,1], target = 3\n输出：-1\n解释：3 在数组中没有出现，返回 -1。\n```\n\n**提示：**\n\n- `3 <= mountain_arr.length() <= 10000`\n- `0 <= target <= 10^9`\n- `0 <= mountain_arr.get(index) <= 10^9`\n\n**解法一**\n\n这题，，，咋说呢，数据太弱了，配不上hard题，顶多算个mid偏简单，数据大的时候可以考虑加上缓存，这样就比较有意思了，这里我就懒得加了😁\n\n```go\nfunc findInMountainArray(target int, mountainArr *MountainArray) int {\n    n := mountainArr.length()\n    //寻找山顶\n    left := 0\n    right := n - 1\n    for left < right {\n        mid := left + (right-left)/2\n        //mid+1肯定不会越界\n        if mountainArr.get(mid) < mountainArr.get(mid+1) {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    res := -1\n    res = binarySearchUp(mountainArr, target, 0, left)\n    if res == -1 {\n        res = binarySearchDown(mountainArr, target, left, n-1)\n    }\n    return res\n}\n\nfunc binarySearchUp(mountainArr *MountainArray, target, left, right int) int {\n    for left < right {\n        mid := left + (right-left)/2\n        if mountainArr.get(mid) < target {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    if mountainArr.get(left) == target {\n        return left\n    }\n    return -1\n}\n\nfunc binarySearchDown(mountainArr *MountainArray, target, left, right int) int {\n    for left < right {\n        mid := left + (right-left)/2\n        if mountainArr.get(mid) > target {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    if mountainArr.get(left) == target {\n        return left\n    }\n    return -1\n}\n```\n\n这两个二分是可以合并的，懒得合了（太懒了吧你也😅）\n\n**UPDATE: 2020.7.14**\n\n自定义函数传递，简化代码\n```golang\nfunc findInMountainArray(target int, mA *MountainArray) int {\n    var n = mA.length()\n    var left = 0\n    var right = n-1\n    var maxIdx = right\n    for left <= right{\n        mid := left + (right-left)/2\n        //左中，所以mid+1不会越界\n        if mA.get(mid) > mA.get(mid+1){\n            maxIdx = mid\n            right = mid - 1 \n        }else{\n            left = mid + 1\n        }\n    }\n    lr := search(mA, target, 0, maxIdx, func(i int, j int)bool{\n        return i <= j\n    })\n    if lr != -1{\n        return lr\n    }\n    return search(mA, target, maxIdx+1, n-1, func(i int, j int)bool{\n        return i >= j\n    })\n    \n}\n\nfunc search(mA *MountainArray, target int, left int, right int, less func(int, int)bool) int {\n    var res = left\n    for left <= right{\n        mid := left + (right-left)/2\n        if less(mA.get(mid), target){\n            res = mid\n            left = mid + 1\n        }else{\n            right = mid - 1\n        }\n    }\n    if mA.get(res) != target{\n        return -1\n    }\n    return res\n}\n```\n\n## [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)\n\n峰值元素是指其值大于左右相邻值的元素。\n\n给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。\n\n数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。\n\n你可以假设 `nums[-1] = nums[n] = -∞`。\n\n**示例 1:**\n\n```java\n输入: nums = [1,2,3,1]\n输出: 2\n解释: 3 是峰值元素，你的函数应该返回其索引 2。\n```\n\n\n**示例 2:**\n\n```java\n输入: nums = [1,2,1,3,5,6,4]\n输出: 1 或 5 \n解释: 你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n```\n\n\n**说明:**\n\n你的解法应该是 `O(logN)` 时间复杂度的。\n\n**解法一**\n\n题目挑明了logN的复杂度，那么肯定就是二分了，那是怎么个二分的思路呢？题目其实也说了很清楚了，边界的左右两边都是`-∞` 所以我们直接按照递增的去搜，最后肯定能搜索到峰值\n\n```java\npublic int findPeakElement(int[] nums) {\n    int left=0,right=nums.length-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(/*mid+1<nums.length &&*/nums[mid]<nums[mid+1]){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\nliweiwei大佬的二分模板真好用！！！\n\n## [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)\n\n编写一个高效的算法来判断 `m x n` 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n每行中的整数从左到右按升序排列。\n每行的第一个整数大于前一行的最后一个整数。\n**示例 1:**\n\n```java\n输入:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\n输出: true\n```\n\n\n**示例 2:**\n\n```java\n输入:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\n输出: false\n```\n\n**解法一**\n\n```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    if(matrix==null || matrix.length<=0 || matrix[0].length<=0){\n        return false;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int low=0,high=m-1;\n    if (target>matrix[m-1][n-1] || target < matrix[0][0]) {\n        return false;\n    }\n    while(low<=high){ //二分确定在哪一行\n        int mid=low+(high-low)/2;\n        if (target == matrix[mid][0]) {\n            return true;\n        }else if(matrix[mid][0]<target){\n            low=mid+1;\n        }else{\n            high=mid-1;\n        }\n    }\n    int column=low!=0?low-1:low;\n    low=0;\n    high=n-1;\n    while(low<high){\n        int mid=low+(high-low)/2;\n        if (matrix[column][mid]==target) {\n            return true;\n        }else if(matrix[column][mid] < target){\n            low=mid+1; \n        }else{\n            high=mid-1;\n        }\n    }\n    return target==matrix[column][low];\n}\n```\n\n😔，这题wa了11次，是的，11次，可想而知我有多彩，最后写出来的解法还是如此的难看，主要就是在确定在哪一行的时候写出了好多问题，可以看到我上下的两种二分方法是不一样的，前期就揪着一种写，按照上面的板子写，结果写出了一堆bug... 以后写二分还是要注意啊，1s确定思路，代码写了3h。。。。\n\n**解法二**\n\n看了评论区写出来的，利用取模和除将二维数组拉成一维的，相当的优秀，也不用考虑那些边界，时间复杂度和上面一样`log(nm)` \n\n```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    if(matrix==null || matrix.length<=0 || matrix[0].length<=0){\n        return false;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int left=0,right=m*n-1;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(matrix[mid/n][mid%n]<target){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return matrix[left/n][left%n]==target;\n}\n```\n\n## [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n\n编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：\n\n- 每行的元素从左到右升序排列。\n- 每列的元素从上到下升序排列。\n\n**示例:**\n现有矩阵 matrix 如下：\n\n```java\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\n给定 target = `5`，返回 `true`。\n\n给定 target = `20`，返回 `false`。\n\n**解法一**\n\n看上一题 [240. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)  的评论区的时候看到了这种解法\n\n```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    if(matrix==null || matrix.length<=0 || matrix[0].length<=0){\n        return false;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int  column=0,row=m-1;\n    while(column<n && row>=0){\n        //System.out.println(row+\",\"+column);\n        if (matrix[row][column]==target) {\n            return true;\n        }\n        if (matrix[row][column] > target) {\n            row--;\n        }else{\n            column++;\n        }\n    }\n    return false;\n}\n```\n整个矩阵从左上到右下，其实就分为了两块，每个元素的左上一定小于当前元素，右下一定大于当前元素，这题也可以二分，就像下面的[1351. 统计有序矩阵中的负数](#1351-统计有序矩阵中的负数)一样，但是时间复杂度会高一些\n\n## [1351. 统计有序矩阵中的负数](https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/)\n\nDifficulty: **简单**\n\n\n给你一个 `m * n` 的矩阵 `grid`，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 \n\n请你统计并返回 `grid` 中 **负数** 的数目。\n\n**示例 1：**\n\n```go\n输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n输出：8\n解释：矩阵中共有 8 个负数。\n```\n\n**示例 2：**\n\n```go\n输入：grid = [[3,2],[1,0]]\n输出：0\n```\n\n**示例 3：**\n\n```go\n输入：grid = [[1,-1],[-1,-1]]\n输出：3\n```\n\n**示例 4：**\n\n```go\n输入：grid = [[-1]]\n输出：1\n```\n\n**提示：**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= grid[i][j] <= 100`\n\n\n**解法一**\n\n没啥好说的，和上面的解法一样，从左下角向上搜索\n```golang\nfunc countNegatives(grid [][]int) int {\n    if len(grid) <= 0 {\n        return 0\n    }\n    var m, n = len(grid), len(grid[0])\n    var count = 0\n    var i, j = m-1, 0\n    for i >= 0 && j < n {\n        if grid[i][j] < 0 {\n            count += n - j\n            i--\n        }else{\n            j++\n        }\n    }\n    return count;\n}\n```\n\n**解法二**\n\nO(mlogn)解法\n\n```golang\n//O(mlogn) 只利用了行逆序的条件\nfunc countNegatives(grid [][]int) int {\n    if len(grid) <= 0 {\n        return 0\n    }\n    var count = 0\n    var m = len(grid)\n    var n = len(grid[0])\n    for i := 0; i < m; i++ {\n        count += (n - search(grid[i]))\n    }\n    return count\n}\n\nfunc search(nums []int) int {\n    var left = 0\n    var right = len(nums)-1\n    var res = right+1\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] < 0 {\n            res = mid\n            right = mid - 1\n        }else{\n            left = mid + 1\n        }\n    }\n    return res\n}\n```\n\n## [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)\n\n给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。\n\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 `O(log(m + n))`。\n\n你可以假设 `nums1` 和 `nums2` 不会同时为空。\n\n**示例 1:**\n\n```java\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n```\n\n**示例 2:**\n\n```java\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n```\n\n**解法一**\n\nHard题，首先想到的是归并，但是时间复杂度不符合要求，最低要求 `O(log(m+n))`，想了好一会儿实在是想不出来（菜）然后看了评论区的解法\n\n```java\n//find nums1+nums2 /2 大的数\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    int m=nums1.length;\n    int n=nums2.length;\n    int leftMid=(m+n+1)/2;\n    int rightMid=(m+n+2)/2;\n    return (findMedian(nums1,0,m-1,nums2,0,n-1,leftMid) + findMedian(nums1,0,m-1,nums2,0,n-1,rightMid)) * 0.5;\n}\n//    i\n//1 2 3 5\n//    j\n//1 2 4 6 7 8 9     k=6 find k/2=3\n//\n//        i\n//*1 2 3* 5\n//  j  \n//1 2 4 6 7 8 9     k=3 find k/2=1  res=4\npublic double findMedian(int[] nums1,int left1,int right1, int[] nums2,int left2,int right2,int k) {\n    int len1=right1-left1+1;\n    int len2=right2-left2+1;\n    if (len1==0) {\n        return nums2[left2+k-1];\n    }\n    if (len2==0) {\n        return nums1[left1+k-1];\n    }\n    if (k==1) {\n        return Math.min(nums1[left1],nums2[left2]);\n    }\n    int i=left1+Math.min(len1,k/2)-1;\n    int j=left2+Math.min(len2,k/2)-1;\n    if (nums1[i] < nums2[j]) {\n        return findMedian(nums1,i+1,right1,nums2,left2,right2,k-(i-left1+1));\n    }else{\n        return findMedian(nums1,left1,right1,nums2,j+1,right2,k-(j-left2+1));\n    }\n}\n```\n这种解法还是挺妙的，求第k小的思路，两个数组都是有序的，我们要求第k小，我们可以将k一分为二，看看两个数组的 `k/2` 位置的元素哪个大哪个小，小的哪个数组前 `k/2` 个元素就可以直接排除掉，因为他们必不可能是第k小的元素，举个例子就很容易理解\n\n```java\n1 2 3 5\n1 2 4 6 7 8 9  k=6\nk/2=3,分别在两数组中找第三个元素，也即是3，4明显3比较小，所以我们可以直接排除第一个数组的1，2，3三个元素，他们必不可能是第k小的元素！\n*1 2 3* 5\n1 2 4 6 7 8 9  k=3\n```\n\n然后重复上面的过程，每次排除`k/2` 的元素，最后在`log(k)` 的时间复杂度下就能找到两个数组的mid，而这里`k=(m+n+1)/2` 所以是符合题目要求的，除此之外，我们还需要考虑奇数和偶数的情况，那我们就可以分别计算一下，我们求一下左中位数和右中位数，如果是奇数左中和右中就是同一个`(k)/2==(k+1)/2` ，偶数的话就是`(k)/2`和`(k+1)/2`分别就是左中和右中，然后我们直接/2就得到了解\n\n## [658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)\n\n给定一个排序好的数组，两个整数 `k` 和 `x`，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。如果有两个数与 `x` 的差值一样，优先选择数值较小的那个数。\n\n**示例 1:**\n\n```java\n输入: [1,2,3,4,5], k=4, x=3\n输出: [1,2,3,4]\n```\n\n**示例 2:**\n\n```java\n输入: [1,2,3,4,5], k=4, x=-1\n输出: [1,2,3,4]\n```\n\n**说明:**\n\n1. k 的值为正数，且总是小于给定排序数组的长度。\n2. 数组不为空，且长度不超过 104\n3. 数组里的每个元素与 x 的绝对值不超过 104\n\n**解法一**\n\n双指针，少点套路，多点真诚\n\n```java\npublic List<Integer> findClosestElements(int[] arr, int k, int x) {\n    int left=0,right=arr.length-1;\n    int count=0;\n    while(left<right){\n        if(Math.abs(arr[left]-x)<=Math.abs(arr[right]-x)){\n            right--;\n        }else{\n            left++;\n        }\n        count++;\n        if(count==arr.length-k) break;\n    }\n    List<Integer> res=new ArrayList<>();\n    for(int i=left;i<=right;i++) res.add(arr[i]);\n    return res;\n}\n```\n\n**解法二**\n\n二分的解法，有点trick，不容易想到，参考[题解](https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/)\n\n```java\npublic List<Integer> findClosestElements(int[] arr, int k, int x) {\n    //左边界的取值范围\n    int left=0,right=arr.length-k;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(x-arr[mid]>arr[mid+k]-x){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    List<Integer> res=new ArrayList<>();\n    for(int i=left;i<left+k;i++) res.add(arr[i]);\n    return res;   \n}\n```\n## [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\nDifficulty: **简单**\n\n\n给定一个正整数 _num_，编写一个函数，如果 _num_ 是一个完全平方数，则返回 True，否则返回 False。\n\n**说明：**不要使用任何内置的库函数，如  `sqrt`。\n\n**示例 1：**\n\n```go\n输入：16\n输出：True\n```\n\n**示例 2：**\n\n```go\n输入：14\n输出：False\n```\n\n**解法一**\n\n二分\n```golang\nfunc isPerfectSquare(num int) bool {\n    var left = 0\n    var right = num\n    var res = num + 1\n    for left <= right {\n        mid := left + (right-left)/2\n        if mid*mid >= num {\n            res = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return res*res == num\n}\n```\n\n**解法二**\n\n完全平方数的性质\n```golang\n//完全平方数性质 n^2 = 1 + 3 + 5 +...+2n+1 (前n个奇数的和)\n//所以只需要判断num能不能被奇数减成0就行了\nfunc isPerfectSquare(num int) bool {\n    var i = 1\n    for num > 0 {\n        num -= i\n        i += 2\n    }\n    return num == 0\n}\n```\n\n## [475. 供暖器](https://leetcode-cn.com/problems/heaters/)\n\nDifficulty: **简单**\n\n\n冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。\n\n现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。\n\n所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。\n\n**说明:**\n\n1.  给出的房屋和供暖器的数目是非负数且不会超过 25000。\n2.  给出的房屋和供暖器的位置均是非负数且不会超过10^9。\n3.  只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。\n4.  所有供暖器都遵循你的半径标准，加热的半径也一样。\n\n**示例 1:**\n\n```golang\n输入: [1,2,3],[2]\n输出: 1\n解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。\n```\n\n**示例 2:**\n\n```golang\n输入: [1,2,3,4],[1,4]\n输出: 1\n解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。\n```\n\n\n**解法一**\n\n这个题目感觉不是easy啊，一开始想劈叉了，以为是二分答案，写了半天后来WA在一个很大的case，一直以为是溢出了，改了半天的bug没改出来。。。后来自己按照case的规律构建了一个小的case，发现也WA了，然后才意识到是方法错了, (case: [4,9] [4,8])，这个case按照二分答案的思路就是错的，二分答案是思路就是验证该半径下能否覆盖整个区间，其实也是题目理解有点问题，题目的要求是**覆盖每个房子**，而**不是覆盖整个区间**，所以只需要找到每个房子最近的供暖器就行了，然后统计这些最小值得最大值就是我们需要的半径\n\n```golang\nfunc findRadius(houses []int, heaters []int) int {\n    //边界处理\n    heaters = append(heaters, math.MaxInt32)\n    heaters = append(heaters, math.MinInt32)\n    sort.Ints(heaters)\n    var Min = func (a, b int) int { if a < b {return a}; return b}\n    var Max = func (a, b int) int { if a < b {return b}; return a}\n    var res = 0\n    for _, h := range houses{\n        left := search(heaters, h)\n        res = Max(res, Min(h-heaters[left], heaters[left+1]-h))\n    }\n    return res\n}\n​\n//target左边最近的一个\nfunc search(heaters []int, target int) int {\n    var left, right = 0, len(heaters)-1\n    var res = left //左边没有供暖器\n    for left <= right {\n        mid := left + (right-left)/2\n        if heaters[mid] <= target{\n            res = mid\n            left = mid + 1\n        }else{\n            right = mid - 1\n        }\n    }\n    return res\n}\n```\n另一种写法，不额外处理边界，也是一开始的写法\n```golang\nfunc findRadius(houses []int, heaters []int) int {\n    sort.Ints(heaters)\n    var n = len(heaters)\n    var Min = func (a, b int) int { if a < b {return a}; return b}\n    var Max = func (a, b int) int { if a < b {return b}; return a}\n    var res = 0\n    for _, h := range houses{\n        left := search(heaters, h)\n        if left == -1{ //全部大于hourse,取最小的那个\n            res = Max(res, heaters[0]-h)\n        }else if left+1 < n{\n            res = Max(res, Min(h-heaters[left], heaters[left+1]-h))\n        }else{\n            res = Max(res, h-heaters[left])\n        }\n    }\n    return res\n}\n\n//target左边最近的一个\nfunc search(heaters []int, target int) int {\n    var left, right = 0, len(heaters)-1\n    var res = -1 //左边没有供暖器\n    for left <= right {\n        mid := left + (right-left)/2\n        if heaters[mid] <= target{\n            res = mid\n            left = mid + 1\n        }else{\n            right = mid - 1\n        }\n    }\n    return res\n}\n```\n时间复杂度细看的话应该是 `O(MlogM + MlogN)`（M，N分别代表houses和heaters的长度）\n\n**解法二**\n\n双指针，时间复杂度差别不大\n```golang\nfunc findRadius(houses []int, heaters []int) int {\n    heaters = append(heaters, math.MaxInt32)\n    heaters = append(heaters, math.MinInt32)\n    sort.Ints(heaters)\n    sort.Ints(houses)\n    var n = len(heaters)\n    var Min = func (a, b int) int { if a < b {return a}; return b}\n    var Max = func (a, b int) int { if a < b {return b}; return a}\n    var res = 0\n    var left = 0\n    for _, h := range houses {\n        for left < n && heaters[left] < h {\n            left++\n        }\n        res = Max(res, Min(heaters[left]-h, h-heaters[left-1]))\n    }\n    return res\n}\n```\n时间复杂度细看的话应该是 `O(NlogN + MlogM + N + M)`（M，N分别代表houses和heaters的长度），差别不大，不过很明显双指针的好写很多\n\n## _二分答案_\n\n## [1283. 使结果不超过阈值的最小除数](https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/)\n\n给你一个整数数组 `nums` 和一个正整数 `threshold`  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。\n\n请你找出能够使上述结果小于等于阈值 `threshold` 的除数中 最小 的那个。\n\n每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。\n\n题目保证一定有解。\n\n**示例 1：**\n\n```java\n输入：nums = [1,2,5,9], threshold = 6\n输出：5\n解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。\n如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [2,3,5,7,11], threshold = 11\n输出：3\n```\n\n**示例 3：**\n\n```java\n输入：nums = [19], threshold = 5\n输出：4\n```\n\n**提示：**\n\n- `1 <= nums.length <= 5 * 10^4`\n- `1 <= nums[i] <= 10^6`\n- `nums.length <= threshold <= 10^6`\n\n**解法一**\n\n周赛的题，太蠢了，没做出来。。。。\n\n```java\npublic int smallestDivisor(int[] nums, int threshold) {\n    int left=1,right=1000000;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        int sum=0;\n        for (int i=0;i<nums.length;i++) {\n            sum+=(nums[i]+mid-1)/mid; //向上取整\n        }\n        if (sum>threshold) {\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n其实只要明确一点这题就很容易想到二分，解空间为：`[1，max(nums[i])]` 我们只需要在这个区间之内做二分搜索就ok了，再然后就是向上取整的一个小技巧\n\n## [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n给定一个包含 n + 1 个整数的数组 `nums`，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n\n**示例 1:**\n\n```java\n输入: [1,3,4,2,2]\n输出: 2\n```\n\n\n**示例 2:**\n\n```java\n输入: [3,1,3,4,2]\n输出: 3\n```\n\n\n**说明：**\n\n- 不能更改原数组（假设数组是只读的）。\n- 只能使用额外的 O(1) 的空间。\n- 时间复杂度小于 O(n2) 。\n- 数组中只有一个重复的数字，但它可能不止重复出现一次 \n\n**解法一**\n\n这题还是挺有意思的，题目要求了数组nums是只读的，且不能使用额外的空间，且时间复杂度还要小于O(N^2)，否则的话其实可以排序，或者使用Hash表来做，这里我们使用二分来做\n\n```java\n//update: 2020.5.26 其实也属于二分答案\npublic int findDuplicate(int[] nums){\n    int left=1,right=nums.length-1;\n    //这里实际上是对【1,2,3,4,...n-1】这个区间进行二分\n    //在过程中对mid检测每个数在nums数组中出现的次数\n    //1 3 4 2 2实际上是对【1,2,3,4】区间进行二分\n    while(left<right){\n        int mid=left+(right-left)/2+1;\n        //小于mid的数大于mid,排除mid\n        if(count(nums,mid)>=mid){ \n            right=mid-1;\n        }else{\n            left=mid;\n        }\n    }\n    return left;\n}\n\n//n-1个整数 , 1~n有n个数     \n//1 2 2 3 4     1~4之间, 1 2 3 4\npublic int count(int[] nums,int n){\n    int res=0;\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]<n) {\n            res++;          \n        }\n    }\n    return res;\n}\n```\n这样的解法还是很巧妙的，对nums数组的**取值范围**进行二分，二分的核心就是，nums数组中，小于取值范围中mid的元素应该小于等于mid\n\n举个例子：`[1 3 4 2 2]` 取值范围是`[1 2 3 4]` ，取中点2，正常情况下nums中小于等于2的元素，应该最多有2个，也就是`[1 2]`2个，但是这里在nums中，有3个`[1 2 2]` 大于2了，这就说明一定有重复的元素，而且一定是小于中点2的，也就是在左半边，下一步就应该舍弃右半边，在`[1,2]`中继续查找 \n\n这里按照我们之前的模板来写，先找排除mid的条件，**在nums中小于mid的元素的数量小于等于mid的时候，包括mid在内的右边界都会被排除，肯定都不是重复的元素** ，然后就按照模板写出二分就行了\n\n**解法二**\n\n快慢指针的做法，技巧性很强，一般人第一次做是很难想到这种做法的，其实和 [链表专题](http://imlgw.top/2019/02/27/leetcode-lian-biao-tag/#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8) 中的环形链表是一样的做法，然后按照那个思路走就行了，不清楚原理可以看看上面环形链表的解法\n\n```java\npublic int findDuplicate(int[] nums){\n    int slow=0,fast=0;\n    boolean isMeet=false;\n    while(true){\n        fast=isMeet?nums[fast]:nums[nums[fast]];\n        slow=nums[slow];\n        if (fast==slow) {\n            if (isMeet) {\n                return slow;\n            }\n            fast=0;\n            isMeet=true;\n        }\n    }\n}\n```\n这种解法的关键是将数组值看作索引然后再数组像链表一样移动，比如 `[1,2,3,4,5,6,7,8,9,5]`用值作为索引连接起来就是`1 2 3 4 [5 6 7 8 9] [5 6 7 8 9] ....` ，时间复杂度`O(N)` 技巧性比较强，如果面试管不追问的话其实答出上面的二分就ok了\n\n## [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)\n\n传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。\n\n传送带上的第 `i` 个包裹的重量为 `weights[i]`。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n\n返回能在 `D` 天内将传送带上的所有包裹送达的船的最低运载能力。\n\n**示例 1：**\n\n```java\n输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5\n输出：15\n解释：\n船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：\n第 1 天：1, 2, 3, 4, 5\n第 2 天：6, 7\n第 3 天：8\n第 4 天：9\n第 5 天：10\n\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 \n```\n\n**示例 2：**\n\n```java\n输入：weights = [3,2,2,4,1,4], D = 3\n输出：6\n解释：\n船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：\n第 1 天：3, 2\n第 2 天：2, 4\n第 3 天：1, 4\n```\n\n**示例 3：**\n\n```java\n输入：weights = [1,2,3,1,1], D = 4\n输出：3\n解释：\n第 1 天：1\n第 2 天：2\n第 3 天：3\n第 4 天：1, 1\n```\n\n**提示：**\n\n1. `1 <= D <= weights.length <= 50000`\n2. `1 <= weights[i] <= 500`\n\n**解法一**\n\n问题的解空间是单调的，所以可以直接二分答案，然后验证是否满足条件就可以了，时间复杂度`O(NlogN)`\n\n```java\npublic int shipWithinDays(int[] weights, int D) {\n    int sum=0,max=0;\n    for(int w:weights){\n        max=Math.max(w,max);\n        sum+=w;\n    }\n    int left=Math.max(sum/D,max),right=sum;\n    int res=0;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(weights,mid,D)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\n//模拟判断\npublic boolean check(int[] weights,int load,int D){\n    int temp=0;\n    for(int w:weights){\n        if(temp+w>load){\n            temp=0;\n            D--;\n        }\n        temp+=w;\n    }\n    //return D>=0;\n    return D>0;\n}\n```\n\n上面是用的一个[大佬](https://www.bilibili.com/video/BV1YT4y137G4)的模板，不是之前的模板，之前的模板我刚刚写了一发，写错了。。。。\n\n```java\n//之前的二分模板\npublic int shipWithinDays(int[] weights, int D) {\n    int sum=0,max=0;\n    for(int w:weights){\n        max=Math.max(w,max);\n        sum+=w;\n    }\n    int left=Math.max(sum/D,max),right=sum;\n    while(left<right){ //这里一开始写成<=了....\n        int mid=left+(right-left)/2;\n        if(check(weights,mid,D)){\n            right=mid;\n        }else{\n            left=mid+1;\n        }\n    }\n    return left;\n}\n```\n\n两种模板各有优点吧，这个大佬的模板相对更简单，但是res的初始值需要格外注意。。。\n\n## [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)\n\n珂珂喜欢吃香蕉。这里有 `N` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `H` 小时后回来。\n\n珂珂可以决定她吃香蕉的速度 `K` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `K` 根。如果这堆香蕉少于 `K` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  \n\n珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n\n返回她可以在 `H` 小时内吃掉所有香蕉的最小速度 `K`（`K` 为整数）。\n\n**示例 1：**\n\n```java\n输入: piles = [3,6,7,11], H = 8\n输出: 4\n```\n\n**示例 2：**\n\n```java\n输入: piles = [30,11,23,4,20], H = 5\n输出: 30\n```\n\n**示例 3：**\n\n```java\n输入: piles = [30,11,23,4,20], H = 6\n输出: 23\n```\n\n**提示：**\n\n- `1 <= piles.length <= 10^4`\n- `piles.length <= H <= 10^9`\n- `1 <= piles[i] <= 10^9`\n\n**解法一**\n\n一开始想用`sum/H`向上取整做左边界，结果直接爆掉了，case还是很给力啊\n\n```java\n//二分答案\npublic int minEatingSpeed(int[] piles, int H) {\n    int max=0;\n    for(int p:piles) max=Math.max(max,p);\n    int left=1,right=max;\n    int res=right;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(piles,mid,H)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[] piles,int k,int H){\n    int count=0;\n    for(int p:piles) count+=(p-1)/k+1; //向上取整\n    return count<=H;\n}\n```\n\n## [1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/) \n\n给你一个大小为 `m x n` 的矩阵 `mat` 和一个整数阈值 `threshold`。\n\n请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 **0** 。\n\n\n**示例 1：**\n\n![Y2wPne.png](https://s1.ax1x.com/2020/05/17/Y2wPne.png)\n\n```java\n输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n输出：2\n解释：总和小于 4 的正方形的最大边长为 2，如图所示。\n```\n\n**示例 2：**\n\n```java\n输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n输出：0\n```\n\n**示例 3：**\n\n```java\n输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6\n输出：3\n```\n\n**示例 4：**\n\n```java\n输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184\n输出：2\n```\n\n**提示：**\n\n- `1 <= m, n <= 300`\n- `m == mat.length`\n- `n == mat[i].length`\n- `0 <= mat[i][j] <= 10000`\n- `0 <= threshold <= 10^5`\n\n**解法一**\n\n这个题是个好题啊，又学到新东西了：**二维前缀和**，首先看到这道题就意识到了这是个二分答案的题，直接二分边长就行了，左端点`1`，右端点`min(m,n)`，某个边长`x`满足的时候，大于`x`的都满足，某个`x`不满足的时候，小于`x`的都不满足，解空间具有单调性\n\n所以关键问题就是`check`怎么写，如果直接暴力枚举所有矩形然后计算时间复杂度会很恐怖，这个时候就可以引入**二维前缀和**，我就不具体讲解了，看看[官方题解](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/yuan-su-he-xiao-yu-deng-yu-yu-zhi-de-zheng-fang-2/)就行了，写的挺好的\n\n```java\npublic int maxSideLength(int[][] mat, int threshold) {\n    int m=mat.length;\n    int n=mat[0].length;\n    int left=1,right=Math.min(m,n);\n    //核心公式\n    //sum([x1,y1]->[x2,y2])\n    //= P[x2][y2]-P[x2][y1-1]-P[x1-1][y2]+P[x1-1][y1-1]\n    //==> mat[i][j]=P[i][j]-P[i-1][j]-P[j-1][i]+P[i-1][j-1]\n    int[][] dp=new int[m+1][n+1];\n    for (int i=1;i<=m;i++) {\n        for (int j=1;j<=n;j++) {\n            dp[i][j]=mat[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n        }\n    }\n    int res=0;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(mat,mid,threshold,dp)){\n            res=mid;\n            left=mid+1;\n        }else{\n            right=mid-1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[][] mat,int side,int threshold,int[][] dp){\n    //枚举所有的左端点\n    for (int i=1;i+side-1<=mat.length;i++) {\n        for (int j=1;j+side-1<=mat[0].length;j++) {\n            int ri=i+side-1,rj=j+side-1;\n            //System.out.println(ri+\",\"+rj+\" dp:\"+ dp[ri][rj]);\n            if(dp[ri][rj]-dp[i-1][rj]-dp[ri][j-1]+dp[i-1][j-1]<=threshold){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n## [1300. 转变数组后最接近目标值的数组和](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/) \n\n给你一个整数数组 `arr` 和一个目标值 `target` ，请你返回一个整数 `value` ，使得将数组中所有大于 `value` 的值变成 `value` 后，数组的和最接近  `target` （最接近表示两者之差的绝对值最小）。\n\n如果有多种使得和最接近 `target` 的方案，请你返回这些整数中的最小值。\n\n请注意，答案不一定是 `arr` 中的数字。\n\n**示例 1：**\n\n```java\n输入：arr = [4,9,3], target = 10\n输出：3\n解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。\n```\n\n**示例 2：**\n\n```java\n输入：arr = [2,3,5], target = 10\n输出：5\n```\n\n**示例 3：**\n\n```java\n输入：arr = [60864,25176,27249,21296,20204], target = 56803\n输出：11361\n```\n\n**提示：**\n\n- `1 <= arr.length <= 10^4`\n- `1 <= arr[i], target <= 10^5`\n\n**解法一**\n\n解空间在`[0,max(arr)]`上单调，所以可以二分答案\n\n一开始傻傻的写了两个二分，一个找第一个小于等于target的，一个找大于等于的，其实根本就不用，这两个值肯定是连在一起的🤣\n\n```java\npublic int findBestValue(int[] arr, int target) {\n    int sum=0;\n    int left=0,right=Integer.MIN_VALUE;\n    for(int num:arr){\n        sum+=num;\n        right=Math.max(right,num);\n    }\n    if(sum<=target) return right;\n    int res=left;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(getSum(arr,mid)<=target){\n            res=mid;\n            left=mid+1;\n        }else{\n            right=mid-1;\n        }\n    }\n    //这两个值肯定是连在一起的\n    if(target-getSum(arr,res)<=getSum(arr,res+1)-target){\n        return res;\n    }\n    return res+1;\n}\n\npublic int getSum(int[] arr,int mid){\n    int sum=0;\n    for(int a:arr){\n        sum+=a>mid?mid:a;\n    }\n    return sum;\n}\n```\n\n## [LCP 12. 小张刷题计划](https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/)\n\n为了提高自己的代码能力，小张制定了 `LeetCode` 刷题计划，他选中了 `LeetCode` 题库中的 `n` 道题，编号从 `0` 到 `n-1`，并计划在 `m` 天内**按照题目编号顺序**刷完所有的题目（注意，小张不能用多天完成同一题）。\n\n在小张刷题计划中，小张需要用 `time[i]` 的时间完成编号 `i` 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。\n\n我们定义 `m` 天中做题时间最多的一天耗时为 `T`（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 `T`是多少。\n\n**示例 1：**\n\n> 输入：`time = [1,2,3,3], m = 2`\n>\n> 输出：`3`\n>\n> 解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。\n\n**示例 2：**\n\n> 输入：`time = [999,999,999], m = 4`\n>\n> 输出：`0`\n>\n> 解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。\n\n**限制：**\n\n- `1 <= time.length <= 10^5`\n- `1 <= time[i] <= 10000`\n- `1 <= m <= 1000`\n\n**解法一**\n\n知道是二分答案但是check写了好久没写出来，真菜啊\n\n```java\npublic int minTime(int[] time, int m) {\n    int left=0,right=0;//上界最多sum(time)\n    for(int i=0;i<time.length;i++){\n        right+=time[i];\n    }\n    int res=right+1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(time,mid,m)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    //其实返回left就行了,主要是避免搞混\n    return res; \n}\n\n//核心的check\npublic boolean check(int[] time,int T,int m){\n    int day=1,sum=0,maxt=0;\n    for (int t:time) {\n        sum+=t;\n        maxt=Math.max(maxt,t); //维护每一组的最大值\n        if(sum-maxt>T){ //当前组减去最大值不满足\n            day++;\n            sum=t;\n            maxt=t;\n        }\n    }\n    return day<=m;\n}\n```\n\n## [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)\n\n给定一个非负整数数组和一个整数 *m*，你需要将这个数组分成 *m* 个非空的连续子数组。设计一个算法使得这 *m* 个子数组各自和的最大值最小。\n\n**注意:**\n数组长度 *n* 满足以下条件:\n\n- 1 ≤ *n* ≤ 1000\n- 1 ≤ *m* ≤ min(50, *n*)\n\n**示例:**\n\n```java\n输入:\nnums = [7,2,5,10,8]\nm = 2\n\n输出:\n18\n\n解释:\n一共有四种方法将nums分割为2个子数组。\n其中最好的方式是将其分为[7,2,5] 和 [10,8]，\n因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。\n```\n\n**解法一**\n\nHard题，但是感觉和前面的mid差不多，没啥好说的，个人感觉这题还没上面的[LCP12.小张刷题计划](#lcp-12-小张刷题计划) 难，不过有个case挺恶心，算的sum会溢出，害我WA了一次，但是他结果返回的又是个int，这就很蠢\n\n```java\n//一样的套路\npublic int splitArray(int[] nums, int m) {\n    long left=0,right=0;\n    for(int num:nums){\n        left=Math.max(left,num);\n        right+=num;\n    }\n    long res=0;\n    while(left<=right){\n        long mid=left+(right-left)/2;\n        if(check(nums,mid,m)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return (int)res;\n}\n\n//分为m组能否保证每组都小于等于mid（如果可以说明还可以更小）\npublic boolean check(int[] nums,long limit,int m){\n    long sum=0;\n    int count=1;\n    for(int num:nums){\n        if(sum+num>limit){\n            sum=0;\n            count++;\n        }\n        sum+=num;\n    }\n    return count<=m;\n}\n```\n\n## [NC82.分组](https://www.nowcoder.com/practice/829419bde0e946b6b4fe813ed3972db8)\n\n题目描述\n牛牛有一个n个数字的序列a1，a2，a3...an现在牛牛想把这个序列分成k段连续段，牛牛想知道分出来的k个连续段的段内数字和的最小值最大可以是多少？\n\n**示例1**\n```go\n输入 : 4,2,[1,2,1,5]\n输出 : 4\n说明:\n有3种分法\n[1],[2,1,5]，数字和分别为1，8，最小值为1\n[1,2][1,5]，数字和分别为3，6，最小值为3\n[1,2,1],[5]数字和分别为4，5，最小值为4\n则最小值的最大值为4\n```\n**备注:**\n- 1 <= k <= n <= 1e5\n- 0 <= ai <= 1e4\n\n第一个参数整数n代表序列数字个数，\n第二个参数整数k代表分出的段数，\n第三个参数vector a 包含n个元素代表n个数字\n\n**解法一**\n\n我是真的菜啊，上面一题会写这题就不会写了，果然我这种菜鸡刷题就是背题，变一下就不会了。。。其实和上面的正好是反过来的，上面是要最大值最小，这里是要最小值最大，所以check的思路也是相反的，上面是验证：分为k组能否保证每组都小于等于mid。所以这题很显然就应该是：分为k组能否保证每组都大于等于mid（这里验证也是逐渐逼近答案）\n```java\n//最小值最大\npublic int solve (int n, int k, int[] a) {\n    int left = 0;\n    int right = 0;\n    for (int i = 0; i < a.length; i++) {\n        left = Math.min(left, a[i]);\n        right += a[i];\n    }\n    int res = 0;\n    while (left <= right) {\n        int mid = left + (right-left)/2;\n        if (check(mid, a, k)) {\n            res = mid;\n            left = mid + 1;\n        }else {\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n\n//分为k组能否保证每组都大于等于mid（如果可以说明还可以更大）\npublic boolean check(int mid, int[] a, int k) {\n    int sum = 0;\n    int count = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n        if (sum >= mid) {\n            sum = 0;\n            count++;\n        }\n    }\n    return count >= k;\n}\n```\n## [1482. 制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)\n\n给你一个整数数组 `bloomDay`，以及两个整数 m 和 k 。\n\n现需要制作 `m` 束花。制作花束时，需要使用花园中 `相邻的 k` 朵花 。\n\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\n\n**示例 1：**\n\n```java\n输入：bloomDay = [1,10,3,10,2], m = 3, k = 1\n输出：3\n解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3\n```\n**示例 2：**\n```java\n输入：bloomDay = [1,10,3,10,2], m = 3, k = 2\n输出：-1\n解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。\n```\n**示例 3：**\n```\n输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n输出：12\n解释：要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。\n```\n**示例 4：**\n```java\n输入：bloomDay = [1000000000,1000000000], m = 1, k = 1\n输出：1000000000\n解释：需要等 1000000000 天才能采到花来制作花束\n示例 5：\n\n输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n输出：9\n ```\n**提示：**\n- bloomDay.length == n\n- 1 <= n <= 10^5\n- 1 <= bloomDay[i] <= 10^9\n- 1 <= m <= 10^6\n- 1 <= k <= n\n\n**解法一**\n\n193th周赛的T3，没参加，但是在群里听群友讨论了，是个二分，刚刚具体的看了题目，发现其实是很明显的二分答案，很可惜没参加这次比赛，感觉能A3道。。。\n```java\npublic int minDays(int[] bloomDay, int m, int k) {\n    int n=bloomDay.length;\n    if(m*k>n) return -1; //花园的花不够\n    //直接写就完事了，这里数据范围只到1e9，log(1e9)很小的，只有30左右\n    int left=1,right=(int)1e9;\n    int res=right+1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(bloomDay,m,k,mid)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\n//check写的好丑...\npublic boolean check(int[] bloomDay,int m,int k,int day){\n    int i=0;\n    int count=0;\n    while(i<bloomDay.length){\n        int temp=0;\n        while(i<bloomDay.length){\n            if(bloomDay[i]<=day){\n                temp++;\n                if(temp==k){\n                    count++;\n                    break;\n                }\n                i++;\n            }else{\n                break;\n            }\n        }\n        if(count>=m) return true;\n        i++;\n    }\n    return false;\n}\n```\n**解法二**\n\n看了评论区，然后自己思考了下，改进了`check`\n```java\npublic int minDays(int[] bloomDay, int m, int k) {\n    int n=bloomDay.length;\n    if(m*k>n) return -1; //花园的花不够\n    //直接写就完事了，这里数据范围只到1e9，log(1e9)很小的，只有30左右\n    int left=1,right=(int)1e9; \n    int res=right+1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(check(bloomDay,m,k,mid)){\n            res=mid;\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[] bloomDay,int m,int k,int day){\n    int i=0;\n    int count=0;\n    int temp=0; //相邻的开花数量\n    for(int d:bloomDay){\n        if(d<=day){ //花开了(md，这个if写反两次)\n            temp++;\n        }else{\n            temp=0;\n        }\n        if(temp==k){\n            temp=0;\n            count++;\n        }\n    }\n    return count>=m;\n}\n```\n\n## [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n\nDifficulty: **中等**\n\n\n给定一个 _`n x n` _矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。  \n请注意，它是排序后的第 `k` 小元素，而不是第 `k` 个不同的元素。\n\n**示例：**\n\n```go\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\n返回 13。\n```\n\n**提示：**  \n你可以假设 k 的值永远是有效的，`1 ≤ k ≤ n<sup>2 </sup>`。\n\n（直接搬运我在lc题解区写的[题解](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/java-xiao-gen-dui-er-fen-da-an-chang-shi-jie-shi-e/)）\n\n**解法一**\n\n小根堆，多路归并，没啥好说的\n```java\npublic int kthSmallest(int[][] matrix, int k) {\n    PriorityQueue<Pair> pq = new PriorityQueue<>((p1,p2)->matrix[p1.x][p1.y] - matrix[p2.x][p2.y]);\n    for(int i = 0;i < matrix.length; i++){\n        pq.add(new Pair(i, 0));  \n    } \n    while(k > 1){\n        Pair pair = pq.poll();\n        if(pair.y + 1 < matrix[0].length){\n            pq.add(new Pair(pair.x, pair.y+1));   \n        }\n        k--;\n    }\n    return matrix[pq.peek().x][pq.peek().y];\n}\n\nclass Pair{\n    int x, y;\n    public Pair(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n```\n\n**解法二**\n\n二分答案，我们求的元素一定是在`matrix[0][0]~matrix[n-1][n-1]`之间，取中间某个元素`mid`，大于`mid`的都分布在右下角，小于`mid`的的分布在右上角，越往右上走，小于`mid`的元素就越少，大于`mid`的元素就越多，所以整体是具有单调性的，所以可以二分\n\n然后我认为很关键的一个地方就是二分的写法，我这里用的是 [zls的一个二分模板](https://www.bilibili.com/video/BV1YT4y137G4)，两个分支，一个是答案区间，一个是排除区间，在答案区间记录答案，现在问题就是：是用 `<=` 作为答案区间，还是用 `>=`做为答案区间？\n\n两种方法的区别就是区间收缩的方式不一样，前者是`left=mid+1`后者是`right=mid-1`，所以问题其实就变成了：当**小于等于mid的数量==k**的时候，二分的区间应该如何缩减？\n\n其实举个例子就懂了\n```go\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 2\n```\nk=2，对应结果应该是5，但是我们现在mid=8，这里8和5在矩阵中小于等于它们的数量是相同的，这个时候很明显应该缩短right去逼近5，所以我们应该选取`>=`作为答案区间并记录答案，并且缩短right逼近矩阵中真实存在的值\n\n>这里是一定是可以取到矩阵中的值的，二分最后会在大于等于区域不断缩减right直至不能再缩减，也就是缩减成为矩阵中的元素（再缩减就小于K了）\n```java\npublic int kthSmallest(int[][] matrix, int k) {\n    int n = matrix.length;\n    int left = matrix[0][0];\n    int right = matrix[n-1][n-1];\n    int res = left;\n    while(left <= right){\n        int mid = left + (right - left)/2;\n        //注意这个地方，很关键，核心就是这个等于号的位置，在小于等于mid的数量==k的时候二分的区间应该如何移动\n        //其实举个例子就懂了，假设k=2，对于结果应该是5，但是我们现在mid=8\n        //这里8和5在矩阵中小于等于它们的数量是相同的，这个时候很明显应该缩短right去逼近5\n        //所以我们应该在二分的大于等于区间记录答案，并且缩短right\n        if (check(matrix, mid) >= k){\n            res = mid;\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return res;\n}\n\n//检查数组中小于等于mid的个数\npublic int check(int[][] matrix, int mid){\n    int row = matrix.length-1, column = 0;\n    int count = 0;\n    int lastRow = 0; \n    while(row >= 0){\n        while (column < matrix[0].length && matrix[row][column] <= mid){\n            column++;\n            lastRow++;\n        }\n        count += lastRow;\n        row--;\n    }\n    return count;\n}\n```\n\n## [441. 排列硬币](https://leetcode-cn.com/problems/arranging-coins/)\n\nDifficulty: **简单**\n\n你总共有 _n _枚硬币，你需要将它们摆成一个阶梯形状，第 _k _行就必须正好有 _k _枚硬币。\n\n给定一个数字 _n_，找出可形成完整阶梯行的总行数。\n\n_n _是一个非负整数，并且在32位有符号整型的范围内。\n\n**示例 1:**\n\n```\nn = 5\n\n硬币可排列成以下几行:\n¤\n¤ ¤\n¤ ¤\n\n因为第三行不完整，所以返回2.\n```\n\n**示例 2:**\n\n```\nn = 8\n\n硬币可排列成以下几行:\n¤\n¤ ¤\n¤ ¤ ¤\n¤ ¤\n\n因为第四行不完整，所以返回3.\n```\n**解法一**\n\n因为是从二分的tag来的，所以知道是二分，然后看了题，确定了有二分答案性质，然后直接二分，可是没想到居然溢出了，看来还是有点大意了啊，时间复杂度O(logN)\n```java\n//二分答案\npublic int arrangeCoins(int n) {\n    int left = 1;\n    int right = n;\n    int res = 0;\n    while(left <= right){\n        long mid = left + (right - left)/2;\n        long sum = (1 + mid) * mid / 2;\n        if(sum <= n){\n            res = (int)mid;\n            left = (int)mid + 1;\n        }else{\n            right = (int)mid - 1;\n        }\n    }\n    return res;\n}\n```\n这题当然也可以直接模拟，不过意义不大，这题还有数学的解法，根据求和公式直接算出根，然后利用sqrt函数，这样并不会比二分快多少，sqrt也是logN级别的，而且面试官应该也不希望你利用库函数（当然人如果能手写牛顿迭代法那肯定没问题）\n\n## [174. 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)\n\nDifficulty: **困难**\n\n\n一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。\n\n<table class=\"dungeon\" style=\"display: table;\">\n\n<tbody style=\"display: table-row-group;\">\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-2 (K)</td>\n\n<td style=\"display: table-cell;\">-3</td>\n\n<td style=\"display: table-cell;\">3</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-5</td>\n\n<td style=\"display: table-cell;\">-10</td>\n\n<td style=\"display: table-cell;\">1</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">10</td>\n\n<td style=\"display: table-cell;\">30</td>\n\n<td style=\"display: table-cell;\">-5 (P)</td>\n\n</tr>\n\n</tbody>\n\n</table>\n\n**说明:**\n\n*   骑士的健康点数没有上限。\n\n*   任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n\n**解法一**\n\n以后每日一题没写出来之前绝壁不看群了，看了一眼群，看见群友讨论了这题，说了二分和dp，然后我就直接向二分的方向去想了，如果独立的想的话，应该也是可以得出二分的解法的，毕竟题目的描述很明显就是二分答案，**最低的健康血量**，大于这个血量的肯定可以救出来，小于这个血量的肯定救不出来，所以check就是判断在某个血量下，能否拯救到公主（DP）\n\n时间复杂度O(N^2logN)（其实我认为也可以当作N^2毕竟上下界都确定了，logN也就30左右），这种解法也挺不错的，融合了二分和dp\n\n```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int left = 0;\n    int right = Integer.MAX_VALUE;\n    int res = 0;\n    while(left <= right){\n        int mid = left + (right-left)/2;\n        if(check(dungeon, mid)){\n            res = mid;\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[][] dungeon, int live){\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MIN_VALUE;\n    //live的血量从左上到dungeon[i][j]的剩余最多血量\n    int[][] dp = new int[m+1][n+1];\n    //地牢外围加上INF的围墙，简化逻辑\n    Arrays.fill(dp[0], INF);\n    dp[0][1] = live;\n    for(int i = 1; i <= m; i++){\n        dp[i][0] = INF;\n        for(int j = 1; j <= n; j++){\n            if(dp[i-1][j] <= 0 && dp[i][j-1] <=0 ){\n                dp[i][j] = INF; //无法到达这里\n            }else{\n                dp[i][j] = dungeon[i-1][j-1] + Math.max(dp[i][j-1], dp[i-1][j]);\n            }\n        }\n    }\n    return dp[m][n] > 0;\n}\n```\n当然这题也有纯dp的做法，很可惜，我压根没往上面想，我只想着二分dp，写完了AC之后就去看评论区了，结果发现大家都是直接dp的。。。然后还看到了一个关键词：逆向dp，然后赶紧关了评论区回来写了下面的dp解法\n\n**解法二**\n```java\n/*\n    -2  -3  3\n    -5 -10  1\n    10  30 -5 1\n            \n    7   5   2\n    6  11   5\n    1   1   6\n*/\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MAX_VALUE;\n    //从dungeon[i-1][j-1]到右下角至少要多少血量\n    int[][] dp = new int[m+1][n+1];\n    Arrays.fill(dp[m], INF);//末行\n    dp[m][n-1] = 1; //初始血量\n    for (int i = m-1; i >= 0; i--) {\n        dp[i][n] = INF; //首列和尾列\n        for (int j = n-1; j >= 0; j--) {\n            dp[i][j] = Math.max(Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1);\n        }\n    }\n    return dp[0][0];\n}\n```\n这题为啥不能正向dp呢，设`dp[i][j]`为从左上角到i,j所需要的最低血量? 其实这个很明显就是有问题的，没办法转移，`dp[i][j]`和`dp[i-1][j]`没有任何关系，都不一定是同一条路径\n\n## [848. 加油站之间的最小距离（LintCode）](https://www.lintcode.com/problem/minimize-max-distance-to-gas-station/description)\n\n在水平数轴上，我们有加油站：stations[0], stations[1], ..., stations[N-1], 这里N = stations.length。\n\n现在，我们再增加K个加油站，D表示相邻加油站之间的最大距离，这样D就变小了。\n\n返回所有可能值D中最小值。\n1. stations.length 为整数，范围 [10, 2000].\n2. stations[i] 为整数，范围 [0, 10^8].\n3. K 为整数，范围 [1, 10^6].\n4. 答案范围在10 ^ -6之内的有理数。\n   \n**样例 1:**\n```go\n输入：stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，K = 9\n输出：0.50\n解释：相邻加油站的距离均为0.50\n```\n**样例 2:**\n```go\n输入：stations = [3,6,12,19,33,44,67,72,89,95]，K = 2\n输出：14.00\n解释：在距离86处建造加油站(fix: 还有58处)\n```\n\n**解法一**\n\n二分答案的性质很明显，但是这里和之前的不一样，这里是浮点数二分，和整数的不太一样，浮点数/2的时候都是实际的一分为2，不会有整除的问题，同时题目给出了eps=1e-6，只要left和right误差在这个范围内就是合法的，并不是要求left和right相等，这里还有一个问题，就是这里如果eps太小的话由于精度问题还是可能会tle，这个时候就可以采取固定循环次数的方式逼近，一般取100，200就够了\n```java\npublic double minmaxGasDist(int[] stations, int k) {\n    // Write your code here\n    double left = 0;\n    double right = 1e8+1;\n    double res = right;\n    //for (int i = 0; i <= 100; i++){\n    while (right-left >= 1e-6){\n        double mid = left+(right-left)/2;\n        if (check(stations, k, mid)) {\n            res = mid;\n            right = mid;\n        }else{\n            left = mid;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[] stations, int k, double D) {\n    int count = 0;\n    for (int i = 1; i < stations.length; i++) {\n        count += (stations[i]-stations[i-1]) / D;\n    }\n    return count <= k;        \n}\n```\n\n## [5489. 两球之间的磁力](https://leetcode-cn.com/problems/magnetic-force-between-two-balls/)\n\nDifficulty: **中等**\n\n\n在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 `n` 个空的篮子，第 `i` 个篮子的位置在 `position[i]` ，Morty 想把 `m` 个球放到这些篮子里，使得任意两球间 **最小磁力** 最大。\n\n已知两个球如果分别位于 `x` 和 `y` ，那么它们之间的磁力为 `|x - y|` 。\n\n给你一个整数数组 `position` 和一个整数 `m` ，请你返回最大化的最小磁力。\n\n**示例 1：**\n\n![mark](http://static.imlgw.top/blog/20200816/1KmEXzfFOozs.png?imageslim)\n```go\n输入：position = [1,2,3,4,7], m = 3\n输出：3\n解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n```\n\n**示例 2：**\n\n```go\n输入：position = [5,4,3,2,1,1000000000], m = 2\n输出：999999999\n解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。\n```\n\n**提示：**\n\n*   `n == position.length`\n*   `2 <= n <= 10^5`\n*   `1 <= position[i] <= 10^9`\n*   所有 `position` 中的整数 **互不相同** 。\n*   `2 <= m <= position.length`\n\n\n**解法一**\n\n202周赛T3，没参赛（实在是没时间打）赛后独立的写出来了，很明显是二分答案，不过这里有一点小不同\n```java\npublic int maxDistance(int[] position, int m) {\n    Arrays.sort(position);\n    int left = 1;\n    int right = (int)1e9+1;\n    int res = 1;\n    while (left <= right) {\n        int mid = left + (right-left)/2;\n        if (check(position, m, mid)) {\n            res = mid;\n            left = mid + 1; \n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n//1  1000 2000 3000 m=3\n//验证在距离至少为force的情况下能否放下所有的球，然后增大force逼近答案\n//所以check验证成功的不一定是合法的答案，但是最终一定会到达real ans\n//类似【378. 有序矩阵中第K小的元素】这道题\npublic boolean check(int[] position, int m, int force) {\n    int last = position[0];\n    m--;\n    for (int i = 1; i < position.length; i++) {\n        if (position[i]-last < force) {\n            continue;\n        }\n        last = position[i];\n        m--;\n        if (m==0) return true;\n    }\n    return false;\n}\n```\ncheck类似[378. 有序矩阵中第K小的元素](#378-有序矩阵中第k小的元素)这道题，都是逼近答案，而不是验证答案，其实一开始我的check不是这样写的，写的很丑，这里看了别人的写法发现continue有时候还是挺好用的","tags":["LeetCode","二分"],"categories":["算法"]},{"title":"堆和优先队列","url":"/2019/12/01/dui-he-you-xian-dui-lie/","content":"\n### 堆\n\n首先我们要明白，堆实际上是一颗完全二叉树，借助**完全二叉树**父子节点关系的性质，我们就可以很方便的在数组中实现这一结构，而堆也分为两种，一种是大根堆，顾名思义也就是父节点value大于子节点value，小根堆则相反\n\n### 动态数组\n\n借助这个类实现堆结构，直接用`ArrayList`也可以\n\n```java\n\npublic class Array<E> {\n\n    private E[] data;\n    private int size;\n\n    // 构造函数，传入数组的容量capacity构造Array\n    public Array(int capacity){\n        data = (E[])new Object[capacity];\n        size = 0;\n    }\n\n    // 无参数的构造函数，默认数组的容量capacity=10\n    public Array(){\n        this(10);\n    }\n\n    // 获取数组的容量\n    public int getCapacity(){\n        return data.length;\n    }\n\n    // 获取数组中的元素个数\n    public int getSize(){\n        return size;\n    }\n\n    // 返回数组是否为空\n    public boolean isEmpty(){\n        return size == 0;\n    }\n\n    // 在index索引的位置插入一个新元素e\n    public void add(int index, E e){\n        if(index < 0 || index > size)\n            throw new IllegalArgumentException(\"Add failed. Require index >= 0 and index <= size.\");\n        if(size == data.length)\n            resize(2 * data.length); //2倍扩容\n        for(int i = size - 1; i >= index ; i --){\n            data[i + 1] = data[i];\n        }\n        data[index] = e;\n        size ++;\n    }\n\n    // 向所有元素后添加一个新元素\n    public void addLast(E e){\n        add(size, e);\n    }\n\n    // 在所有元素前添加一个新元素\n    public void addFirst(E e){\n        add(0, e);\n    }\n\n    // 获取index索引位置的元素\n    public E get(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Get failed. Index is illegal.\");\n        return data[index];\n    }\n\n    // 修改index索引位置的元素为e\n    public void set(int index, E e){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Set failed. Index is illegal.\");\n        data[index] = e;\n    }\n\n    // 查找数组中是否有元素e\n    public boolean contains(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return true;\n        }\n        return false;\n    }\n\n    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1\n    public int find(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return i;\n        }\n        return -1;\n    }\n\n    // 从数组中删除index位置的元素, 返回删除的元素\n    public E remove(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Remove failed. Index is illegal.\");\n\n        E ret = data[index];\n        for(int i = index + 1 ; i < size ; i ++)\n            data[i - 1] = data[i];\n        size --;\n        data[size] = null; // loitering objects != memory leak\n        //数据不到1/4的时候缩减\n        if(size == data.length / 4 && data.length / 2 != 0)\n            resize(data.length / 2);\n        return ret;\n    }\n\n    // 从数组中删除第一个元素, 返回删除的元素\n    public E removeFirst(){\n        return remove(0);\n    }\n\n    // 从数组中删除最后一个元素, 返回删除的元素\n    public E removeLast(){\n        return remove(size - 1);\n    }\n\n    // 从数组中删除元素e\n    public void removeElement(E e){\n        int index = find(e);\n        if(index != -1)\n            remove(index);\n    }\n\n    //交换\n    public void swap(int a,int b){\n        if (a<0||a>=size || b<0||b>=size) {\n            throw new IllegalArgumentException(\"index illegal\");\n        }\n        E temp=data[a];\n        data[a]=data[b];\n        data[b]=temp;\n    }\n\n    @Override\n    public String toString(){\n\n        StringBuilder res = new StringBuilder();\n        res.append(String.format(\"Array: size = %d , capacity = %d\\n\", size, data.length));\n        res.append('[');\n        for(int i = 0 ; i < size ; i ++){\n            res.append(data[i]);\n            if(i != size - 1)\n                res.append(\", \");\n        }\n        res.append(']');\n        return res.toString();\n    }\n\n    // 将数组空间的容量变成newCapacity大小\n    private void resize(int newCapacity){\n        E[] newData = (E[])new Object[newCapacity];\n        for(int i = 0 ; i < size ; i ++)\n            newData[i] = data[i];\n        data = newData;\n    }\n}\n\n```\n\n### 大根堆\n\n```java\npublic class MaxHeap<E extends Comparable<E>>{\n    private Array<E> data;\n\n    public MaxHeap(int capacity){\n        data=new Array<>(capacity);\n    }\n\n    public MaxHeap(){\n        data=new Array<>();\n    }\n\n    public int size(){\n        return data.getSize();\n    }\n\n    public boolean isEmpty(){\n        return data.isEmpty();\n    }\n\n    //父节点\n    private int parent(int index){\n        if (index==0) {\n            throw new IllegalArgumentException(\"index 0 don't have parent\");\n        }\n        return (index-1)/2;\n    }\n\n    //左孩子\n    private int leftChild(int index){\n        return index*2+1;\n    }\n\n    //右孩子\n    private int rightChild(int index){\n        return index*2+2;\n    }\n\n    public void add(E e){\n        data.addLast(e);\n        siftUp(data.getSize()-1);\n    }\n\n    //上浮\n    private void siftUp(int cur){\n        while(cur>0 && data.get(parent(cur)).compareTo(data.get(cur)) < 0){\n            data.swap(cur,parent(cur));\n            cur=parent(cur);\n        }\n    }\n\n    public E findMax(){\n        if (data.getSize()==0) {\n            throw new IllegalArgumentException(\"heap is empty !!!\");\n        }\n        return  data.get(0);\n    }\n\n    public E popMax(){\n        if (data.getSize()==0) {\n            throw new IllegalArgumentException(\"heap is empty !!!\");\n        }\n        E res=findMax();\n        data.swap(0,data.getSize()-1);\n        data.removeLast();\n        siftDown(0);\n        return res;\n    }    \n\n    private void siftDown(int cur){\n        while(leftChild(cur)<data.getSize()){ //有左孩子\n            int large=leftChild(cur);\n            //如果也有右孩子,就比较下两个节点的值取最大值\n            if (large+1<data.getSize() && data.get(large).compareTo(data.get(large+1))<0) {\n                large=large+1;\n            }\n            //比左右孩子都大就直接结束了\n            if (data.get(large).compareTo(data.get(cur))<=0){\n                return;\n            }\n            data.swap(large,cur);\n            cur=large;\n        }\n    }\n}\n```\n\n其实上面的实现还是有一些缺陷的，只能按照给定的键的默认排序规则进行比较，不方便实现自定义的比较规则，需要进行封装才可以，关于这一点其实可以借鉴Java中的`PriorityQueue`\n\n### 测试\n\n```java\nimport java.util.*;\npublic class HeapTest{\n    public static void main(String[] args) {\n        int[] nums=generateRandomArray(50000000,500);\n        MaxHeap heap=new MaxHeap();\n        for (int i=0;i<nums.length;i++) {\n            heap.add(nums[i]);\n        }\n        for (int i=0;i<nums.length;i++) {\n            nums[i]=(int)heap.popMax();\n        }\n        for (int i=1;i<nums.length;i++) {\n            if (nums[i-1]<nums[i]) {\n                System.out.println(\"fuxk!!!\");\n                return;\n            }\n        }\n        System.out.println(\"sucess!!!!!\");\n    }\n\n    // for test\n    public static int[] generateRandomArray(int maxSize, int maxValue) {\n        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());\n        }\n        return arr;\n    }\n}\n```\n\n### PriorityQueue\n\n```java\npackage java.util;\n\nimport java.util.function.Consumer;\nimport sun.misc.SharedSecrets;\n\n/**\n * An unbounded priority {@linkplain Queue queue} based on a priority heap.\n * The elements of the priority queue are ordered according to their\n * {@linkplain Comparable natural ordering}, or by a {@link Comparator}\n * provided at queue construction time, depending on which constructor is\n * used.  A priority queue does not permit {@code null} elements.\n * A priority queue relying on natural ordering also does not permit\n * insertion of non-comparable objects (doing so may result in\n * {@code ClassCastException}).\n *\n * <p>The <em>head</em> of this queue is the <em>least</em> element\n * with respect to the specified ordering.  If multiple elements are\n * tied for least value, the head is one of those elements -- ties are\n * broken arbitrarily.  The queue retrieval operations {@code poll},\n * {@code remove}, {@code peek}, and {@code element} access the\n * element at the head of the queue.\n *\n * <p>A priority queue is unbounded, but has an internal\n * <i>capacity</i> governing the size of an array used to store the\n * elements on the queue.  It is always at least as large as the queue\n * size.  As elements are added to a priority queue, its capacity\n * grows automatically.  The details of the growth policy are not\n * specified.\n *\n * <p>This class and its iterator implement all of the\n * <em>optional</em> methods of the {@link Collection} and {@link\n * Iterator} interfaces.  The Iterator provided in method {@link\n * #iterator()} is <em>not</em> guaranteed to traverse the elements of\n * the priority queue in any particular order. If you need ordered\n * traversal, consider using {@code Arrays.sort(pq.toArray())}.\n *\n * <p><strong>Note that this implementation is not synchronized.</strong>\n * Multiple threads should not access a {@code PriorityQueue}\n * instance concurrently if any of the threads modifies the queue.\n * Instead, use the thread-safe {@link\n * java.util.concurrent.PriorityBlockingQueue} class.\n *\n * <p>Implementation note: this implementation provides\n * O(log(n)) time for the enqueuing and dequeuing methods\n * ({@code offer}, {@code poll}, {@code remove()} and {@code add});\n * linear time for the {@code remove(Object)} and {@code contains(Object)}\n * methods; and constant time for the retrieval methods\n * ({@code peek}, {@code element}, and {@code size}).\n *\n * <p>This class is a member of the\n * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n * Java Collections Framework</a>.\n *\n * @since 1.5\n * @author Josh Bloch, Doug Lea\n * @param <E> the type of elements held in this collection\n */\npublic class PriorityQueue<E> extends AbstractQueue<E>\n    implements java.io.Serializable {\n\n    private static final long serialVersionUID = -7720805057305804111L;\n\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n    /**\n     * Priority queue represented as a balanced binary heap: the two\n     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The\n     * priority queue is ordered by comparator, or by the elements'\n     * natural ordering, if comparator is null: For each node n in the\n     * heap and each descendant d of n, n <= d.  The element with the\n     * lowest value is in queue[0], assuming the queue is nonempty.\n     */\n    transient Object[] queue; // non-private to simplify nested class access\n\n    /**\n     * The number of elements in the priority queue.\n     */\n    private int size = 0;\n\n    /**\n     * The comparator, or null if priority queue uses elements'\n     * natural ordering.\n     * 如果没有传入比较器的话，按照元素的自然排序进行比较\n     */\n    private final Comparator<? super E> comparator;\n\n    /**\n     * The number of times this priority queue has been\n     * <i>structurally modified</i>.  See AbstractList for gory details.\n     */\n    transient int modCount = 0; // non-private to simplify nested class access\n\n    /**\n     * Creates a {@code PriorityQueue} with the default initial\n     * capacity (11) that orders its elements according to their\n     * {@linkplain Comparable natural ordering}.\n     */\n    public PriorityQueue() {\n        this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n\n    public PriorityQueue(int initialCapacity) {\n        this(initialCapacity, null);\n    }\n    \n    //传入自定义的比较规则\n    public PriorityQueue(Comparator<? super E> comparator) {\n        this(DEFAULT_INITIAL_CAPACITY, comparator);\n    }\n\n    public PriorityQueue(int initialCapacity,\n                         Comparator<? super E> comparator) {\n        // Note: This restriction of at least one is not actually needed,\n        // but continues for 1.5 compatibility\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new Object[initialCapacity];\n        this.comparator = comparator;\n    }\n\n    /**\n     * Creates a {@code PriorityQueue} containing the elements in the\n     * specified collection.  If the specified collection is an instance of\n     * a {@link SortedSet} or is another {@code PriorityQueue}, this\n     * priority queue will be ordered according to the same ordering.\n     * Otherwise, this priority queue will be ordered according to the\n     * {@linkplain Comparable natural ordering} of its elements.\n     * 传入一个集合类型，如果是SortSet（有序）类型的集合或者也是PriorityQueue就会按照相同的规则去比较。\n     * 否则就会按照元素的自然排序规则去比较。\n     * \n     * @param  c the collection whose elements are to be placed\n     *         into this priority queue\n     * @throws ClassCastException if elements of the specified collection\n     *         cannot be compared to one another according to the priority\n     *         queue's ordering\n     * @throws NullPointerException if the specified collection or any\n     *         of its elements are null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public PriorityQueue(Collection<? extends E> c) {\n        if (c instanceof SortedSet<?>) {\n            SortedSet<? extends E> ss = (SortedSet<? extends E>) c;\n            //拿到SortSet集合中元素的比较器，用于后序的操作\n            this.comparator = (Comparator<? super E>) ss.comparator();\n            initElementsFromCollection(ss);\n        }\n        else if (c instanceof PriorityQueue<?>) {\n            PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;\n            this.comparator = (Comparator<? super E>) pq.comparator();\n            initFromPriorityQueue(pq);\n        }\n        else {\n            this.comparator = null;\n            initFromCollection(c);\n        }\n    }\n\n    /**\n     * Creates a {@code PriorityQueue} containing the elements in the\n     * specified priority queue.  This priority queue will be\n     * ordered according to the same ordering as the given priority\n     * queue.\n     *\n     * @param  c the priority queue whose elements are to be placed\n     *         into this priority queue\n     * @throws ClassCastException if elements of {@code c} cannot be\n     *         compared to one another according to {@code c}'s\n     *         ordering\n     * @throws NullPointerException if the specified priority queue or any\n     *         of its elements are null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public PriorityQueue(PriorityQueue<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initFromPriorityQueue(c);\n    }\n\n    /**\n     * Creates a {@code PriorityQueue} containing the elements in the\n     * specified sorted set.   This priority queue will be ordered\n     * according to the same ordering as the given sorted set.\n     *\n     * @param  c the sorted set whose elements are to be placed\n     *         into this priority queue\n     * @throws ClassCastException if elements of the specified sorted\n     *         set cannot be compared to one another according to the\n     *         sorted set's ordering\n     * @throws NullPointerException if the specified sorted set or any\n     *         of its elements are null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public PriorityQueue(SortedSet<? extends E> c) {\n        this.comparator = (Comparator<? super E>) c.comparator();\n        initElementsFromCollection(c);\n    }\n\n    private void initFromPriorityQueue(PriorityQueue<? extends E> c) {\n        if (c.getClass() == PriorityQueue.class) {\n            this.queue = c.toArray();\n            this.size = c.size();\n        } else {\n            initFromCollection(c);\n        }\n    }\n\t\n\t//从SortSet有序集合中的元素直接复制到当前的queue中\n    private void initElementsFromCollection(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        // If c.toArray incorrectly doesn't return Object[], copy it.\n        if (a.getClass() != Object[].class)\n            a = Arrays.copyOf(a, a.length, Object[].class);\n        int len = a.length;\n        if (len == 1 || this.comparator != null)\n            for (int i = 0; i < len; i++)\n                if (a[i] == null)\n                    throw new NullPointerException();\n        this.queue = a;\n        this.size = a.length;\n    }\n\n    /**\n     * Initializes queue array with elements from the given Collection.\n     * 从无序集合中构建queue\n     * @param c the collection\n     */\n    private void initFromCollection(Collection<? extends E> c) {\n        initElementsFromCollection(c);\n        //复制完成之后进行调整\n        heapify();\n    }\n\n    /**\n     * The maximum size of array to allocate.\n     * Some VMs reserve some header words in an array.\n     * Attempts to allocate larger arrays may result in\n     * OutOfMemoryError: Requested array size exceeds VM limit\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * Increases the capacity of the array.\n     * queue 数组扩容\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        int oldCapacity = queue.length;\n        // Double size if small; else grow by 50%\n        int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                         (oldCapacity + 2) :\n                                         (oldCapacity >> 1));\n        // overflow-conscious code\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        queue = Arrays.copyOf(queue, newCapacity);\n    }\n\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     * Inserts the specified element into this priority queue.\n     *\n     * @return {@code true} (as specified by {@link Collection#add})\n     * @throws ClassCastException if the specified element cannot be\n     *         compared with elements currently in this priority queue\n     *         according to the priority queue's ordering\n     * @throws NullPointerException if the specified element is null\n     */\n    public boolean add(E e) {\n        return offer(e);\n    }\n\n    /**\n     * Inserts the specified element into this priority queue.\n     *\n     * @return {@code true} (as specified by {@link Queue#offer})\n     * @throws ClassCastException if the specified element cannot be\n     *         compared with elements currently in this priority queue\n     *         according to the priority queue's ordering\n     * @throws NullPointerException if the specified element is null\n     */\n    public boolean offer(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        modCount++;\n        int i = size;\n        if (i >= queue.length)\n            grow(i + 1);\n        size = i + 1;\n        if (i == 0)\n            queue[0] = e;\n        else\n            siftUp(i, e);\n        return true;\n    }\n\n    public E peek() {\n        return (size == 0) ? null : (E) queue[0];\n    }\n\n    private int indexOf(Object o) {\n        if (o != null) {\n            for (int i = 0; i < size; i++)\n                if (o.equals(queue[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Removes a single instance of the specified element from this queue,\n     * if it is present.  More formally, removes an element {@code e} such\n     * that {@code o.equals(e)}, if this queue contains one or more such\n     * elements.  Returns {@code true} if and only if this queue contained\n     * the specified element (or equivalently, if this queue changed as a\n     * result of the call).\n     *\n     * @param o element to be removed from this queue, if present\n     * @return {@code true} if this queue changed as a result of the call\n     */\n    public boolean remove(Object o) {\n        int i = indexOf(o);\n        if (i == -1)\n            return false;\n        else {\n            removeAt(i);\n            return true;\n        }\n    }\n\n    /**\n     * Version of remove using reference equality, not equals.\n     * Needed by iterator.remove.\n     *\n     * @param o element to be removed from this queue, if present\n     * @return {@code true} if removed\n     */\n    boolean removeEq(Object o) {\n        for (int i = 0; i < size; i++) {\n            if (o == queue[i]) {\n                removeAt(i);\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n\n\n    public Object[] toArray() {\n        return Arrays.copyOf(queue, size);\n    }\n\n    public <T> T[] toArray(T[] a) {\n        final int size = this.size;\n        if (a.length < size)\n            // Make a new array of a's runtime type, but my contents:\n            return (T[]) Arrays.copyOf(queue, size, a.getClass());\n        System.arraycopy(queue, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n    private final class Itr implements Iterator<E> {\n        /**\n         * Index (into queue array) of element to be returned by\n         * subsequent call to next.\n         */\n        private int cursor = 0;\n\n        /**\n         * Index of element returned by most recent call to next,\n         * unless that element came from the forgetMeNot list.\n         * Set to -1 if element is deleted by a call to remove.\n         */\n        private int lastRet = -1;\n\n\n        private ArrayDeque<E> forgetMeNot = null;\n\n        /**\n         * Element returned by the most recent call to next iff that\n         * element was drawn from the forgetMeNot list.\n         */\n        private E lastRetElt = null;\n\n        /**\n         * The modCount value that the iterator believes that the backing\n         * Queue should have.  If this expectation is violated, the iterator\n         * has detected concurrent modification.\n         */\n        private int expectedModCount = modCount;\n\n        public boolean hasNext() {\n            return cursor < size ||\n                (forgetMeNot != null && !forgetMeNot.isEmpty());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public E next() {\n            if (expectedModCount != modCount)\n                throw new ConcurrentModificationException();\n            if (cursor < size)\n                return (E) queue[lastRet = cursor++];\n            if (forgetMeNot != null) {\n                lastRet = -1;\n                lastRetElt = forgetMeNot.poll();\n                if (lastRetElt != null)\n                    return lastRetElt;\n            }\n            throw new NoSuchElementException();\n        }\n\n        public void remove() {\n            if (expectedModCount != modCount)\n                throw new ConcurrentModificationException();\n            if (lastRet != -1) {\n                E moved = PriorityQueue.this.removeAt(lastRet);\n                lastRet = -1;\n                if (moved == null)\n                    cursor--;\n                else {\n                    if (forgetMeNot == null)\n                        forgetMeNot = new ArrayDeque<>();\n                    forgetMeNot.add(moved);\n                }\n            } else if (lastRetElt != null) {\n                PriorityQueue.this.removeEq(lastRetElt);\n                lastRetElt = null;\n            } else {\n                throw new IllegalStateException();\n            }\n            expectedModCount = modCount;\n        }\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public void clear() {\n        modCount++;\n        for (int i = 0; i < size; i++)\n            queue[i] = null;\n        size = 0;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public E poll() {\n        if (size == 0)\n            return null;\n        int s = --size;\n        modCount++;\n        E result = (E) queue[0];\n        E x = (E) queue[s];\n        queue[s] = null;\n        if (s != 0)\n            siftDown(0, x);\n        return result;\n    }\n\n    /**\n     * Removes the ith element from queue.\n     * 删除某个位置的元素\n     * Normally this method leaves the elements at up to i-1,\n     * inclusive, untouched.  Under these circumstances, it returns\n     * null.  Occasionally, in order to maintain the heap invariant,\n     * it must swap a later element of the list with one earlier than\n     * i.  Under these circumstances, this method returns the element\n     * that was previously at the end of the list and is now at some\n     * position before i. This fact is used by iterator.remove so as to\n     * avoid missing traversing elements.\n     */\n    private E removeAt(int i) {\n        // assert i >= 0 && i < size;\n        modCount++;\n        int s = --size;\n        if (s == i) // removed last element 移除最后一个元素\n            queue[i] = null;\n        else {\n            E moved = (E) queue[s]; //保存队列尾部的元素\n            queue[s] = null; //置为null\n            siftDown(i, moved); //moved直接插入到i位置，相当于直接删除了i位置的元素\n            if (queue[i] == moved) {\n                siftUp(i, moved);\n                if (queue[i] != moved)\n                    return moved;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts item x at position k, maintaining heap invariant by\n     * promoting x up the tree until it is greater than or equal to\n     * its parent, or is the root.\n     * 将x插入k位置，并进行上浮调整\n     * To simplify and speed up coercions and comparisons. the\n     * Comparable and Comparator versions are separated into different\n     * methods that are otherwise identical. (Similarly for siftDown.)\n     *\n     * @param k the position to fill\n     * @param x the item to insert\n     */\n    private void siftUp(int k, E x) {\n        if (comparator != null)\n            siftUpUsingComparator(k, x);\n        else\n            siftUpComparable(k, x);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftUpComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>) x;\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (key.compareTo((E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = key;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftUpUsingComparator(int k, E x) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (comparator.compare(x, (E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = x;\n    }\n\n    /**\n     * Inserts item x at position k, maintaining heap invariant by\n     * demoting x down the tree repeatedly until it is less than or\n     * equal to its children or is a leaf.\n     * 插入元素x到到位置k,并进行下沉调整\n     * \n     * @param k the position to fill\n     * @param x the item to insert\n     */\n    private void siftDown(int k, E x) {\n        if (comparator != null)\n            siftDownUsingComparator(k, x);  //带比较器的\n        else\n            siftDownComparable(k, x); //不带比较器，用x的compator\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftDownComparable(int k, E x) {\n        Comparable<? super E> key = (Comparable<? super E>)x;\n        int half = size >>> 1;        // loop while a non-leaf\n        while (k < half) {\n            int child = (k << 1) + 1; // assume left child is least\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)\n                c = queue[child = right];\n            if (key.compareTo((E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = key;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void siftDownUsingComparator(int k, E x) {\n        int half = size >>> 1;\n        while (k < half) {\n            int child = (k << 1) + 1;\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                comparator.compare((E) c, (E) queue[right]) > 0)\n                c = queue[child = right];\n            if (comparator.compare(x, (E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = x;\n    }\n\n    /**\n     * Establishes the heap invariant (described above) in the entire tree,\n     * assuming nothing about the order of the elements prior to the call.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void heapify() {\n        for (int i = (size >>> 1) - 1; i >= 0; i--)\n            siftDown(i, (E) queue[i]);\n    }\n\n    public Comparator<? super E> comparator() {\n        return comparator;\n    }\n\n    /**\n     * Saves this queue to a stream (that is, serializes it).\n     *\n     * @serialData The length of the array backing the instance is\n     *             emitted (int), followed by all of its elements\n     *             (each an {@code Object}) in the proper order.\n     * @param s the stream\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n        // Write out element count, and any hidden stuff\n        s.defaultWriteObject();\n\n        // Write out array length, for compatibility with 1.5 version\n        s.writeInt(Math.max(2, size + 1));\n\n        // Write out all elements in the \"proper order\".\n        for (int i = 0; i < size; i++)\n            s.writeObject(queue[i]);\n    }\n\n    /**\n     * Reconstitutes the {@code PriorityQueue} instance from a stream\n     * (that is, deserializes it).\n     *\n     * @param s the stream\n     */\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        // Read in size, and any hidden stuff\n        s.defaultReadObject();\n\n        // Read in (and discard) array length\n        s.readInt();\n\n        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size);\n        queue = new Object[size];\n\n        // Read in all elements.\n        for (int i = 0; i < size; i++)\n            queue[i] = s.readObject();\n\n        // Elements are guaranteed to be in \"proper order\", but the\n        // spec has never explained what that might be.\n        heapify();\n    }\n\n    /**\n     * Creates a <em><a href=\"Spliterator.html#binding\">late-binding</a></em>\n     * and <em>fail-fast</em> {@link Spliterator} over the elements in this\n     * queue.\n     *\n     * <p>The {@code Spliterator} reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, and {@link Spliterator#NONNULL}.\n     * Overriding implementations should document the reporting of additional\n     * characteristic values.\n     *\n     * @return a {@code Spliterator} over the elements in this queue\n     * @since 1.8\n     */\n    public final Spliterator<E> spliterator() {\n        return new PriorityQueueSpliterator<E>(this, 0, -1, 0);\n    }\n\n    static final class PriorityQueueSpliterator<E> implements Spliterator<E> {\n        /*\n         * This is very similar to ArrayList Spliterator, except for\n         * extra null checks.\n         */\n        private final PriorityQueue<E> pq;\n        private int index;            // current index, modified on advance/split\n        private int fence;            // -1 until first use\n        private int expectedModCount; // initialized when fence set\n\n        /** Creates new spliterator covering the given range */\n        PriorityQueueSpliterator(PriorityQueue<E> pq, int origin, int fence,\n                             int expectedModCount) {\n            this.pq = pq;\n            this.index = origin;\n            this.fence = fence;\n            this.expectedModCount = expectedModCount;\n        }\n\n        private int getFence() { // initialize fence to size on first use\n            int hi;\n            if ((hi = fence) < 0) {\n                expectedModCount = pq.modCount;\n                hi = fence = pq.size;\n            }\n            return hi;\n        }\n\n        public PriorityQueueSpliterator<E> trySplit() {\n            int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;\n            return (lo >= mid) ? null :\n                new PriorityQueueSpliterator<E>(pq, lo, index = mid,\n                                                expectedModCount);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public void forEachRemaining(Consumer<? super E> action) {\n            int i, hi, mc; // hoist accesses and checks from loop\n            PriorityQueue<E> q; Object[] a;\n            if (action == null)\n                throw new NullPointerException();\n            if ((q = pq) != null && (a = q.queue) != null) {\n                if ((hi = fence) < 0) {\n                    mc = q.modCount;\n                    hi = q.size;\n                }\n                else\n                    mc = expectedModCount;\n                if ((i = index) >= 0 && (index = hi) <= a.length) {\n                    for (E e;; ++i) {\n                        if (i < hi) {\n                            if ((e = (E) a[i]) == null) // must be CME\n                                break;\n                            action.accept(e);\n                        }\n                        else if (q.modCount != mc)\n                            break;\n                        else\n                            return;\n                    }\n                }\n            }\n            throw new ConcurrentModificationException();\n        }\n\n        public boolean tryAdvance(Consumer<? super E> action) {\n            if (action == null)\n                throw new NullPointerException();\n            int hi = getFence(), lo = index;\n            if (lo >= 0 && lo < hi) {\n                index = lo + 1;\n                @SuppressWarnings(\"unchecked\") E e = (E)pq.queue[lo];\n                if (e == null)\n                    throw new ConcurrentModificationException();\n                action.accept(e);\n                if (pq.modCount != expectedModCount)\n                    throw new ConcurrentModificationException();\n                return true;\n            }\n            return false;\n        }\n\n        public long estimateSize() {\n            return (long) (getFence() - index);\n        }\n\n        public int characteristics() {\n            return Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.NONNULL;\n        }\n    }\n}\n\n```\n\n### 扩展\n\n**d叉堆**：多叉堆，上面我们实现的都是二叉堆，但是其实我们还可以将其扩展为多叉堆，一个节点有多个子节点\n\n**索引堆**：我们上面实现的二叉堆只能看见堆顶的元素，看不到堆中的元素，有时候我们可能需要操作堆中间的元素，索引堆顾名思义就是有索引可以对应每个元素，借此就可以操作堆中间的元素\n\n**二项堆**，**斐波拉契堆** ..... 这些结构其实都是扩展的，简单了解即可\n\n### 源码地址\n\n[Github](https://github.com/imlgw/LeetCode/blob/master/tree/heap/MaxHeap.java)\n\n","tags":["数据结构","堆","优先队列"],"categories":["数据结构"]},{"title":"LeetCode背包问题","url":"/2019/11/29/leetcode-bei-bao-wen-ti/","content":"\n> 从[动态规划专题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/) 中抽取出来的\n\n## [92.背包问题（lintCode）](https://www.lintcode.com/problem/backpack/description)\n\n在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]\n\n- 你不可以将物品进行切割\n\n**样例**\n\n```java\n样例 1:\n\t输入:  [3,4,8,5], backpack size=10\n\t输出:  9\n样例 2:\n\t输入:  [2,3,5,7], backpack size=12\n\t输出:  12\n```\n\n**挑战**\n\n- O(n x m) time and O(m) memory.\n\n- O(n x m) memory is also acceptable if you do not know how to optimize memory.\n\n**解法一**\n\n记忆化递归，对于每个元素，有两种选择，装或者不装\n\n```java\n//用Integer[][],空间会超空间。。。lintCode好严格\nint [][] cache=null;    \n\npublic int backPack2(int m,int[] A) {\n    cache=new int[A.length+1][m+1];\n    for (int i=0;i<A.length;i++) {\n        Arrays.fill(cache[i],-1);   \n    }\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    return putPack(m,A,A.length-1);\n}\n\n//将A[index,A.len-1]范围内的元素装进大小为m的背包的最大收益\npublic int putPack(int m,int[] A,int index) {\n    //index==0的时候不应该返回=0代表第一个,是可以装的\n    //对于m也是一样, 这种边界思考一下m就等于0，或者就只有一个元素，index就等于0这种特例就可以\n    //只要这种特例是正确的那么整个递归就是正确的,并不需要去思考整个递归的结束条件\n    if (index<0 || m<=0) {\n        return 0;\n    }\n    if (cache[index][m]!=-1) {\n        return cache[index][m];\n    }\n    //不装index位置的元素\n    int res=putPack(m,A,index-1);\n    if (A[index]<=m) {\n        //说明可以装下index位置的元素，所以我们将index位置的元素装进去试试看\n        //然后求出剩下的空间还最多能装多少，最后求是装index收益大还是不装index收益大\n        res=Math.max(res,A[index]+putPack(m-A[index],A,index-1));\n    }\n    cache[index][m]=res;\n    return res;\n}\n```\n\n暴力递归的时间复杂度将会是`O((2^N)*N)`\n\n其实整个递归的思路是很清晰明白的，对于每个元素，有两种情况，这也是之所以称之为0-1背包的原因\n\n- 不选的话，背包的容量不变，改变为问题`putPack(m,A,index-1)`\n- 选的话，背包的容量变小，改变为问题`putPack(m-A[index],A,index-1)+A[index]`\n\n到底选还是不选，取决于两种方案哪一种更好，我们要求的，就是这个最好的方案，知道了这样的递推关系后我们就可以很容易的写出递归方程，这里在递归的过程中有可能会产生重叠的子问题（其实这里我还纠结了好一会儿，我一直感觉没有重叠的子问题，后来画一下递归树就明白了，只是重叠的不明显），所以我们可以通过缓存每次计算的结果来进行记忆化递归，整体的时间复杂度应该是`O(2^N)`，空间`O(M*N)`显然不是我们想要的结果\n\n> 这里一开始我是想用`Integer[][]`的数组，然后就不用赋初始值，判断不为null就行，结果空间溢出了。。。lintCode好严格，换成`int[][]`然后赋个初始值就过了\n\n**解法二**\n\n动态规划解法，在讲解之前，我们用一个二维表来分析下整个递推的过程\n\n物品列表（样例1），因为这题价值就是重量，所以w和v是一样的\n\n![mark](http://static.imlgw.top/blog/20200227/XIvS0eAf1FqA.png?imageslim)\n\n**DpTable（样例1）**\n\n![mark](http://static.imlgw.top/blog/20200227/YkPisR3fx1wa.png?imageslim)\n\n一行一行的看，从左到右，`dp[index][m]`代表 **背包总容量不超过m的情况下，考虑装入`[0,index]`中的元素能获得最大收益**，比如`dp[1][7]`代表的就是背包总容量不超过7的情况下，考虑装入`[0,1]` 范围内的元素所能获得的最大收益，人脑思考结果自然是7了，下面我们分析下如果dp推出这个结果\n\n前面我们已经分析过0-1背包的递归过程，每个元素面临两个选择，这里也一样\n\n`dp[1][7]`如果我们选择不装入当前index位置的元素的话，那么最大收益就是`dp[0][7]=3`这一点应该没啥疑问\n\n如果我们考虑装入当前index位置的元素的话，m肯定会减小，那么所获得的最大收益就应该是`A[index]+dp[0][7-4]=7` \n\n> 注意这里当前index的值都是依赖于上一层`index-1`的计算结果的，也就是依赖于上一次`m,[0,index-1]`最大值的结果，所以我们需要手动的初始化第一层的值）\n\n最后我们得到的核心状态方程就是下面这样的\n\n`dp[index][m]=max(dp[index-1][m],A[index]+dp[index-1][j-A[index]])`\n\n然后我们根据这个很容易就可以写出dp的解法\n\n```java\n//二维动态规划\npublic int backPack(int m,int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[A.length][m+1];\n    for (int i=0;i<A.length;i++) {\n        for (int j=0;j<=m;j++) {\n            if (j==0) {//初始化第一列\n                dp[i][j]=0;\n            }else if (i==0) {//初始化第一行\n                dp[i][j]=j-A[i]>=0?A[i]:0;\n            }else if (i>0) {\n                dp[i][j]=j-A[i]>=0?Math.max(dp[i-1][j],dp[i-1][j-A[i]]+A[i]):dp[i-1][j];\n            }\n        }\n    }\n    return dp[A.length-1][m];\n}\n```\n当然我们肯定是不满足于这种二维的dp的，所以我们还得优化下空间，这里每一层都只依赖于上一层的结果，所以我么很容易就可以改成一维的，当然这里还有个小坑，如果直接按照上面的代码来改的话就是错的，我们先看看正确的改法\n\n```java\npublic int backPack4(int m,int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[m+1];\n    for (int i=0;i<A.length;i++) {\n        for (int j=m;j>=0;j--) {//从右向左，避免覆盖\n            if (j==0) {//初始化第一列\n                dp[j]=0;\n            }else if (i==0) {//初始化第一行\n                dp[j]= j-A[i]>=0?A[i]:0;\n            }else{\n                dp[j]=j-A[i]>=0?Math.max(dp[j],dp[j-A[i]]+A[i]):dp[j];\n            }\n        }\n    }\n    return dp[m];\n}\n```\n可以看到，我们的内层循环不再是从左往右，而是从右往左，这样的好处就是避免了`dp[j-A[i]]`已经被**当前内层循环前面的元素**覆盖的尴尬情况，结合上面的表推一下就知道了\n\n**解法三**\n\n算是对之前代码的优化吧，之前写的乱七八糟的\n\n```java\n//代码优化\npublic int backPack(int m,int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[m+1];\n    for (int i=0;i<A.length;i++) {\n        for (int j=m;j>=A[i];j--) {\n            dp[j]=Math.max(dp[j],dp[j-A[i]]+A[i]);\n        }\n    }\n    return dp[m];\n}\n```\n## [完全背包问题（acwing）](https://www.acwing.com/problem/content/description/3/) \n\n有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。\n\n第 i 种物品的体积是 vi，价值是 wi。\n\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。\n\n**输入格式**\n\n第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。\n\n接下来有 N 行，每行两个整数 vi,wi用空格隔开，分别表示第 i 种物品的体积和价值。\n\n**输出格式**\n\n输出一个整数，表示最大价值。\n\n**数据范围**\n\n0<N,V≤10000<N,V≤1000\n0<vi,wi≤10000<vi,wi≤1000\n\n**输入样例**\n\n```java\n4 5\n1 2\n2 4\n3 4\n4 5\n```\n\n**输出样例：**\n\n```java\n10\n```\n\n**解法一**\n\n相比01背包交换了内循环的顺序就ok了，当然也可以将每个物品拆分，不过复杂度会变高\n\n```java\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int V=sc.nextInt();\n        int[] dp=new int[V+1];\n        for(int i=0;i<N;i++){\n            int vi=sc.nextInt();\n            int wi=sc.nextInt();\n            for(int j=vi;j<=V;j++) {\n                dp[j]=Math.max(dp[j],dp[j-vi]+wi);\n            }\n        }\n        System.out.println(dp[V]);\n    }\n}\n```\n\n其实这个结论要直接理解还是有点难懂的，具体的推导过程可以看下面的 [零钱兑换](#322-零钱兑换)\n\n## [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n**注意:**\n\n1. 每个数组中的元素不会超过 100\n2. 数组的大小不会超过 200\n\n**示例 1:**\n\n```java\n输入: [1, 5, 11, 5]\n\n输出: true\n\n解释: 数组可以分割成 [1, 5, 5] 和 [11].\n```\n\n**示例 2:**\n\n```\n输入: [1, 2, 3, 5]\n\n输出: false\n\n解释: 数组不能分割成两个元素和相等的子集.\n```\n\n**解法一**\n\n现在递归写起来已经有点感觉了，类似的题基本上都能写出记忆化递归的方法来\n\n```java\n//记忆化递归37ms 44%,开始慢是因为stream的原因\nBoolean[][] cache=null;\n\npublic boolean canPartition(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    //int sum=Arrays.stream(nums).sum();\n    int sum=0;\n    for (int e:nums) sum+=e; //求和\n    cache=new Boolean[nums.length][sum+1];\n    if (sum%2!=0) {\n        return false;\n    }\n    return partition(nums,0,0,sum/2);\n}\n\n//尝试添加[0,index]位置的元素,看能否使得half=sum (这里其实应该直接在sum上减,看能不能减为0)\npublic boolean partition(int[] nums,int index,int half,int sum) {\n    if (index==nums.length) {\n        return false;\n    }\n    if (cache[index][half]!=null) {\n        return cache[index][half];\n    }\n\n    if (half==sum) {\n        return true;\n    }\n    cache[index][half]=partition(nums,index+1,half,sum) || \n        (half<sum&&partition(nums,index+1,half+nums[index],sum));\n    return cache[index][half];\n}\n```\n**解法二**\n\n动态规划，依然是典型的背包问题，可以理解为用nums中的元素，填满sum/2容量大小的背包，递推公式\n\n `dp[i][j] =dp[i-1][j] || dp[i-1][j-nums[i]]`  选当前元素和不选当前元素，有一个能填满就ok\n\n`dp[i][j]` 含义为：考虑`[0,i]` 范围内的元素，能否恰好装满 `j`大小的容器\n\n```java\n//二维dp\npublic boolean canPartition(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    //int sum=Arrays.stream(nums).sum(); 用stream好慢\n    int sum=0;\n    for (int e:nums) sum+=e; //求和\n    if (sum%2!=0) {\n        return false;\n    }\n    int half=sum/2;\n    //dp[i][j]的含义是从[0,i]中选取元素,能否刚好填满j\n    boolean[][] dp=new boolean[nums.length][half+1];\n    for (int j=0;j<=half;j++) {\n        dp[0][j]= nums[0]==j;\n    }\n    for (int i=1;i<nums.length;i++) {\n        for (int j=0;j<=half;j++) {\n            dp[i][j]= j>=nums[i]?dp[i-1][j] || dp[i-1][j-nums[i]]:dp[i-1][j];\n        }\n        //如果在某个位置（每行最后一个）已经刚好填满了就直接返回\n        if (dp[i][half]) {\n            return true;\n        }\n    }\n    return dp[nums.length-1][half];\n}\n```\n空间上的优化\n\n```java\npublic boolean canPartition(int[] nums) {\n    if (nums==null || nums.length<=0) return false;\n    int sum=0;\n    for (int e:nums) sum+=e; //求和\n    if (sum%2!=0) {\n        return false;\n    }\n    int half=sum/2;\n    //dp[j]的含义是从[0,i]中选取元素,能否刚好填满j\n    boolean[] dp=new boolean[half+1];\n    for (int j=0;j<=half;j++) {\n        dp[j]= nums[0]==j;\n    }\n\n    for (int i=1;i<nums.length;i++) {\n        for (int j=half;j>=nums[i];j--) {\n            //dp[i][j]= j>=nums[i]?dp[i-1][j] || dp[i-1][j-nums[i]]:dp[i-1][j];\n            dp[j]=dp[j]||dp[j-nums[i]];\n        }\n        if (dp[half]) {\n            return true;\n        }\n    }\n    return dp[half];\n}\n```\n## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n**示例 1:**\n\n```java\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n解释: 11 = 5 + 5 + 1\n```\n\n**示例 2:**\n\n```java\n输入: coins = [2], amount = 3\n输出: -1\n```\n\n**说明:**\n你可以认为每种硬币的数量是无限的\n\n**解法一**\n\n其实就是dfs，我最开始就是写的dfs只不过时间复杂度太高，没做记忆化，这里其实一开始做了记忆化也一直没跑过，一直超时，最后给的case是6249 好像也不算很大吧，然后我后来把`fill` 填充数组删了，用Integer就跑过了。。。\n\n```java\n//记忆化递归AC 50%左右\nprivate Integer[] cache=null;\n\npublic int coinChange2(int[] coins,int amount){\n    cache=new Integer[amount+1];\n    //Arrays.fill(cache,-1); 这里fill直接tle了。。。。\n    return takeCoins(coins,amount);\n}\n\npublic int takeCoins(int[] coins, int amount) {\n    if (amount==0) {\n        return 0;\n    }\n    if (cache[amount]!=null) {\n        return cache[amount];\n    }\n    //int t1=coins(coins,amount,index+1);\n    int res=Integer.MAX_VALUE;\n    for (int i=0;i<coins.length;i++) {\n        if (amount<coins[i]) continue;\n        int sub=takeCoins(coins,amount-coins[i]);\n        if (sub!=-1) {\n            res=Math.min(sub+1,res);\n        }\n    }\n    cache[amount]= res==Integer.MAX_VALUE?-1:res;\n    return cache[amount];\n}\n```\n**解法二**\n\n动态规划，二维dp，注意这里其实和前面的背包问题就有区别了，这里实际上就是个`无限背包`问题，因为这里的硬币是无限的，每个面值的硬币都可以重复的选取\n\n**DPTable**\n\n![mark](http://static.imlgw.top/blog/20200227/ekmjFAHgA2K4.png?imageslim)\n\n**状态定义**\n\n这里`dp[i][j]` 的含义为：**考虑`[0，i]` 范围内的元素，能凑成 `j` 所需的最少硬币数**，和之前的01背包问题状态定义没什么区别\n\n**状态方程**\n\n首先明确一点，这里我们对第`coins[i]`个硬币有两种选择 \n\n1. 不拿 \n2.  拿，拿1~k个(k为硬币个数的限制，这里没有限制，所以是无穷大)\n\n进而我们可以的到状态转移的方程：\n\n`f[i][j] = min(f[i-1][j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)`\n\n但是这个方程有很多计算是重复的\n\n`f[i][j-c]=min(f[i-1][j-c], f[i-1][j-2*c]+1, ..., f[i-1][j-k*c]+k-1)`\n\n两者合并得到\n\n`f[i][j] = min(f[i-1]f[j], f[i][j-c]+1)`  有了状态方程，代码就好写了\n\n```java\npublic int coinChange4(int[] coins,int amount){\n    int[][] dp=new int[coins.length][amount+1];\n    for (int j=0;j<=amount;j++) {\n        dp[0][j]=j%coins[0]==0?j/coins[0]:Integer.MAX_VALUE;\n    }\n    for (int i=1;i<coins.length;i++) {\n        for (int j=0;j<=amount;j++) {\n            if (j<coins[i] || dp[i][j-coins[i]]==Integer.MAX_VALUE) {\n                //放不下\n                dp[i][j]=dp[i-1][j];\n            }else {\n                dp[i][j]=Math.min(dp[i][j-coins[i]]+1,dp[i-1][j]);\n            }\n        }\n    }\n    return dp[coins.length-1][amount]!=Integer.MAX_VALUE?dp[coins.length-1][amount]:-1;\n}\n```\n\n**空间优化**\n\n将上面的二维改成一维就是像下面一样，注意内层的循环！因为后面是 `f[i][j-c]+1` 所以需要依赖同一层前面的结果，所以必须顺序的遍历\n\n```java\npublic int coinChange(int[] coins,int amount){\n    int[] dp=new int[amount+1];\n    //填充初始值为Integer.MAX_VALUE,代表不可达\n    Arrays.fill(dp,Integer.MAX_VALUE);\n    dp[0]=0; //除了dp[0]\n    for (int i=0;i<coins.length;i++) {\n        //注意这里不能逆序！\n        for (int j=coins[i];j<=amount;j++) {\n            if (dp[j-coins[i]]!=Integer.MAX_VALUE) {\n                dp[j]=Math.min(dp[j-coins[i]]+1,dp[j]);   \n            }\n        }\n    }\n    return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];\n}\n```\n## [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)\n\n给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个\n\n**示例 1:**\n\n```java\n输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n```\n\n**示例 2:**\n\n```java\n输入: amount = 3, coins = [2]\n输出: 0\n解释: 只用面额2的硬币不能凑成总金额3。\n```\n\n**示例 3:**\n\n```java\n输入: amount = 10, coins = [10] \n输出: 1\n```\n\n**注意:**\n\n你可以假设：\n\n- 0 <= amount (总金额) <= 5000\n- 1 <= coin (硬币面额) <= 5000\n- 硬币种类不超过 500 种\n- 结果符合 32 位符号整数\n\n**解法一**\n\n求方案数，不考虑顺序\n\n```java\npublic int change(int amount, int[] coins) {\n    if (coins==null || coins.length<=0) {\n        return amount==0?1:0;\n    }\n    int[][] dp=new int[coins.length][amount+1];\n    for (int i=0;i<coins.length;i++) {\n        for (int j=0;j<=amount;j++) {\n            if (i==0) {\n                dp[0][j]=j%coins[i]==0?1:0;\n            }else if (j==0) {\n                dp[i][0]=1;\n            }else{\n                  dp[i][j]= j>=coins[i]?dp[i-1][j]+dp[i][j-coins[i]]:dp[i-1][j];\n                //dp[i][j]= j>=coins[i]?dp[i-1][j]+dp[i-1][j-coins[i]]:dp[i-1][j];\n            }\n        }\n    }\n    return dp[coins.length-1][amount];\n}\n```\n**空间优化**\n\n`f(5)=f(4)+f(3)+f(0)` 突然感觉写二维的有点多余。。。这种子结构要清晰的多\n\n```java\n//直接理解一维dp还是不太容易,但是知道递推公式后先写个二维dp再改为一维就很容易\npublic int change(int amount, int[] coins) {\n    int[] dp=new int[amount+1];\n    dp[0]=1;\n    //这种方式相当于对dpTable从左向右,一行行的递推\n    for (int i=0;i<coins.length;i++) {\n        for (int j=0;j<=amount;j++) {\n            //dp[j]+= dp[j-coins[i]]:0;\n            dp[j]=j-coins[i]>=0?dp[j]+dp[j-coins[i]]:dp[j];\n        }\n    }\n    /* 交换一下内外顺序就变成了另一个问题的解\n    for (int j=0;j<=amount;j++) {\n        for (int i=0;i<coins.length;i++) {\n            dp[j]+= j-coins[i]>=0?dp[j-coins[i]]:0;\n        }\n    }*/\n    return dp[amount];\n}\n```\n**解法二**\n\n记忆化递归，基本上dp能过得，记忆化递归一定能过，相比之下，我觉得记忆化递归会好写一些\n\n```java\npublic int change(int amount, int[] coins) {\n    if (coins==null || coins.length<=0) {\n        return amount==0?1:0;\n    }\n    cache=new Integer[coins.length][amount+1];\n    return takeCoins(amount,coins,0);\n}\n\nInteger[][] cache=null;\n\n//[index,coins.length] 中凑成amount的方案数，考虑顺序\npublic int takeCoins(int amount,int[] coins,int index){\n    if (index>=coins.length || amount<0) {\n        return 0;\n    }\n    if (cache[index][amount]!=null) {\n        return cache[index][amount];\n    }\n    if (amount==0) {\n        return 1;\n    }\n    return cache[index][amount]=takeCoins(amount-coins[index],coins,index)+takeCoins(amount,coins,index+1);\n}\n```\n## [面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)\n\n硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)\n\n**解法一**\n\n和上面的一样的，但是这里有一些其他的方法，记录下，元素解法就不写了，和上面的一样\n\n```java\nint mod=1000000007;\n\npublic int waysToChange(int n) {\n    n/=5; //余数没有影响，都用1补\n    int[] coins={5,2,1}; //币值也/5\n    long[] dp=new long[n+1];\n    Arrays.fill(dp,1L); //排除1分的硬币，所有的面额都可以用1分的凑出来\n    for(int i=0;i<coins.length;i++){\n        for(int j=coins[i];j<=n;j++){\n            dp[j]=(dp[j]+dp[j-coins[i]])%mod;\n        }\n    }\n    return (int)(dp[n]%mod);\n}\n```\n\n直接把时间从114ms干到了17ms，其实时间复杂度没变，但是缩小了解空间，所以整体的时间会提高很多，当然这里能缩小的原因主要还是因为题目比较特殊\n\n## [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)\n\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n\n**示例:**\n\n```java\nnums = [1, 2, 3]\ntarget = 4\n\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\n请注意，顺序不同的序列被视作不同的组合。\n\n因此输出为 7。\n```\n\n**进阶：**\n如果给定的数组中含有负数会怎么样？\n问题会产生什么变化？\n我们需要在题目中添加什么限制来允许负数的出现？\n\n**解法一**\n\n记忆化递归，没啥好说的\n\n```java\n//记忆化递归 1ms 100%\npublic int combinationSum4(int[] nums, int target) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    cache=new Integer[target+1];\n    return combination(nums,target);\n}\n\nInteger[] cache=null;\n\npublic int combination(int[] nums,int target){\n    if (cache[target]!=null) {\n        return cache[target];\n    }\n    if (target==0) {\n        return 1;\n    }\n    int res=0;\n    for (int i=0;i<nums.length;i++) {\n        if (target-nums[i]>=0) {\n            res+=combination(nums,target-nums[i]);\n        }\n    }\n    return cache[target]=res;\n}\n```\n**解法二**\n\n动态规划，乍一看好像和上面一题一样，实际上并不一样，这里是考虑顺序的，最优子结构也是\n\n`f(5)=f(4)+f(3)+f(0)` 这样的\n\n```java\n//一维dp\npublic int combinationSum4(int[] nums,int target){\n    int[] dp=new int[target+1];\n    dp[0]=1;\n    for (int i=0;i<=target;i++) {\n        for (int j=0;j<nums.length;j++) {\n            dp[i]+= i>=nums[j]?dp[i-nums[j]]:0;\n        }\n    }\n    return dp[target];\n}\n```\n\n这里还是要存个疑啊，没搞明白啊，为啥交换个顺序就不一样了呢？一个是按行打表，一个是按列打表？？？还是递归好写。。。\n\n## [494. 目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n**示例 1:**\n\n```java\n输入: nums: [1, 1, 1, 1, 1], S: 3\n输出: 5\n解释: \n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n```\n\n**注意:**\n\n- 数组非空，且长度不会超过20。\n- 初始的数组的和不会超过1000。\n- 保证返回的最终结果能被32位整数存下\n\n**解法一**\n\n后面的题都优先写记忆化递归了，动态规划确实有点难顶\n\n```java\nInteger[][] cache=null;\n\n//HashMap<Integer,Integer> cache=new HashMap<>\n\npublic int findTargetSumWays(int[] nums, int S) {\n    if (nums==null || nums.length<=0 || S>1000) {\n        return 0;\n    }\n    //\n    int sum=0;\n    for(int n:nums)sum+=n;\n    if(S>sum)return 0;\n    \n    //相当于平移了一下,从[-sum,sum] --> [0,2*sum]\n    cache=new Integer[nums.length][2*sum+1];\n    return findTarget(nums,S,0,2*sum+1);\n}\n\npublic int findTarget(int[] nums,int S,int index,int max){\n    if (S==0 && index ==nums.length) {\n        return 1;\n    }\n    if (index>=nums.length) {\n        return 0;\n    }\n    if(S <0  && cache[index][S+max]!=null){\n        return cache[index][S+max];\n    }\n    if (S>=0 && cache[index][S]!=null) {\n        return cache[index][S];\n    }\n    int temp=findTarget(nums,S-nums[index],index+1,max)+findTarget(nums,S+nums[index],index+1,max);\n    if (S<0) {\n        cache[index][S+max]=temp;\n    }else{\n        cache[index][S]=temp;\n    }\n    return  temp;\n}\n```\n这题还是挺有意思的，因为里面是有负数的，直接记忆化是不行的，需要转换一下，这里我是直接将cache数组扩大，同时保证不会有覆盖，所以直接扩大为 2sum就ok，这样整个S的范围就从`[-sum,+sum]` 变为 `[0,2sum]` 从而可以缓存所有的递归结果，其实也可以使用两个数组一个存正数，一个存负数，然后只需要符号取反就ok了，只不过占用的空间会大一点\n\n**解法二**\n\n正儿八经的01背包做法\n\n```java\npublic int findTargetSumWays(int[] nums, int S) {\n    if(nums==null || nums.length<=0) return 0;\n    //nsum负,psum正; sum;\n    //sum=psum+nsum;\n    //S=psum-nsum;\n    //(sum+S)/2 = psum\n    int sum=0;\n    for(int i=0;i<nums.length;i++) sum+=nums[i];\n    if((sum+S)%2!=0 || S>sum) return 0;\n    int target=(sum+S)/2;\n    int[] dp=new int[target+1];\n    //Arrays.fill(dp,-1);\n    dp[0]=1;\n    for(int i=0;i<nums.length;i++){\n        for(int j=target;j>=nums[i];j--){\n            dp[j]+=dp[j-nums[i]];\n        }\n    }\n    return dp[target];\n}\n```\n\n## [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n- 如果 `x == y`，那么两块石头都会被完全粉碎；\n- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n\n最后，最多只会剩下一块石头。返回此石头**最小的可能重量**。如果没有石头剩下，就返回 `0`。\n\n**示例：**\n\n```go\n输入：[2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n```\n\n**提示：**\n\n1. `1 <= stones.length <= 30`\n2. `1 <= stones[i] <= 1000`\n\n**解法一**\n\n想了一下，其实就是在所有石头中选取部分石头，求这部分的石头和大于`sum/2`的最小值（和正常的背包思路反着来的）\n\n```java\n//   sum   = psum + nsum\n//  target = psum - nsum  (psum >= nsum)\n//  sum+target = 2*psum\n//  target = 2*psum-sum\n//  2*psum-sum>=0\n//记忆化递归\nInteger[][] dp=null;\n\npublic int lastStoneWeightII(int[] stones) {\n    int sum=0;\n    for (int i=0;i<stones.length;i++) {\n        sum+=stones[i];\n    }\n    dp=new Integer[stones.length+1][sum];\n    return 2*dfs(stones,0,0,sum)-sum;\n}\n\npublic int dfs(int[] stones,int index,int psum,int sum){\n    if(2*psum>=sum){\n        return psum;\n    }\n    if(dp[index][psum]!=null){\n        return dp[index][psum];\n    }\n    int min=Integer.MAX_VALUE;\n    for (int i=index;i<stones.length;i++) {\n        min=Math.min(dfs(stones,i+1,psum+stones[i],sum),min);\n    }\n    return dp[index][psum]=min;\n}\n```\n当我按照这个思路i写出来后发现不好改递推了😂，这个思路确实有一点点怪\n\n**解法二**\n\n正常的01背包解法，其实把上面的结论反过来就行了，既然要求一个大于等于`sum/2`的最小值，其实就是求一个小于等于`sum/2` 的最大值，这样一说就很清楚了，经典的01背包\n\n```java\npublic int lastStoneWeightII(int[] stones) {\n    if(stones==null ||stones.length<=0){\n        return 0;\n    }\n    int n=stones.length;\n    int sum=0;\n    for(int i=0;i<n;i++){\n        sum+=stones[i];\n    }\n    //背包容量为sum/2,求最多能装多少,经典的01背包\n    int amount=sum/2;\n    int[] dp=new int[amount+1];\n    for (int i=0;i<stones.length;i++) {\n        for (int j=amount;j>=stones[i];j--) {\n            dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);\n        }\n    }\n    //wrong: return (amount-dp[amount])*2;\n    //return sum%2==0?(amount-dp[amount])*2:(amount-dp[amount])*2+1\n    //nsum=dp[amount]\n    //target=psum-nsum = sum-nusm-nsum\n    return sum-2*dp[amount];\n}\n```\n这里的retrun有两种写法，推荐第二种，第一种还要判奇偶\n\n> 拿到这题的的第一个解法其实是贪心，每次消除两个最大的，用优先队列维护石头大小\n>\n> 天真的错误解法 74 / 82 个通过测试用例\n> [21,26,31,33,40] ->[7,21,26,31] -> [5,7,21] -> [5,14] ->[9]\n> [21,26,31,33,40] ->[19,26,31,33]->[5]\n>\n> 这个思路其实是 这题的弱化版本 [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/) 的解法\n\n## [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n在计算机界中，我们总是追求用有限的资源获取最大的收益。\n\n现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。\n\n你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。\n\n**注意:**\n\n- 给定 0 和 1 的数量都不会超过 100。\n- 给定字符串数组的长度不会超过 600。\n\n**示例 1:**\n\n```java\n输入: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\n输出: 4\n\n解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 \"10\",\"0001\",\"1\",\"0\" 。\n```\n\n**示例 2:**\n\n```java\n输入: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n输出: 2\n\n解释: 你可以拼出 \"10\"，但之后就没有剩余数字了。更好的选择是拼出 \"0\" 和 \"1\" 。\n```\n\n**解法一**\n\n之前只用Java写了个记忆化的，补一下纯dp的\n```golang\n//之前只用Java写了个记忆化的，补一下纯dp的\nfunc findMaxForm(strs []string, m int, n int) int {\n    var sn = len(strs)\n    var dp = make([][]int, m+1)\n    var Max = func(a, b int) int {if a>b {return a};return b}\n    for i := 0; i <= m; i++ {\n        dp[i] = make([]int, n+1)\n    }\n    for i := 0; i < sn; i++ {\n        zero, one := count(strs[i])\n        for j := m; j >= zero; j-- {\n            for k := n; k >= one; k-- {\n                dp[j][k] = Max(dp[j][k], dp[j-zero][k-one]+1)\n            }\n        }\n    }\n    return dp[m][n]\n}\n\nfunc count(str string) (int, int) {\n    var one, zero = 0, 0\n    for i := 0; i < len(str); i++ {\n        if str[i] == '0' {\n            zero++\n        }\n        if str[i] == '1' {\n            one++\n        }\n    }\n    return zero, one\n}\n```\n\n**解法二**\n\n其实这是一个多重背包问题，一个物品有多个权值\n\n```java\nInteger [][][] cache=null;\n\npublic int findMaxForm(String[] strs, int m, int n) {\n    cache=new Integer[m+1][n+1][strs.length];\n    return findMax(strs,m,n,0);\n}\n\n//m:0 n:1\npublic int findMax(String[] strs, int m, int n,int index) {\n    if (index>=strs.length) {\n        return 0;\n    }\n    if (cache[m][n][index]!=null) {\n        return cache[m][n][index];\n    }\n    int[] oz=count(strs[index]);\n    if (oz[1]<=n && oz[0]<=m) {\n        return cache[m][n][index]=Math.max(1+findMax(strs,m-oz[0],n-oz[1],index+1),findMax(strs,m,n,index+1));\n    }\n    return cache[m][n][index]=findMax(strs,m,n,index+1);\n}\n\npublic int[] count(String str){\n    int one=0,zero=0;\n    char[] s=str.toCharArray();\n    for (char c:s) {\n        if (c=='1') {\n            one++;\n        }else{\n            zero++;\n        }\n    }\n    return new int[]{zero,one};\n}\n```\n\n## [1255. 得分最高的单词集合](https://leetcode-cn.com/problems/maximum-score-words-formed-by-letters/)\n\n你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。\n\n请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。\n\n单词拼写游戏的规则概述如下：\n\n- 玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。\n- 可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。\n- 单词表 words 中每个单词只能计分（使用）一次。\n- 根据字母得分情况表score，字母 'a', 'b', 'c', ... , 'z' 对应的得分分别为 score[0], score[1], ..., score[25]。\n- 本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和\n\n**示例 1：**\n\n```java\n输入：words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\n输出：23\n解释：\n字母得分为  a=1, c=9, d=5, g=3, o=2\n使用给定的字母表 letters，我们可以拼写单词 \"dad\" (5+1+5)和 \"good\" (3+2+2+5)，得分为 23 。\n而单词 \"dad\" 和 \"dog\" 只能得到 21 分。\n```\n\n\n**示例 2：**\n\n```java\n输入：words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\n输出：27\n解释：\n字母得分为  a=4, b=4, c=4, x=5, z=10\n使用给定的字母表 letters，我们可以组成单词 \"ax\" (4+5)， \"bx\" (4+5) 和 \"cx\" (4+5) ，总得分为 27 。\n单词 \"xxxz\" 的得分仅为 25 。\n```\n\n\n**示例 3：**\n\n```java\n输入：words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\n输出：0\n解释：\n字母 \"e\" 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。\n```\n\n**提示：**\n\n- `1 <= words.length <= 14`\n- `1 <= words[i].length <= 15`\n- `1 <= letters.length <= 100`\n- `letters[i].length == 1`\n- `score.length == 26`\n- `0 <= score[i] <= 10`\n- `words[i] 和 letters[i] `只包含小写的英文字母\n\n**解法一**\n\n看着题目就知道这题不简单😂，11.10的周赛最后一题，1ms，用01背包的思路做的，很多地方其实还没处理好\n\n```java\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\n    int[] les=new int[26];\n    for (int i=0;i<letters.length;i++) {\n        les[letters[i]-'a']++;\n    }\n    return maxScoreWords(words,letters,score,0,les);\n}\n\npublic int maxScoreWords(String[] words, char[] letters, int[] score,int index,int[] les) {\n    if (index==words.length) {\n        return 0;\n    }\n    int res=maxScoreWords(words,letters,score,index+1,les);\n    String word=words[index];\n    if (hasWord(les,word)) {\n        int[] bak=new int[les.length];\n        System.arraycopy(les,0,bak,0,les.length);\n        res=Math.max(res,getScore(bak,word,score)+maxScoreWords(words,letters,score,index+1,bak));\n    }\n    return res;\n}\n\npublic boolean hasWord(int[] les,String word){\n    int[] bak=new int[les.length];\n    System.arraycopy(les,0,bak,0,les.length);\n    int count=0;\n    for(char c:word.toCharArray()){\n        if (bak[c-'a']!=0) {\n            bak[c-'a']--;\n            count++;\n        }\n    }\n    return count==word.length();\n}   \n\npublic int getScore(int[] les,String word,int[] score){\n    int sc=0;\n    for (char c:word.toCharArray()) {\n        les[c-'a']--;\n        sc+=score[c-'a'];\n    }\n    return sc;\n}\n```\n\n## [HUD4501.小明系列故事——买年货（HUDOJ）](http://acm.hdu.edu.cn/showproblem.php?pid=4501)\n\n**Problem Description**\n\n春节将至，小明要去超市购置年货，于是小明去了自己经常去的都尚超市。\n\n刚到超市，小明就发现超市门口聚集一堆人。用白云女士的话说就是：“那家伙，那场面，真是人山人海，锣鼓喧天，鞭炮齐呤，红旗招展。那可真是相当的壮观啊！”。好奇的小明走过去，奋力挤过人群，发现超市门口贴了一张通知，内容如下\n\n值此新春佳节来临之际，为了回馈广大顾客的支持和厚爱，特举行春节大酬宾、优惠大放送活动。凡是都尚会员都可用会员积分兑换商品，凡是都尚会员都可**免费拿k件商品**，凡是购物顾客均有好礼相送。满100元送bla bla bla bla，满200元送bla bla bla bla bla...blablabla....\n\n还没看完通知，小明就高兴的要死，因为他就是都尚的会员啊。迫不及待的小明在超市逛了一圈发现超市里有**n件他想要的商品**。小明顺便对这n件商品打了分，表示商品的实际价值。小明发现身上带了**v1的人民币**，会员卡里面有**v2的积分**。他想知道他最多能买多大价值的商品。\n\n由于小明想要的商品实在太多了，他算了半天头都疼了也没算出来，所以请你这位聪明的程序员来帮帮他吧。\n \n\n**Input**\n```go\n输入包含多组测试用例。\n每组数据的第一行是四个整数n，v1，v2，k；\n然后是n行，每行三个整数a，b，val，分别表示每个商品的价钱，兑换所需积分，实际价值。\n[Technical Specification]\n1 <= n <= 100\n0 <= v1, v2 <= 100\n0 <= k <= 5\n0 <= a, b, val <= 100\n\nPs. 只要钱或者积分满足购买一件商品的要求，那么就可以买下这件商品。\n```\n\n**Output**\n```go\n对于每组数据，输出能买的最大价值。\n详细信息见Sample。\n```\n**Sample Input**\n\n```go\n5 1 6 1\n4 3 3\n0 3 2\n2 3 3\n3 3 2\n1 0 2\n4 2 5 0\n0 1 0\n4 4 1\n3 3 4\n3 4 4\n```\n\n**Sample Output**\n\n```go\n12\n4\n```\nSource\n2013腾讯编程马拉松初赛第〇场（3月20日）\n\n**解法一**\n\n三维费用的背包，但是和前面的[474.一和零](#474-一和零)还有点不一样，三个维度的费用是无关的，而1和0中1的个数和0的个数是相关的\n> 代码使用了Petr的输入模板，自己改进了下，增加了输入结束判断，所以看起来特别长\n```java\nimport java.util.*;\nimport java.io.*;// petr的输入模板\nimport java.math.*; // 不是大数题可以不要这个\n\npublic class Solve_HDOJ_4501 {\n\n    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) throws Exception{\n        InputReader in = new InputReader(System.in);\n        //InputReader in = new InputReader(new FileInputStream(\"./input.txt\"));\n        while(!in.EOF()) {\n            int n = in.nextInt();\n            int v1 = in.nextInt();\n            int v2 = in.nextInt();\n            int k = in.nextInt();\n            int[][] cost = new int[n][3];\n            for (int i = 0; i < n; i++) {\n                cost[i][0] = in.nextInt();\n                cost[i][1] = in.nextInt();\n                cost[i][2] = in.nextInt();\n            }\n            solve(n, v1, v2, k, cost);\n        }\n        //别忘了flush\n        out.flush();\n        out.close();\n    }\n\n    //因为数据量不大，就直接Scanner了\n    public static void solve(int n, int v1, int v2, int k, int[][] cost) {\n        int[][][] dp = new int[k+1][v1+1][v2+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= 0; j--) {\n                for (int u = v1; u >= 0; u--) {\n                    for (int w = v2; w >= 0; w--) {\n                        //这里不能直接u>=cost[i][0] w >= cost[i][1]，因为积分和钱和免费拿是分开的，没有关联的\n                        //即使我不能免费拿，但是我能用积分拿，即使不能用积分拿，我可以用钱买\n                        //dp[j][u][w] = Math.max(dp[j][u][w], dp[j-1][u-cost[i][0]][w-cost[i][1]] + cost[i][2]);\n                        int ans = 0;\n                        if (j >= 1) { //免费拿\n                            ans = Math.max(ans, dp[j-1][u][w] + cost[i][2]);\n                        }\n                        if (u >= cost[i][0]) { //钱\n                            ans = Math.max(ans, dp[j][u-cost[i][0]][w] + cost[i][2]);\n                        }\n                        if (w >= cost[i][1]) { //积分\n                            ans = Math.max(ans, dp[j][u][w-cost[i][1]] + cost[i][2]);\n                        }\n                        dp[j][u][w] = Math.max(ans, dp[j][u][w]);\n                    }\n                }\n            }\n        }\n        out.println(dp[k][v1][v2]);\n    }\n}\n\n\nclass InputReader {\n\n    public BufferedReader reader;\n    \n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        //char[32768]\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    //默认以\" \"作为分隔符，读一个\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    //有的题目不给有多少组测试用例，只能一直读，读到结尾，需要自己判断结束\n    //该函数也会读取一行，并初始化tokenizer，后序直接nextInt..等就可以读到该行\n    public boolean EOF() {\n        String str = null;\n        try {\n            str = reader.readLine();\n            if (str == null) {\n                return true;\n            }\n            //创建tokenizer\n            tokenizer = new StringTokenizer(str);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }\n\n    int nextInt(){\n        return Integer.parseInt(next());\n    }\n    \n    long nextLong(){\n        return Long.parseLong(next());\n    }\n    \n    double nextDouble(){\n        return Double.parseDouble(next());\n    }\n    \n    BigInteger nextBigInteger(){\n        return new BigInteger(next());\n    }\n\n    BigDecimal nextBigDecimal(){\n        return new BigDecimal(next());\n    }\n}\n```","tags":["LeetCode","背包"],"categories":["算法"]},{"title":"Map映射结构","url":"/2019/11/25/map-ying-she/","content":"\n## Map接口\n\n```java\npublic interface Map<K,V>{\n    void put(K key,V value);\n    V remove(K key);\n    boolean contains(K key);\n    V get(K key);\n    void set(K key,V newValue);\n    int getSize();\n    boolean isEmpty();\n}\n```\n\n## LinkedListMap\n\n```java\npublic class LinkedListMap<K,V> implements Map<K,V>{\n    \n    private class Node{\n        public K key;\n        public V value;\n        public Node next;\n\n        public Node(K key,V value,Node next){\n            this.key=key;\n            this.value=value;\n            this.next=next;\n        }\n\n        public Node(K key){\n            this(key,null,null);\n        }\n\n        public Node(){\n            this(null,null,null);\n        }\n\n        @Override\n        public String toString(){\n            return key.toString()+\" : \"+value.toString();\n        }\n    }\n\n    private Node dummyNode;\n\n    private int size;\n\n    public LinkedListMap(){\n        dummyNode=new Node();\n        size=0;\n    }\n\n    @Override\n    public int getSize(){\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty(){\n        return size==0;\n    }\n\n    private Node getNode(K key){\n        Node cur=dummyNode.next;\n        while(cur!=null){\n            if (cur.key.equals(key)) {\n                return cur;\n            }\n            cur=cur.next;\n        }\n        return null;\n    }\n\n    @Override\n    public boolean contains(K key){\n        return getNode(key)==null;\n    }\n\n    @Override\n    public V get(K key){\n        Node node=getNode(key);\n        return node==null?null:node.value;\n    }\n\n    @Override\n    public void put(K key,V value){\n        Node node = getNode(key);\n        if(node==null){\n            dummyNode.next=new Node(key,value,dummyNode.next);\n            size++;\n        }else{\n            node.value=value;\n        }\n    }\n\n    @Override\n    public void set(K key,V value){\n        Node node = getNode(key);\n        if(contains(key)){\n            node.value=value;\n        }else{\n            throw new IllegalArgumentException(key +\" doesn't exist!\");\n        }\n    }\n\n    @Override\n    public V remove(K key){\n        Node prev=dummyNode;\n        while(prev.next!=null){\n            if (prev.next.key.equals(key)) {\n                break;\n            }\n            prev=prev.next;\n        }\n        if (prev.next==null) {\n            //其实可以和上面一样抛一个异常\n            return null;\n        }\n        Node deleNode=prev.next;\n        prev.next=deleNode.next;\n        deleNode.next=null;\n        size--;\n        return deleNode.value;\n    }\n}\n```\n\n## BSTMap\n\n```java\npublic class BSTMap<K extends Comparable,V> implements Map<K,V>{\n\n    private class Node{\n        public K key;\n        public V value;\n        public Node left;\n        public Node right;\n        public Node(K key,V value){\n            this.key=key;\n            this.value=value;\n            left=null;\n            right=null;\n        }\n    }  \n\n    public Node root;\n\n    private int size;\n\n    public BSTMap(){\n        root=null;\n        size=0;\n    }\n\n    public int getSize(){\n        return size;\n    }\n\n    public boolean isEmpty(){\n        return size==0;\n    }\n\n    public void put(K key,V value){\n        root=put(root,key,value);\n    }\n\n    //add元素后返回新的根节点\n    private Node put(Node node,K key,V value){\n        if (node == null) {\n            size++;\n            return new Node(key,value);\n        }\n        if(key.compareTo(node.key) < 0){\n            node.left=put(node.left, key,value);\n        }else if (key.compareTo(node.key) > 0) {\n            node.right=put(node.right, key,value);   \n        }else{\n            //相等的情况\n            node.value=value;\n        }\n        return node;\n    }\n\n    private Node getNode(Node node,K key){\n        if (node==null) {\n            return null;\n        }\n        int temp=node.key.compareTo(key);\n        if (temp==0) {\n            return node;\n        }\n        if (temp>0) { //node.key > key\n            return getNode(node.left,key);\n        }\n        return getNode(node.right,key);\n    }\n\n    public boolean contains(K key){\n        return getNode(root,key)!=null;\n    }\n\n    public V get(K key){\n        Node node=getNode(root,key);\n        return node==null?null:node.value;\n    }\n\n    public void set(K key,V newValue){\n        Node node=getNode(root,key);\n        if (node!=null) {\n            node.value=newValue;\n            return;\n        }\n        throw new IllegalArgumentException(key+ \" doesn't exist\");\n    }\n\n    private Node getMin(Node root){\n        if (root.left==null) {\n            return root;\n        }\n        return getMin(root.left);\n    }\n\n    private Node deleteMin(Node node){\n        if (node.left==null) {\n            return node.right;\n        }\n        node.left=deleteMin(node.left);\n        return node;\n    }\n\n    public V remove(K key){\n        Node node=getNode(root,key);\n        if (node==null) {\n            return null;\n        }\n        root=remove(node,key);\n        size--;\n        return node.value;\n    }\n\n    public Node remove(Node root,K key){\n        if (key.compareTo(root.key)>0) { //key > root\n            root.right=remove(root.right,key);\n        }else if (key.compareTo(root.key)<0) {\n            root.left=remove(root.left,key);\n        }else{\n            if (root.left==null) {\n                return root.right;\n            }\n            if (root.right==null) {\n                return root.left;\n            }\n            Node deleNode=root;\n            root=getMin(root.right);\n            root.right=deleteMin(deleNode.right);\n            root.left=deleNode.left;\n        }\n        return root;\n    }\n}\n```\n\n## MapTest\n\n```java\npublic class MapTest{\n    public static void main(String[] args) {\n        Map<Integer,Integer> map=new BSTMap<>();\n        map.put(1,2);\n        map.put(2,2);\n        map.put(3,2);\n        map.put(4,2);\n        map.put(5,2);\n        map.put(6,2);\n        map.put(7,2);\n        map.put(8,2);\n        map.put(9,32131);\n        map.put(11,2);\n        System.out.println(map.contains(13)); //false\n        System.out.println(map.getSize()); //10\n        System.out.println(map.get(9)); //32131\n        map.remove(9);\n        System.out.println(map.get(9)); //null\n        System.out.println(map.getSize()); //10\n        map.set(11,1234567);\n        System.out.println(map.get(11)); //1234567\n    }\n}\n```\n\n## HashMap\n\n```java\nimport java.util.TreeMap;\n\npublic class HashTable<K,V>{\n    private TreeMap<K,V>[] hashtable;\n    private int M;\n    private int size;\n\n    private static final int upperTol=10;\n    private static final int lowerTol=2;\n    private static final int initCapacity=7;\n\n    public HashTable(int M){\n        this.M=M;\n        size=0;\n        hashtable=new TreeMap[M];\n        for (int i=0;i<M;i++) {\n            hashtable[i]=new TreeMap<>();\n        }\n    }\n\n    public HashTable(){\n        this(initCapacity);\n    }\n\n    private int hash(K key){\n        return key.hashCode() & 0x7fffffff %M;\n    }\n\n    private int getSize(){\n        return size;\n    }\n\n    public void add(K key,V value){\n        TreeMap<K,V> map=hashtable[hash(key)];\n        if(map.containsKey(key)){\n            map.put(key,value);\n        }else{\n            map.put(key,value);\n            size++;\n            //扩容\n            // size/M >=upperTol\n            if (size>=upperTol*M) {\n                resize(2*M);\n            }\n        }\n    }\n\n    public V remove(K key){\n        TreeMap<K,V> map=hashtable[hash(key)];\n        V ret=null;\n        if(map.containsKey(key)){\n            ret=map.remove(key);\n            size--;\n            if (size<lowerTol*M && M/2 >= initCapacity) {\n                resize(M/2);\n            }\n        }\n        return ret;\n    }\n\n    public void resize(int size){\n        TreeMap<K,V> newHashTable=new TreeMap[size];\n        for (int i=0;i<size;i++) {\n            newHashTable[i]=new TreeMap<>();\n        }\n        int oldSize=M;\n        this.M=size; //要先将M设置好,不然hash的值不对\n        for (int i=0;i<oldSize;i++) {\n            TreeMap<K,V> map=hashtable[i];\n            for (K key:map.keySet()) {\n                newHashTable[hash(key)].put(key,map.get(key));\n            }\n        }\n        this.hashtable=newHashTable;\n    }\n\n    public void set(K key,V value){\n        TreeMap<K,V> map=hashtable[hash(key)];\n        if(!map.containsKey(key)){\n            throw new IllegalArgumentException(\"key not exist!\");\n        }\n        map.put(key,value);\n    }\n\n    public boolean contains(K key){\n        return hashtable[hash(key)].containsKey(key);\n    }\n\n    public V get(K key){\n        return hashtable[hash(key)].get(key);\n    }\n}\n```\n\n## 源码地址\n\n[Github](https://github.com/imlgw/LeetCode/tree/master/tree/map)\n\n\n\n\n\n","tags":["数据结构","映射"],"categories":["数据结构"]},{"title":"LRU队列实现","url":"/2019/11/16/lrucache/","content":"\n## [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n\n获取数据 `get(key)` - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。\n写入数据 `put(key, value)` - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。\n\n**进阶:**\n\n你是否可以在 `O(1)` 时间复杂度内完成这两种操作？\n\n**示例:**\n\n```java\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得密钥 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得密钥 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n```\n\n**解法一**\n\n改了好几次才改对，核心思路就是利用HashMap+双向链表\n\n```java\npublic class LRUCache {\n\n    class Node{\n        int key;\n        int value;\n        Node pre;\n        Node next;\n        public Node(int key,int value){\n            this.value=value;\n            this.key=key;\n        }\n    }\n\n    HashMap<Integer,Node> map=new HashMap<>();\n\n    Node head=null;\n\n    Node tail=null;\n\n    int capacity=0;\n\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            //移动到链表头\n            move2Head(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        Node newHead=new Node(key,value);\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            node.value=value;\n            //移动到链表头\n            move2Head(node);\n            return;\n        }\n        if (map.size()==capacity) {\n            map.remove(tail.key);\n            removeNode(tail);\n        }\n        move2Head(newHead);\n        map.put(key,newHead);\n    }\n\n    public void removeNode(Node node){\n        if (node.key==tail.key) {\n            tail=tail.pre;\n            return;\n        }\n        if (node.pre==null || node.next==null) {\n            return;\n        }\n        node.pre.next=node.next;\n        node.next.pre=node.pre;\n    }\n\n    public void move2Head(Node newHead){\n        if (map.size()==0) {\n            head=tail=newHead;\n            return;\n        }\n        if (newHead.key==head.key) {\n            return;\n        }\n        removeNode(newHead);\n        newHead.next=head;\n        newHead.pre=null;\n        head.pre=newHead;\n        head=newHead;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n既然已经实现了，我们就来考虑下为啥要这样实现\n\n其实我一开始也不知道咋实现，查了下才知道，这里有几个点需要注意：\n\n1. 首先是题目要求get/put时间复杂度是`O(1)` 的，而我们在get/put的时候肯定会频繁的移动元素的位置，那我们肯定是不能用数组，队列之类的结构了\n\n2. 那我们能用单链表么？我们可以将最近访问的节点放在头部，然后每次满的时候剔除尾节点的元素，由于是链表，移动节点的位置都是很容易的，但是我们如果要get一个元素的时候就麻烦了，需要遍历整个链表才能取到元素，也就是说单链表定位某个元素比较耗时，所以我们考虑用HashMap来辅助单链表，这样我们以key为map的key，Node节点为map的value就可以迅速定位到某个元素\n\n3. 单链表+HashMap就可以了么？其实还差点儿，如果现在满了，需要删除最后一个节点，那我们就需要将tail的前一个作为新的tail，但是由于是单链表，没有前置指针，不方便定位前一个节点，所以我们最后的方案就是采用**双向链表+HashMap**来实现LRU\n\n   ![img](https://pic4.zhimg.com/80/v2-09f037608b1b2de70b52d1312ef3b307_hd.jpg)\n\n其实LRU思想并不复杂，按照规则来移动节点，删除节点就OK，操作系统教程上也有类似的过程图，理解了下面的图代码就好写了\n\n![mark](http://static.imlgw.top/blog/20191116/BISfMVdI96FT.png?imageslim)\n\n但是如果实现的方式不太好的话，就会写很多if-else判断一些边界，比如我上面自己的实现就是。。。\n\n其实还有一个原因就是我上面的方式head和tail是真实的节点，不是虚节点，所以会有很多边界的逻辑判断，面试的时候不建议那样写，很容易出问题！！！\n\n**解法二**\n\n面试中比较推荐像这样写\n\n```java\npublic class LRUCache {\n\n    class Node{\n        int key;\n        int value;\n        Node pre;\n        Node next;\n        public Node(int key,int value){\n            this.value=value;\n            this.key=key;\n        }\n    }\n\t\n    HashMap<Integer,Node> map=new HashMap<>();\n\n    Node head=null;\n\n    Node tail=null;\n\n    int capacity=0;\n\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n        //初始化头尾节点,注意这两个节点只是个哨兵节点,并不会存入map中\n        head=new Node(-1,-1);\n        tail=new Node(-1,-1);\n        head.next=tail;\n        tail.pre=head;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            //移动到链表头\n            move2Head(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        Node newHead=new Node(key,value);\n        if (map.containsKey(key)) {\n            Node node=map.get(key);\n            //设置节点值为新value\n            node.value=value;\n            //移动到链表头\n            move2Head(node);\n            return;\n        }\n        //满了,先剔除tail再插入\n        if (map.size()==capacity) {\n            map.remove(popTail().key);\n        }\n        addFirst(newHead);\n        map.put(key,newHead);\n    }\n\n    //弹出tail\n    private Node popTail(){\n        Node newTail=tail.pre;\n        removeNode(newTail);\n        return newTail;\n    }\n\n    //移除节点\n    private void removeNode(Node node){\n        node.pre.next=node.next;\n        node.next.pre=node.pre;\n    }\n\n    //从头添加\n    private void addFirst(Node node){\n        node.next=head.next;\n        head.next.pre=node;\n        head.next=node;\n        node.pre=head;\n    }\n\n    //移动节点到head\n    private void move2Head(Node node){\n        //删除原链表中对应位置的node\n        removeNode(node);\n        //从头再添加一遍\n        addFirst(node);\n    }\n}\n```\n\n像这样写，就不用考虑那么多边界，写那么多的if和else，预先开辟两个节点的作为哨兵节点，这样代码就显得清晰简洁，也不容易出问题\n\n[参考](https://zhuanlan.zhihu.com/p/34133067)\n\n## UPDATE\n随便重写了下\n\n```java\nclass LRUCache {\n    \n    HashMap<Integer, Node> map = null;\n        \n    int capacity = 0;\n    \n    Node head = null;\n    \n    Node tail = null;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        Node node = map.get(key);\n        if (node == null) {\n            return -1;\n        }\n        removeNode(node);\n        insert2head(node);\n        return node.val;\n    }\n    \n    public void put(int key, int value) {\n        Node node = map.get(key);\n        if (node == null) {\n            node = new Node(key, value);\n            insert2head(node);\n            map.put(key, node);\n        } else {\n            removeNode(node);\n            node.val = value;\n            insert2head(node);\n        }\n        if (map.size() > capacity) {\n            map.remove(tail.prev.key);\n            removeNode(tail.prev);\n        }\n    }\n    \n    public void insert2head(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    //移除Node节点\n    public void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        node.next = null;\n        node.prev = null;\n    }\n    \n    class Node {\n        Node prev, next;\n        int key, val;\n        public Node (int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\nGolang\n\n```golang\ntype LRUCache struct {\n    capacity int\n    cache map[int]*Node\n    head *Node\n    tail *Node\n}\n\ntype Node struct {\n    prev *Node\n    next *Node\n    key int\n    val int\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    head := &Node{key : -1, val : -1}\n    tail := &Node{key : -1, val : -1}\n    head.next = tail\n    tail.next = head\n    return LRUCache{\n        capacity : capacity,\n        cache : make(map[int]*Node),\n        head : head,\n        tail : tail,\n    }\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n    if v, ok := this.cache[key]; ok {\n        this.removeNode(v)\n        this.insert2Head(v)\n        return v.val\n    }\n    return -1\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    if v, ok := this.cache[key]; ok {\n        this.removeNode(v)\n        v.val = value\n        this.insert2Head(v)\n    } else {\n        newNode := &Node{key : key, val : value}\n        this.cache[key] = newNode\n        this.insert2Head(newNode)\n    }\n    if len(this.cache) > this.capacity {\n        delete(this.cache, this.tail.prev.key)\n        this.removeNode(this.tail.prev)\n    }\n}\n\nfunc (this *LRUCache) removeNode (node *Node) {\n    node.next.prev = node.prev\n    node.prev.next = node.next\n    node.prev = nil\n    node.next = nil\n}\n\nfunc (this *LRUCache) insert2Head (node *Node) {\n    node.prev = this.head\n    node.next = this.head.next\n    this.head.next.prev = node\n    this.head.next = node\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n```","tags":["LeetCode","LRU"],"categories":["算法"]},{"title":"Redis思维导图","url":"/2019/11/16/redis-si-wei-dao-tu/","content":"\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:2000px; height:5000px;\" src=\"https://www.processon.com/embed/mind/5dda2b45e4b0bbcb8a6ae8bc\"></iframe>\n\n## 原始Xmind文件\n\n[Redis思维导图](http://static.imlgw.top/Redis.xmind)\n\n![Redis](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/Redis.png)\n\n\n\n\n\n","tags":["Redis"],"categories":["Web"]},{"title":"二分搜索树","url":"/2019/11/08/er-fen-sou-suo-shu/","content":"\n## 二分搜索树\n\n**二叉查找树**（英语：Binary Search Tree），也称为**二分搜索树**，**二叉搜索树**、**有序二叉树**（ordered binary tree）或**排序二叉树**（sorted binary tree）也可以简写为 `BST`，是指一棵空树或者具有下列性质的[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)：\n\n1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n3. 任意节点的左、右子树也分别为二叉查找树；\n4. 没有键值相等的节点。\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的[时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)较低。为` O(logN) `。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合，映射等\n\n## 基本结构\n\n先搭一个基本的架子出来，后面再来慢慢的完善功能\n\n```java\npublic class BST<E extends Comparable<E>>{\n    //TreeNode\n    private class Node{\n        public E e;\n        public Node left;\n        public Node right;\n        public Node(E e){\n            this.e=e;\n            left=null;\n            right=null;\n        }\n    }\n\n    private Node root;\n\n    private int size;\n\n    public BST(){\n        root=null;\n        size=0;\n    }\n\n    public int size(){\n        return size;\n    }\n\n    public boolean isEmpty(){\n        return size==0;\n    }\n\n    public void add(E e){\n        //...\n    }\n\n    public boolean contains(E e){\n        //...\n    }\n}\n```\n\n## 添加\n\n添加函数，时间复杂度`O(logN)`，只要抓住了它的性质就很好写，画个图描述下这个过程\n\n![mark](http://static.imlgw.top/blog/20191113/P39b50Ikv4sV.png?imageslim)\n\n① 首先和root节点8比较，比8小，所以肯定再8的左子树中\n\n② 再和root的左子树根节点5比较，比5大，所以最后肯定插入5的右子树中\n\n③ 再和5节点的右子树根节点6比较，比6大，所以最后插入6的右子树中\n\n④ 右子树为空，直接插入到6的右边\n\n根据上面的流程我们很容易写出代码\n\n```java\npublic void addLoop(E e){\n    if (root==null) {\n        size++;\n        root=new Node(e);\n        return;\n    }\n    Node temp=root;\n    while(temp!=null){\n        if (e.compareTo(temp.e)>0) {\n            if (temp.right==null) {\n                temp.right=new Node(e);\n                size++;\n                return;\n            }\n            temp=temp.right;\n        }else if (e.compareTo(temp.e)<0) {\n            if (temp.left==null) {\n                temp.left=new Node(e);\n                size++;\n                return;\n            }\n            temp=temp.left;\n        }else return; //不能有相等元素\n    }\n}\n```\n这里既然是树结构，用循环似乎有的显得不够优雅😂\n\n所以我们尝试把这个改成递归\n\n```java\npublic void add2(E e){\n    if(root == null){\n        root = new Node(e);\n        size ++;\n    }else add(root, e);\n}\n\n// 向以node为根的二分搜索树中插入元素e,略显繁琐\nprivate void add2(Node node, E e){\n    if(e.equals(node.e)) return;\n    if(e.compareTo(node.e) < 0 && node.left == null){\n        node.left = new Node(e);\n        size ++;\n        return;\n    }\n    if(e.compareTo(node.e) > 0 && node.right == null){\n        node.right = new Node(e);\n        size ++;\n        return;\n    }\n    if(e.compareTo(node.e) < 0)\n        add(node.left, e);\n    else //e.compareTo(node.e) > 0\n    \tadd(node.right, e);\n}\n```\n这个递归？？？咋感觉比循环还繁琐🙄 \n\n确实，上面这个递归的终止条件太繁琐了，`compareTo`一共比较了4次，有很多重复代码，所以我们还得改改😋\n\n我们让这个`add`函数有返回值，返回插入后的根节点，这样我们的函数 `add(Node node,E e)` 定义就变成了 **插入元素`e`到 以 `node` 为根节点的BST中，并且返回根节点** ，清楚了递归函数的定义，我们再来写方法就会容易很多\n\n```java\npublic void add(E e){\n    root=add(root,e);\n}\n\n//插入元素`e`到 以 `node` 为根节点的BST中，并且返回根节点\nprivate Node add(Node node, E e){\n    if (node == null) {\n        size++;\n        return new Node(e);\n    }\n    if(e.compareTo(node.e) < 0){\n        //插入左子树中，并返回根节点，然后接在node.left\n        node.left=add(node.left, e);\n    }else if (e.compareTo(node.e) > 0) { //注意不要写else,前面没有对相等的元素做判断\n        //插入右子树中，并返回根节点，然后接在node.right\n        node.right=add(node.right, e);   \n    }\n    return node;\n}\n```\n还是那句话，写递归函数，不要纠结于函数的每一步是如何去进行，如何去得到结果的，从全局出发，只要搞清楚递归函数的定义，按照函数的定义来写代码，最后思考一下边界，最后的代码就一定是正确的！\n\n这个边界的思考，其实也很简单，就比如上面的这个结束条件，我们不用去考虑一步步直到递归终结时是什么情况，我们思考一下极端的边界情况（其实这就是终结的情况），root为null，还没有初始化，BST还是空的，这个时候add元素，其实想都不用想，肯定是直接把这个 e作为根节点返回就ok了，所以很自然的就写出了终止条件\n\n## 查找\n\n查找相比于上面的添加，会简单很多，可以很容易的写出代码\n\n```java\n//查询操作\npublic boolean contains(E e){\n    if (e==null) {\n        return false;\n    }\n    return contains(e,root);\n}\n\nprivate boolean contains(E e,Node root){\n    if (root==null) {\n        return false;\n    }\n    if (e.compareTo(root.e)==0) {\n        return true;\n    }\n    return e.compareTo(root.e)<0?contains(e,root.left):contains(e,root.right);\n}\n```\n这里我为了简洁写了三目，不熟悉的可以改成if，整体时间复杂度依然是`O(logN)` ，比线性表的查找会快很多！\n\n## 遍历\n\n老生常谈的话题，这个在我之前的 [LeetCode-二叉树](http://imlgw.top/2019/11/06/leetcode-er-cha-shu-di-gui/) 里面也做过了，这里再翻出来看看，其实重点是想把后序遍历给搞清楚了，之前一直挺迷糊的\n\n### 前序遍历\n\n#### 递归写法\n\n```java\n//前序遍历,递归\npublic void preorderTravelRecur(){\n    preorderTravel(root);\n}\n\nprivate void preorderTravel(Node root){\n    if (root==null) {\n        return;\n    }\n    System.out.print(root.e+\" \");\n    preorderTravel(root.left);\n    preorderTravel(root.right);\n}\n```\n#### 非递归写法\n\n```java\n//前序遍历,非递归实现\npublic void preorderTravelNoRecur(){\n    Stack<Node> stack=new Stack<>();\n    Node cur=root;\n    while( cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            System.out.print(cur.e+\" \");\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        cur=cur.right;\n    }\n}\n```\n注意这里并不是经典的前序遍历方式，是按照 “模板” 来的，首先我们考虑栈里面存的是什么，这里的栈里面存的实际上是 `左子树的左边` 的集合，这里我不知道咋描述，画个图吧\n\n![mark](http://static.imlgw.top/blog/20191113/BF0cCcWcy3zP.png?imageslim)\n\n图中绿色部分就是我所说的**左子树的左边的集合**，整个栈的入栈顺序就是从左往右，从上到下，依次的将这些“左边” 入栈，并且在没有左子树，也就是遍历到叶子节点的时候开始出栈，然后切换成`当前出栈的节点`的右子树，将右子树的`左子树的左边`重复前面的过程继续入栈出栈，我们要考虑的就是在什么时候访问节点！\n\n细心的同学肯定已经发现了，其实这里进栈顺序和出栈顺序，分别对应的就是这颗树前序遍历和中序遍历！！！所以我们就只需要在进栈和出栈的时候，进行访问节点的操作，就可以完成前序和后序遍历\n\n### 中序遍历\n\n#### 递归写法\n\n```java\n//中序遍历,递归\npublic void inorderTravelRecur(){\n    inorderTravel(root);\n}\n\nprivate void inorderTravel(Node root){\n    if (root==null) {\n        return;\n    }\n    inorderTravel(root.left);\n    System.out.print(root.e+\" \");\n    inorderTravel(root.right);\n}\n```\n#### 非递归写法\n\n结合上面的分析，我们也可以很容易的得出非递归的中序遍历的写法\n\n```java\n//中序遍历,非递归\npublic void inorderTravelNoRecur(){\n    Stack<Node> stack=new Stack<>();\n    Node cur=root;\n    while( cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        System.out.print(cur.e+\" \");\n        cur=cur.right;\n    }\n}\n```\n### 后序遍历\n\n#### 递归写法\n\n```java\n//后序遍历,递归\npublic void postorderTravelRecur(){\n    postorderTravel(root);\n}\n\nprivate void postorderTravel(Node root){\n    if (root==null) {\n        return;\n    }\n    postorderTravel(root.left);\n    postorderTravel(root.right);\n    System.out.print(root.e+\" \");\n}\n```\n#### 非递归写法\n\n这里的非递归写法就不一样了，比前两种要复杂\n\n```java\n//后序遍历,非递归\npublic void postorderTravelNoRecur(){\n    Stack<Node> stack=new Stack<>();\n    Node cur=root,lastNode=null;\n    while(cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.peek();//查看栈顶元素\n        //如果右子树为空或者右节点已经访问过，则当前节点出栈，并记录lastNode\n        if (cur.right==null || lastNode==cur.right) { \n            System.out.print(cur.e+\" \");\n            stack.pop();\n            lastNode=cur;\n            //为了下一次能直接查看栈顶元素\n            //cur的使命其实已经结束了，cur和它的孩子都已经访问了，下一次直接从栈顶取，不然就死循环了\n            cur=null; \n        }else{\n            cur=cur.right;\n        }\n    }\n}\n```\n![mark](http://static.imlgw.top/blog/20191113/zM80igBy0RDX.png?imageslim)\n\n其实不管是什么遍历，对于这个模板来说，**栈的轨迹都是一样的**，只不过访问节点的时机有所不同，蓝色线条代表审查的顺序，红色辅助的代表出栈部分，右边对应的就是遍历过程中栈的变化，和对应结果的变化，对照这个图再分析下就很清楚了。\n\n如果觉得实在是不好理解也可以换用下面的方式\n\n```java\npublic void postorderTravelNoRecur2() {\n    Stack<Node> stack=new Stack<>();\n    stack.push(root);\n    Node lastNode=null;\n    while(!stack.isEmpty()){\n        //取栈顶元素\n        Node cur=stack.peek();\n        //左右子树都为空，或者上一个访问的节点是当前节点的子节点就输出该节点\n        if ( (cur.left==null && cur.right ==null) || \n             (lastNode!=null &&(cur.left==lastNode || cur.right==lastNode))){\n            stack.pop();\n            System.out.print(cur.e+\" \");\n            lastNode=cur;\n        }else{\n            if (cur.right!=null) {\n                stack.push(cur.right);\n            } if (cur.left!=null) {\n                stack.push(cur.left);\n            }  \n        } \n    }\n}\n```\n这种方式相比上面就好理解多了，左右子树都为空，或者上一个访问的节点是当前节点的子节点，就可以输出该节点了，注意添加的时候是逆序添加的，这样就可以保证先访问左节点，再访问右节点，最后访问根节点\n\n### 层次遍历\n\n#### 递归写法\n\n```java\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> res = new ArrayList<>();\n    helper(res, root, 0);\n    return res;\n}\n\nprivate void helper(List<List<Integer>> res, TreeNode root, int depth) {\n    if (root == null) return;\n    //需要增加一层\n    if (res.size() == depth) res.add(new LinkedList<>());\n    res.get(depth).add(root.val);\n    helper(res, root.left, depth + 1);\n    helper(res, root.right, depth + 1);\n}\n```\n\n#### 非递归写法\n\n经典的BFS\n\n```java\n//层次遍历\npublic void levelorderTravel(){\n    Queue<Node> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        while(count>0){\n            Node node=queue.poll();\n            System.out.print(node.e+\" \");\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n    }\n}\n```\n\n> 其实关于前中后序的遍历方式，还有很多，我这里主要记录的是` 模板 `的思路，其实还有一种很🐂🍺的做法，模拟系统栈的方式，具体可以参考我之前的  [LeetCode二叉树](http://imlgw.top/2019/11/06/leetcode-er-cha-shu-di-gui/#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86) 这里就不多解释了\n\n## 取整\n\n### 向下取整（floor）\n\n```java\npublic E floor(E e){\n    Node node=floor(root,e);\n    return node!=null?node.e:null;\n}\n\npublic Node floor(Node root,E e){\n    if (root==null) {\n        return null;\n    }\n    int temp=e.compareTo(root.e);\n    if (temp==0) {\n        return root;\n    }\n    if (temp<0) { //root.e > e,求小于e的值,一定在左边\n        return floor(root.left,e);\n    }\n    //tmep>0 e>root.e\n    Node node=floor(root.right,e);\n    return node!=null?node:root;\n}\n```\n### 向上取整（ceiling）\n\n```java\npublic E ceiling(E e){\n    Node node=ceiling(root,e);\n    return node!=null?node.e:null;\n}\n\npublic Node ceiling(Node root,E e){\n    if (root==null) {\n        return null;\n    }\n    int temp=e.compareTo(root.e);\n    if (temp==0) {\n        return root;\n    }\n    if (temp>0) { //root.e<e,求的是最后大于root.e的元素,一定在右边\n        return ceiling(root.right,e);\n    }\n    //tmep<0 e<root.e\n    Node node=ceiling(root.left,e);\n    return node!=null?node:root;\n}\n```\n这两个函数还是挺有用的，比如这个题 [220-存在重复元素-III ](http://imlgw.top/2019/09/15/leetcode-cha-zhao/#220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III) 通过率只有25%的mid题。。。。\n\n## 获取第K大\n\n获取第k大（从0开始）的元素，如果左子树节点数小于`k`，则第k大的元素肯定在右子树，同时我们可以直接排除`size(left)+1` 个元素（加上根节点） 。\n\n然后直接在 右子树中继续搜索 `getKth(root.right,k-size(left)-1)`  ，只有当左子树刚好k个元素的时候，根节点就是我们要找的`Kth`\n\n```java\npublic E getKth(int k){\n    if (k>=size || k<0) {\n        return null;\n    }\n    return getKth(root,k).e;\n}\n\npublic Node getKth(Node root,int k){\n    if (root==null) {\n        return root;\n    }\n    int temp = childSize(root.left);\n    if (temp>k) {\n        return getKth(root.left,k);\n    }\n    if (temp<k) {\n        return getKth(root.right,k-temp-1);\n    }\n    return root;\n}\n```\n> 这里其实我的实现是有问题的，我的时间复杂度是`O(NlogN)`！！！！主要是`childSize()`时间复杂度是O(N)不是O(1)，在《算法4》中这个实现的时间复杂度就是O(1)，书上在定义的Node的时候给Node加了一个count属性，用来记录每个节点的子节点数（包括自己），在每次add和delete的时候动态的维护这个count，这样最后求子节点数的操作时间复杂度就是O(1)的了，那个版本的我也实现了一下，但是我没有在这篇文章中这样写（主要是懒得改），而且这也不是重点，感兴趣可以去看看 [BSTWithCount](https://github.com/imlgw/LeetCode/blob/master/tree/BSTWithCount.java) 主要就是要**注意操作count的时机**\n>\n这里既然没有count数组，那么其实就不应该这样求，应该直接中序遍历，求第K大，时间复杂度O(N)\n\n## Rank()\n\n其实是上面的逆过程，如果根节点等于key，那么直接返回左子树的键总数；如果key小于根节点，就继续去左子树中递归找，如果大于根节点，返回`size(left)+1`加上它在右子树中的`rank()`\n\n```java\npublic int getRank(E e){\n    return getRank(root,e);\n}\n\npublic int getRank(Node root,E e){\n    if (e.compareTo(root.e)<0) { //e<root.e\n        return getRank(root.left,e);\n    }\n    if (e.compareTo(root.e)>0) {\n        return getRank(root.right,e)+childSize(root.left)+1;\n    }\n    return childSize(root.left);\n}\n```\n## Max&Min\n\n没啥好说的\n\n```java\n//求最大值,递归比较优雅\npublic E getMax(){\n    return getMax(root).e;\n}\n\npublic Node getMax(Node root){\n    if (root.right==null) {\n        return root;\n    }\n    return getMax(root.right);\n}\n\n//求最小值\npublic E getMin(){\n    return getMin(root).e;\n}\n\npublic Node getMin(Node root){\n    if (root.left==null) {\n        return root;\n    }\n    return getMin(root.left);\n}\n```\n## 删除\n\n删除应该来说是BST中里面比较复杂的一个操作了，我们先从简单的开始\n\n### 删除最值\n\n```java\n//删除最小的键\npublic void deleteMin(){\n    root=deleteMin(root);\n}\n//删除node为头节点的树中的最小值，并返回头节点\nprivate Node deleteMin(Node node){\n    if (node.left==null) {\n        return node.right;\n    }\n    node.left=deleteMin(node.left);\n    return node;\n}\n\n//删除最大的键\npublic void deleteMax(){\n    root=deleteMax(root);\n}\n\nprivate Node deleteMax(Node node){\n    if (node.right==null) {\n        return node.left;\n    }\n    node.right=deleteMax(node.right);\n    return node;\n}\n```\n递归函数定义为**删除node为头节点的树中的最小值，并返回头节点**，删除最小值实际上就是删除二叉树最左边的节点，所以我们递归的删除node.left就ok，当node.left为空的时候返回node.right，这样前面节点的left就接在了node.right上，就达到了删除的作用\n\n### 删除任意值\n\n```java\n//删除任意的键\npublic void delete(E e){\n    root=delete(root,e);\n}\n\n//删除以node为首的BST中,值为e的节点并且返回根节点\nprivate Node delete(Node node,E e){\n    if (node==null) {\n        return null;\n    }\n    if (e.compareTo(node.e)>0) { //e>root.e\n        node.right=delete(node.right,e);\n    }else if (e.compareTo(node.e)<0) {\n        node.left=delete(node.left,e);\n    }else{ //e==root.e\n        if (node.left==null) { //如果没有左子树就返回右子树\n            return node.right;\n        }\n        if (node.right==null) { //如果没有右子树就返回左子树\n            return node.left;\n        }\n        Node delNode=node;\n        //有左右子节点都有\n        node=getMin(node.right); //用右子树的最小值填补删除的元素的空位\n        //删除对应的右子树的最小值,然后连接起来\n        node.right=deleteMin(delNode.right);\n        node.left=delNode.left;\n    }\n    return node;\n}\n```\n这里文字的描述比较无力，画个图就清晰明白了，核心的思想就是利用右子树中的最小值填补待删除节点\n\n![mark](http://static.imlgw.top/blog/20191113/yyI0q2yftm0X.png?imageslim)\n\n当然这里其实也是有坑的，主要就是连最后两句\n\n```java\n//删除对应的右子树的最小值,然后连接起来\nnode.right=deleteMin(delNode.right);\nnode.left=delNode.left;\n```\n这里的两句话是不能交换的，如果我们交换了两句话的位置，那么我们下一步删除最小值就会出现问题，我们希望的是删除右子树中最小的node节点，结果你先把待删除节点的left接到了node的左边，这样的话node就不再是delNode.right中的最小值，最后结果可能就会成这个样子，成了一个闭环！！！\n\n![mark](http://static.imlgw.top/blog/20191113/qc5kHljj03uq.png?imageslim)\n\n所以最后的结果肯定是不对的，其实这一点书上并没有提到，我也是在做这道题[删除节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/) 的时候写反了，才发现这个问题，感兴趣可以去试试\n\n> 其实这样的删除时一种很随机的做法，虽然能正确的删除元素，但是并没有考虑树的对称性，关于树的对称性，我们后面再来研究\n\n## 代码地址\n\n[BST.java](https://github.com/imlgw/LeetCode/blob/master/tree/BST.java)\n\n[BSTTest.java](https://github.com/imlgw/LeetCode/blob/master/tree/BSTTest.java)\n\n[BSTWithCount.java](https://github.com/imlgw/LeetCode/blob/master/tree/BSTWithCount.java)\n\n","tags":["数据结构","树"],"categories":["数据结构"]},{"title":"LeetCode二叉树","url":"/2019/11/06/leetcode-er-cha-shu/","content":"\n## _LeetCode 二叉树_\n\n> 善用**ctrl+f**\n\n## [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n\nGiven a binary tree, return the *preorder* traversal of its nodes' values.\n\n**Example:**\n\n```java\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [1,2,3]\n```\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**解法一**\n\n递归，没啥好说的\n\n```java\nprivate List<Integer> res=new ArrayList<>();\n\npublic List<Integer> preorderTraversal(TreeNode root) {\n    if(root!=null){\n        res.add(root.val);\n        preorderTraversal(root.left);\n        preorderTraversal(root.right);\n    }\n    return res;\n}\n```\n**解法二**\n\n教科书上的写法，经典的前序遍历非递归实现方式\n\n```java\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        TreeNode top=stack.pop();\n        res.add(top.val);\n        //注意顺序\n        if (top.right!=null) {\n            stack.push(top.right);\n        }\n        if (top.left!=null) {\n            stack.push(top.left);\n        }\n    }\n    return res;\n}\n```\n**解法三**\n\n非递归，模拟递归栈的方式，记录节点以及是否需要继续寻找子节点\n\n```java\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<Command> stack=new Stack<>();\n    stack.push(new Command(true,root));\n    while(!stack.isEmpty()){\n        Command command=stack.pop();\n        if (!command.isGo) {\n            res.add(command.node.val);\n        }else{\n            TreeNode node=command.node;\n            //逆序进栈\n            if (node.right!=null) {\n                stack.push(new Command(true,node.right));\n            }\n            if (node.left!=null) {\n                stack.push(new Command(true,node.left));\n            }    \n            stack.push(new Command(false,node));\n        }\n    }\n    return res;\n}\n\nstatic class Command{\n    boolean  isGo; //是否继续寻找子节点\n    TreeNode node; //当前节点\n    public Command(boolean isGo,TreeNode node){\n        this.isGo=isGo;\n        this.node=node;\n    }\n}\n```\nbobo老师的一种思路，可以说是相当妙了👏，一下就解决了三种遍历的非递归实现，另外两种只需要调整一下进栈的顺序就可以了！\n\n**解法四**\n\n找到一个板子，可以很好的解决三种遍历\n\n```java\n//经典的非递归实现方式\npublic List<Integer> preorderTraversal4(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(cur!=null||!stack.isEmpty()){\n        while (cur!=null) {\n            res.add(cur.val);\n            stack.push(cur);\n            cur=cur.left;\n        }\n        //没有左子树了\n        cur=stack.pop();\n        //切换为右子树\n        cur=cur.right;\n        \n    }\n    return res;\n}\n```\n> 关于 `while(cur!=null||!stack.isEmpty())`，其实栈中存的只是某一个根节点的所有左子树，并不是所有的节点，所以栈为空不代表已经遍历完所有节点了，只能代表当前节点的左子树都遍历完了，还有右子树还没遍历，只有当右子树也为空也就是`cur==null` 的时候才是遍历完了，具体看一下下面这颗树就明白了\n>\n> ```java\n>       5\n>      / \\\n>     4    6 \n>   /      \\\n> 3       8\n> ```\n>\n> \n\n## [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的*前序遍历*。\n\n例如，给定一个 `3叉树` :\n\n![MWwEt0.png](https://s2.ax1x.com/2019/11/20/MWwEt0.png)\n\n返回其前序遍历: `[1,3,5,6,2,4]`。\n\n**说明:** 递归法很简单，你可以使用迭代法完成此题吗?\n\n**解法一**\n\n递归没啥好说的\n\n```java\n//递归的方式\nList<Integer> res=new LinkedList<>();\n\npublic List<Integer> preorder(Node root) {\n    dfs(root);\n    return res;\n}\n\npublic void dfs(Node root) {\n    if (root==null) {\n        return;\n    }\n    List<Node> children=root.children;\n    res.add(root.val);\n    for (Node node:children) {\n        preorder(node);\n    }\n}\n```\n**解法二**\n\n迭代的方式\n\n```java\npublic List<Integer> preorder(Node root) {\n    List<Integer> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    Stack<Node> stack=new Stack<>();\n    stack.add(root);\n    while(!stack.isEmpty()){\n        Node node=stack.pop();\n        res.add(node.val);\n        List<Node> children=node.children;\n        //逆序添加\n        for (int i=children.size()-1;i>=0;i--) {\n            stack.add(children.get(i));\n        }\n    }\n    return res;\n}\n```\n到这里我是真的对遍历的那个板子无感了，这里我开始想用板子写，结果发现并不好写，无从下手（可能是我太菜），所以采用了经典的前序遍历方式，果然经典就是经典，通用性很强，而且相当好理解，所以以后遇到遍历的题目，尽量还是自己写，别套板子（对后序的板子也一直不是特别理解，所以也一直没记住，套板子还是要建立在理解的基础上啊，不然永远不会做！）\n\n## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\nGiven a binary tree, return the *inorder* traversal of its nodes' values.\n\n**Example:**\n\n```java\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [1,3,2]\n```\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**解法一**\n\n递归的方式和模拟栈的方式就不记录了，重点看一下这个板子\n\n```java\n//经典的非递归实现方式\npublic List<Integer> inorderTraversal3(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(cur!=null||!stack.isEmpty()){\n        while (cur!=null) {\n            stack.push(cur);\n            cur=cur.left;\n        }\n        //没有左子树了\n        cur=stack.pop();\n        //将当前节点添加到res中\n        res.add(cur.val);\n        //切换为右子树\n        cur=cur.right;\n    }\n    return res;\n}\n```\n## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n\nGiven a binary tree, return the *postorder* traversal of its nodes' values.\n\n**Example:**\n\n```java\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [3,2,1]\n```\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n**解法一**\n\n这题是个hard题，没那么容易（不过根据bobo老师的方式来做确实简单😂）\n\n```java\npublic List<Integer> postorderTraversal3(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root,lastNode=null; //lastNode为上一次访问的节点\n    while(cur!=null||!stack.isEmpty()){\n        while (cur!=null) {\n            stack.push(cur);\n            cur=cur.left;\n        }\n        //没有左子树了,把后一个左节点拿出来\n        cur=stack.peek();\n        //如果没有右节点,或者右节点访问过了\n        if (cur.right==null||cur.right==lastNode) {\n            //添加节点\n            res.add(cur.val);\n            //记录当前节点为lastNode\n            lastNode=cur;\n            //将他pop出去\n            stack.pop();\n            //节点已经弹出\n            //指向null,不然就死循环了\n            cur=null;\n        }else{\n            //右节点不为空,并且没访问过\n            //切换为右子树,重复上面的步骤\n            cur=cur.right;\n        }\n        \n    }\n    return res;\n}\n```\n这种题一定要记住 \"招式\"，乱写只会越写越乱\n\n**解法二**\n\n这种解法似乎更加容易理解！！！\n\n```java\npublic List<Integer> postorderTraversals(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> stack=new Stack<>();\n    stack.push(root);\n    TreeNode lastNode=null;\n    while(!stack.isEmpty()){\n        TreeNode cur=stack.peek();\n        if ((cur.left==null && cur.right ==null) || (lastNode!=null &&( cur.left==lastNode || cur.right==lastNode))) {\n            stack.pop();\n            res.add(cur.val);\n            lastNode=cur;\n        }else{\n            if (cur.right!=null) {\n                stack.push(cur.right);\n            }\n            if (cur.left!=null) {\n                stack.push(cur.left);\n            }\n        }\n    }\n    return res;\n}\n```\n## [590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的*后序遍历*。\n\n例如，给定一个 `3叉树` :\n\n![NTree](https://i.loli.net/2019/12/01/KAQP9UNfV5bau7J.png)\n\n返回其后序遍历: `[5,6,3,2,4,1]`.\n\n**说明:** 递归法很简单，你可以使用迭代法完成此题吗?\n\n**解法一**\n\n递归的解法，没啥好说的\n\n```java\nList<Integer> res=new LinkedList<>();\n\npublic List<Integer> postorder(Node root) {\n    if (root==null) {\n        return res;\n    }\n    dfs(root);\n    return res;\n}\n\npublic void dfs(Node root) {\n    List<Node> children=root.children;\n    for (Node node:children) {\n        dfs(node);\n    }\n    res.add(root.val);\n}\n```\n\n**解法二**\n\n锁了！这才是树遍历的板子\n\n```java\npublic List<Integer> postorder(Node root) {\n    List<Integer> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    Stack<Node> stack=new Stack<>();\n    stack.push(root);\n    Node lastNode=null;\n    while(!stack.isEmpty()){\n        Node node=stack.peek();\n        List<Node> children=node.children;\n        if (children.isEmpty() || (lastNode!=null && lastNode == children.get(children.size()-1))) {\n            res.add(node.val);\n            stack.pop();\n            lastNode=node;\n        }else{\n            for (int i=children.size()-1;i>=0;i--) {\n                stack.push(children.get(i));\n            }\n        }\n    }\n    return res;\n}\n```\n\n这题开始因为一个空的case把我搞晕了，搞了半天才发现\n\n## [102. 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n\nGiven a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\nreturn its level order traversal as:\n\n```java\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\n**解法一**\n\nBFS，利用队列\n\n```java\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> res=new ArrayList<>();\n    if (root==null)return res;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        //count代表的其实就是每一层的节点个数\n        int count=queue.size();\n        List<Integer> list=new ArrayList<>();\n        while(count>0){\n            //取出当前节点,并将其左右子节点入队列\n            TreeNode node=queue.poll();\n            list.add(node.val);\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n        res.add(list);\n    }\n    return res;\n}\n```\n\n**解法二**\n\n递归DFS，这种其实还是挺有意思的，可以看下\n\n```java\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> res = new ArrayList<>();\n    helper(res, root, 0);\n    return res;\n}\n\nprivate void helper(List<List<Integer>> res, TreeNode root, int depth) {\n    if (root == null) return;\n    //需要增加一层\n    if (res.size() == depth) res.add(new LinkedList<>());\n    res.get(depth).add(root.val);\n    helper(res, root.left, depth + 1);\n    helper(res, root.right, depth + 1);\n}\n```\n## [429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)\n\n给定一个 N 叉树，返回其节点值的*层序遍历*。 (即从左到右，逐层遍历)。\n\n例如，给定一个 `3叉树` :\n\n![NTee](https://i.loli.net/2019/12/01/He8KVlms1jynbvr.png)\n\n\n\n返回其层序遍历:\n\n```java\n[\n     [1],\n     [3,2,4],\n     [5,6]\n]\n```\n\n**说明:**\n\n1. 树的深度不会超过 `1000`。\n2. 树的节点总数不会超过 `5000`。\n\n**解法一**\n\n```java\npublic List<List<Integer>> levelOrder(Node root) {\n    List<List<Integer>> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    Queue<Node> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        List<Integer> temp=new LinkedList<>();\n        while(count>0){\n            Node node=queue.poll();\n            temp.add(node.val);\n            for (Node child:node.children) {\n                queue.add(child);\n            }\n            count--;\n        }\n        if (!temp.isEmpty()) {\n            res.add(temp);   \n        }\n    }\n    return res;\n}\n```\n## [107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)\n\nGiven a binary tree, return the *bottom-up level order* traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\nFor example:\nGiven binary tree `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n\n\nreturn its bottom-up level order traversal as:\n\n```java\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n```\n\n**解法一**\n\n```java\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> res=new ArrayList<>();\n    if(root==null)return res;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        List<Integer> list=new ArrayList<>();\n        int count=queue.size();\n        while(count>0){\n            TreeNode top=queue.poll();\n            if (top.left!=null) {\n                queue.add(top.left);\n            }\n            if (top.right!=null) {\n                queue.add(top.right);\n            }\n            list.add(top.val);\n            count--;\n        }\n        //从头添加\n        res.add(0,list);\n    }\n    return res;\n}\n```\n主要是复习下层次遍历，相比上面就多了 `res.add(0,list)` 从头部添加\n\n## [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n\nGiven a binary tree, return the *zigzag level order* traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n\nFor example:\nGiven binary tree `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\nreturn its zigzag level order traversal as:\n\n```java\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n```\n\n**解法一**\n\n```java\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    List<List<Integer>> res=new ArrayList<>();\n    if(root==null)return res;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    boolean reverse=false;\n    while(!queue.isEmpty()){\n        LinkedList<Integer> list=new LinkedList<>();\n        int count=queue.size();\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (reverse) {\n                //从头添加，相当于逆序了\n                list.addFirst(node.val);\n            }else{\n                list.add(node.val);\n            }\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n        reverse=!reverse;\n        res.add(list);\n    }\n    return res;\n}\n```\n和上面一题一样，老想着怎么去按照题目的要求去遍历节点，哎，太蠢了，灵活一点啊\n\n## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n**示例:**\n\n```java\n输入: [1,2,3,null,5,null,4]\n输出: [1, 3, 4]\n解释:\n\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\n```\n\n**解法一**\n\n还是和上面一样，一上午做了三道一样的题，这题吸取了上面的教训没有去想怎么遍历了\n\n```java\npublic List<Integer> rightSideView(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    if(root==null) return res;\n    LinkedList<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            //取每一层最后一个节点\n            if (count==1) {\n                res.add(node.val);\n            }\n            count--;\n        }\n    }\n    return  res;\n}\n```\n只记录每一层最后一个节点，最后得到的就是右视图\n\n**解法二**\n\ndfs，其实就是一直向右走，走不动就向左走，这样遍历的轨迹就是沿着二叉树的右边缘向下的，我们只需要记录层数，然后当层数和res数量相等的时候记录结果就行了（看见头条面试要求写logN空间的，应该就是这种解法了，但是下面的解法空间复杂度应该还是O(N)的，最坏情况下形成一链表就成N了，不过相比上面层次遍历永远是N的做法还是要好一点）\n\n```go\nfunc rightSideView(root *TreeNode) []int {\n    var dfs func(root *TreeNode, depth int)\n    var res = make([]int, 0)\n    dfs = func(root *TreeNode, depth int) {\n        if root == nil {\n            return\n        }\n        if depth > len(res) {\n            res = append(res, root.Val)\n        }\n        dfs(root.Right, depth+1)\n        dfs(root.Left, depth+1)\n    }\n    dfs(root, 1)\n    return res\n}\n```\n\n\n\n## [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) \n\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.\n\n**示例 1:**\n\n```java\n输入:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出: [3, 14.5, 11]\n解释:\n第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].\n```\n\n\n**注意：**\n\n1. 节点值的范围在32位有符号整数范围内。\n\n**解法一**\n\n一百遍啊一百遍，这应该属于树类型题的HelloWorld吧 ~ \n\n```java\npublic List<Double> averageOfLevels(TreeNode root) {\n    if (root==null) {\n        return new LinkedList<>();\n    }\n    Queue<TreeNode> queue=new LinkedList<>();\n    List<Double> res=new ArrayList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        int size=queue.size();\n        int temp=size;\n        double average=0;\n        while(size-->0){\n            TreeNode cur=queue.poll();\n            average+=cur.val;\n            if (cur.left!=null) {\n                queue.add(cur.left);\n            }\n            if (cur.right!=null) {\n                queue.add(cur.right);\n            }\n        }\n        average/=temp;\n        res.add(average);\n    }\n    return res;\n}\n```\n## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例：**\n给定二叉树 [3,9,20,null,null,15,7]\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n\n返回它的最大深度 3 。\n\n**解法一**\n\n递归解法，很简洁\n\n```java\n//maxDepth(root)=1+max(maxDepth(root.left),maxDepth(root.right));\npublic int maxDepth(TreeNode root) {\n    if(root==null){\n        return 0;\n    }\n    int maxLeft=maxDepth(root.left);\n    int maxRight=maxDepth(root.right);\n    return (maxLeft>maxRight?maxLeft:maxRight)+1;\n}\n```\n**解法二**\n\nBFS，广度优先搜索\n\n```java\npublic int maxDepth(TreeNode root) {\n    if (root==null) return 0;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    int max=0;//注意初始值\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n        max++;\n    }\n    return max;\n}\n```\n## [559. N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)\n\n给定一个 N 叉树，找到其最大深度。\n\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n\n例如，给定一个 `3叉树` :\n\n![3叉树](https://s2.ax1x.com/2019/11/20/MWwEt0.png)\n\n我们应返回其最大深度，3。\n\n**说明:**\n\n1. 树的深度不会超过 `1000`。\n2. 树的节点总不会超过 `5000`。\n\n**解法一**\n\n没啥好说的\n\n```java\npublic int maxDepth(Node root) {\n    if (root==null) {\n        return 0;\n    }\n    int max=0;\n    List<Node> children=root.children;\n    for (Node node:children) {\n        max=Math.max(max,maxDepth(node));\n    }\n    return max+1;\n}\n```\n## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例:**\n\n给定二叉树 `[3,9,20,null,null,15,7]`   \n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n\n返回它的最小深度  2.\n\n**解法一**\n\n最大都求了，最小也来一发，经典BFS做法，求最短路径\n\n```java\npublic int minDepth(TreeNode root) {\n    if (root==null) return 0;\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    int min=0;\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        min++;\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (node.left==null && node.right==null) {\n                return min;\n            }\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n    }\n    return min;\n}\n```\n**解法二**\n\n递归\n\n```java\npublic int minDepth(TreeNode root) {\n    if (root==null) return 0;\n    if (root.left==null) {\n        return minDepth(root.right)+1;\n    }\n    if (root.right==null) {\n        return minDepth(root.left)+1;\n    }\n    return Math.min(minDepth(root.left),minDepth(root.right))+1;\n}\n```\n很上面最大的相反，但是有个细节需要注意，如果一个根节点左右子树，**有一颗为空**，如果不处理，按照之前的逻辑，这颗空子树下一次就会返回0，肯定会比另一颗小最后返回的就是到这颗子树的路径，但是仔细想想这样是正确的么？明显不是，最短路径的尽头一定是叶子节点也就是左右子树都为空的时候，所以这里需要特别注意\n\n\n## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n翻转一棵二叉树。\n\n**示例：**\n\n输入：\n\n```java\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n```\n\n\n输出：\n\n```java\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n```\n\n**备注:**\n这个问题是受到 Max Howell 的 原问题 启发的 ：\n\n> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n\n**解法一**\n\n```java\npublic TreeNode invertTree(TreeNode root) {\n    if (root==null) {\n        return null;\n    }\n    invertTree(root.left);\n    invertTree(root.right);\n    //交换左右节点\n    TreeNode temp=root.left;\n    root.left=root.right;\n    root.right=temp;\n    return root;\n}\n```\n注意递归调用和交换节点的顺序，不能搞反了\n\n```java\npublic TreeNode invertTree(TreeNode root) {\n    if (root==null) {\n        return null;\n    }\n    TreeNode right=root.right;\n    root.right=invertTree(root.left);\n    root.left=invertTree(right);\n    return root;\n}\n```\n比较简洁也比较符合递归的做法\n\n## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n给定两个二叉树，编写一个函数来检验它们是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n**示例 1:**\n\n```java\n输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入:      1          1\n          /           \\\n         2             2\n    \n        [1,2],     [1,null,2]\n\n输出: false\n```\n\n**示例 3:**\n\n```java\n输入:       1         1\n          / \\       / \\\n         2   1     1   2\n        \n        [1,2,1],   [1,1,2]\n输出: false\n```\n\n**解法一**\n\n```java\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p==null && q==null) {\n        return true;\n    }\n    if (p!=null && q!=null && p.val==q.val) {\n        return isSameTree(p.right,q.right)&&isSameTree(p.left,q.left);\n    }\n    return false;\n}\n```\n\n## [951. 翻转等价二叉树](https://leetcode-cn.com/problems/flip-equivalent-binary-trees/)\n\nDifficulty: **中等**\n\n\n我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。\n\n只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X _翻转等价_于二叉树 Y。\n\n编写一个判断两个二叉树是否是_翻转等价_的函数。这些树由根节点 `root1` 和 `root2` 给出。\n\n**示例：**\n\n```go\n输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n输出：true\n解释：我们翻转值为 1，3 以及 5 的三个节点。\n\n```\n\n**提示：**\n\n1.  每棵树最多有 `100` 个节点。\n2.  每棵树中的每个值都是唯一的、在 `[0, 99]` 范围内的整数。\n\n\n**解法一**\n\n交错的比较就行了\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc flipEquiv(root1 *TreeNode, root2 *TreeNode) bool {\n    if root1 == nil && root2 == nil {\n        return true\n    }\n    if root1 == nil || root2 == nil {\n        return false\n    }\n    if root1.Val != root2.Val {\n        return false\n    }\n    return (flipEquiv(root1.Left, root2.Left) && \n            flipEquiv(root1.Right, root2.Right)) || \n           (flipEquiv(root1.Left, root2.Right) &&\n            flipEquiv(root1.Right, root2.Left))\n}\n```\n\n## [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)\n\n给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。\n\n**示例 1:**\n给定的树 s:\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n```\n\n\n给定的树 t：\n\n```java\n   4 \n  / \\\n 1   2\n```\n\n返回 **true**，因为 t 与 s 的一个子树拥有相同的结构和节点值。\n\n**示例 2:**\n给定的树 s：\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n    /\n   0\n```\n\n给定的树 t：\n\n```java\n   4\n  / \\\n 1   2\n```\n\n返回 **false**\n\n**解法一**\n\n先上一个错误解法\n\n```java\npublic boolean isSubtree(TreeNode s, TreeNode t) {\n    if (t==null && s==null) {\n        return true;\n    }\n    if (s==null) {\n        return false;\n    }\n    if (s!=null&& t!=null && s.val == t.val) {\n        return isSubtree(s.left,t.left) && isSubtree(s.right,t.right);\n    }\n    return isSubtree(s.left,t) | isSubtree(s.right,t);\n}\n```\n过了146/176的case，但是这个明显是错的，不过核心的递归还是大概雏形写出来了\n\n**解法二**\n\n思考了一会，光速瞄了一眼评论区，隐约看到了有人说双递归，然后想到了下面的解\n\n```java\n//简化代码\npublic boolean isSubtree(TreeNode s, TreeNode t) {\n    if (s==null) {\n        return false;\n    }\n    return isSame(s,t)| isSubtree(s.left,t) | isSubtree(s.right,t);\n}\n\npublic boolean isSame(TreeNode s, TreeNode t){\n    if (s==null && t==null) {\n        return true;        \n    }\n    if (s==null || t==null) {\n        return false;\n    }\n    return s.val==t.val && isSame(s.left,t.left) && isSame(s.right,t.right);\n}\n```\n\n开始的代码没这么简洁，比较罗嗦，要判断一棵树是不是另一颗的子树很好判断，要么s和t直接相等，要么t是s左子树的子树，或者右子树的子树，所以我们还需要一个函数判断两个两棵树是否相等，只用一个函数确实不好实现\n\n**解法三**\n\n其实还有一种解法，也是最开始想到的，就是直接中序遍历和前序遍历，得到两个序列，然后用kmp匹配两棵树，kmp很久没看了，不会写了，后面有时间再来写\n\n## [面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)\n\n输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\n\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n\n**例如:**\n给定的树 A:\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n```\n\n给定的树 B：\n\n```java\n   4 \n  /\n 1\n```\n\n\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n\n**示例 1：**\n\n```java\n输入：A = [1,2,3], B = [3,1]\n输出：false\n```\n\n**示例 2：**\n\n```java\n输入：A = [3,4,5,1,2], B = [4,1]\n输出：true\n```\n\n**限制：**\n\n0 <= 节点个数 <= 10000\n\n**解法一**\n\n一样的题为啥还加上？仔细看题，我开始也以为是一样的\n\n```java\npublic boolean isSubStructure(TreeNode A, TreeNode B) {\n    if(A==null || B==null){\n        return false;\n    }\n    return isSame(A,B) | isSubStructure(A.left,B) | isSubStructure(A.right,B);\n}\n\npublic boolean isSame(TreeNode A,TreeNode B){\n    if (B==null) { //AB同时为NULL应该返回true,所以上下不能交换\n        return true;\n    }\n    if(A==null){\n        return false;\n    }\n    return A.val==B.val && isSame(A.left,B.left) && isSame(A.right,B.right);\n}\n```\n这里说的是子结构不是子树，isSame函数不需要保证完全相等，这里就需要注意了，当`A!=null && B==null`的时候就说明B已经匹配完了A还没有，这就说明B是A的子结构\n\n**UPDATE(2020.5.7)**\n\n换了一下写法，不用考虑顺序了\n\n```go\nfunc isSubStructure(A *TreeNode, B *TreeNode) bool {\n    if B==nil || A==nil{\n        return false\n    }\n    return dfs(A,B) || isSubStructure(A.Left,B) || isSubStructure(A.Right,B)\n}\n\nfunc dfs(A *TreeNode, B *TreeNode)bool{\n    if A==nil && B==nil{\n        return true\n    }\n    if A==nil || B==nil{\n        return B==nil\n    }\n    return A.Val==B.Val && dfs(A.Left,B.Left) && dfs(A.Right,B.Right)\n}\n```\n\n## [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n\n给出一个**完全二叉树**，求出该树的节点个数。\n\n**说明：**\n\n完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n\n**示例:**\n\n```java\n输入: \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\n输出: 6\n```\n\n**解法一**\n\nBFS，权当复习了\n\n```java\n//BFS\npublic int countNodes(TreeNode root) {\n    Queue<TreeNode> queue=new LinkedList<>();\n    if (root == null) return 0;\n    queue.add(root);\n    int count=1;\n    while(!queue.isEmpty()){\n        int nextLevel=queue.size();\n        while(nextLevel>0){\n            TreeNode node=queue.poll(); \n            count++;\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            nextLevel--;\n        }\n    }\n    return count;\n}\n```\n**解法二**\n\n递归解法\n\n```java\n//暴力\npublic int countNodes(TreeNode root) {\n    if (root==null) return 0;\n    return countNodes(root.left)+countNodes(root.right)+1;\n}\n```\n更加精简点可以缩减成一行\n\n**解法三**\n\n这题是mid难度，而且题目给的条件还没用上：**这是一颗完全二叉树**，所以我们可以利用它的性质来做，众所周知，**满二叉树的节点个数**可以直接根据公式 `2^H-1` 计算得来，所以我们只要判断当前的完全二叉树是不是**满二叉树**，如果是直接算出来，这样就可以省去中间很多节点的遍历\n\n```java\n//利用完全二叉树的性质\npublic int countNodes(TreeNode root) {\n    if (root==null) return 0;\n    TreeNode left=root.left;\n    TreeNode right=root.right;\n    int hight=0;\n    while(left!=null && right!=null){\n        left=left.left;\n        right=right.right;\n        hight++;\n    }\n    //同时向左向右走，走到最后left==null就说明这颗树是满二叉树，可以利用公式直接求出节点个数\n    //否则就对其左右子树递归求解\n    return left==null?(1<<hight)-1:countNodes(root.left)+countNodes(root.right)+1;\n}\n```\n不得不说这样的方式还是挺巧妙的，时间复杂度应该是`O(2logN)`? \n\n## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)\n\n给定一个二叉树和一个目标和，判断该树中是否存在**根节点到叶子节点**的路径，这条路径上所有节点值相加等于目标和。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例:** \n给定如下二叉树，以及目标和 `sum = 22`\n\n```java\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n```\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`\n\n**解法一**\n\n递归解法\n\n```java\npublic boolean hasPathSum(TreeNode root, int sum) {\n    if (root==null) {\n        return false;\n    }\n    //需要注意这里的叶节点判断\n    if (root.left==null && root.right==null&&root.val==sum) {\n        return true;\n    }\n    return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\n}\n```\n值得注意的地方就是这个叶子节点的判断，一开始没注意到，直接写的 `root.val==sum` ，其实如果不是叶子节点的话，其实是不成立的，比如\n\n```java\n  1\n /\n2       sum=1\n```\n\n其实这就是`false` ，因为他没有右子树，而题目要求的是从**根节点到叶子节点**\n\n## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)\n\n计算给定二叉树的所有左叶子之和。\n\n**示例：**\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n\n**解法一**\n\n说实话，这些题给的例子都挺误导人的，会让人不自觉地忽略**叶子节点**这个条件😂\n\n```java\nprivate int sum=0;\n\npublic int sumOfLeftLeaves(TreeNode root){\n    sumOfLeft(root);\n    return sum;\n};\n\npublic void sumOfLeft(TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    //注意这里的条件！！！！\n    if (root.left!=null && root.left.left==null &&root.left.right==null) {\n        sum+=root.left.val;\n    }\n    sumOfLeft(root.left);\n    sumOfLeft(root.right);\n}\n```\n## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例:**\n\n```java\n 输入:\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出: [\"1->2->5\", \"1->3\"]\n\n解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3\n```\n\n**解法一**\n\n递归DFS的解法\n\n```java\n//DFS\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> res=new ArrayList<>();\n    if (root==null) return res;\n\n    if (root!=null&&root.left==null&&root.right==null) {\n        res.add(String.valueOf(root.val));\n        return res;\n    }\n    //左子树的所有路径\n    List<String> lefts=binaryTreePaths(root.left);\n    //右子树的所有路径\n    List<String> rights=binaryTreePaths(root.right);\n    \n    //在每条路径前面加上当前根节点\n    for (int i=0;i<lefts.size();i++) {\n        res.add(root.val+\"->\"+lefts.get(i));\n    }\n    for (int i=0;i<rights.size();i++) {\n        res.add(root.val+\"->\"+rights.get(i));\n    }\n    return res;\n}\n```\n比上面的递归稍微复杂点，核心思想还是要抓住递归的本质，不要去纠结递归每一步都是怎么得到的，从宏观上去写代码，还是要多练啊\n\n**解法二**\n\nBFS广搜\n\n```java\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> res=new ArrayList<>();\n    if (root==null) return res;\n    Stack<TreeNode> node_stack=new Stack<>();\n    Stack<String> path_stack=new Stack<>();\n    node_stack.add(root);\n    path_stack.add(String.valueOf(root.val));\n    String path=\"\";\n    while(!node_stack.isEmpty()){\n        TreeNode node=node_stack.pop();\n        path=path_stack.pop();\n        //叶子节点，这条路径搜索结束，添加到res中\n        if (node.left==null&&node.right==null) {\n            res.add(path);\n        }\n        \n        if (node.left!=null) {\n            node_stack.add(node.left);\n            path_stack.add(path+\"->\"+node.left.val);\n        }\n        if (node.right!=null) {\n            node_stack.add(node.right);\n            path_stack.add(path+\"->\"+node.right.val);\n        }\n    }\n    return res;\n}\n```\n这里和传统的BFS不太一样，是用的栈来遍历的\n\n**解法三**\n\n这种解法应该会比上面的解法复杂度低一点\n\n```go\nfunc binaryTreePaths(root *TreeNode) []string {\n    var res []string\n    dfs(root,\"\",&res)\n    return res\n}\n\n//注意这个res要传指针\nfunc dfs(root *TreeNode,path string,res *[]string){\n    if root==nil {return}\n    path+=strconv.Itoa(root.Val)\n    if root.Left==nil && root.Right==nil{\n        *res=append(*res,path)\n        return\n    }\n    dfs(root.Left,path+\"->\",res)\n    dfs(root.Right,path+\"->\",res)\n}\n```\n\n## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)\n\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n**说明:** 叶子节点是指没有子节点的节点\n\n**示例:**\n给定如下二叉树，以及目标和 `sum = 22`，\n\n```java\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\    / \\\n    7    2  5   1\n```\n返回:\n\n```java\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n```\n\n**解法一**\n\n和上一题的做法基本一致，本来应该是一遍bugfree的，编译错误整了半天\n\n```java\npublic List<List<Integer>> pathSum(TreeNode root, int sum) {\n    List<List<Integer>> res=new LinkedList<>();\n    if (root==null) {\n        return res;\n    }\n    if (root!=null && root.left==null && root.right==null && root.val==sum) {\n        LinkedList<Integer>  lis= new LinkedList<>(); \n        lis.add(root.val);\n        res.add(lis);\n        return res;\n    }\n    //左右子树符合条件的路径\n    List<List<Integer>> lefts=pathSum(root.left,sum-root.val);\n    List<List<Integer>> rights=pathSum(root.right,sum-root.val);\n\n    for (int i=0;i<lefts.size();i++) {\n        ((LinkedList<Integer>)lefts.get(i)).addFirst(root.val);\n        res.add(lefts.get(i));\n    }\n\n    for (int i=0;i<rights.size();i++) {\n        ((LinkedList<Integer>)rights.get(i)).addFirst(root.val);\n        res.add(rights.get(i));\n    }\n    return res;\n}\n```\n**解法二**\n\n废了老大劲终于把BFS写出来了。。。可以看出还是借鉴的上面的思路\n\n```java\npublic List<List<Integer>> pathSum2(TreeNode root,int sum) {\n    List<List<Integer>> res=new LinkedList<>();\n    if (root==null) return res;\n    //节点栈\n    Stack<TreeNode> node_stack=new Stack<>();\n    //路径栈\n    Stack<List<Integer>> path_stack=new Stack<>();\n    //节点sum栈\n    Stack<Integer> sum_stack=new Stack<>();\n    //给每个栈存入初始值\n    node_stack.add(root);\n    path_stack.add(new LinkedList(){{\n        add(root.val);\n    }});\n    sum_stack.add(root.val);\n    //BFS\n    while(!node_stack.isEmpty()){\n        TreeNode node=node_stack.pop();\n        List<Integer> pathList=path_stack.pop();\n        int tempS=sum_stack.pop();\n        //终止条件\n        if (node.left==null && node.right==null&&tempS==sum) {\n            res.add(pathList);\n            continue;\n        }\n        if (node.left!=null) {\n            //这三个栈是同步的,node栈存放当前节点\n            //path栈存放根节点到当前节点的路径\n            //sum栈存放的是path栈中所有节点的val和\n            node_stack.add(node.left);\n            //这里不要直接操作pathList,否则左右的路径会混在一起\n            LinkedList<Integer> tlis= new LinkedList(pathList);\n            tlis.add(node.left.val);\n            path_stack.add(tlis);\n            //累加路径上的节点值\n            sum_stack.add(tempS+node.left.val);\n        }\n        if (node.right!=null) {\n            node_stack.add(node.right);\n            //同上\n            LinkedList<Integer> tlis= new LinkedList(pathList);\n            tlis.add(node.right.val);\n            path_stack.add(tlis);\n            sum_stack.add(tempS+node.right.val);\n        }\n    }\n    return res;\n}\n```\n用到三个栈，同步保存节点的信息，还是挺简单的\n\n**解法三**\n\n补一种dfs+回溯的思路，上面的所有路径也可以这样做，感觉会比上面的要好一点\n\n```java\npublic List<List<Integer>> pathSum(TreeNode root, int sum) {\n    dfs(root,sum,new ArrayList<>());\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void dfs(TreeNode root,int sum,List<Integer> lis){\n    if(root==null) return;\n    lis.add(root.val);\n    if(root.left==null && root.right==null && sum==root.val){\n        res.add(new ArrayList(lis)); //这里不能return，得到后面回溯后才能return\n    }else{\n        dfs(root.left,sum-root.val,lis);\n        dfs(root.right,sum-root.val,lis);\n    }\n    lis.remove(lis.size()-1);\n}\n```\n\n## [894. 所有可能的满二叉树](https://leetcode-cn.com/problems/all-possible-full-binary-trees/)\n\n*满二叉树*是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。\n\n返回包含 `N` 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。\n\n答案中每个树的每个`结点`都**必须**有 `node.val=0`。\n\n你可以按任何顺序返回树的最终列表。\n\n![tXXu4A.png](https://s1.ax1x.com/2020/06/13/tXXu4A.png)\n\n**示例：**\n\n```java\n输入：7\n输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n解释：\n```\n\n**提示：**\n\n- `1 <= N <= 20`\n\n**解法一**\n\n这题和上面两题很类似，可惜我并没有直接做出来，菜啊，看了一眼评论区看见了几个for循环立马就懂了，然后过了好几天实现了下，一开始root的位置放错了，改了一会儿\n\n```java\npublic List<TreeNode> allPossibleFBT(int N) {\n    List<TreeNode> res=new ArrayList<>();\n    if(N%2==0) return res; //偶数提前返回，加快速度\n    if(N==1){\n        res.add(new TreeNode(0));\n        return res;  \n    }\n    N--; //减去根节点\n    for(int i=1;i<N;i+=2){ //将左右子树划分位两个奇数\n        List<TreeNode> lefts=allPossibleFBT(i);\n        List<TreeNode> rights=allPossibleFBT(N-i);\n        for(TreeNode le:lefts){\n            for(TreeNode ri:rights){\n                //一路从最外层移动到这里。。。。\n                TreeNode root=new TreeNode(0); \n                root.left=le;\n                root.right=ri;\n                res.add(root);\n            }\n        }\n    }\n    return res;\n}\n```\n\n## [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\n\n给定一个二叉树，它的每个结点都存放一个 `0-9` 的数字，每条从根到叶子节点的路径都代表一个数字。\n\n例如，从根到叶子节点路径 `1->2->3` 代表数字 `123`\n\n计算从根到叶子节点生成的所有数字之和。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例 1:**\n\n```java\n输入: [1,2,3]\n    1\n   / \\\n  2   3\n输出: 25\n解释:\n从根到叶子节点路径 1->2 代表数字 12.\n从根到叶子节点路径 1->3 代表数字 13.\n因此，数字总和 = 12 + 13 = 25.\n```\n\n**示例 2:**\n\n```java\n输入: [4,9,0,5,1]\n    4\n   / \\\n  9   0\n / \\\n5   1\n输出: 1026\n解释:\n从根到叶子节点路径 4->9->5 代表数字 495.\n从根到叶子节点路径 4->9->1 代表数字 491.\n从根到叶子节点路径 4->0 代表数字 40.\n因此，数字总和 = 495 + 491 + 40 = 1026.\n```\n\n**解法一**\n\nBFS，延续上面的做法\n\n```java\npublic int sumNumbers(TreeNode root) {\n    int res=0;\n    if (root == null ) return res;\n    Stack<TreeNode> node_stack=new Stack<>();\n    Stack<Integer> sum_stack=new Stack<>();\n    node_stack.add(root);\n    sum_stack.add(root.val);\n    while(!node_stack.isEmpty()){\n        TreeNode node=node_stack.pop();\n        int tempS=sum_stack.pop();\n        if (node.left==null && node.right==null) {\n            res+=tempS;\n            continue;\n        }\n        if (node.left!=null) {\n            node_stack.add(node.left);\n             //注意*10,在上一层的基础上*10\n            sum_stack.add(tempS*10+node.left.val);\n        }\n        if (node.right!=null) {\n            node_stack.add(node.right);\n            sum_stack.add(tempS*10+node.right.val);\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\nDFS解法，一开始没想出来。。。\n\n```java\nprivate int sum=0;\n//DFS\npublic int sumNumbers2(TreeNode root) {\n    sumNumber(0,root);\n    return sum;\n}\n\npublic void sumNumber(int parent,TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    int cur=parent*10+root.val;\n    //叶子节点\n    if (root!=null && root.left==null&& root.right==null) {\n        sum+=cur;\n    }\n    sumNumber(cur,root.left);\n    sumNumber(cur,root.right);\n}\n```\n\n## [1022. 从根到叶的二进制数之和](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/)\n\n给出一棵二叉树，其上每个结点的值都是 `0` 或 `1` 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 `0 -> 1 -> 1 -> 0 -> 1`，那么它表示二进制数 `01101`，也就是 `13` 。\n\n对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。\n\n以 **10^9 + 7** 为**模**，返回这些数字之和。\n\n**示例：**\n\n![JI4uDI.png](https://s1.ax1x.com/2020/04/28/JI4uDI.png)\n\n```java\n输入：[1,0,1,0,1,0,1]\n输出：22\n解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n```\n\n \n\n**提示：**\n\n1. 树中的结点数介于 `1` 和 `1000` 之间。\n2. node.val 为 `0` 或 `1` 。\n\n**解法一**\n\n和上一题一摸一样，没啥好说的，只不过一个是10进制，一个是二进制\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nvar mod=int(1e9+7)\n\nfunc sumRootToLeaf(root *TreeNode) int {\n    sum:=0;\n    dfs(root,0,&sum)\n    return sum\n}\n\nfunc dfs(root *TreeNode,cur int,sum *int){\n    if root==nil{\n        return\n    }\n    cur=(cur<<1+root.Val)%mod\n    if root!=nil && root.Left==nil && root.Right==nil{\n        *sum=(*sum+cur)%mod\n        return\n    }\n    dfs(root.Left,cur,sum)\n    dfs(root.Right,cur,sum)\n}\n```\n\n> 这题的数据太弱了，甚至都不用取模照样可以过。。。。我一开始看到1000个节点，还考虑要不要处理大数的情况，看到返回值是int才作罢🤣\n\n## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)\n\n给定一个二叉树，它的每个结点都存放着一个整数值。\n\n找出路径和等于给定数值的路径总数。\n\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n\n**示例：**\n\n```java\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n```\n\n返回 3。和等于 8 的路径有:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3.  -3 -> 11\n\n**解法一**\n\n```java\npublic int pathSum(TreeNode root, int sum) {\n    if (root == null ) {\n        return 0;\n    }\n    int res=findPath(root,sum);\n    res+=pathSum(root.left,sum);\n    res+=pathSum(root.right,sum);\n    return res;\n}\n\npublic int findPath(TreeNode node,int sum){\n    int res=0;\n    if (node==null) {\n        return res;\n    }\n    if (node.val==sum) {\n        res++;\n    }\n    res+=findPath(node.left,sum-node.val);\n    res+=findPath(node.right,sum-node.val);\n    return res;\n}\n```\n~~emmmm，这题分类是easy确实太迷了，嵌套的递归，看了解法确实看的懂，但是写是绝对写不出来的（眼睛：我懂了，脑子：你懂个锤子）除非能记住~~\n\n回头来看发现其实挺简单的，确实是easy题~ 但是这个解很明显不是最优解，这个里面会有很多的重复的计算，最优解是利用 前缀和+回溯的解法，有点小顶~\n\n**解法二**\n\n补上前缀和的做法，之前好像是看了答案，然后感觉很难，就没写？今天又重新做了下，先写了暴力解，然后就直接写出了前缀和的做法，感觉前缀和的思路还是挺优秀的，一开始忘了回溯，思考了下意识到这里记录的应该是一条分支之上而下的前缀和，所以在统计完某个节点后应该回溯\n```golang\n//前缀和的思路O(N)挺不错的\nfunc pathSum(root *TreeNode, sum int) int {\n    if root == nil {\n        return 0\n    }\n    var res = 0\n    //前缀和，记录一条自上而下的路径前缀和\n    var preSum = make(map[int]int)\n    preSum[0] = 1\n    dfs(root, 0, sum, preSum, &res)\n    return res\n}\n\nfunc dfs(root *TreeNode, sum int, target int, preSum map[int]int, res *int) {\n    if root == nil {\n        return\n    }\n    sum += root.Val\n    //preSum[sum]++，这里WA了一发，写在上面如果tatget为0就把当前节点算进去了\n    *res += preSum[sum-target]\n    preSum[sum]++\n    dfs(root.Left, sum, target, preSum, res)\n    dfs(root.Right, sum, target, preSum, res)\n    preSum[sum]--\n}\n\n```\n\n## [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）\n\n例如，给定如下二叉搜索树:  `root = [6,2,8,0,4,7,9,null,null,3,5]`\n\n![mark](http://static.imlgw.top/blog/20191001/KlQJmqmdWmP3.png?imageslim)\n\n**示例 1:**\n\n```java\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6\n```\n\n**示例 2:**\n\n```java\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n**说明:**\n\n- 所有节点的值都是唯一的。\n- p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n**解法一**\n\n看了一点点思路，然后bugfree\n\n```java\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    //特殊情况,其中一个已经是另一个的祖先了\n    //if (p==root || q==root) return root;\n    //都小于根节点\n    if (p.val<root.val && q.val<root.val) {\n        return lowestCommonAncestor(root.left,p,q);\n    }else if (p.val > root.val && q.val > root.val) {\n        //都大于根节点\n        return lowestCommonAncestor(root.right,p,q);\n    }else{\n        //一大一小 或者有一个是root\n        return root;\n    }\n}\n```\n其实核心就是利用好BST的性质，左子树一定小于根节点，右子树一定大于根节点，求公共祖先，如果一个节点在左子树，一个在右子树，那么最近的公共祖先一定是root，除此之外，还有一种特殊情况就是当两个节点已经有祖先关系的时候，那么直接返回祖先节点就可以了\n\n> 这里其实前面的`if`可以去掉，题目中说到了所有节点的值都是唯一的，所以节点值相等就说明是同一个节点，就已经包含在最后一个else的情况中了\n\n## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n- 节点的左子树只包含**小于**当前节点的数。\n- 节点的右子树只包含**大于**当前节点的数。\n- 所有左子树和右子树自身必须也是二叉搜索树。\n\n**示例 1:**\n\n```java\n输入:\n    2\n   / \\\n  1   3\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 \n```\n\n**解法一**\n\n递归解法，很巧妙\n\n```java\npublic boolean isValidBST(TreeNode root) {\n    if (root==null) {\n        return true;\n    }\n    return isValidBST(root,null,null);\n}\n\npublic boolean isValidBST(TreeNode node,Integer low,Integer high){\n    if (node==null) return true;\n    if (low!=null && low>=node.val || high!=null && high<=node.val) {\n        return false;\n    }\n    return isValidBST(node.left,low,node.val) && isValidBST(node.right,node.val,high);\n}\n```\n一定要注意BST的性质是根节点**大于所有** 右子树的节点，**小于所有**左子树的节点，而不是简单的验证当前节点和左右节点的大小关系就可以了，所以我们在验证的时候传入对应的**上界**和**下界**，节点必须要大于下界，小于上界，那么上界和下界从哪里来？_当前节点就是左子树的上界，右子树的下界！_  然后递归左右子树就ok了\n\n> 这题其实还有一个坑，只不过我这个做法直接跳过了，题目的case中有的节点值是`Integer.MIN_VALUE`，和`Integer.MAX_VALUE`  ，如果上界下界直接用int来传递的话，很有可能递归初始调用就是这样的\n>\n> `return isValidBST(root,Integer.MIN_VALUE,Integer.MAX_VALUE);` 这就正中出题人下怀，所以我们这里用一个包装类型，这样我们只需要检测上界下界是不是null就可以了\n\n**解法二**\n\n这个就利用了BST和中序遍历的关系，我们知道中序遍历是 `左->根->右`  这个顺序放到 BST中恰好就是一个升序的序列，所以我们就可以利用这个性质来判断二叉树是不是BST\n\n```java\n//BST的中序遍历一定是升序的\npublic boolean isValidBST(TreeNode root){\n    LinkedList<Integer> order=new LinkedList<>();\n    if (root==null) {\n        return true;\n    }\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        //和上一次的最后一个节点值比较\n        if (!order.isEmpty() && order.getLast()>= cur.val) {\n            return false;\n        }\n        order.add(cur.val);\n        cur=cur.right;\n    }\n    return true;\n}\n```\n这里其实可以不用list保存结果，~~用一个int保存上一次的节点值就行了~~ md重做的时候因为这个WA了好几次，如果用int的话需要加一个标志位用来初始化\n\n## [958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)\n\nDifficulty: **中等**\n\n\n给定一个二叉树，确定它是否是一个_完全二叉树_。\n\n**中对完全二叉树的定义如下：**\n\n若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2<sup>h</sup> 个节点。）\n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png)\n\n```go\n输入：[1,2,3,4,5,6]\n输出：true\n解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。\n```\n\n**示例 2：**\n\n**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png)**\n\n```go\n输入：[1,2,3,4,5,null,7]\n输出：false\n解释：值为 7 的结点没有尽可能靠向左侧。\n```\n\n**提示：**\n\n1.  树中将会有 1 到 100 个结点。\n\n\n**解法一**\n\n一开始思路出现了问题，想着去按照节点个数去校验，然后对最后一层做特判，然后发现这种思路是死胡同，实际上判断是否是完全二叉树很简单，只要节点**中间**没有出现null就说明是完全二叉树\n```java\npublic boolean isCompleteTree(TreeNode root) {\n    if (root == null) {\n        return true;\n    }\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    TreeNode pre = root;\n    while(!queue.isEmpty()){\n        TreeNode cur = queue.poll();\n        //当前节点前面出现了null\n        if (pre==null && cur!=null){\n            return false;\n        }\n        if (cur!=null) {\n            //因为要判断null是否在中间，所以null节点也要存进去\n            queue.add(cur.left);\n            queue.add(cur.right);\n        }\n        pre = cur;\n    }\n    return true;\n}\n```\n\n## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n将一个按照升序排列的有序数组，转换为一棵**高度平衡二叉搜索树**\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n**示例:**\n\n```java\n给定有序数组: [-10,-3,0,5,9]\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n**解法一**\n\n```java\npublic TreeNode sortedArrayToBST(int[] nums) {\n    return sortedArrayToBST(nums,0,nums.length-1);\n}\n\npublic TreeNode sortedArrayToBST(int[] nums,int left,int right) {\n    if (left>right) {\n        return null;\n    }\n    int mid=(right-left)/2+left;\n    TreeNode node=new TreeNode(nums[mid]);\n    node.left=sortedArrayToBST(nums,left,mid-1);\n    node.right=sortedArrayToBST(nums,mid+1,right);\n    return node;\n}\n```\n这题最开始终止条件写错了，思路是对的，对递归运用的还是不够熟练，终止条件其实只需要想一下极端情况就可以了\n\n## [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。\n\n**示例:**\n\n```sql\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n**解法一**\n\n~~BST不太熟看了下评论写出来的~~\n\n好久之前写的题了，每日打卡题出了上面的题目，随便做一下这题，发现这题被记录在链表专题中了，移过来下，和上面的一样，只不过找中点的方式不一样（UPDATE: 2020.7.3）\n\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n    return build(head,null);\n}\n\npublic static TreeNode build(ListNode head,ListNode tail){\n    if(head==tail){\n        return null;\n    }\n    //快慢指针找中点\n    ListNode fast=head,slow=head;\n    while(fast!=tail&&fast.next!=tail){\n        //左闭右开\n        fast=fast.next.next;\n        slow=slow.next;\n    }\n    //slow为中点或中点后一个\n    //1 2 3 4\n    TreeNode root=new TreeNode(slow.val);\n    root.left=build(head,slow);\n    root.right=build(slow.next,tail);\n    return root;\n}\n```\n**UPDATE: 2020.7.3**\n```golang\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    if head == nil{\n        return nil\n    }\n    if head.Next == nil{\n        return &TreeNode{Val : head.Val}\n    }\n    var fast = head\n    var slow = head //slow为左中点\n    var pre  = head\n    for fast != nil && fast.Next !=nil{\n        fast = fast.Next.Next\n        pre = slow\n        slow = slow.Next\n    }\n    pre.Next = nil //斩断和slow的联系\n    root := &TreeNode{Val : slow.Val}\n    root.Left = sortedListToBST(head)\n    root.Right = sortedListToBST(slow.Next)\n    return root\n}\n```\n\n## [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 k 个最小的元素\n\n**说明：**\n你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。\n\n**示例 1:**\n\n```java\n输入: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出: 1\n```\n\n\n**示例 2:**\n\n```java\n输入: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出: 3\n```\n\n\n**进阶：**\n如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？\n\n**解法一**\n\n非递归中序遍历\n\n```java\npublic int kthSmallest(TreeNode root, int k) {\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    int count=0;\n    while(cur!=null || !stack.isEmpty()){\n        while(cur!=null){\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        if (count==k-1) {\n            return cur.val;\n        }\n        cur=cur.right;\n        count++;\n    }\n    //没找到\n    return -1;\n}\n```\n还是利用BST中序遍历是升序的性质，在取到第k个元素的时候就直接`break`\n\n**解法二**\n\n递归的方式，加了两个额外的实例变量其实不太好\n\n```java\npublic int kthSmallest(TreeNode root, int k) {\n    kthSmallest(root,k);\n    return res;\n}\n\nprivate int count=0;\n\nprivate int res=0;\n\npublic void kthSmall(TreeNode root, int k) {\n    if (root==null) {\n        return;\n    }\n    kthSmall(root.left,k);\n    if (count==k-1) {\n        res=root.val;\n        return;\n    }\n    count++;\n    kthSmall(root.right,k);\n}\n```\n如果是第K大就交换下遍历顺序就行了\n```golang\nfunc kthLargest(root *TreeNode, k int) int {\n    var res = root.Val\n    var count = 0\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode){\n        if root == nil{\n            return\n        }\n        //先right\n        dfs(root.Right)\n        count++\n        if count == k{\n            res = root.Val\n        }\n        dfs(root.Left)\n    }\n    dfs(root)\n    return res\n}\n```\n**进阶**\n\n可以维护一个大根堆，就和最小栈一样，每次对BST操作的时候同步操作这个大根堆\n\n## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\n\n ![mark](http://static.imlgw.top/blog/20191003/m0bWNSMUQWy2.png?imageslim)\n\n**示例 1:**\n\n```java\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n```\n\n**示例 2:**\n\n```java\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n**说明:**\n\n- 所有节点的值都是唯一的。\n- p、q 为不同节点且均存在于给定的二叉树中。\n\n**解法一**\n\n```java\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if(root==null || root==p || root==q) return root; \n    TreeNode left=lowestCommonAncestor(root.left,p,q);\n    TreeNode right=lowestCommonAncestor(root.right,p,q);\n    if(left==null){\n        return right;\n    }else if(right==null){\n        return left;\n    }\n    return root;\n}\n```\n\n这个函数的功能有三个：给定两个节点 pp 和 qq\n\n- 如果 pp 和 qq 都存在，则返回它们的公共祖先\n- 如果只存在一个，则返回存在的一个\n- 如果 pp 和 qq 都不存在，则返回NULL \n\n**解法二**\n\n2020.4.9新增解法，利用Map记录父节点，然后根据p,q倒推就行了\n\n```java\n//update: 2020.5.10原来用的TreeNode做键，居然能过也是很神奇，我试了下，TreeNode应该是没有覆盖equals的\n//所以要是碰撞的够多，那种做法就错了\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || p==root ||q==root) {\n        return root;\n    }\n    Deque<TreeNode> stack=new ArrayDeque<>();\n    //题目说了值唯一，所以可以用Integer当键\n    HashMap<Integer,TreeNode> map=new HashMap<>();\n    map.put(root.val,null); //根节点\n    stack.push(root);\n    while(!stack.isEmpty()){\n        TreeNode cur=stack.poll();\n        if(cur.right!=null){\n            stack.push(cur.right);\n            map.put(cur.right.val,cur);\n        }\n        if(cur.left!=null){\n            stack.push(cur.left);\n            map.put(cur.left.val,cur);\n        }\n    }\n    HashSet<Integer> set=new HashSet<>();\n    while(p!=null){\n        set.add(p.val);\n        p=map.get(p.val);\n    }\n    while(!set.contains(q.val)){\n        q=map.get(q.val);\n    }\n    return q;\n}\n```\n## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的\n\n```java\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n\n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是**镜像对称**的:\n\n```java\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n\n**说明:**\n\n如果你可以运用递归和迭代两种方法解决这个问题，会很加分。\n\n**解法一**\n\n哎，感觉刷题还是得在白天，脑子清醒点，下午就感觉做题老是出问题，一开始题都没看清就开始做\n\n其实一开始是想BFS层次遍历然后判断每一层是不是镜像对称的，然后发现有些case是过不了的，比如\n\n`[1,3,3,2,null,2]` 这样的case\n\n```java\n    1\n   / \\\n  3   3\n /   /\n2   2\n```\n\n~~层序遍历判断不出了这样的case~~   下面解法四打脸\n\n然后换一种遍历方式，其实一开始就想到了前序遍历，如果是镜像对称的话，前序遍历刚好就是对称的，但是！！！还是有case过不了！！！我们再看上面的case，我们改一改\n\n```java\n    1\n   / \\\n  2   2\n /   /\n2   2\n```\n\n第`192/195个case`，我惊了，居然还有这种操作！！！实在没办法翻了下解答，发现有位老兄也是这样做的，然后他很巧妙的在每个节点值后面加了一个**层数**，他好像是直接当作字符串添加的，我感觉不太好，改用了数组，最后判断的时候需要保证层数和值都相同才行，完整代码如下\n\n```java\n//[1,2,2,2,null,2] 忘了还有这样的case了,哭了\npublic boolean isSymmetric(TreeNode root) {\n    if (root == null) {\n        return true;\n    }\n    List<Integer[]> lis=new ArrayList<>();\n    preTravle(root,lis,0); \n    for (int i=0,j=lis.size()-1;i<=j;i++,j--) {\n        if (lis.get(i)[0]!= lis.get(j)[0] ||  lis.get(j)[1]!= lis.get(i)[1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//前序遍历\npublic void preTravle(TreeNode node,List<Integer[]> lis,int k){\n    if (node!=null) {\n        preTravle(node.left,lis,k+1);\n        //这里其实用个字符串就可以，但是感觉拼接的效率不高，而且，是不是有可能出现问题？\n        // 11+3 ==1+13 ？？？是不是有可能出现类似这样的情况\n        Integer[] temp=new Integer[2];\n        temp[0]=node.val;\n        temp[1]=k;\n        lis.add(temp);\n        preTravle(node.right,lis,k+1);\n    }\n}\n```\n\n**解法二**\n\n递归的解法，应该算是官解了，一开始也是想用递归写的，没抓住问题的本质，太菜了\n\n```java\npublic boolean isSymmetric(TreeNode root) {\n    if (root ==null) {\n        return true;\n    }\n    //转换为求左右子树是否镜像对称的问题\n    return isSymmetric(root.left,root.right);\n    //return isSymmetric(root,root);\n}\n\n//dfs\npublic boolean isSymmetric(TreeNode t1,TreeNode t2) {\n    if (t1==null && t2==null) {\n        return true;\n    }\n    //有一个为null\n    if (t1== null || t2==null) {\n        return false;\n    }\n    //都不为null\n    return t1.val==t2.val && isSymmetric(t1.left,t2.right) && isSymmetric(t1.right,t2.left);\n}\n```\n一棵树是镜像对称，说明左右子树左右对称，所以这个问题就可以转换为，判断左右两颗子树是否是镜像对称的问题\n\n![mark](http://static.imlgw.top/blog/20191107/Ae6daB6SuXdl.png?imageslim)\n\n判断两颗树是否成镜像对称的话，其实就和照镜子一样的，如上图，判断左子树和右子树是否成镜像对称，就需要判断**t1的左子树和t2的右子树是否镜像对称,t1的右子树和t2的左子树是否镜像对称**，根据这个就可以写出递归函数，还是挺妙的\n\n**解法三**\n\n类似于层次遍历，其实就是根据上面的递归方法改来的，核心思想和上面递归的是一样的\n\n```java\n//非递归解法\npublic boolean isSymmetric(TreeNode root) {\n    if (root ==null) {\n        return true;\n    }\n    Stack<TreeNode> stack=new Stack<>();\n    stack.push(root.left);\n    stack.push(root.right);\n    while(!stack.isEmpty()){\n        TreeNode t1=stack.pop();\n        TreeNode t2=stack.pop();\n        if (t1==null && t2==null) {\n            continue;\n        }\n        if (t1==null||t2==null || t1.val!=t2.val) {\n            return false;\n        }\n        /*if (t1.val!=t2.val) {\n                return false;\n         }*/\n        stack.push(t1.left);\n        stack.push(t2.right);\n        stack.push(t1.right);\n        stack.push(t2.left);\n    }\n    return true;\n}       \n```\n\n**解法四**\n\n前序遍历，其实我一开始也想到了用占位的方式，但是因为之前遍历方式不同，导致没想好在哪里加\n\n```java\npublic boolean isSymmetric(TreeNode root) {\n    if (root ==null) {\n        return true;\n    }\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        ArrayList<Integer> lis=new ArrayList<>();\n        while(count>0){\n            TreeNode node=queue.poll();\n            //lis.add(node.val);\n            if (node.left!=null) {\n                queue.add(node.left);\n                lis.add(node.left.val);\n            }else{\n                //-1占位\n                lis.add(-1);\n            }\n            \n            if (node.right!=null) {\n                queue.add(node.right);\n                lis.add(node.right.val);\n            }else{\n                //为空加-1占位\n                lis.add(-1);\n            }\n            count--;\n        }\n        //对每一层经常判断\n        for (int i=0,j=lis.size()-1;i<=j;i++,j--) {\n            if (lis.get(i)!=lis.get(j)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n这样的做法明显时间复杂度会之前要高，不仅遍历了整颗树一遍，还对每一层遍历了一遍，一共遍历了两遍\n\n## [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\n\n给定一个二叉树，在树的最后一行找到最左边的值。\n\n示例 1:\n```java\n输入:\n    2\n   / \\\n  1   3\n输出:\n1\n```\n\n示例 2:\n```java\n输入:\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n输出:\n7\n```\n**注意:** 您可以假设树（即给定的根节点）不为 NULL。\n\n**解法一**\n\n这种题写一百遍了😂，然而我还是没有bugfree\n\n```java\n//其实这种层序遍历的方式对这题有一点小题大作，不过我还是比较习惯这种方式\npublic int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    int res=-1;\n    while(!queue.isEmpty()){\n        int count=queue.size();\n        int temp=count;\n        while(count>0){\n            TreeNode node=queue.poll();\n            if (count==temp) {\n                res=node.val;\n            }\n            if (node.left!=null) {\n                queue.add(node.left);\n            }\n            if (node.right!=null) {\n                queue.add(node.right);\n            }\n            count--;\n        }\n    }\n    return res;   \n}\n```\n**解法二**\n\n最左边的值，也就是最后一行的第一个元素，dfs深度优先，深度每增加一次就更新一次res\n\n```java\n//DFS\npublic int findBottomLeftValue2(TreeNode root) {\n    dfs(root,0);\n    return res;\n}\n\nint res=-1,max=Integer.MIN_VALUE;\n\npublic void dfs(TreeNode node,int depth){\n    if (node==null) return;\n    if (depth>max) {\n        max=depth;\n        res=node.val;\n    }\n    dfs(node.left,depth+1);\n    dfs(node.right,depth+1);\n}\n```\n\n## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n**注意:**\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n```java\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n```\n\n\n返回如下的二叉树：\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n**解法一**\n\n```java\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\n    if (preorder==null) {\n        return null;\n    }\n    return buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1);\n}\n\npublic TreeNode buildTree(int[] preorder,int preleft,int preright,int[] inorder,int inleft,int inright) {\n    //递归出口只需要想一下边界,比如只要一个节点的时候,很明显只有一个节点的时候这几个值都是 0\n    //但是此时肯定不能返回null,所以这里递归出口不是大于等于,而是大于\n    if (preleft>preright || inleft>inright) {\n        return null;\n    }\n    TreeNode root=new TreeNode(preorder[preleft]);\n    int index=inleft;\n    while(inorder[index] != preorder[preleft]) {\n        index++;\n    }\n    root.left=buildTree(preorder,preleft+1,preleft+index-inleft,inorder,inleft,index-1);\n    root.right=buildTree(preorder,preleft+index-inleft+1,preright,inorder,index+1,inright);\n    return root;\n}\n```\n这题核心思想就是利用这几种遍历的性质，文字总是苍白的，看个图吧\n\n![mark](http://static.imlgw.top/blog/20191106/pcmvnEK8Hwg8.png?imageslim)\n\n这样一看就清晰了，前序遍历左边第一个节点 `1` 一定是根节点，所以我们首先确定了根节点，然后我们去中序遍历中去找这个根节点（一定有），如上图，我们找到了中间的 `1`然后再根据中序遍历的性质，我们可以就知道，中序遍历中，这个`1` 的左边是 `1` 的左子树，右边是`1` 的右子树，到这里我们就确定了根节点及其左右子树，剩下的就交给递归去完成了😁，我们只需要对左右子树分别递归该过程就可以得到一颗完整的树了\n\n当然这里值得注意的地方就是下标的变换，要十分注意，自己带入几个值试试\n\n**UPDATE(2020.5.22)**\n\n```go\nvar m map[int]int\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n    n:=len(inorder)\n    //m:=make(map[int]int,n) 靠！这个bug看了半天\n    m=make(map[int]int,n)\n    for i,val:=range inorder{\n        m[val]=i\n    }\n    return build(preorder,0,n-1,inorder,0,n-1)\n}\n\nfunc build(pre []int,pl int,pr int,in []int,il int,ir int) *TreeNode{\n    if pl>pr || il>ir{\n        return nil\n    }\n    root:=&TreeNode{Val:pre[pl]}\n    idx:=m[pre[pl]]\n    root.Left=build(pre,pl+1,pl+idx-il,in,il,idx-1)\n    root.Right=build(pre,pl+idx-il+1,pr,in,idx+1,ir)\n    return root\n}\n```\n\n## [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n**注意:**\n你可以假设树中没有重复的元素。\n\n例如，给出\n\n```java\n中序遍历 inorder = [9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3]\n```\n\n\n返回如下的二叉树：\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n**解法一**\n\n方法同上，只不过是从后往前了\n\n```java\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\n    if (inorder==null || inorder.length<=0) {\n        return null;\n    }\n    return buildTree(inorder,0,inorder.length-1,postorder,0,postorder.length-1);\n}\n\npublic TreeNode buildTree(int[] inorder,int inL,int inR, int[] postorder,int pL,int pR) {\n    //递归出口只需要想一下边界,比如只要一个节点的时候,很明显只有一个节点的时候这几个值都是0\n    //但是此时肯定不能返回null,所以这里递归出口不是大于等于,而是大于\n    if (inL>inR || pL>pR) { \n        return null;\n    }\n    TreeNode root=new TreeNode(postorder[pR]);\n    int index=inL;\n    while(inorder[index]!=postorder[pR]){\n        index++; //一定有,所以不用担心越界的问题\n    }\n    root.left=buildTree(inorder,inL,index-1,postorder,pL,pL+index-inL-1);\n    root.right=buildTree(inorder,index+1,inR,postorder,pL+index-inL,pR-1);\n    return root;\n}\n```\n和上面一样没啥好说的\n\n**解法二**\n\n上面两种解法提交后效率都不高，这里去中序遍历中找根节点的操作其实可以用Hash表代替\n\n```java\n//hash表优化\nHashMap<Integer,Integer> map=new HashMap<>();\n\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\n    if (inorder==null || inorder.length<=0) {\n        return null;\n    }\n    for (int i=0;i<inorder.length;i++) {\n        map.put(inorder[i],i);\n    }\n    return buildTree(inorder,0,inorder.length-1,postorder,0,postorder.length-1);\n}\n\npublic TreeNode buildTree(int[] inorder,int inL,int inR, int[] postorder,int pL,int pR) {\n    //递归出口只需要想一下边界,比如只要一个节点的时候,很明显只有一个节点的时候这几个值都是相等的\n    //但是此时肯定不能返回null,所以这里递归出口不是大于等于,而是大于\n    if (inL>inR || pL>pR) { \n        return null;\n    }\n    TreeNode root=new TreeNode(postorder[pR]);\n    int index=map.get(postorder[pR]);\n    root.left=buildTree(inorder,inL,index-1,postorder,pL,pL+index-inL-1);\n    root.right=buildTree(inorder,index+1,inR,postorder,pL+index-inL,pR-1);\n    return root;\n}\n```\n\n## [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n\n返回与给定的前序和后序遍历匹配的任何二叉树。\n\n pre 和 post 遍历中的值是不同的正整数。\n\n**示例：**\n\n```java\n输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\n输出：[1,2,3,4,5,6,7]\n```\n\n**提示：**\n\n- `1 <= pre.length == post.length <= 30`\n- `pre[]` 和 `post[]` 都是 1, 2, ..., pre.length 的排列\n- 每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。\n\n**解法一**\n\n和上面的有一点点区别\n\n```java\nHashMap<Integer,Integer> map=new HashMap<>();\n\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\n    for (int i=0;i<post.length;i++) {\n        map.put(post[i],i);\n    }\n    return constructFromPrePost(pre,0,pre.length-1,post,0,post.length-1);\n}\n\npublic TreeNode constructFromPrePost(int[] pre,int preL,int preR,int[] post,int postL,int postR){\n    if (preL>preR || postL>preR) {\n        return null;\n    }\n    TreeNode root=new TreeNode(pre[preL]);\n    if (preL==preR) {\n        return root;\n    }\n    int postIndex=map.get(pre[preL+1]); //这种位置一定要注意溢出\n    int len=postIndex-postL;\n    root.left=constructFromPrePost(pre,preL+1,preL+1+len,post,postL,postIndex);\n    root.right=constructFromPrePost(pre,preL+2+len,preR,post,postIndex+1,postR-1);\n    return root;\n}\n```\n![mark](http://static.imlgw.top/blog/20191106/pcmvnEK8Hwg8.png?imageslim)\n\n还是这张图，前序的第一个是根节点，后序的最后一个是根节点，而我们要找的是左右子树的分界线，这里没有中序遍历，乍一看似乎不好确定，其实不然，注意观察前序的第二个节点，也就是左子树的根节点，比如上面的2，对应到后序遍历中其实正好就可以作为左子树的分界线，这样一来就和上面一样了，所以这里的关键就是找到一个划分点\n\n🔔 **有一点需要注意，题目说了这题的结果可能是不唯一的，数据结构的课程里面也讲过，仅凭前序和后序是无法确定一颗二叉树的，但是一定么？**\n\n并不一定，我们题目的case就是个反例，它就可以通过前序和后序唯一的确定这颗二叉树，那什么时候可以确定，什么时候无法确定呢？\n\n无法确定的例子好说，【1，2】，【2，1】这个就无法确定\n\n ```java\n  1              1   \n   \\            /\n    2          2        两种可能都有\n ```\n\n 但是如果是这样的【1，2，3】【2，3，1】这种就可以唯一的确定\n\n ```java\n  1\n / \\\n2   3  只可能是这种情况\n ```\n归纳总结一下，可以发现，**如果这颗二叉树每个节点的度都是0或者2** 那么他就可以通过前序和后序确定，反之就不一定了，因为你只有一个子节点那么就无法确定这个节点是左节点还是右节点，如果没有或者两个都有那么就可以确定了（根据顺序确定，前面的是左后面的是右，但是你只有一个我就不知道是左还是右了）\n\n## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n\n给定一个二叉树，原地将它展开为链表。\n\n例如，给定二叉树\n\n```java\n\t1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n```\n\n将其展开为：\n\n```java\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n```\n\n> 题目没抄错，就是这样的，确实题目没有说明按照什么方式展开，但是看case能猜到是前序遍历的方式展开（靠猜的？）\n\n**解法一**\n\n前序遍历，递归的解法，用一个全局变量保存链表的结尾，每次将节点添加到last的后面\n\n```java\nTreeNode last=null;\n\npublic void flatten(TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    if (last!=null) {\n        last.left=null;\n        last.right=root;\n    }\n    last=root;\n    TreeNode right=root.right;//保存右子树\n    flatten(root.left);\n    flatten(right);\n}\n```\n需要注意的地方就是需要保存右子树，因为前面的操作将左子树添加到根节点右子树的时候，会导致原本的右子树丢失\n\n**非递归的写法**\n\n```java\npublic void flatten(TreeNode root) {\n    if (root==null) return;\n    TreeNode last=null;\n    Deque<TreeNode> stack=new ArrayDeque<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        TreeNode cur=stack.pop();\n        if(last!=null){\n            last.right=cur;\n            last.left=null;\n        }\n        last=cur;\n        if(cur.right!=null){\n            stack.push(cur.right);\n        }\n        if(cur.left!=null){\n            stack.push(cur.left);\n        }\n    }\n}\n```\n\n**解法二**\n\n变形的后序遍历，递归解法\n\n```java\nTreeNode pre=null;\n\npublic void flatten(TreeNode root) {\n    if (root==null) {\n        return;\n    }\n    flatten(root.right);\n    flatten(root.left);\n    root.right=pre;\n    root.left=null;\n    pre=root;\n}\n```\n相比前面的解法，为了不丢失右子树，先遍历右子树，再遍历左子树，整个序列就是`6 5 4 3 2 1`  我们只需要将每个节点的right指向前一个节点就ok了\n\n**解法三**\n\n迭代，我觉得这种解法挺秀，而且是完全的 `in-place`，但是时间复杂度会高一些，每个元素不只遍历一次\n\n```java\npublic void flatten(TreeNode root) {\n    TreeNode mRight=null;\n    while(root!=null){\n        if (root.left!=null) {\n            mRight=root.left;\n            //找到左子树的最右节点\n            while(mRight.right!=null){\n                mRight=mRight.right;\n            }\n            //将根的右节点接在 mRight.right\n            mRight.right=root.right;\n            //将root.left接在root.right\n            root.right=root.left;\n            //左节点置为null\n            root.left=null;\n        }\n        //重复该过程\n        root=root.right;\n    }\n}\n```\n画个图就是这样\n\n![mark](http://static.imlgw.top/blog/20191108/BIx12P1AYjeX.png?imageslim)\n\n## [面试题36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n\n![3VE7QO.png](https://s2.ax1x.com/2020/02/19/3VE7QO.png)\n\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n![Nn3iZR.png](https://s1.ax1x.com/2020/06/18/Nn3iZR.png)\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n\n**解法一**\n\n开始还以为挺难搞，一遍就写出来了😁比上一题简单\n\n```java\npublic Node treeToDoublyList(Node root) {\n    if(root==null) return root;\n    dfs(root);\n    head.left=lastNode;\n    lastNode.right=head;\n    return head;\n}\n\nNode lastNode,head=null;\n\npublic void dfs(Node root){\n    if(root==null) return;\n    dfs(root.left);\n    if(lastNode==null){\n        head=lastNode=root;\n    }else{\n        root.left=lastNode;\n        lastNode.right=root;\n        lastNode=root;\n    }\n    dfs(root.right);\n}\n```\n\n## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)\n\n给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n```java\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL\n\n初始状态下，所有 next 指针都被设置为 NULL\n\n![leet](https://i.loli.net/2019/11/10/eC4VBqXmwuspZlG.png)\n\n**解法一**\n\n开始没做出来，菜！！！然后特意留到今天总结，又在web上提交了一遍\n\n```java\npublic Node connect(Node root) {\n    if (root ==null ||root.left==null) {\n        return root;\n    }\n    root.left.next=root.right;\n    if (root.next!=null) {\n        root.right.next=root.next.left;   \n    }\n    connect(root.left);\n    connect(root.right);\n    return root;\n}\n```\n**解法二**\n\n这个解法梳理还是很清奇的，类似拉拉链的过程\n\n```java\npublic Node connect(Node root) {\n    if (root ==null ||root.left==null) {\n        return root;\n    }\n    Node left=root.left;\n    Node right=root.right;\n    //有的像拉拉链的过程\n    while(left!=null){\n        left.next=right;\n        left=left.right;\n        right=right.left;\n    }\n    connect(root.left);\n    connect(root.right);\n    return root;\n}\n```\n\n> 还有一个很直白的层序遍历的方法，这里就不写了\n\n## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/) \n\n给定一个二叉树\n\n```java\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。\n\n初始状态下，所有 next 指针都被设置为 `NULL`。\n\n**进阶：**\n\n- 你只能使用常量级额外空间。\n- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n**示例：**\n\n![Y7BwBd.png](https://s1.ax1x.com/2020/05/20/Y7BwBd.png)\n\n```java\n输入：root = [1,2,3,4,5,null,7]\n输出：[1,#,2,3,#,4,5,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。\n```\n\n**提示：**\n\n- 树中的节点数小于 `6000`\n- `-100 <= node.val <= 100`\n\n**解法一**\n\n题目要求的O(1)空间，参考了大佬的解法，模拟层序遍历，着实是很巧妙，代码简洁清晰，值得细细品味\n\n```java\npublic Node connect(Node root) {\n    Node dummyNode=new Node(-1);\n    Node cur=root;\n    //cur在上层，dummyNode和tail在下层，tail负责连接下层所有子节点\n    while(cur!=null){\n        dummyNode.next=null; //重置\n        Node tail=dummyNode;\n        while(cur!=null){\n            if(cur.left!=null){\n                tail.next=cur.left;\n                tail=tail.next;\n            }\n            if(cur.right!=null){\n                tail.next=cur.right;\n                tail=tail.next;\n            }\n            cur=cur.next;\n        }\n        cur=dummyNode.next; //cur转换到下一层\n    }\n    return root;\n}\n```\n\n## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n1. 首先找到需要删除的节点；\n\n2. 如果找到了，删除它。\n\n**说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n**示例:**\n\n```java\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n\n```\n\n**解法一**\n\n更多解释看另一篇 [二叉搜索树](http://imlgw.top/2019/11/08/er-fen-sou-suo-shu/#%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E5%80%BC)\n\n```java\npublic TreeNode deleteNode(TreeNode root, int key) {\n    if (root ==null) {\n        return null;           \n    }\n    if (root.val>key) {\n        root.left=deleteNode(root.left,key);\n    }else if (root.val<key) {\n        root.right=deleteNode(root.right,key);\n    }else{\n        if (root.left==null) {\n            return root.right;\n        }\n        if (root.right==null) {\n            return root.left;\n        }\n        //用右子树的最小值填补删除的元素\n        TreeNode delNode=root;\n        root=getMin(root.right);\n        //下面的left和right不能交换,还好刚开始写错了一波,不然也不会发现,哈哈啊哈哈哈\n        //这里的deleteMin是为了删除delNode的最小值root,如果你先把delNode.left连接到了root.left\n        //那么root就不再是最小值了,再进行deleteMin就会导致root无法删除,最后返回root,导致root.right=root形成环\n        //结果无法打印\n        root.right=deleteMin(delNode.right);\n        root.left=delNode.left;\n    }\n    return root;\n}\n\npublic TreeNode deleteMin(TreeNode node){\n    if (node.left==null) {\n        return node.right;\n    }\n    node.left=deleteMin(node.left);\n    return node;\n}\n\npublic TreeNode getMin(TreeNode node){\n    if (node.left==null) {\n        return node;\n    }\n    return getMin(node.left);\n}\n```\n\n## [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。\n\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。\n\n例如, \n\n给定二叉搜索树:\n\n```java\n    4\n   / \\\n  2   7\n / \\\n1   3\n\n和 插入的值: 5\n```\n\n\n你可以返回这个二叉搜索树:\n\n```java\n     4\n   /   \\\n  2     7\n / \\   /\n1   3 5\n```\n或者这个树也是有效的:\n\n```java\n     5\n   /   \\\n  2     7\n / \\   \n1   3\n     \\\n      4\n```\n\n**解法一**\n\n```java\npublic TreeNode insertIntoBST(TreeNode root, int val) {\n    if (root==null) {\n        return new TreeNode(val);\n    }\n    if (root.val>val) {\n        root.left=insertIntoBST(root.left,val);   \n    }else if (root.val<val) {\n        root.right=insertIntoBST(root.right,val);   \n    }\n    return root;\n}\n```\n没啥好说的，看代码就懂了\n\n\n\n## [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n\n给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。**这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。**\n\n每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n\n**Example 1:**\n\n```java\nInput: \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   3     9 \n\nOutput: 4\nExplanation: The maximum width existing in the third level with the length 4 (5,3,null,9).\n```\n\n**Example 2:**\n\n```java\nInput: \n\n          1\n         /  \n        3    \n       / \\       \n      5   3     \n\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n```\n\n**Example 3:**\n\n```java\nInput: \n\n          1\n         / \\\n        3   2 \n       /        \n      5      \n\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n```\n\n**Example 4:**\n\n```java\nInput: \n\n          1\n         / \\\n        3   2\n       /     \\  \n      5       9 \n     /         \\\n    6           7\nOutput: 8\nExplanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\n```\n\n**Note:** Answer will in the range of 32-bit signed integer.\n\n**解法一**\n\n一开始居然没想到，哎😐还是菜啊\n\n```java\npublic int widthOfBinaryTree(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    Queue<TreeNode> queue=new LinkedList<>();\n    LinkedList<Integer> idxs=new LinkedList<>();\n    int max=1;\n    idxs.add(1);\n    queue.add(root);\n    while(!queue.isEmpty()){\n        int size=queue.size();\n        while(size>0){\n            TreeNode top=queue.poll();\n            int index=idxs.removeFirst();\n            if (top.left!=null) {\n                queue.add(top.left);\n                idxs.add(index*2);\n            }\n            if (top.right!=null) {\n                queue.add(top.right);\n                idxs.add(index*2+1);\n            }\n            size--;\n        }\n        if (idxs.size()!=0) {\n            max=Math.max(idxs.getLast()-idxs.getFirst()+1,max);    \n        }\n    }\n    return max;\n}\n```\n还是层次遍历的思路，不过需要额外添加一个索引列表，用来**记录每个节点对应在完全二叉树中的索引**，这个索引值完全可以根据上一层父节点的索引的到，我们初始化定义根节点的index为1，然后进行层次遍历记录每一层的每个节点的index就ok，当遍历完一层之后统计列表最左和最右两个节点之差，这个值就是当前层的宽度，最后求个最大值就ok了，很可惜，看了答案才知道\n\n**解法二**\n\n递归版本\n\n```java\npublic int widthOfBinaryTree(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    dfs(root,0,0,new LinkedList<>());\n    return max;\n}\n\nint max=1;\n\npublic void dfs(TreeNode node,int depth,int index,List<Integer> leftIdxs){\n    if (node==null) {\n        return;\n    }\n    if (depth>=leftIdxs.size()) {\n        leftIdxs.add(index);\n    }\n    //记录当前节点和当前层最左节点的差\n    max=Math.max(index-leftIdxs.get(depth)+1,max);\n    dfs(node.left,depth+1,index*2,leftIdxs);\n    dfs(node.right,depth+1,index*2+1,leftIdxs);\n}\n```\n这个版本在空间复杂度可能会低一点，list中只存每个层最左的节点，当深度大于等于list的长度时候说明当前节点一定是新一层的最左节点，这个时候添加进去就ok，然后求每个节点和当前层最左的节点index差值就最后更新最大值就ok，这个解法还是没有那么自然，还是上面的BFS好理解一点\n\n## [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)\n\n给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 \n\n给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。\n\n**示例 1:**\n\n```java\n输入: \n    2\n   / \\\n  2   5\n     / \\\n    5   7\n\n输出: 5\n说明: 最小的值是 2 ，第二小的值是 5 。\n```\n\n**示例 2:**\n\n```java\n输入: \n    2\n   / \\\n  2   2\n\n输出: -1\n说明: 最小的值是 2, 但是不存在第二小的值。\n```\n\n**解法一**\n\n```go\n//自然的从上到下的思路\nvar INT_MAX = int(^uint(0) >> 1)\n\nfunc findSecondMinimumValue(root *TreeNode) int {\n\tres := dfs(root)\n\tif res == INT_MAX {\n\t\treturn -1\n\t}\n\treturn res\n}\n\nfunc dfs(root *TreeNode) int {\n\tif root == nil || root.Left == nil {\n\t\treturn INT_MAX\n\t}\n\t//和左右子树都不等，谁小就是谁\n\tif root.Val != root.Left.Val && root.Val != root.Right.Val {\n\t\treturn min(root.Left.Val, root.Right.Val)\n\t}\n\t//和左右子树都相等，分别在左右子树中找第二小比较\n\tif root.Val == root.Left.Val && root.Val == root.Right.Val {\n\t\treturn min(dfs(root.Left), dfs(root.Right))\n\t}\n\t//和左子树相等,在左子树中找第二小和右子树比较\n\tif root.Val == root.Left.Val {\n\t\treturn min(dfs(root.Left), root.Right.Val)\n\t}\n\t//同上\n\treturn min(dfs(root.Right), root.Left.Val)\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t}\n\treturn a\n}\n```\n\n## [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)\n\n给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。\n\n二叉搜索树保证具有唯一的值。\n\n**示例 1：**\n\n```java\n输入：root = [10,5,15,3,7,null,18], L = 7, R = 15\n输出：32\n```\n\n\n**示例 2：**\n\n```java\n输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10\n输出：23\n```\n\n**提示：**\n\n- 树中的结点数量最多为 10000 个。\n- 最终的答案保证小于 2^31\n\n**解法一**\n\n还行，这题反应过来了，中序遍历\n\n```java\nprivate int sum=0;\n\npublic int rangeSumBST(TreeNode root, int L, int R) {\n    preorder(root,L,R);\n    return sum;\n}\n\npublic void preorder(TreeNode root, int L, int R) {\n    if (root==null) {\n        return;\n    }\n    rangeSumBST(root.left,L,R);\n    if (root.val>=L && root.val<=R) {\n        sum+=root.val;\n    }\n    rangeSumBST(root.right,L,R);\n}\n```\n\n## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n**示例 1:**\n\n```java\n输入: \n\tTree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n输出: \n合并后的树:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n```\n\n**注意:** 合并必须从两个树的根节点开始。\n\n**解法一**\n\n```java\npublic TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n    if (t2==null) {\n        return  t1;\n    }\n    if (t1==null) {\n        return t2;\n    }\n    t1.val+=t2.val;\n    t1.left=mergeTrees(t1.left,t2.left);\n    t1.right=mergeTrees(t1.right,t2.right);\n    return t1;\n}\n```\n\n## [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)\n\n给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。\n\n**示例 :**\n\n```java\n输入:\n\n   1\n    \\\n     3\n    /\n   2\n\n输出:\n1\n\n解释:\n最小绝对差为1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。\n```\n\n**注意:** 树中至少有2个节点。\n\n**解法一**\n\n很可惜，这题还WA了一次。。。\n\n```java\npublic int getMinimumDifference(TreeNode root) {\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    int diff=Integer.MAX_VALUE,last=-1;\n    while(!stack.isEmpty() || cur!=null){\n        while(cur!=null){\n            stack.push(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        if (last!=-1) {\n            diff=Math.min(diff,Math.abs(last-cur.val));   \n        }\n        last=cur.val;\n        cur=cur.right;\n    }\n    return diff;\n}\n```\n**解法二**\n\n递归的方式\n\n```java\nprivate int diff = Integer.MAX_VALUE;\n\nprivate int last = -1;\n\npublic int getMinimumDifference(TreeNode root) {\n    inorder(root);\n    return diff;\n}\n\npublic void inorder(TreeNode root){\n    if (root==null) {\n        return;\n    }\n    inorder(root.left);\n    diff = last==-1?diff:Math.min(diff,Math.abs(last-root.val));\n    last = root.val;\n    inorder(root.right);\n}\n```\n\n## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)\n\nDifficulty: **简单**\n\n\n给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。\n\n假定 BST 有如下定义：\n\n*   结点左子树中所含结点的值小于等于当前结点的值\n*   结点右子树中所含结点的值大于等于当前结点的值\n*   左子树和右子树都是二叉搜索树\n\n例如：  \n给定 BST `[1,null,2,2]`,\n\n```go\n   1\n    \\\n     2\n    /\n   2\n```\n\n`返回[2]`.\n\n**提示**：如果众数超过1个，不需考虑输出顺序\n\n**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n\n\n**解法一**\n\n之前忘了记录了，中序遍历统计答案就ok，但是非要严格的O(1)就需要使用Morris遍历（不会\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findMode(root *TreeNode) []int {\n    var dfs func(root *TreeNode)\n    var prev *TreeNode\n    var count, max = 0, 0\n    var res []int\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        dfs(root.Left)\n        if prev == nil || prev.Val == root.Val {\n            count++\n        } else {\n            count = 1\n        }\n        if count == max {\n            res = append(res, root.Val)\n        }\n        if count > max {\n            res = []int{}\n            res = append(res, root.Val)\n            max = count\n        }\n        prev = root\n        dfs(root.Right)\n    }\n    dfs(root)\n```\n\n## [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)\n\n您需要在二叉树的每一行中找到最大的值。\n\n**示例：**\n\n```java\n输入: \n\t  1\n     / \\\n    3   2\n   / \\   \\  \n  5   3   9 \n输出: [1, 3, 9]\n```\n\n**解法一**\n\n娱乐题\n\n```java\npublic List<Integer> largestValues(TreeNode root) {\n    List<Integer> res=new ArrayList<>();\n    dfs(root,res,0);\n    return res;\n}\n\npublic void dfs(TreeNode node,List<Integer> list,int level){\n    if (node==null) {\n        return;\n    }\n    if (level>=list.size()) {\n        list.add(node.val);\n    }\n    if(node.val>list.get(level)){\n        list.set(level,node.val);\n    }\n    dfs(node.left,list,level+1);\n    dfs(node.right,list,level+1);\n}\n```\n\n## [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 `next()` 将返回二叉搜索树中的下一个最小的数。\n\n **示例：**\n\n![leetcode](https://i.loli.net/2019/12/25/TXK397rI5hwjG4B.png)\n\n```java\nBSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false\n```\n\n**提示：**\n\n- next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 **O(h)** 内存，其中 h 是树的高度。\n- 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。 \n\n**解法一**\n\n注意这题空间复杂度要求是`O(h)` ，并不是憨憨题\n\n```java\nStack<TreeNode> stack=new Stack<>();\n\npublic BSTIterator(TreeNode root) {\n    pushLeft(root);\n}\n\npublic int next() {\n    TreeNode node=stack.pop();\n    if (node.right!=null) {\n        pushLeft(node.right);\n    }\n    return node.val;\n}\n\npublic boolean hasNext() {\n    return !stack.isEmpty();\n}\n\npublic void pushLeft(TreeNode node){\n    while(node!=null){\n        stack.add(node);\n        node=node.left;\n    }\n}\n```\n\n我们可以用一个stack存储BST的左链，当取最小值就从stack中直接取，如果取出来的node还有右子树就将右子树的左链也添加进来，是不是有点熟悉？其实就是中序遍历的过程\n\n## [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的**二叉搜索树**。\n\n**示例:**\n\n```java\n输入: 3\n输出:\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n解释:\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n**解法一**\n\n```java\npublic  List<TreeNode> generateTrees(int n) {\n    if(n<=0){\n        return new ArrayList<>();\n    }\n    return generateTrees(1,n);\n}\n\npublic List<TreeNode> generateTrees(int start,int end) {\n    List<TreeNode> res=new ArrayList<>();\n    if (start>end) {\n        //null也是一种情况，左右子树为空\n        res.add(null);\n        return res;\n    }\n    for (int i=start;i<=end;i++) {\n        List<TreeNode> left=generateTrees(start,i-1);\n        List<TreeNode> right=generateTrees(i+1,end);\n        for (TreeNode l:left) {\n            for (TreeNode r:right) {\n                TreeNode currentNode=new TreeNode(i);\n                currentNode.left=l;\n                currentNode.right=r;\n                res.add(currentNode);\n            }\n        }\n    }\n    return res;\n}\n```\n很久之前做过的题，今天又拿出来看看，其实属于分治思路\n\n## [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)\n\n给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。\n\n**例如：**\n\n```java\n输入: 二叉搜索树:\n              5\n            /   \\\n           2     13\n\n输出: 转换为累加树:\n             18\n            /   \\\n          20     13\n```\n\n**解法一**\n\n这里我想先上一个**错误的解法**\n\n```java\n//以下代码纯属娱乐\npublic TreeNode convertBST(TreeNode root) {\n    if (root==null) {\n        return new TreeNode(0);//这里肯定是错的，null应该直接返回null\n    }\n    if (root.left==null && root.right==null) {\n        return root;\n    }\n    root.val+= convertBST(root.right).val;\n    convertBST(root.left).val+=root.val;\n    return root;\n}\n```\n\n忽略返回值的部分，乍一看好像是对的😂，其实问题大了，首先是左边的值算的不对，因为是DFS会从最左边开始算，都只加了他的父节点原始的值，而父节点的累加值还没有算出来，其次有些情况是算不出来的比如左子树的某一个右节点你就算不出来\n\n**解法二**\n\n其实一开始就知道可以直接中序遍历做，只是想玩一些其他的方法，可惜没搞出来😂\n\n```java\npublic TreeNode convertBST(TreeNode root) {\n    dfs(root);\n    return root;\n}\n\nprivate int sum=0;\n\npublic void dfs(TreeNode root){\n    if (root==null) {\n        return;\n    }\n    dfs(root.right);\n    sum+=root.val;\n    root.val=sum;\n    dfs(root.left);\n}\n```\n这里需要注意的就是要翻过来遍历，从大到小，因为它求的是比它大的节点的值\n\n## [508. 出现次数最多的子树元素和](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)\n\n给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。\n\n**示例 1**\n\n```java\n输入:\n\n  5\n /  \\\n2   -3\n返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。\n```\n\n**示例 2**\n\n```java\n输入:\n\n  5\n /  \\\n2   -5\n返回 [2]，只有 2 出现两次，-5 只出现 1 次。\n```\n\n**解法一**\n\n左子树和+右子树和，HashMap记录出现的次数，记录最大值然后取出出现次数最多的\n\n```java\nprivate Map<Integer,Integer> map = new HashMap<>();\n\nprivate int maxCount=0;\n\npublic int[] findFrequentTreeSum(TreeNode root) {\n    if (root ==null) {\n        return new int[]{};\n    }\n    dfs(root);\n    List<Integer> res=new ArrayList<>();\n    map.keySet().stream().filter(val->map.get(val)==maxCount).forEach(res::add);\n    return res.stream().mapToInt(Integer::valueOf).toArray(); //list转数组的又一个小技巧，单纯的toArray只能转换成Integer[],还需要转\n}\n\npublic int dfs(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    int value=root.val+dfs(root.right)+dfs(root.left);\n    map.put(value,map.getOrDefault(value,0)+1);\n    maxCount=Math.max(maxCount,map.get(value));\n    return value;\n}\n```\n\n写法是基于Lambda的，函数式写起来真的舒服\n\n## [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)\n\n你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。\n\n空节点则用一对空括号 \"()\" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。\n\n**示例 1:**\n\n```java\n输入: 二叉树: [1,2,3,4]\n       1\n     /   \\\n    2     3\n   /    \n  4     \n\n输出: \"1(2(4))(3)\"\n\n解释: 原本将是“1(2(4)())(3())”，\n在你省略所有不必要的空括号对之后，\n它将是“1(2(4))(3)”。\n```\n\n**示例 2:**\n\n```java\n输入: 二叉树: [1,2,3,null,4]\n       1\n     /   \\\n    2     3\n     \\  \n      4 \n\n输出: \"1(2()(4))(3)\"\n\n解释: 和第一个示例相似，\n除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。\n```\n\n**解法一**\n\n```java\npublic String tree2str(TreeNode t) {\n    StringBuilder s=new StringBuilder();\n    dfs(t,s);\n    return s.toString();\n}\n\npublic void dfs(TreeNode node,StringBuilder s){\n    if (node==null) {\n        return;\n    }\n    s.append(node.val);\n    if(node.left==null && node.right==null){//没有子节点\n        return;\n    }\n    s.append(\"(\");\n    dfs(node.left,s);\n    s.append(\")\");\n    if (node.right==null) { //没有右节点\n        return;\n    }\n    s.append(\"(\");\n    dfs(node.right,s);\n    s.append(\")\");\n}\n```\n\n没啥好说的，搞清楚题目意思然后注意递归的几个出口就行了\n\n## [1315. 祖父节点值为偶数的节点和](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/)\n\n给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：\n\n该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）\n如果不存在祖父节点值为偶数的节点，那么返回 0 。\n\n**示例：**\n\n![1473_ex1.png](https://i.loli.net/2020/01/13/CgBK9WOMbNvxJpY.png)\n\n```java\n输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n输出：18\n解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。\n```\n\n**提示：**\n\n- 树中节点的数目在 `1` 到 `10^4` 之间。\n- 每个节点的值在 `1` 到 `100` 之间。\n\n**解法一**\n\n好像是170前一天的双周赛的第3题，还是很直白的题，遍历的时候带上它的father的值和grandfather的值带到下一层，然后判断就可以了\n\n```java\npublic int sumEvenGrandparent(TreeNode root) {\n    return dfs(root,-1,-1);\n}\n\npublic int dfs(TreeNode node,int fa,int ga){\n    if (node==null) {\n        return 0;\n    }\n    int sum=0;\n    if (fa!=-1 && ga!=-1 && ga%2==0) {\n        sum+=node.val;\n    }\n    sum+=dfs(node.left,node.val,fa);\n    sum+=dfs(node.right,node.val,fa);\n    return sum;\n}\n```\n\n\n\n\n\n## [1026. 节点与其祖先之间的最大差值](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/) \n\n给定二叉树的根节点 `root`，找出存在于不同节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。\n\n（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n\n**示例：**\n\n![YpF3r9.png](https://s1.ax1x.com/2020/05/03/YpF3r9.png)\n\n```java\n输入：[8,3,10,1,6,null,14,null,null,4,7,13]\n输出：7\n解释： \n我们有大量的节点与其祖先的差值，其中一些如下：\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\n在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。\n```\n\n**提示：**\n\n1. 树中的节点数在 `2` 到 `5000` 之间。\n2. 每个节点的值介于 `0` 到 `100000` 之间。\n\n**解法一**\n\n水题，维护每条路径上的最值，然后统计最大差就行了\n\n```go\nfunc maxAncestorDiff(root *TreeNode) int {\n    var res = 0\n    dfs(root, 1<<30, -1>>30, &res)\n    return res\n}\n\nfunc dfs(root *TreeNode, min, max int, res *int) {\n    if root == nil {\n        return\n    }\n    min = fmin(min, root.Val)\n    max = fmax(max, root.Val)\n    *res = fmax(max-min, *res)\n    dfs(root.Left, min, max, res)\n    dfs(root.Right, min, max, res)\n}\n\nfunc fmin(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc fmax(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n```\n\n## [1325. 删除给定值的叶子节点](https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/)\n\n给你一棵以 `root` 为根的二叉树和一个整数 `target` ，请你删除所有值为 `target` 的 叶子节点 。\n\n注意，一旦删除值为 `target` 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 `target` ，那么这个节点也应该被删除。\n\n也就是说，你需要重复此过程直到不能继续删除。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/01/28/e7dOxoLNciVa4Uf.png)\n\n```java\n输入：root = [1,2,3,2,null,2,4], target = 2\n输出：[1,null,3,null,4]\n解释：\n上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。\n有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/01/28/aNLo4wQz3C1ZiAf.png)\n\n```java\n输入：root = [1,3,3,3,2], target = 3\n输出：[1,3,null,null,2]\n```\n\n**示例 3：**\n\n![image.png](https://i.loli.net/2020/01/28/JHBRy7uZDFWLMVT.png)\n\n```java\n输入：root = [1,2,null,2,null,2], target = 2\n输出：[1]\n解释：每一步都删除一个绿色的叶子节点（值为 2）。\n```\n\n**提示：**\n\n- `1 <= target <= 1000`\n- 每一棵树最多有 `3000` 个节点。\n- 每一个节点值的范围是 `[1, 1000]` 。\n\n**解法一**\n\n某次周赛的第三题\n\n```java\npublic TreeNode removeLeafNodes(TreeNode root, int target) {\n    return delete(root,target);\n}\n\npublic TreeNode delete(TreeNode root,int target){\n    if (root==null) {\n        return null;\n    }\n    root.left=delete(root.left,target);\n    root.right=delete(root.right,target);\n    if (root.left==null && root.right==null && root.val==target) {\n        return null;\n    }\n    return root;\n}\n```\n搞了半天。。。一开始写的时候写的前序遍历的方式，先删除自己然后再去删除左右孩子，然后在如何判断是否有叶子节点上卡了半天，最后写了个for3000的循环过的。。。好菜啊，只要交换一下顺序变成后序遍历的方式，先删除左右子节点，然后再回头删除自己的就可以一直删了。。\n\n## [1305. 两棵二叉搜索树中的所有元素](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)\n\n给你 `root1` 和 `root2` 这两棵二叉搜索树。\n\n请你返回一个列表，其中包含 **两棵树** 中的所有整数并按 **升序** 排序。.\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/01/31/Hy3MEwa4sRO6jUq.png)\n\n```java\n输入：root1 = [2,1,4], root2 = [1,0,3]\n输出：[0,1,1,2,3,4]\n```\n\n**示例 2：**\n\n```java\n输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]\n输出：[-10,0,0,1,2,5,7,10]\n```\n\n\n**示例 3：**\n\n```java\n输入：root1 = [], root2 = [5,1,7,0,2]\n输出：[0,1,2,5,7]\n```\n\n\n**示例 4：**\n\n```java\n输入：root1 = [0,-10,10], root2 = []\n输出：[-10,0,10]\n```\n\n**解法一**\n\n某次周赛的题，大水题，白板回忆写出了中序的非递归haha，感觉忘不了了\n\n```java\npublic List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n    //return megerList(inorder(root1),0,inorder(root2),0);\n    return megerList(inorder(root1),inorder(root2));\n}\n\npublic List<Integer> inorder(TreeNode root){\n    List<Integer> res=new ArrayList<>();\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    while(!stack.isEmpty() || cur!=null){\n        while(cur!=null){\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        res.add(cur.val);\n        cur=cur.right;\n    }\n    return res;\n}\n\npublic List<Integer> megerList(List<Integer> list1,List<Integer> list2){\n    List<Integer> res=new ArrayList<>();\n    int index1=0,index2=0;\n    while(index1<list1.size() && index2<list2.size()){\n        res.add(list1.get(index1)<list2.get(index2)?list1.get(index1++):list2.get(index2++));\n    }\n    while(index1<list1.size()){\n        res.add(list1.get(index1++));\n    }\n    while(index2<list2.size()){\n        res.add(list2.get(index2++));\n    }\n    return res;\n}\n\n\n//递归的TLE了 42/48,不停的创建list太耗时了\npublic List<Integer> megerList(List<Integer> list1,int index1,List<Integer> list2,int index2){\n    List<Integer> res=new ArrayList<>();\n    if (index1==list1.size()) {\n        for (int i=index2;i<list2.size();i++) {\n            res.add(list2.get(i));\n        }\n        return res;\n    }\n    if (index2==list2.size()) {\n        for (int i=index1;i<list1.size();i++) {\n            res.add(list1.get(i));\n        }\n        return res;\n    }\n    if (list1.get(index1)<list2.get(index2)) {\n        res.add(list1.get(index1));\n        res.addAll(megerList(list1,index1+1,list2,index2));\n    }else{\n        res.add(list2.get(index2));\n        res.addAll(megerList(list1,index1,list2,index2+1));\n    }\n    return res;\n}\n```\n\n## [1339. 分裂二叉树的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/)\n\n给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。\n\n由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/02/HT93vAj7gcXwY8U.png)\n\n```java\n输入：root = [1,2,3,4,5,6]\n输出：110\n解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/02/02/Fit7Xl2jkzCZyhV.png)\n\n```java\n输入：root = [1,null,2,3,4,null,null,5,6]\n输出：90\n解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）\n```\n\n**解法一**\n\n174周赛的第三题，当时比赛TLE了。。写了个很蠢的算法\n\n```java\nprivate long mod=1000000007;\n\npublic int maxProduct(TreeNode root) {\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode cur=root;\n    long sumAll=sum(root);\n    while(!stack.isEmpty() || cur!=null){\n        TreeNode temp=null;\n        long s=0L;\n        while(cur!=null){\n            temp=cur.left;\n            cur.left=null;\n            long r=sum(root);\n            s=r*(sumAll-r);\n            max=Math.max(s,max);\n            cur.left=temp;\n            stack.add(cur);\n            cur=cur.left;\n        }\n        cur=stack.pop();\n        temp=cur.right;\n        cur.right=null;\n        long r=sum(root);\n        s=r*(sumAll-r);\n        max=Math.max(s,max);\n        cur.right=temp;\n        cur=cur.right;\n    }\n    return (int)(max%mod);\n}\n\nprivate long max=-1;\n\npublic long sum(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    return root.val+sum(root.left)+sum(root.right);\n}\n```\n\n我居然真的去删除节点去了。。。导致后面都没办法对sum做记忆化，太菜了啊\n\n**解法二**\n\n能AC但是效率感人\n\n```java\nprivate long mod=1000000007;\n\nprivate long sumAll=0;\n\nprivate long max=-1;\n\npublic int maxProduct(TreeNode root) {\n    sumAll=sum(root);\n    dfs(root);\n    return (int)(max%mod);\n}\n\npublic void dfs(TreeNode root){\n    if (root==null) {\n        return;\n    }\n    long temp=sum(root);\n    max=Math.max(max,temp*(sumAll-temp));\n    dfs(root.left);\n    dfs(root.right);\n}\n\nprivate HashMap<String,Long> cache=new HashMap<>();\n\npublic long sum(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    if (cache.containsKey(root.toString())) {\n        return cache.get(root.toString());\n    }\n    cache.put(root.toString(),root.val+sum(root.left)+sum(root.right));\n    return cache.get(root.toString());\n}\n```\n\n**解法三**\n\n标准`O(N)`的解法\n\n```java\nprivate long mod=1000000007;    \n\nList<Long> sum=new ArrayList<>();\n\n//标准解法\npublic int maxProduct(TreeNode root) {\n    long max=-1;\n    long sumAll=dfs(root);\n    for (Long s:sum) {\n        max=Math.max(max,s*(sumAll-s));    \n    }\n    return (int)(max%mod);\n}\n\npublic long dfs(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    sum.add(root.val+dfs(root.left)+dfs(root.right));\n    return sum.get(sum.size()-1);\n}\n```\n\n在dfs的过程中将子树的sum存起来，然后直接遍历list，求 `max(s*(sumAll-s))`就ok\n\n> 这里最开始被大数据也卡了一会儿，不知道啥时候取模，其实这里题目没有那么难，相乘的结果并不会溢出Long，如果要是溢出Long的话可能就要用什么带模快速乘了\n\n## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n**示例:** \n\n```java\n你可以将以下二叉树：\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\n序列化为 \"[1,2,3,null,null,4,5]\"\n```\n\n**提示:** 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n**说明:** 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。\n\n**解法一**\n\n层序遍历非递归的方式\n\n```java\n//层序遍历的方式\npublic String serialize(TreeNode root) {\n    if (root==null) {\n        return \"\";\n    }\n    //BFS\n    StringBuilder sb=new StringBuilder();\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        TreeNode cur=queue.poll();\n        if (cur!=null) {\n            sb.append(cur.val+\",\");\n            queue.add(cur.left);\n            queue.add(cur.right);\n        }else{\n            sb.append(\"null,\"); //会多很多null,不过影响不大\n        }\n    }\n    return sb.toString();\n}\n\n//按照题目意思写代码就ok\npublic TreeNode deserialize(String data) {\n    if (\"\".equals(data)) {\n        return null;\n    }\n    String[] treeData=data.split(\",\");\n    int index=0;\n    TreeNode root=node(treeData[index]);\n    Queue<TreeNode> queue=new LinkedList<>();\n    queue.add(root);\n    while(!queue.isEmpty()){\n        TreeNode cur=queue.poll();\n        cur.left=node(treeData[++index]);\n        if (cur.left!=null) {\n            queue.add(cur.left);\n        }\n        cur.right=node(treeData[++index]);\n        if (cur.right!=null) {\n            queue.add(cur.right);\n        }\n    }\n    return root;\n}\n\npublic TreeNode node(String str){\n    if (!\"null\".equals(str)) {\n        return new TreeNode(Integer.valueOf(str));\n    }\n    return null;\n}\n```\n\n**解法二**\n\n前序遍历递归方式，我们将序列化的结果存在一个`queue`中，然后从头开始取，因为是前序遍历，所以整体结构肯定是`【root,root.left,root.right】` \n\n反序列化关键就是如何区分左右子树，仅仅依靠一个前序遍历是无法重建二叉树的，所以我们可以做一些小手段，在序列化节点为空的时候加入`null`字符，这样左右节点就会被连续的两个`[null,null]`分隔开，方便重建\n\n> eg.  示例一：  1,2,null,null,3,4,null,null,5,null,null\n\n```java\npublic TreeNode node(String str){\n    if (!\"null\".equals(str)) {\n        return new TreeNode(Integer.valueOf(str));\n    }\n    return null;\n}\n\npublic String serialize(TreeNode root) {\n    if (root==null) {\n        return \"null\";\n    }\n    return root.val+\",\"+serialize(root.left)+\",\"+serialize(root.right);\n}\n\npublic TreeNode deserialize(String data) {\n    if (\"\".equals(data)) {\n        return null;\n    }\n    String[] dataTree=data.split(\",\");\n    Queue<String> queue=new LinkedList<>(Arrays.asList(dataTree));\n    return deserialize(queue);\n}\n\npublic TreeNode deserialize(Queue<String> queue){\n    String val=queue.poll();\n    if (\"null\".equals(val)) {\n        return null;\n    }\n    TreeNode root=node(val);\n    root.left=deserialize(queue);\n    root.right=deserialize(queue);\n    return root;\n}\n```\n**解法三**\n\n补充一个go的写法，和解法二的思路是一样的\n```go\ntype Codec struct {\n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {\n        return \"nil\"\n    }\n    return strconv.Itoa(root.Val) + \",\" + this.serialize(root.Left) + \",\" + this.serialize(root.Right)\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {\n    queue := strings.Split(data, \",\")\n    return this.des(&queue)\n}\n\nfunc (this *Codec) des(queue *[]string) *TreeNode {\n    if len(*queue) == 0 {\n        return nil\n    }\n    cur := (*queue)[0]\n    *queue = (*queue)[1:]\n    if cur == \"nil\" {\n        return nil\n    }\n    val, _ := strconv.Atoi(cur)\n    root := &TreeNode{Val: val}\n    root.Left = this.des(queue)\n    root.Right = this.des(queue)\n    return root\n}\n```\n## [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)\n序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。\n\n设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。\n\n编码的字符串应尽可能紧凑。\n\n**注意：** 不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。\n\n**解法一**\n\n题目说 `编码的字符串应尽可能紧凑`，所以直接把上面297的搬过来其实不太好，因为会有很多null字符，并且也没有用到题目二`bst`的条件，`bst`只需要知道一个前序或者后序就可以还原整棵树，题目就变成了根据`前序/后序`和`中序`还原二叉树\n\n`golang`新手，用`golang`写了一发，感觉写复杂了（官方解法中还有更加激进的压缩编码的方式，感觉有点偏了）\n\n```go\ntype Codec struct {\n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {\n        return \"\"\n    }\n    var queue []string\n    var dfs func(root *TreeNode)\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        queue = append(queue, strconv.Itoa(root.Val))\n        dfs(root.Left)\n        dfs(root.Right)\n    }\n    dfs(root)\n    return strings.Join(queue, \",\")\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {\n    if data == \"\" {\n        return nil\n    }\n    //fmt.Println(data)\n    queue := strings.Split(data, \",\")\n    inOrder := make([]int, len(queue))\n    for i, v := range queue {\n        inOrder[i], _ = strconv.Atoi(v)\n    }\n    preOrder := make([]int, len(inOrder))\n    copy(preOrder, inOrder)\n    sort.Ints(inOrder)\n    var dfs func(preOrder, inOrder []int) *TreeNode\n    dfs = func(preOrder, inOrder []int) *TreeNode {\n        if len(inOrder) == 0 {\n            return nil\n        }\n        root := &TreeNode{Val: preOrder[0]}\n        rootIdx := 0\n        for i, v := range inOrder {\n            if v == preOrder[0] {\n                rootIdx = i\n                break\n            }\n        }\n        root.Left = dfs(preOrder[1:rootIdx+1], inOrder[:rootIdx])\n        root.Right = dfs(preOrder[rootIdx+1:], inOrder[rootIdx+1:])\n        return root\n    }\n    return dfs(preOrder, inOrder)\n}\n```\n\n\n## [面试题33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n\n参考以下这颗二叉搜索树：\n\n```java\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n```\n**示例 1：**\n\n```java\n输入: [1,6,3,2,5]\n输出: false\n```\n\n**示例 2：**\n\n```java\n输入: [1,3,2,6,5]\n输出: true\n```\n\n**提示：**\n\n1. `数组长度 <= 1000`\n\n**解法一**\n\n核心在于意识到最后一个节点是根节点\n\n```java\npublic boolean verifyPostorder(int[] postorder) {\n    if(postorder==null || postorder.length<=0) return true;\n    return verify(postorder,0,postorder.length-1);\n}\n\npublic boolean verify(int[] postorder,int left,int right){\n    if(left>=right) return true;\n    int root=postorder[right];\n    //WA点,这里要设置成left-1防止没有左子树的情况,比如5 4 3 2 1\n    //这样可以跳过第二个循环并且不用递归验证左子树\n    int index=left-1;\n    for(int i=right-1;i>=left;i--){ //从后往前找第一个小于root\n        if(postorder[i]<root){\n            index=i; //找到第一个小于root的,作为左子树的根\n            break;\n        }\n    }\n    //判断左子树是否都是小于root的\n    for(int i=index;i>=left;i--){\n        if(postorder[i]>root){\n            return false;\n        }\n    }\n    //递归验证左右子树\n    return verify(postorder,left,index) && verify(postorder,index+1,right-1);\n}\n```\n这题WA了3发，前两发是代码逻辑的问题，想简化代码，结果把自己带坑里面去了，最后一次是因为一个变量设置的问题，代码中已经注释\n\n**UPDATE: 2020.7.14**\n\n重写了下，这样写就不会有奇怪的WA点了，还是要多注意细节和边界\n```golang\nfunc verifyPostorder(post []int) bool {\n    return dfs(post, 0, len(post)-1)\n}\n\nfunc dfs(post[] int, left int, right int) bool {\n    if left>=right{\n        return true\n    }\n    var p = right-1\n    for p >= left && post[p] > post[right]{\n        p--\n    }\n    for i := p; i >= left; i--{\n        if post[i] > post[right]{\n            return false\n        }\n    }\n    return dfs(post, left, p) && dfs(post, p+1,right-1)\n}\n```\n\n**解法二**\n\n单调栈的解法，放在[单调栈专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/#%E9%9D%A2%E8%AF%95%E9%A2%9833-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97)中\n\n## [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)\n\n给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：\n\n1. 二叉树的根是数组中的最大元素。\n2. 左子树是通过数组中最大值左边部分构造出的最大二叉树。\n3. 右子树是通过数组中最大值右边部分构造出的最大二叉树。\n\n通过给定的数组构建最大二叉树，并且输出这个树的根节点。\n\n**示例 ：**\n\n```java\n输入：[3,2,1,6,0,5]\n输出：返回下面这棵树的根节点：\n\t  6\n\t/   \\\n   3     5\n    \\    / \n     2  0   \n       \\\n        1\n```\n\n**提示：**\n\n1. 给定的数组的大小在 [1, 1000] 之间。\n\n**解法一**\n\n```java\n//不做预处理,直接搜索2ms,我这个50ms+.....懒得改的就当练手了\npublic TreeNode constructMaximumBinaryTree(int[] nums) {\n    int n=nums.length;\n    int[][] max=new int[n][n];\n    for(int i=0;i<n;i++){\n        max[i][i]=i;\n        for(int j=i+1;j<n;j++){\n            max[i][j]=nums[j]>nums[max[i][j-1]]?j:max[i][j-1];\n        }\n    }\n    return dfs(nums,0,n-1,max);\n}\n\npublic TreeNode dfs(int[] nums,int left,int right,int[][] max){\n    if(left>right) return null;\n    int maxIdx=max[left][right];\n    TreeNode root=new TreeNode(nums[maxIdx]);\n    root.left=dfs(nums,left,maxIdx-1,max);\n    root.right=dfs(nums,maxIdx+1,right,max);\n    return root;\n}\n```\n\n> 慢的主要原因是构建这个树的话大概只会查询logN次（树高度）最大值，而每层查询的复杂度和为N，所以整体的复杂度其实只要O(NlogN)，除非数组完全有序，这样每次分割都及其不均匀，数的高度为N时间复杂度才会到N^2，而我这个就直接是N^2了hhhhh，太菜了，预处理的思想是好的，但是还是要看具体的题目，这里其实很多的区间值都用不上（除非搞线段树🤣\n\n**解法二**\n\n这题也可以用单调栈做，明天写，这题还有个2，明天一起做了\n\n## [998. 最大二叉树 II](https://leetcode-cn.com/problems/maximum-binary-tree-ii/)\n\n题目描述很辣鸡，简单来说就是在`最大二叉树A`的右边插入一个val，仍然是最大二叉树\n\n**解法一**\n\n```java\npublic TreeNode insertIntoMaxTree(TreeNode root, int val) {\n    if(root==null){\n        return new TreeNode(val);\n    }\n    if(root.val>val){\n        root.right=insertIntoMaxTree(root.right,val);    \n        return root;\n    }\n    TreeNode newRoot=new TreeNode(val);\n    newRoot.left=root;\n    return newRoot;\n}\n```\n## [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)\n\n给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。\n\n两棵树重复是指它们具有相同的结构以及相同的结点值。\n\n**示例 1：**\n\n```java\n        1\n       / \\\n      2   3\n     /   / \\\n    4   2   4\n       /\n      4\n```\n\n下面是两个重复的子树：\n\n```java\n      2\n     /\n    4\n```\n\n和\n\n```java\n    4\n```\n\n因此，你需要以列表的形式返回上述重复子树的根结点。\n\n**解法一**\n\n做了忘了加上了，序列化子树，用哈希表判重就行了\n\n```java\nHashMap<String,Integer> map=new HashMap<>();\n\nList<TreeNode> res=new ArrayList<>();\n\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n    dfs(root);\n    return res;\n}\n\npublic String dfs(TreeNode root){\n    if(root==null){\n        //return \"#null\";\n        return \"null\";\n    }\n    //String key=\"#\"+root.val+dfs(root.left)+dfs(root.right);\n    String key=root.val+dfs(root.left)+dfs(root.right);\n    int count=map.getOrDefault(key,0);\n    if(count==1){\n        res.add(root);\n    }\n    map.put(key,count+1);\n    return key;\n}\n```\n\n> 这题少了case，不加分隔符也能A，我以为会卡这个，试了下结果没卡，100积分到手 ==>  [issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/284) \n\n## [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)\n\n给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n\n**案例 1:**\n\n```java\n输入: \n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 9\n\n输出: True\n```\n\n**案例 2:**\n\n```java\n输入: \n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 28\n\n输出: False\n```\n\n**解法一**\n\n开始还想着在logN的解法，发现好像搞不了，而且这是个easy题，所以肯定就是直接中序+双指针了\n\n```go\nfunc findTarget(root *TreeNode, k int) bool {\n    var inorder []int\n    dfs(root, &inorder)\n    i, j := 0, len(inorder)-1\n    for i < j {\n        if inorder[i]+inorder[j] < k {\n            i++\n        } else if inorder[i]+inorder[j] > k {\n            j--\n        } else {\n            return true\n        }\n    }\n    return false\n}\n\nfunc dfs(root *TreeNode, inorder *[]int) {\n    if root == nil {\n        return\n    }\n    dfs(root.Left, inorder)\n    *inorder = append(*inorder, root.Val)\n    dfs(root.Right, inorder)\n}\n```\n\n## [872. 叶子相似的树](https://leetcode-cn.com/problems/leaf-similar-trees/)\n\n请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 。\n\n![YDcL28.png](https://s1.ax1x.com/2020/05/14/YDcL28.png)\n\n举个例子，如上图所示，给定一颗叶值序列为 `(6, 7, 4, 9, 8)` 的树。\n\n如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 *叶相似* 的。\n\n如果给定的两个头结点分别为 `root1` 和 `root2` 的树是叶相似的，则返回 `true`；否则返回 `false` 。\n\n**提示：**\n\n- 给定的两颗树可能会有 `1` 到 `200` 个结点。\n- 给定的两颗树上的值介于 `0` 到 `200` 之间。\n\n**解法一**\n\n换成`StringBuilder`可能会快一点\n\n```java\n//没啥好说的\npublic boolean leafSimilar(TreeNode root1, TreeNode root2) {\n    if(root1==null || root2==null) return false;\n    return dfs(root1).equals(dfs(root2));\n}\n\npublic String dfs(TreeNode root){\n    if(root==null){\n        return \"\";\n    }\n    if(root.left==null && root.right==null){\n        return \"#\"+root.val;\n    }\n    return dfs(root.left)+dfs(root.right);\n}\n```\n> 当时看到这题就着会不会又有case遗漏，比如不加分隔符什么的，结果看到github已经有人先手提交了\n\n## [5398. 统计二叉树中好节点的数目](https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/)\n\n给你一棵根为 `root` 的二叉树，请你返回二叉树中好节点的数目。\n\n「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。\n\n**示例 1：**\n\n![YREc7j.png](https://s1.ax1x.com/2020/05/17/YREc7j.png)\n\n```java\n输入：root = [3,1,4,3,null,1,5]\n输出：4\n解释：图中蓝色节点为好节点。\n根节点 (3) 永远是个好节点。\n节点 4 -> (3,4) 是路径中的最大值。\n节点 5 -> (3,4,5) 是路径中的最大值。\n节点 3 -> (3,1,3) 是路径中的最大值。\n```\n\n**示例 2：**\n\n![YREukR.png](https://s1.ax1x.com/2020/05/17/YREukR.png)\n\n```java\n输入：root = [3,3,null,4,2]\n输出：3\n解释：节点 2 -> (3, 3, 2) 不是好节点，因为 \"3\" 比它大。\n```\n\n**示例 3：**\n\n```java\n输入：root = [1]\n输出：1\n解释：根节点是好节点。\n```\n\n**提示：**\n\n- 二叉树中节点数目范围是 `[1, 10^5]` 。\n- 每个节点权值的范围是 `[-10^4, 10^4]` 。\n\n**解法一**\n\n26th双周赛的t3，水题\n\n```java\nint count=0;\n\npublic int goodNodes(TreeNode root) {\n    if(root==null) return 0;\n    dfs(root,root.val);\n    return count;\n}\n\npublic void dfs(TreeNode root,int max){\n    if(root==null){\n        return;\n    }\n    if(max<=root.val){\n        count++;\n        max=root.val;\n    }\n    dfs(root.left,max);\n    dfs(root.right,max);\n}\n```\n\n## [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)\n\n给定一个二叉搜索树，同时给定最小边界`L` 和最大边界 `R`。通过修剪二叉搜索树，使得所有节点的值在`[L, R]`中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。\n\n**示例 1:**\n\n```\n输入: \n    1\n   / \\\n  0   2\n\n  L = 1\n  R = 2\n\n输出: \n    1\n      \\\n       2\n```\n\n**示例 2:**\n\n```java\n输入: \n    3\n   / \\\n  0   4\n   \\\n    2\n   /\n  1\n\n  L = 1\n  R = 3\n\n输出: \n      3\n     / \n   2   \n  /\n 1\n```\n\n**解法一**\n\n没啥好说的，递归后序遍历就完事了，树的题还是挺套路的\n\n```java\npublic TreeNode trimBST(TreeNode root, int L, int R) {\n    if(root==null){\n        return root;\n    }\n    root.left=trimBST(root.left,L,R);\n    root.right=trimBST(root.right,L,R);\n    //root.val<L,左子树全部小于L\n    if(root.val<L){\n        return root.right;\n    }\n    if(root.val>R){\n        return root.left;\n    }\n    return root;\n}\n```\n## [814. 二叉树剪枝](https://leetcode-cn.com/problems/binary-tree-pruning/)\n\nDifficulty: **中等**\n\n\n给定二叉树根结点 `root` ，此外树的每个结点的值要么是 0，要么是 1。\n\n返回移除了所有不包含 1 的子树的原二叉树。\n\n( 节点 X 的子树为 X 本身，以及所有 X 的后代。)\n\n```golang\n示例1:\n输入: [1,null,0,0,1]\n输出: [1,null,0,null,1]\n\n解释: \n只有红色节点满足条件“所有不包含 1 的子树”。\n右图为返回的答案。\n```\n\n```golang\n示例2:\n输入: [1,0,1,0,0,0,1]\n输出: [1,null,1,null,1]\n\n```\n\n```golang\n示例3:\n输入: [1,1,0,1,1,0,1,0]\n输出: [1,1,0,1,1,null,1]\n\n```\n\n**说明:**\n\n*   给定的二叉树最多有 `100` 个节点。\n*   每个节点的值只会为 `0` 或 `1` 。\n\n**解法一**\n\n和上面差不多，感觉应该是是easy。。。\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc pruneTree(root *TreeNode) *TreeNode {\n    if root == nil{\n        return nil\n    }\n    root.Left = pruneTree(root.Left)\n    root.Right = pruneTree(root.Right)\n    if root.Left == nil && root.Right==nil && root.Val == 0{\n        return nil\n    }\n    return root\n}\n```\n\n## [965. 单值二叉树](https://leetcode-cn.com/problems/univalued-binary-tree/)\n\n题目就不copy了，二叉树只有一个值，水题\n\n**解法一**\n\n```java\npublic boolean isUnivalTree(TreeNode root) {\n    return dfs(root,root.val);\n}\n\npublic boolean dfs(TreeNode root,int val){\n    if(root==null) return true;\n    return root.val==val && dfs(root.left,val) && dfs(root.right,val);\n}\n```\n\n## [1145. 二叉树着色游戏](https://leetcode-cn.com/problems/binary-tree-coloring-game/)\n\n有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 `root`，树上总共有 `n` 个节点，且 `n` 为奇数，其中每个节点上的值从 `1` 到 `n` 各不相同。\n\n游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，\n\n「一号」玩家从 `[1, n]` 中取一个值 `x`（`1 <= x <= n`）；\n\n「二号」玩家也从 `[1, n]` 中取一个值 `y`（`1 <= y <= n`）且 `y != x`。\n\n「一号」玩家给值为 `x` 的节点染上红色，而「二号」玩家给值为 `y` 的节点染上蓝色。\n\n之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 **未着色** 的邻节点（即左右子节点、或父节点）进行染色。\n\n如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。\n\n若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。\n\n现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 `y` 值可以确保你赢得这场游戏，则返回 `true`；若无法获胜，就请返回 `false`。\n\n**示例：**\n\n![tpXUW6.png](https://s1.ax1x.com/2020/05/25/tpXUW6.png)\n\n```java\n输入：root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\n输出：True\n解释：第二个玩家可以选择值为 2 的节点。\n```\n\n**提示：**\n\n- 二叉树的根节点为 `root`，树上由 `n` 个节点，节点上的值从 `1` 到 `n` 各不相同。\n- `n` 为奇数。\n- `1 <= x <= n <= 100`\n\n**解法一**\n\n第一个选手选择了一个节点之后，将二叉树实际上划分为了3个区域，左孩子区域，右孩子区域，还有父节点所在区域，三个区域以x为界限，没有交集，第二个选手需要在三个区域中选取一个区域，使自己能赢，很明显我们肯定要选最大的那个区域，所以我们只需要判断最大的区域是否比剩下其他部分和都要大就行了\n\n```java\nint max=0;\n\npublic boolean btreeGameWinningMove(TreeNode root, int n, int x) {\n    dfs(root,x,n);\n    return max>n-max;\n}\n\npublic int dfs(TreeNode root,int x,int n){\n    if(root==null) return 0;\n    int left=dfs(root.left,x,n);\n    int right=dfs(root.right,x,n);\n    if(root.val==x){\n        max=Math.max(left,max);\n        max=Math.max(right,max);\n        max=Math.max(n-left-right-1,max);\n    }\n    return left+right+1;\n}\n```\n\n## [993. 二叉树的堂兄弟节点](https://leetcode-cn.com/problems/cousins-in-binary-tree/)\n\n在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。\n\n如果二叉树的两个节点深度相同，但**父节点不同**，则它们是一对*堂兄弟节点*。\n\n我们给出了具有唯一值的二叉树的根节点 `root`，以及树中两个不同节点的值 `x` 和 `y`。\n\n只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true`。否则，返回 `false`。\n\n**示例 1：**\n\n![tsO8yR.png](https://s1.ax1x.com/2020/06/05/tsO8yR.png)\n\n```java\n输入：root = [1,2,3,4], x = 4, y = 3\n输出：false\n```\n\n**示例 2：**\n\n![tsOYex.png](https://s1.ax1x.com/2020/06/05/tsOYex.png)\n\n```java\n输入：root = [1,2,3,null,4,null,5], x = 5, y = 4\n输出：true\n```\n\n**示例 3：**\n\n![tsOaFO.png](https://s1.ax1x.com/2020/06/05/tsOaFO.png)\n\n```java\n输入：root = [1,2,3,null,4], x = 2, y = 3\n输出：false\n```\n\n**提示：**\n\n1. 二叉树的节点数介于 `2` 到 `100` 之间。\n2. 每个节点的值都是唯一的、范围为 `1` 到 `100` 的整数。\n\n**解法一**\n\n二叉树水题（3天没刷新题了，再不刷几道实在是说不过其了，刷题还是要保持手感啊）\n\n```go\nfunc isCousins(root *TreeNode, x int, y int) bool {\n    var depX = -1\n    var pX *TreeNode\n    var depY = -1\n    var pY *TreeNode\n    var dfs func(root, parent *TreeNode, x, y int, depth int)\n    dfs = func(root, parent *TreeNode, x, y int, depth int) {\n        if root == nil { //按题目说的这里其实不需要\n            return\n        }\n        if root.Val == x {\n            depX = depth\n            pX = parent\n            //结束该子树的搜索，加快速度，下面即使有Y也肯定不是X的堂兄弟\n            return\n        }\n        if root.Val == y {\n            depY = depth\n            pY = parent\n            //同上\n            return\n        }\n        dfs(root.Left, root, x, y, depth+1)\n        dfs(root.Right, root, x, y, depth+1)\n    }\n    dfs(root, nil, x, y, 0)\n    return pX != pY && depX == depY\n}\n```\n\n有一个小的优化点还是挺有意思的，就是return的地方，一开始没考虑这么多，AC了之后感觉不对，是不是LC又少CASE了，结果仔细一想发现这里是个优化点😁\n\n## [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)\n\n给定整数 `n` 和 `k`，找到 `1` 到 `n` 中字典序第 `k` 小的数字。\n\n注意：1 ≤ k ≤ n ≤ 1e9。\n\n**示例 :**\n\n```java\n输入:\nn: 13   k: 2\n\n输出:\n10\n\n解释:\n字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n```\n**解法一**\n\n一开始看了评论区说了10叉树,然后我就顺着这个思路去想了,然后就直接去前序遍历了,然后就T了,这里看下数据范围就知道肯定是过不了的\n```java\n//TLE\npublic int findKthNumber(int n, int k) {\n    for (int i=1;i<=9;i++) {\n        dfs(i,n,k);\n    }\n    return res;\n}\n\nint idx=0,res=-1;\n\npublic void dfs(int cur,int n,int k){\n    if(res!=-1) return;\n    if(cur>n) return;\n    idx++;\n    if(k==idx){\n        res=cur;\n        return;\n    }\n    for (int i=0;i<=9;i++) {\n        dfs(cur*10+i,n,k);\n    }\n}\n```\n**解法二**\n\n直接遍历肯定是行不通,那么就只能想办法跳过一些节点,这里我们就可以通过计算每个节点的子节点的个数来判断第k个是不是在该节点下,而子节点的个数就可以用`Min(n+1,next*10)-cur`计算得到,`next`是和cur相邻的节点,`n`是最大值,画个图就懂了\n![mark](http://static.imlgw.top/blog/20200614/3WPecCGnzxQl.png?imageslim)\n```golang\n//UPDATE: 2020.7.29 之前的代码细节有的不好理解，重写了一版\n//正解\nfunc findKthNumber(n int, k int) int {\n    //k和count都是从1开始\n    var cur = 1\n    for k > 1 {\n        count := getChild(cur, n)\n        if count < k { //不在该节点下，切换成兄弟节点\n            cur++ \n            k-=count\n        } else { //在该节点下，切换成子节点\n            cur *= 10\n            k--\n        }\n    }\n    return cur\n}\n\n//当前节点下有多少个子节点，也就是以cur开头的有多少个（包括cur）\nfunc getChild(cur int, n int) int {\n    var count = 0\n    var next = cur+1\n    for cur <= n {\n        count += Min(n+1, next) - cur\n        cur *= 10\n        next *= 10\n    }\n    return count\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n\n## [386. 字典序排数](https://leetcode-cn.com/problems/lexicographical-numbers/)\n给定一个整数 n, 返回从 1 到 n 的字典顺序。\n\n例如，\n\n给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。\n\n请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。\n\n**解法一**\n\n先做的上面那一题,再做这一题就简单多了,前面tle的方法就是这里的正解,十叉树的前序遍历\n```java\nList<Integer> res=new ArrayList<>();\n\npublic List<Integer> lexicalOrder(int n) {\n    for(int i=1;i<=9;i++){\n        dfs(i,n);   \n    }\n    return res;\n}\n\npublic void dfs(int cur,int n){\n    if(cur>n) return;\n    res.add(cur);\n    for(int i=0;i<=9;i++){\n        dfs(cur*10+i,n);   \n    }\n}\n```\n## [1028. 从先序遍历还原二叉树](https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/)\n\n我们从二叉树的根节点 root 开始进行深度优先搜索。\n\n在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。\n\n如果节点只有一个子节点，那么保证该子节点为左子节点。\n\n给出遍历输出 S，还原树并返回其根节点 root。\n\n**示例 1：**\n```java\n输入：\"1-2--3--4-5--6--7\"\n输出：[1,2,5,3,4,6,7]\n```\n**示例 2：**\n```java\n输入：\"1-2--3---4-5--6---7\"\n输出：[1,2,5,3,null,6,null,4,null,7]\n```\n**示例 3：**\n```java\n输入：\"1-401--349---90--88\"\n输出：[1,401,null,349,88,90]\n```\n**提示：**\n原始树中的节点数介于 1 和 1000 之间。\n每个节点的值介于 1 和 10 ^ 9 之间。\n\n**解法一**\n\n抄答案，第一天看了几分钟，一开始想写递归，直接看了答案，第二天还是没有完整的写出来，其实这题迭代会好理解很多，递归的看了下，有点不好理解，很trick\n```java\npublic TreeNode recoverFromPreorder(String S) {\n    //栈中存的是深度严格单调递增（步伐为1）的节点 0 1 2 3 4....\n    Deque<TreeNode> stack=new ArrayDeque(); \n    int i=0;\n    while(i<S.length()){\n        int depth=0;\n        while(i<S.length() && S.charAt(i)=='-') {\n            depth++;\n            i++;\n        }\n        int val=0;\n        while(i<S.length() && S.charAt(i)>='0' && S.charAt(i)<='9'){\n            val=val*10+S.charAt(i)-48;\n            i++;\n        }\n        TreeNode node=new TreeNode(val);\n        if(depth==stack.size()){ //栈的节点数量就是当前的深度\n            if(!stack.isEmpty()) stack.peek().left=node;\n        }else{\n            while(depth!=stack.size()){\n                stack.pop();\n            }\n            //depth==0的只有一个根节点，是不会走这个分支的，所以这里肯定不为空\n            stack.peek().right=node;\n        }\n        stack.push(node);\n    }\n    while(stack.size()!=1) stack.pop();\n    return stack.pop();\n}\n```\n\n## [897. 递增顺序查找树](https://leetcode-cn.com/problems/increasing-order-search-tree/)\n\n给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。\n\n**示例 ：**\n```java\n输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]\n\n       5\n      / \\\n    3    6\n   / \\    \\\n  2   4    8\n /        / \\ \n1        7   9\n\n输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n 1\n  \\\n   2\n    \\\n     3\n      \\\n       4\n        \\\n         5\n          \\\n           6\n            \\\n             7\n              \\\n               8\n                \\\n                 9  \n```\n \n**提示：**\n\n给定树中的结点数介于 1 和 100 之间。每个结点都有一个从 0 到 1000 范围内的唯一整数值。\n\n**解法一**\n\ngo中序遍历配合全局变量，没啥好说的（看评论区很多人直接new TreeNode感觉不太好吧，题目的意思不是在原树上改么？）\n```golang\nfunc increasingBST(root *TreeNode) *TreeNode {\n    var dfs func(root *TreeNode)\n    dummyNode:=&TreeNode{}\n    last:=dummyNode\n    dfs = func(root *TreeNode){\n        if root==nil{\n            return\n        }\n        dfs(root.Left)\n        root.Left=nil\n        last.Right=root\n        last = root\n        dfs(root.Right)\n    }\n    dfs(root)\n    return dummyNode.Right\n}\n```\n> 这题和[面试题 17.12. BiNode](https://leetcode-cn.com/problems/binode-lcci/)解法是一摸一样的，但是这个sb题的描述我是真没看懂，结合评论区和case才知道到底要干啥，看评论区好像都整的挺明白的，一度以为我理解能力出了问题\n\n## [979. 在二叉树中分配硬币](https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/)\n\nDifficulty: **中等**\n\n\n给定一个有 `N` 个结点的二叉树的根结点 `root`，树中的每个结点上都对应有 `node.val` 枚硬币，并且总共有 `N` 枚硬币。\n\n在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。\n\n返回使每个结点上只有一枚硬币所需的移动次数。\n\n**示例 1：**\n![UTOOLS1594052444483.png](https://upload.cc/i1/2020/07/07/w2G7JY.png)\n\n```go\n输入：[3,0,0]\n输出：2\n解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。\n```\n\n**示例 2：**\n\n![UTOOLS1594052495418.png](https://upload.cc/i1/2020/07/07/kPOvxa.png)\n\n```go\n输入：[0,3,0]\n输出：3\n解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。\n```\n\n**示例 3：**\n\n![UTOOLS1594052508155.png](https://upload.cc/i1/2020/07/07/j4YpZS.png)\n\n```go\n输入：[1,0,2]\n输出：2\n```\n\n**示例 4：**\n\n![UTOOLS1594052519453.png](https://upload.cc/i1/2020/07/07/DYZ6cE.png)\n\n```go\n输入：[1,0,0,null,3]\n输出：4\n```\n\n**提示：**\n\n1.  `1<= N <= 100`\n2.  `0 <= node.val <= N`\n\n\n**解法一**\n\n一开始直接想出来的做法，后面看了其他人的解法发现还不太一样😂，不过我还是感觉我的方法更好理解\n```golang\n//闭包的写法\nfunc distributeCoins(root *TreeNode) int {\n    var res = 0\n    var Abs = func(a int) int {\n        if a < 0 {\n            return -a\n        }\n        return a\n    }\n    //dfs返回树的节点数量 和 金币数量\n    var dfs func(*TreeNode) (int, int)\n    dfs = func(root *TreeNode) (int, int) {\n        if root == nil {\n            return 0, 0\n        }\n        lCount, lCoins := dfs(root.Left)\n        //其实两者的差值就是需要经过该节点中转的次数\n        //统计出所有节点的中转次数就是整体的转移次数\n        res += Abs(lCount - lCoins)\n        rCount, rCoins := dfs(root.Right)\n        res += Abs(rCount - rCoins)\n        return 1 + lCount + rCount, root.Val + lCoins + rCoins\n    }\n    dfs(root)\n    return res\n}\n```\n\n**解法二**\n\n其他人的做法，dfs返回节点的盈亏值（节点数和金币数的差值），盈亏值绝对值之和就是总体的转移次数（所以两种解法其实是一样的，只是计算的时间不一样，我的是函数返回后计算盈亏，而下面的解法是返回前计算盈亏，感觉我的更好理解😂）\n```golang\n//另一种做法\nfunc distributeCoins(root *TreeNode) int {\n    var res = 0\n    var Abs = func(a int) int {\n        if a < 0 {\n            return -a\n        }\n        return a\n    }\n    var dfs func(*TreeNode) int\n    dfs = func(root *TreeNode) int {\n        if root == nil {\n            return 0\n        }\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n        res += Abs(left) + Abs(right)\n        return root.Val + left + right - 1\n    }\n    dfs(root)\n    return res\n}\n```\n\n## [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)\n\nDifficulty: **困难**\n\n\n二叉搜索树中的两个节点被错误地交换。\n\n请在不改变其结构的情况下，恢复这棵树。\n\n**示例 1:**\n\n```go\n输入: [1,3,null,null,2]\n\n   1\n  /\n 3\n  \\\n   2\n\n输出: [3,1,null,null,2]\n\n   3\n  /\n 1\n  \\\n   2\n```\n\n**示例 2:**\n\n```go\n输入: [3,1,4,null,null,2]\n\n  3\n / \\\n1   4\n   /\n  2\n\n输出: [2,1,4,null,null,3]\n\n  2\n / \\\n1   4\n   /\n  3\n```\n\n**进阶:**\n\n*   使用 O(_n_) 空间复杂度的解法很容易实现。\n*   你能想出一个只使用常数空间的解决方案吗？\n\n\n**解法一**\n\n中序遍历，记录下位置不对的节点，最后交换他们的值就行了\n```golang\nfunc recoverTree(root *TreeNode) {\n    var node1 *TreeNode\n    var node2 *TreeNode\n    //这里犯了一个错误，一开始给pre赋值了一个root,导致节点记录错了\n    var pre *TreeNode\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        dfs(root.Left)\n        if pre != nil && root.Val < pre.Val {\n            if node1 == nil {\n                node1 = pre\n            }\n            node2 = root\n        }\n        pre = root\n        dfs(root.Right)\n    }\n    dfs(root)\n    node1.Val, node2.Val = node2.Val, node1.Val\n}\n```\n这种解法严格来说空间复杂度并不是O(1)，递归会有系统栈的开销，空间复杂度应该是O(h)，h是树的高度，真正的O(1)的做法应该是Morris遍历，这种解法就称得上hard了\n\n## [1302. 层数最深叶子节点的和](https://leetcode-cn.com/problems/deepest-leaves-sum/)\n\nDifficulty: **中等**\n\n\n给你一棵二叉树，请你返回层数最深的叶子节点的和。\n\n**示例：**\n\n![wmC0aT.png](https://s1.ax1x.com/2020/09/06/wmC0aT.png)\n\n```\n输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n输出：15\n```\n\n**提示：**\n\n*   树中节点数目在 `1` 到 `10^4` 之间。\n*   每个节点的值在 `1` 到 `100` 之间。\n\n\n**解法一**\n\nBFS没啥好说的，DFS的挺有意思\n```golang\nfunc deepestLeavesSum(root *TreeNode) int {\n    var dfs func(*TreeNode, int)\n    var maxDep = 0\n    var sum = 0\n    dfs = func(root *TreeNode, dep int) {\n        if root == nil {\n            return\n        }\n        if maxDep == dep {\n            sum += root.Val\n        }\n        if dep > maxDep {\n            sum = root.Val\n            maxDep = dep\n        }\n        dfs(root.Left, dep+1)\n        dfs(root.Right, dep+1)\n        \n    }\n    dfs(root, 0)\n    return sum\n}\n```\n\n## _树形DP(大概)_\n\n> 2020.5.10更新，在看了左神的书后，大概了解了树形DP，所谓的树形DP实际上就是把递推方程搬到了树结构上，按我的理解树形DP很大的特点就是最终的解可能存在于树上每个节点，像我下面的题有的暴力解用的就是双重递归，就是dfs遍历没个节点，然后再对每个节点递归求解，但是对根节点求解的时候，实际上其他的子节点都成了子问题，所以后面再对子节点求解的时候问题就重复了，所以就可以采用后序遍历，自底向上，先求左右节点的值再更新根节点，**下面的题其实我不知道到底是不是属于树形DP，可能太简单了，但是再我看来解法比较统一，很有套路所以整理到一起**，我查了下网上介绍的树形DP还是挺难的，后面有时间了解后再来记录\n\n## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n>  一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1\n\n**示例 1:**\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回 true 。\n\n**示例 2:**\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n```java\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n```\n\n\n返回 false 。\n\n**解法一**\n\n暴力法，结合上面的[二叉树最大深度](#104. 二叉树的最大深度)，**自顶向下**，求左右子树的高度差\n\n```java\n//top 2 bottom\npublic boolean isBalanced(TreeNode root) {\n    if (root==null) return true;\n    if (Math.abs(hight(root.left)-hight(root.right))>1) {\n        return false;\n    }\n    return isBalanced(root.left) && isBalanced(root.right);\n}\n\npublic int hight(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    return Math.max(hight(root.right),hight(root.left))+1;\n}\n```\n自顶向下，先判断根节点，然后判断左右子树，很明显。在判断左右子树的时候，会重复的遍历判断根节点的时候已经遍历过的节点，时间复杂度应该是`O(N^2)`\n\n**解法二**\n\n自底向上，利用一个实例变量保存结果，其实就是在上面的求heigh过程中将左右子树的高度先取出来直接比较，如果差距大于1就直接记录下结果false，但是其实这里还是可以优化下\n\n```java\nprivate boolean ans=true;\n\n//buttom 2 top\npublic boolean isBalanced(TreeNode root) {\n    if (root==null) return true;\n    hight(root);\n    return ans;\n}\n\npublic int hight(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    //递归分治，自底向上，在求高度的过程中计算左右高度差\n    int left=hight(root.left);\n    int right=hight(root.right);\n    if (Math.abs(left-right)>1) {\n        ans=false;\n    }\n    return Math.max(left,right)+1;\n}\n```\n自底向上，只需要遍历一遍二叉树就可以得到结果，时间复杂度`O(N)` \n\n**解法三**\n\n```java\npublic boolean isBalanced(TreeNode root) {\n    if (root==null) return true;\n    return hight(root)!=-1;\n}\n\npublic int hight(TreeNode root){\n    if (root==null) {\n        return 0;\n    }\n    int left=hight(root.left);\n    if (left==-1) {\n        return -1;\n    }\n    int right=hight(root.right);\n    if (right==-1) {\n        return -1;\n    }\n    return Math.abs(left-right)>1?-1:Math.max(left,right)+1;\n}\n```\n\n在不符合的时候一路`return -1` 节省后面的计算\n\n## [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)\n\n给定一个二叉树，计算整个树的坡度。\n\n一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。\n\n整个树的坡度就是其所有节点的坡度之和。\n\n**示例:**\n\n```java\n输入: \n         1\n       /   \\\n      2     3\n输出: 1\n解释: \n结点的坡度 2 : 0\n结点的坡度 3 : 0\n结点的坡度 1 : |2-3| = 1\n树的坡度 : 0 + 0 + 1 = 1\n```\n\n**注意:**\n\n1. 任何子树的结点的和不会超过32位整数的范围。\n2. 坡度的值不会超过32位整数的范围。. \n\n**解法一**\n\n很快写出来的解法，发现这题和上面的 **平衡二叉树** 有异曲同工之妙！\n\n```java\n//首先想到的解法\npublic int findTilt(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    return findTilt(root.left)+findTilt(root.right)+Math.abs(childSum(root.left)-childSum(root.right));\n}\n\npublic int childSum(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    return childSum(root.left)+childSum(root.right)+root.val;\n}\n```\n嵌套递归，相当暴力\n\n**解法二**\n\n上面的做法确实有点可惜，其实在计算childSum的时候就可以字节把坡度算出来然后累加就是整体的坡度\n\n```java\nint tilt=0;\n\n//结果发现上面的做法傻逼了。。。其实我知道是不对的,但是不知道咋改,不过写了个嵌套递归也还行hahaha\npublic int findTilt(TreeNode root) {\n    childSum(root);\n    return tilt;\n}\n\npublic int childSum(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    int left=childSum(root.left);\n    int right=childSum(root.right);\n    tilt+=Math.abs(left-right);\n    return left+right+root.val;\n}\n```\n\n## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)\n\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。\n\n**示例 :**\n给定二叉树\n\n```java\n      1\n     / \\\n    2   3\n   / \\     \n  4   5    \n```\n返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n**注意：**两结点之间的路径长度是以它们之间边的数目表示\n\n**解法一**\n\n树的题目做多了，发现其实也就几种题型，都很熟悉，这题就和上面的 [二叉树的坡度]() ，[平衡二叉树]() 很类似，这题需要注意**直径不一定过根节点**\n\n```java\nint max=Integer.MIN_VALUE;\n\npublic int diameterOfBinaryTree(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    hight(root);\n    return max;\n}\n\npublic int hight(TreeNode node){\n    if (node==null) {\n        return 0;\n    }\n    int left=hight(node.left);\n    int right=hight(node.right);\n    max=Math.max(left+right,max);\n    return Math.max(left,right)+1;\n}\n```\n\n**解法二**\n\n和之前一样，先写了个暴力的嵌套递归😂，代码确实简介，难道这就是暴力美学么，i了\n\n```java\npublic int diameterOfBinaryTree(TreeNode root) {\n    return root==null?0:Math.max(hight(root.left)+hight(root.right),Math.max(diameterOfBinaryTree(root.right),diameterOfBinaryTree(root.left)));\n}\n\npublic int hight(TreeNode node){\n    return node==null?0:Math.max(hight(node.left),hight(node.right))+1;\n}\n```\n\n## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)\n\n给定一个**非空**二叉树，返回其最大路径和。\n\n本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。\n\n**示例 1:**\n\n```java\n输入: [1,2,3]\n   1\n  / \\\n 2   3\n输出: 6\n```\n\n**示例 2:**\n\n```java\n输入: [-10,9,20,null,null,15,7]\n   -10\n   / \\\n  9  20\n    /  \\\n   15   7\n\n输出: 42\n```\n\n**错误解法**\n\n先上一个错误答案，过了 `71/93` 个case（lc的case好少）\n\n```java\npublic int maxPathSum(TreeNode root) {\n    if (root==null) {\n        return Integer.MIN_VALUE;\n    }\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int res=helper(root);\n    return Math.max(res,Math.max(maxPathSum(root.left),maxPathSum(root.right)));\n}\n\n//以当前节点为根的最大路径和\npublic int helper(TreeNode root){\n    if(root==null) return Integer.MIN_VALUE;;\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int left=helper(root.left);\n    int right=helper(root.right);\n    return root.val+(left>0?left:0)+(right>0?right:0);\n}\n```\n我一开始的想法是按照根节点来讨论的，每个节点的最大值就是 左右子树的最大路径和（大于0）加上当前节点的值，改了半天WA了几发后发现是有问题的\n\n```java\n     1 \n   /   \\\n  2     3\n / \\   / \\\n7   9  5  6\n```\n\n比如这样的，2为根的最长路径是1，2，9但是这个在1为根的节点中是不合法的，所以我们需要的只有单边的路径和，如上图的树，我们需要的就是 `2->9` 这条路径，所以我们需要再添加一个求最长路径的函数\n\n**解法二**\n\n可AC，但是效率较低\n\n```java\npublic int maxPathSum(TreeNode root) {\n    if (root==null) {\n        return Integer.MIN_VALUE;\n    }\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int res=helper(root);\n    return Math.max(res,Math.max(maxPathSum(root.left),maxPathSum(root.right)));\n}\n\n//以当前节点为根的最大路径和(双边)\npublic int helper(TreeNode root){\n    if(root==null) return Integer.MIN_VALUE;\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    int left=dfs(root.left);\n    int right=dfs(root.right);\n    return root.val+(left>0?left:0)+(right>0?right:0);\n}\n\n//root为起始节点的最大路径和(单边)\n//这里可以cache一下\n//cache 前 219ms\n//cache 后 30ms\n\nprivate  HashMap<String,Integer> cache=new HashMap<>();\n\npublic int dfs(TreeNode root){\n    if (root==null) {\n        return Integer.MIN_VALUE;\n    }\n    if (cache.containsKey(root.toString())) {\n        return cache.get(root.toString());\n    }\n    int left=dfs(root.left);\n    int right=dfs(root.right);\n    int max=Math.max(left,right);\n    cache.put(root.toString(),root.val+(max>0?max:0));\n    return root.val+(max>0?max:0);\n}\n```\n**解法三**\n\n这个解法其实就是将我前面的代码逻辑简化了，核心的思路还是一样的\n\n```java\nprivate int res=Integer.MIN_VALUE;\n\npublic int maxPathSum(TreeNode root) {\n    helper(root);\n    return res;\n}\n\n//返回以当前节点为*起点*的最大路径和(单边,左右子树中选最大的一个)\npublic int helper(TreeNode root){\n    if(root==null) return 0;\n    int left=Math.max(helper(root.left),0);\n    int right=Math.max(helper(root.right),0);\n    res=Math.max(res,root.val+left+right); //在这里记录最大值\n    return root.val+Math.max(left,right); //返回的实际上是我上面dfs的结果\n}\n```\n\n在递归函数中用全局变量记录最大值，最后返回的却是**单边**的最大值，也就是我上面写的dfs函数返回的值，可以说是相当巧妙了，除此外对递归的出口也进行了简化\n\n**Update: 2020.6.21**\n\n用go重写一下，最近很喜欢写这种闭包的结构，感觉比较简洁\n```golang\nfunc maxPathSum(root *TreeNode) int {\n    res:=-1<<31\n    var Max =func(a,b int) int {\n        if a>b{\n            return a   \n        }\n        return b\n    }\n    //以root开头最大单侧路径\n    var dfs func(root *TreeNode) int\n    dfs = func(root *TreeNode) int {\n        if root==nil{\n            return -1<<31 //返回的小于0就行\n        }\n        left:=Max(0,dfs(root.Left))\n        right:=Max(0,dfs(root.Right))\n        res=Max(res,left+right+root.Val)\n        return root.Val+Max(left,right)\n    }\n    dfs(root)\n    return res\n}\n```\n\n## [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)\n\n给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。\n\n**注意**：两个节点之间的路径长度由它们之间的边数表示。\n\n**示例 1:**\n\n输入:\n\n```java\n              5\n             / \\\n            4   5\n           / \\   \\\n          1   1   5\n```\n\n输出:\n\n```java\n2\n```\n\n**示例 2:**\n\n输入:\n\n```java\n              1\n             / \\\n            4   5\n           / \\   \\\n          4   4   5\n```\n\n输出:\n\n```java\n2\n```\n\n**注意:** 给定的二叉树不超过10000个结点。 树的高度不超过1000。\n\n**错误解法**\n\n其实写了一会儿就意识到和上面的[124.二叉树的最大路径和](#124-二叉树的最大路径和)，[543.二叉树的直径](#543-二叉树的直径)是一样的思路，但是自己还是没写好，递归函数的写着写着就写变了，脱离了最开始的定义\n\n```java\n//错误解法，其实整体思路是对的，但是细节没处理好\npublic int longestUnivaluePath(TreeNode root) {\n    dfs(root);\n    return res;\n}\n\nint res=0;\n\npublic int dfs(TreeNode root){\n    if(root==null){\n        return 0;\n    }\n    int leftMax=dfs(root.left);\n    int rightMax=dfs(root.right);\n    int flag=0;\n    if(root.left!=null && root.left.val==root.val){\n        flag++;\n        leftMax++;\n    }\n    if(root.right!=null && root.right.val==root.val){\n        flag++;\n        rightMax++;\n    }\n    if(flag==2){\n        res=Math.max(res,leftMax+rightMax);\n    }\n    res=Math.max(res,Math.max(leftMax,rightMax));\n    return flag==0?0:Math.max(leftMax,rightMax);\n}\n```\n\n**解法一**\n\n在看了题解后对上面错误解法的纠正\n\n```java\npublic int longestUnivaluePath(TreeNode root) {\n    if(root==null) return 0;\n    dfs(root);\n    return res;\n}\n\nint res=0;\n\n//以root开头的同值路径长度\npublic int dfs(TreeNode root){\n    if(root==null){\n        return 0;\n    }\n    int leftMax=dfs(root.left);\n    int rightMax=dfs(root.right);\n    if(root.left!=null){\n        //不相等就直接设置成0\n        leftMax=root.left.val==root.val?leftMax+1:0;\n    }\n    if(root.right!=null){\n        rightMax=root.right.val==root.val?rightMax+1:0;\n    }\n    //其实3种情况都包含了\n    res=Math.max(res,leftMax+rightMax);\n    return Math.max(leftMax,rightMax);\n}\n```\n\n注意dfs函数的定义：_**以root开头的最长同值路径**_\n\n既然是以root开头，所以代表的其实是**单侧**的最长路径，也就是说这个路径不能穿过root，所以我们要分别求左右的值，然后取最大值，再判断和左右节点是否相等\n\n再然后我们需要判断root和左右节点值是否相等，如果和左右节点不想等，那么`leftMax`和`rightMax`应该直接置为0，不应该再代入做计算，上面的错误解法就是错在这里，如果相等那就应该+1，然后统计最大值的时候也就可以很轻松的包含所有的3种情况\n\n> 这里为什么要先求最大值，再判断，先判断在求最大值不行么？\n>\n> 其实想想就知道不行，先判断其实相当于`前序遍历`，在访问节点第一次的时候如果不符合条件就直接返回了，这样根本无法遍历完所有的节点自然是不行，所以这种类型的一般都是`后序遍历`，待子节点都处理完之后再返回根节点做处理，和分治的思想很像\n\n**Update: 2020.6.21**\n\ngo重写一遍，换了个方式，统计节点个数最后减一\n```golang\nfunc longestUnivaluePath(root *TreeNode) int {\n    if root==nil{\n        return 0\n    }\n    var Max=func(a,b int)int{\n        if a>b{return a}\n        return b\n    }\n    var res=0\n    var dfs func(root *TreeNode)int\n    dfs = func (root *TreeNode)int{\n        if root==nil{\n            return 0\n        }\n        //root和左右子节点能形成的最长同值路径(至少是1)\n        left := 1+dfs(root.Left) \n        right := 1+dfs(root.Right)\n        if root.Left==nil || root.Val!=root.Left.Val{\n            left=1\n        }\n        if root.Right==nil || root.Val!=root.Right.Val{\n            right=1\n        }\n        res=Max(res,left+right-1)\n        return Max(left,right)\n    }\n    dfs(root)\n    return res-1\n}\n```\n**解法二**\n\n另一种dfs的思路，代码更加简洁一点，但是稍微有一点不好想\n\n```java\npublic int longestUnivaluePath(TreeNode root) {\n    if(root==null) return 0;\n    //起点的值无所谓,root节点没有父节点不用向上层函数返回值\n    dfs(root,-1); \n    return res;\n}\n\nint res=0;\n\n//以 root父节点和root 开始的同值路径长度\npublic int dfs(TreeNode root,int parent){\n    if(root==null){\n        return 0;\n    }\n    int leftMax=dfs(root.left,root.val);\n    int rightMax=dfs(root.right,root.val);\n    //这里res的计算其实3种情况都包含了\n    res=Math.max(res,leftMax+rightMax);\n    if(root.val==parent){\n        //和父节点同值,返回左右最大值+1\n        return Math.max(leftMax,rightMax)+1;\n    }\n    //和父节点不同值，直接返回0\n    return 0;\n}\n```\n\n注意dfs函数的定义：_**以node父节点和node开始的同值路径长度**_\n\n在函数中添加一个父节点的值，然后在遍历到一个节点的时候判断当前节点和父节点的关系就行了，如果和父节点不相等，那么直接返回0，相等就返回左右最大值+1（这个+1加的是当前节点），然后同样采用后序遍历，这个思路没有那么自然，不过也挺不错的\n\n> 还有一种暴力解法，这里就不贴了\n\n## [595. 二叉树最长连续序列（LintCode）](https://www.lintcode.com/problem/binary-tree-longest-consecutive-sequence/description?ordering=-updated_at) \n\n**描述**\n\n给一棵二叉树，找到最长连续路径的长度。\n这条路径是指 任何的节点序列中的起始节点到树中的任一节点都必须遵循 父-子 联系。最长的连续路径必须是从父亲节点到孩子节点（`不能逆序`）。\n\n**样例1:**\n\n```java\n输入:\n{1,#,3,2,4,#,#,#,5}\n输出:3\n说明:\n这棵树如图所示\n   1\n    \\\n     3\n    / \\\n   2   4\n        \\\n         5\n最长连续序列是3-4-5，所以返回3.\n```\n\n**样例2:**\n\n```java\n输入:\n{2,#,3,2,#,1,#}\n输出:2\n说明:\n这棵树如图所示：\n   2\n    \\\n     3\n    / \n   2    \n  / \n 1\n最长连续序列是2-3，而不是3-2-1，所以返回2.\n```\n\n**解法一**\n\n和上一题最长同值路径几乎一摸一样，这题leetCode也有，[但是是会员题](https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence)，前几天每日一题出了这个（后来改了），然后我在lintcode找到了，应该是同一题，随手做一下\n\n```java\npublic int longestConsecutive(TreeNode root) {\n    // write your code here\n    dfs(root);\n    return max;\n}\n\nint max=0;\n\n//以root开始的最长连续序列\npublic int dfs(TreeNode root){\n    if(root == null){\n        return 0;\n    }\n    //保证至少是1\n    int leftMax = Math.max(1,dfs(root.left));\n    int rightMax = Math.max(1,dfs(root.right));\n    if(root.left!=null){\n        leftMax = root.val==root.left.val-1 ? leftMax+1:1;\n    }\n    if(root.right!=null){\n        rightMax = root.val==root.right.val-1 ? rightMax+1:1;\n    }\n    max=Math.max(max,Math.max(leftMax,rightMax));\n    return Math.max(leftMax,rightMax);\n}\n```\n\n其实一开始写了一个很复杂的，dfs的定义又和父节点耦合了，感觉和父节点耦合之后就很难搞，很容易搞晕，所以尽量不和父节点耦合，直接以当前节点定义\n\n**Update: 2020.6.21**\n\n```golang\nfunc longestConsecutive (root *TreeNode) int {\n    var Max = func(a,b int)int{\n        if a>b{return a}\n        return b\n    }\n    var dfs func(root *TreeNode) int\n    var res=0\n    dfs = func(root *TreeNode)int{\n        if root ==nil {\n            return 0\n        }\n        left:= 1+dfs(root.Left)\n        right:= 1+dfs(root.Right)\n        if root.Left==nil ||root.Left.Val!=root.Val+1{\n            left=1\n        }\n        if root.Right==nil ||root.Right.Val!=root.Val+1{\n            right=1\n        }\n        res=Max(res,Max(left,right))\n        return Max(left,right)\n    }\n    dfs(root)\n    return res\n}\n```\n\n## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)\n\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n**示例 1:**\n\n```java\n输入: [3,2,3,null,3,null,1]\n \t 3\n\t/ \\\n   2   3\n    \\   \\ \n     3   1\n\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n```\n\n**示例 2:**\n\n~~~java\n输入: [3,4,5,1,3,null,1]\n\n \t 3\n\t/ \\\n   4   5\n  / \\   \\ \n 1   3   1\n\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n~~~\n\n**解法一**\n\n暴力递归，应该还是写得出来\n\n```java\n//AC了,但是效率很低\n//可以用hashMap缓存一下每个节点rob的值,但是没必要\npublic int rob(TreeNode root) {\n    return tryRob(root);\n}\n\npublic int tryRob(TreeNode root) {\n    if (root==null) {\n        return 0;\n    }\n    if (root.left==null && root.right==null) {\n        return root.val;\n    }\n    //偷取当前节点\n    int res=root.val;\n    if (root.left!=null) {\n        res+=tryRob(root.left.left)+tryRob(root.left.right);\n    }\n    if (root.right!=null) {\n        res+=tryRob(root.right.left)+tryRob(root.right.right);\n    }\n    //不偷当前节点\n    int res2=0;\n    res2=tryRob(root.left)+tryRob(root.right);\n    return Math.max(res,res2);\n}\n```\n**解法二**\n\n看评论区说是啥树形dp ? 知识盲区了hahaha\n\n```java\npublic int rob(TreeNode root) {\n    int[] res=tryRob(root);\n    return Math.max(res[0],res[1]);\n}\n\n//树形dp???\n//看的懂，但是肯定写不出来 。。。。\npublic int[] tryRob(TreeNode root) {\n    int[] dp=new int[2];\n    if (root==null) {\n        return dp;\n    }\n\n    int[] left=tryRob(root.left);\n    int[] right=tryRob(root.right);\n    //不包含当前节点的最大值\n    dp[0]=Math.max(left[0],left[1])+Math.max(right[0],right[1]);\n    //包含当前节点的最大值\n    dp[1]=left[0]+right[0]+root.val;\n    return dp;\n}\n```\n~~不是我吹，就这样的题目，再遇见多少次我都写不出来这样的解（笑~~\n\n> 2020.5.10更新，在看了左神的书后，了解到这种其实就是树形DP，所谓的树形DP实际上就是把递推方程搬到了树结构上，按我的理解树形DP很大的特点就是最终的解可能存在于树上每个节点，所以每个节点都是个子问题，可以从子问题推出父问题\n\n## [1372. 二叉树中的最长交错路径](https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/)\n\n给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：\n\n- 选择二叉树中 **任意** 节点和一个方向（左或者右）。\n- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。\n- 改变前进方向：左变右或者右变左。\n- 重复第二步和第三步，直到你在树中无法继续移动。\n\n交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。\n\n请你返回给定树中最长 **交错路径** 的长度。\n\n**示例 1：**\n\n![YX1tJO.png](https://s1.ax1x.com/2020/05/22/YX1tJO.png)\n\n```java\n输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n输出：3\n解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。\n```\n\n**示例 2：**\n\n![YX1NWD.png](https://s1.ax1x.com/2020/05/22/YX1NWD.png)\n\n```java\n输入：root = [1,1,1,null,1,null,null,1,1,null,1]\n输出：4\n解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。\n```\n\n**示例 3：**\n\n```java\n输入：root = [1]\n输出：0\n```\n\n**提示：**\n\n- 每棵树最多有 `50000` 个节点。\n- 每个节点的值在 `[1, 100]` 之间。\n\n**解法一**\n\n某次周赛的T3，树形DP\n\n```java\nint max=0;\n\npublic int longestZigZag(TreeNode root) {\n    dfs(root);\n    return max-1;\n}\n\n//当前节点左右交错路径的长度\npublic int[] dfs(TreeNode root){\n    int[] res=new int[2];\n    if(root==null){\n        return res;\n    }\n    res[0]=dfs(root.left)[1]+1;\n    res[1]=dfs(root.right)[0]+1;\n    max=Math.max(max,Math.max(res[0],res[1]));\n    return res;\n}\n```\n**Update: 2020.6.21**\n\n用go重写（回顾）下\n```golang\nfunc longestZigZag(root *TreeNode) int {\n    var Max = func(a,b int)int{\n        if a>b{return a}\n        return b\n    }\n    var dfs func(root *TreeNode)[]int\n    var res = 0\n    dfs = func(root *TreeNode)[]int{\n        if root==nil{\n            return []int{0,0}\n        }\n        //0：向左走最长交错 1：向右最长交错路径\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n        res=Max(res,Max(left[1]+1,right[0]+1))\n        return []int{left[1]+1,right[0]+1}\n    }\n    dfs(root)\n    return res-1\n}\n```\n\n**解法二**\n\n直接搜索的做法，其实这种做法没有上面树形dp好理解，dfs函数的定义会和父节点混合\n\n```java\nint res=0;\n\npublic int longestZigZag(TreeNode root) {\n    dfs(root,false);//true false都无所谓，root没有父节点\n    return res-1;\n}\n\n//当前节点和父节点形成的交错路径长度，isRight代表父节点到当前节点的走向是不是right\npublic int dfs(TreeNode root,boolean isRight){\n    if(root==null){\n        return 0;\n    }\n    int l=dfs(root.left,false);\n    int r=dfs(root.right,true);\n    res=Math.max(res,Math.max(l+1,r+1));\n    if(isRight){\n        return l+1;\n    }\n    return r+1;\n}\n```\n\n## [968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)\n\nDifficulty: **困难**\n\n\n给定一个二叉树，我们在树的节点上安装摄像头。\n\n节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**\n\n计算监控树的所有节点所需的最小摄像头数量。\n\n**示例 1：**\n\n![wjBgQ1.png](https://s1.ax1x.com/2020/09/23/wjBgQ1.png)\n\n```golang\n输入：[0,0,null,0,0]\n输出：1\n解释：如图所示，一台摄像头足以监控所有节点。\n```\n\n**示例 2：**\n\n![wjBfeK.png](https://s1.ax1x.com/2020/09/23/wjBfeK.png)\n\n```golang\n输入：[0,0,null,0,null,0,null,null,0]\n输出：2\n解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n```\n\n**提示：**\n\n1.  给定树的节点数的范围是 `[1, 1000]`。\n2.  每个节点的值都是 0。\n\n\n**解法一**\n\n树形DP\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n//0: 覆盖整棵树，root必须设置监控\n//1: 覆盖整棵树，无论root是否设置监控\n//2: 覆盖两颗子树，无论root是否被覆盖\nfunc minCameraCover(root *TreeNode) int {\n    var Min = func(a, b int) int {if a < b {return a}; return b}\n    var INF = 0x3f3f3f3f\n    var dfs func(root *TreeNode) [3]int \n    dfs = func (root *TreeNode) [3]int {\n        var res [3]int\n        if root == nil {\n            return [3]int{INF, 0, 0}\n        }\n        left := dfs(root.Left)\n        right := dfs(root.Right)\n        res[0] = left[2] + right[2] + 1\n        res[1] = Min(res[0], Min(left[0]+right[1], left[1]+right[0]))\n        res[2] = Min(res[0], left[1] + right[1])\n        return res\n    }\n    r := dfs(root)\n    return r[1]\n}\n```\n\n## _树状数组（BIT）_\n\n暂时先放在这里，等以后累计多了再单独开辟专题\n\n## [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n\nDifficulty: **困难**\n\n给定一个整数数组 _nums_，按要求返回一个新数组 _counts_。数组 _counts_ 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。\n\n**示例：**\n\n```java\n输入：nums = [5,2,6,1]\n输出：[2,1,1,0] \n解释：\n5 的右侧有 2 个更小的元素 (2 和 1)\n2 的右侧仅有 1 个更小的元素 (1)\n6 的右侧有 1 个更小的元素 (1)\n1 的右侧有 0 个更小的元素\n```\n\n**提示：**\n\n*   `0 <= nums.length <= 10^5`\n*   `-10^4 <= nums[i] <= 10^4`\n\n**解法一**\n\n这题有[更好的做法](http://imlgw.top/2019/05/04/leetcode-shu-zu/#315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0)，直接归并就行了，这里主要是为了学习BIT\n\n暴力的做法: 其实就是桶排序的思想，我们从右向左扫数组，扫描一个就在对应的桶+1，同时计算该位置左边的前缀和，就是右边比当前元素小的值，也就是我们需要的结果，但是问题是这个`bit`数组是一直在变化的，扫描一个元素就会在bit数组对应的位置上+1，每次变化后都需要O(N)来重新计算后缀和，这样整体的复杂度就是O(N^2)，数据量1e5，过不了OJ\n\n所以我们可以用线段树来维护区间和，但是线段树代码量比较大，常数也比较大，所以这里学一下新科技：**[树状数组](https://blog.csdn.net/Yaokai_AssultMaster/article/details/79492190)**，区间查询，单点修改时间复杂度都是logN，且代码简单。\n\n同时还有一个问题，这里我们直接按照值来定位是不合适的，数据范围比较大，直接按照元素值来定位会造成很大空间的浪费，并且题目也不允许开这么大的空间，所以还需要离散化，因为我们只关系元素之间的大小关系，所以我们转换成每个元素说对应的rank就行了\n\n```java\nint[] tree;\n\nint n = 0;\n\npublic int lowbit(int i) {\n    return i & -i;\n}\n\n//update索引i位置\npublic void update(int i, int delta) {\n    while (i <= n) {\n        tree[i] += delta;\n        i += lowbit(i);\n    }\n}\n\npublic int query(int i) {\n    int sum = 0;\n    //从1开始\n    while (i > 0) {\n        sum += tree[i];\n        i -= lowbit(i);\n    }\n    return sum;\n}\n\n/*\n暴力的做法: 其实就是桶排序的思想，我们从右向左扫数组，扫描一个就在对应的桶+1，\n同时计算该位置左边的前缀和，就是右边比当前元素小的值，也就是我们需要的结果，\n但是问题是这个`bit`数组是一直在变化的，扫描一个元素就会在bit数组对应的位置上+1，\n每次变化后都需要O(N)来重新计算后缀和，这样整体的复杂度就是O(N^2)，数据量1e5，过不了OJ\n\n所以我们可以用线段树来维护区间和，但是线段树代码量比较大，常数也比较大\n所以这里学一下新科技：**树状数组**，区间查询，单点修改时间复杂度都是logN，且代码简单。\n同时还有一个问题，这里我们直接按照值来定位是不合适的，数据范围比较大，\n直接按照元素值来定位会造成很大空间的浪费，并且题目也不允许开这么大的空间\n所以还需要离散化，因为我们只关系元素之间的大小关系，所以我们转换成每个元素说对应的rank就行了\n*/\npublic List<Integer> countSmaller(int[] nums) {\n    n = nums.length;\n    tree = new int[n+1];\n    List<Integer> res = new LinkedList<>();\n    int[] rank = new int[n];\n    //temp[0]: index temp[1]: val\n    int[][] temp = new int[n][2];\n    for (int i = 0; i < n; i++) {\n        temp[i] = new int[]{i, nums[i]};\n    }\n    //离散化\n    Arrays.sort(temp, (t1, t2) -> t1[1]-t2[1]);\n    for (int i = 0; i < n; i++) {\n        rank[temp[i][0]] = i+1;\n    }\n    for (int i = n-1; i >= 0; i--) {\n        //O(NlogN)构建BIT(可以优化成O(N))\n        update(rank[i], 1);\n        res.add(0, query(rank[i]-1));\n    }\n    return res;\n}\n```","tags":["LeetCode","二叉树"],"categories":["算法"]},{"title":"LeetCode回溯&递归","url":"/2019/10/10/leetcode-hui-su/","content":"\n## [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n\n给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）注意 1 不对应任何字母\n\n![mark](http://static.imlgw.top/blog/20191012/Ro4wr1dv5pR7.png?imageslim)\n\n**示例:**\n\n```java\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n\n**说明:**\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n**解法一**\n\n```java\nString[] letter={\" \",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n\nprivate List<String> res=new LinkedList<>();\n\npublic List<String> letterCombinations(String digits) {\n    //空字符串要注意\n    if (\"\".equals(digits)) return res;\n    letterCombinations(digits,0,\"\");\n    return res;\n}\n\npublic void letterCombinations(String digits,int index,String str) {\n    //递归出口,当index==digits的长度的时候就说明走到尽头了\n    //需要回头尝试其他的情况\n    if (index==digits.length()) {\n        res.add(str);\n        return;\n    }\n    //当前字符对应的字母组合\n    char[] ls=letter[digits.charAt(index)-48].toCharArray();\n    //遍历每种可能,其实就是DFS\n    for (int i=0;i<ls.length;i++) {\n        letterCombinations(digits,index+1,str+ls[i]);\n    }\n    return;\n}\n```\n\n可想而知，这个算法的时间复杂度相当高，`3^N * 4^M = O(2^N)` M是能表示3个字符的数字个数，N是表示4个字符的数字个数，指数级别的算法，但是也没有其他别的比较好的算法了\n\n## [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)\n\n给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。\n\n**示例:**\n\n```java\n输入: \"25525511135\"\n输出: [\"255.255.11.135\", \"255.255.111.35\"]\n```\n\n**解法一**\n\n其实还是有一个大致的思路，但是没写出来，很多细节不知道咋处理\n\n```java\npublic List<String> restoreIpAddresses(String s) {\n    restoreIpAddresses(s,0,\"\",0);\n    return res;\n}\n\nLinkedList<String> res=new LinkedList<>();\n\npublic void restoreIpAddresses(String s,int index,String des,int count) {\n    if (count>4) {\n        return;\n    }\n    //到字符串末尾了\n    if (index==s.length()) {\n        if (count==4) {\n            res.add(des.substring(0,des.length()-1));    \n        }\n        return;\n    }\n    //如果为0就不用切分了,这里就相当于直接跳过\n    if (s.charAt(index)=='0') {\n        restoreIpAddresses(s,index+1,des+\"0.\",count+1);\n    }else{\n        //不为0就需要继续切分为1，2，3\n        //切分过程中需要注意要小于255,同时需要一个计数器来判度是否终止\n        for (int i=1;i<4;i++) {\n            if (index+i<=s.length()) {\n                String temp=s.substring(index,index+i);\n                if (Integer.valueOf(temp)<=255){\n                    restoreIpAddresses(s,index+i,des+temp+\".\",count+1);    \n                }\n            }\n        }\n    }\n}\n```\n\n**UPDATE: 2020.8.9**\n\n今天的打卡题，用go重写了下，比之前写的好多了，不过一开始忘了处理0WA了一发，然后懒的对长度不合法的剪枝又T了一发。。。\n```golang\nfunc restoreIpAddresses(s string) []string {\n    var res []string\n    if len(s) < 4 || len(s) > 12 {\n        return res\n    }\n    var dfs func(s string, lis []string)\n    dfs = func(s string, lis []string) {\n        if s == \"\" {\n            if len(lis) == 4 {\n                res = append(res, strings.Join(lis, \".\"))\n            }\n            return\n        }\n        //s未遍历完就集齐了4块\n        if len(lis) >= 4 {\n            return\n        }\n        for i := 1; i <= 3; i++ {\n            if i <= len(s) && check(s[:i]) {\n                lis = append(lis, s[:i])\n                dfs(s[i:], lis)\n                lis = lis[:len(lis)-1]\n                //前导0的处理，读取0之后就不再向后扩展\n                if s[:i] == \"0\" {\n                    return\n                }\n            }\n        }\n    }\n    dfs(s, []string{})\n    return res\n}\n\nfunc check(s string) bool {\n    if ns, _ := strconv.Atoi(s); ns <= 255 {\n        return true\n    }\n    return false\n}\n\n```\n\n## [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)\n\n给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。\n\n返回 s 所有可能的分割方案。\n\n**示例:**\n\n```java\n输入: \"aab\"\n输出:\n[\n  [\"aa\",\"b\"],\n  [\"a\",\"a\",\"b\"]\n]\n```\n\n**解法一**\n\n总算自己完整做了一题出来了\n\n```java\npublic List<List<String>> partition(String s) {\n    partition(s,0,new ArrayList());\n    return res;\n}   \n\nList<List<String>> res=new ArrayList<>();\n\npublic void partition(String s,int index,List<String> lis) {\n    if (index==s.length()) {\n        //注意这里要copy一个list不能直接添加lis\n        //lis引用的对象后面还会继续变化，最后会变为null\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=index+1;i<=s.length();i++) {\n        String temp=s.substring(index,i);\n        //System.out.println(index+\"=\"+i+\"=\"+temp);\n        if (isPalind(temp)) {\n            lis.add(temp);\n            partition(s,i,lis);\n            //不能直接remove(temp),主要是会有重复的字符,所以会导致最后的顺序不一致,而且效率也很低\n            //lis.remove(temp);\n            lis.remove(lis.size()-1);\n        }\n    }\n}\n\npublic boolean isPalind(String s){\n    for (int i=0,j=s.length()-1;i<=j;i++,j--) {\n        if (s.charAt(i)!=s.charAt(j)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n4ms，93%，其实就是暴力回溯，还是挺简单的，一开始忘了`remove()`，直接把所有结果打出来了， 然后一直在想怎么调整递归的结构。。。DFS基本的套路都忘了😂\n\n## [46. 全排列](https://leetcode-cn.com/problems/permutations/)\n\n给定一个**没有重复**数字的序列，返回其所有可能的全排列。\n\n**示例:**\n\n```java\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n**解法一**\n\n经典的全排列问题，熟悉了DFS套路之后都挺简单的，注意回溯就行了\n\n```java\npublic List<List<Integer>> permute(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    boolean[] visit=new boolean[nums.length];\n    permute(nums,new ArrayList(),visit);\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void permute(int[] nums,List<Integer> lis,boolean[] visit) {\n    if (lis.size()==nums.length) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=0;i<nums.length;i++) {\n        if (visit[i]) continue;\n        lis.add(nums[i]);\n        visit[i]=true;\n        permute(nums,lis,visit);\n        //回溯\n        visit[i]=false;\n        lis.remove(lis.size()-1);\n    }\n}\n```\n## [60. 第k个排列](https://leetcode-cn.com/problems/permutation-sequence/)\n\n给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。\n\n按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：\n\n1. `\"123\"`\n2. `\"132\"`\n3. `\"213\"`\n4. `\"231\"`\n5. `\"312\"`\n6. `\"321\"`\n\n给定 n 和 k，返回第 k 个排列。\n\n**说明：**\n\n- 给定 n 的范围是 [1, 9]。\n- 给定 k 的范围是[1,  n!]。\n\n**示例 1: **\n\n```java\n输入: n = 3, k = 3\n输出: \"213\"\n```\n\n\n**示例 2:**\n\n```java\n输入: n = 4, k = 9\n输出: \"2314\"\n```\n\n**解法一**\n\n```java\npublic String getPermutation(int n, int k) {\n    boolean[] visit=new boolean[n+1];\n    getPermutation(n,k,0,visit,new StringBuilder(\"\"));\n    return res.get(k-1).toString();\n}\n\nprivate List<StringBuilder> res=new LinkedList<>();\n\npublic void getPermutation(int n, int k,int count,boolean[] visit,StringBuilder str) {\n    if (count == n) {\n        res.add(new StringBuilder(str));\n        return;\n    }\n    if (res.size()==k) {\n        return;\n    }\n    for (int i=1;i<=n;i++) {\n        if (!visit[i]) {\n            str.append(i);\n            visit[i]=true;\n            getPermutation(n,k,count+1,visit,str);\n            visit[i]=false;\n            str.delete(str.length()-1,str.length());\n        }\n    }\n}\n```\n偶然发现这一题并没有记录，之前没有记录的原因肯定是因为方法太垃圾了，这题最优解是 `康托展开`，说实话，暂时并不想去了解😂，后面有时间再说吧\n\n## [5374. 长度为 n 的开心字符串中字典序第 k 小的字符串](https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/) \n\n一个 「开心字符串」定义为：\n\n- 仅包含小写字母 ['a', 'b', 'c'].\n- 对所有在 1 到 s.length - 1 之间的 i ，满足 s[i] != s[i + 1] （字符串的下标从 1 开始）。\n\n比方说，字符串 \"abc\"，\"ac\"，\"b\" 和 \"abcbabcbcb\" 都是开心字符串，但是 \"aa\"，\"baa\" 和 \"ababbc\" 都不是开心字符串。\n\n给你两个整数 n 和 k ，你需要将长度为 n 的所有开心字符串按字典序排序。\n\n请你返回排序后的第 k 个开心字符串，如果长度为 n 的开心字符串少于 k 个，那么请你返回 空字符串 。\n\n**示例 1：**\n\n```java\n输入：n = 1, k = 3\n输出：\"c\"\n解释：列表 [\"a\", \"b\", \"c\"] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 \"c\" 。\n```\n\n**示例 2：**\n\n```java\n输入：n = 1, k = 4\n输出：\"\"\n解释：长度为 1 的开心字符串只有 3 个。\n```\n\n**示例 3：**\n\n```java\n输入：n = 3, k = 9\n输出：\"cab\"\n解释：长度为 3 的开心字符串总共有 12 个 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"] 。第 9 个字符串为 \"cab\"\n```\n\n**示例 4：**\n\n```java\n输入：n = 2, k = 7\n输出：\"\"\n```\n\n**示例 5：**\n\n```java\n输入：n = 10, k = 100\n输出：\"abacbabacb\"\n```\n\n**提示：**\n\n- `1 <= n <= 10`\n- `1 <= k <= 100`\n\n**解法一**\n\n补下24th双周赛T3，和上面一题很类似，直接暴力回溯了\n\n```java\npublic String getHappyString(int n, int k) {\n    dfs(\"a\",n,k);\n    dfs(\"b\",n,k);\n    dfs(\"c\",n,k);\n    return res;\n}\n\nprivate int count=0;\n\nprivate String res=\"\";\n\npublic void dfs(String cur,int n,int k){\n    if(!\"\".equals(res)) return;\n    if(cur.length()==n){\n        count++;\n        if(count==k){\n            res=cur;\n        }\n        return;\n    }\n    char last=cur.charAt(cur.length()-1);\n    if(last=='a'){\n        dfs(cur+'b',n,k);\n        dfs(cur+'c',n,k);\n    }\n    if(last=='b'){\n        dfs(cur+'a',n,k);\n        dfs(cur+'c',n,k);\n    }\n    if(last=='c'){\n        dfs(cur+'a',n,k);\n        dfs(cur+'b',n,k);\n    }\n}\n```\n其实直接队列模拟也是可以的，模拟的效率应该会更高一些，好像也可以直接构造出来\n\n## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)\n\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n**示例:**\n\n```java\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n**解法一**\n\n开始我很纠结这题，后来想通了，其实就是去重，遇到已经存在于结果中相同的元素就直接跳过就行了\n\n```java\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    //Arrays.sort(nums); 解法二需要先排序\n    boolean[] visit=new boolean[nums.length];\n    permuteUnique(nums,new ArrayList(),visit);\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void permuteUnique(int[] nums,List<Integer> lis,boolean[] visit){\n    HashSet<Integer> set=new HashSet<>();\n    if (lis.size()==nums.length) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=0;i<nums.length;i++) {\n        if (!visit[i] && !set.contains(nums[i])) {\n            lis.add(nums[i]);\n            visit[i]=true;\n            set.add(nums[i]);\n            permuteUnique(nums,lis,visit);\n            visit[i]=false;\n            lis.remove(lis.size()-1);\n        }\n    }\n}\n\n//需要排序\npublic void permuteUnique2(int[] nums,List<Integer> lis,boolean[] visit){\n    if (lis.size()==nums.length) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=0;i<nums.length;i++) {\n        //剪枝去重，和前一个元素比较\n        //Bug警告，应该写!visit[i-1]\n        if (i>0&&nums[i]==nums[i-1] && !visit[i-1]) \n            continue;\n        if (!visit[i]) {\n            lis.add(nums[i]);\n            visit[i]=true;\n            permuteUnique2(nums,lis,visit);\n            visit[i]=false;\n            lis.remove(lis.size()-1);\n        }\n    }\n}\n```\n关于去重的方式，其实我们可以从回溯的**根节点**来考虑，也就是我们考虑最顶层的【**1，1，2**】的遍历情况，每一次遍历实际上都是在找**以当前元素开头的排列**，当第一次已经遍历完1开头的所以排列后，后面的循环再碰到1自然就可以直接跳过了，所以我们可以在一次遍历中用HashMap来去重，来保证一次循环中不会有重复的元素被选取，其实也只有这题可以用HashSet，因为这里排列是讲究顺序的，循序完全一样才是重复，后面的题都是不讲究顺序的，都需要排序才能去重，具体后面再分析\n\n> 我首先想到的就是Hash表，这里翻了下评论区好像都是用的第二种方式去重的，难道用HashSet不好么😂，第二种必须要先排序，保证相同的元素都聚在一起，方便判断，这种题在纸上画一画递归树其实就很清楚了\n\n### Bug警告\n\n这里 `!visit[i-1]`和 `visit[i-1]`对于这题来说并不影响正确性，但是你如果将生成的过程打印出来对比下就知道为啥了，具体的请看下面 [1079. 活字印刷](#1079-活字印刷) 的解释\n\n## [1286. 字母组合迭代器](https://leetcode-cn.com/problems/iterator-for-combination/)\n\n请你设计一个迭代器类，包括以下内容：\n\n- 一个构造函数，输入参数包括：一个 有序且字符唯一 的字符串 characters（该字符串只包含小写英文字母）和一个数字 combinationLength 。\n- 函数 next() ，按 字典序 返回长度为 combinationLength 的下一个字母组合。\n- 函数 hasNext() ，只有存在长度为 combinationLength 的下一个字母组合时，才返回 True；否则，返回 False。\n\n**示例：**\n\n```java\nCombinationIterator iterator = new CombinationIterator(\"abc\", 2); // 创建迭代器 iterator\n\niterator.next(); // 返回 \"ab\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"ac\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"bc\"\niterator.hasNext(); // 返回 false\n```\n\n**提示：**\n\n- 1 <= combinationLength <= characters.length <= 15\n- 每组测试数据最多包含 10^4 次函数调用。\n- 题目保证每次调用函数 next 时都存在下一个字母组合。\n\n**解法一**\n\n唉，真的菜，好久没写回溯了，又給忘了，这题开始被别人误导了，以为是下一个排列，然后就一直在想怎么去求next，其实根本就不用这样...\n\n```java\nprivate LinkedList<String> res=new LinkedList<>();\n\n//abc\npublic CombinationIterator(String characters, int combinationLength) {\n    dfs(\"\",combinationLength,0,0,characters);\n}\n\npublic String next() {\n    return res.pollFirst();\n}\n\npublic void dfs(String cur,int len,int index,int count,String source) {\n    if (count == len) {\n        res.add(cur); //直接根据cur得长度判断就ok了\n        return;\n    }\n    for (int i=index;i<source.length();i++) {\n        dfs(cur+source.charAt(i),len,i+1,count+1,source);\n    }\n}\n\npublic boolean hasNext() {\n    return !res.isEmpty();\n}\n```\n\n> 回头开了下之前的代码，发现都写得不好，很喜欢加个count统计数量，其实直接根据cur得长度判断就可以了\n\n## [77. 组合](https://leetcode-cn.com/problems/combinations/)\n\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n**示例:**\n\n```java\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n```\n\n**解法一**\n\n其实一开始没写出剪枝的代码，看了一点提示后才写出了下面的的第一种剪枝的方法\n\n```java\npublic List<List<Integer>> combine(int n, int k) {\n    if (k>n || n<=0 ||k<=0) {\n        return res;\n    }\n    //boolean[] visit=new boolean[n+1];\n    combine(n,k,1,new ArrayList(),0);\n    return res;\n}   \n\nprivate List<List<Integer>> res=new ArrayList<>();\n\n//剪枝优化1\npublic void combine(int n, int k,int index,List<Integer> lis,int count) {\n    if (count==k) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    //1 2 3 4 | 3\n    //index = 3 k=3  n=4 count=0 (3为头,显然是不行的,肯定会和前面重复) --> 3<=3\n    //index = 3 k=3  n=4 count=1 (3为第二个,是可行的) --> 3 <= 2\n    if (n-index+2<=k-count) {\n        return;\n    }\n    for (int i=index;i<=n;i++) {\n        lis.add(i);\n        combine(n,k,i+1,lis,count+1);\n        //回溯的关键\n        lis.remove(lis.size()-1);\n    }\n}\n\n//剪枝优化2\npublic void combine4(int n, int k,int index,List<Integer> lis,int count) {\n    if (count==k) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    //循环的区间至少要有k-count个元素 也就是[i,N]之间至少要有k-count个元素\n    //N-i+1>=k-count --> i<=n-(k-count)+1\n    for (int i=index;i<=n-(k-count)+1;i++) {\n        lis.add(i);\n        combine4(n,k,i+1,lis,count+1);\n        //回溯的关键\n        lis.remove(lis.size()-1);\n    }\n}\n```\n举个例子`1，2，3，4 k=3`  其实在循环n=3的时候就可以结束了，因为后面已经没有那么多元素可以和3构成组合了\n\n## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 ，`candidates` 中的数字可以无限制重复被选取\n\n说明：\n\n- 所有数字（包括 target）都是正整数。\n\n- 解集不能包含重复的组合。 \n\n**示例 1:**\n\n```java\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n\n**示例 2:**\n\n```java\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n**解法一**\n\n没有任何剪枝处理的回溯，感觉一开始就想好怎么剪枝还是不太容易，这题其实和上面的组合很类似，值得注意的就是子递归调用的时候传递的index参数\n\n```java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    if (candidates==null || candidates.length<=0) {\n        return res;\n    }\n    combinationSum(candidates,target,0,0,new ArrayList());\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic void combinationSum(int[] candidates, int target,int index,int sum,List<Integer> lis) {\n    if (sum>target) {\n        return;\n    }\n    if (target==sum) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    //这里一次循环其实就确定了包含i的所有可能解，所以起点是index不是0\n    for (int i=index;i<candidates.length;i++) {\n        //跳过比target大的\n        if (candidates[i]>target) continue;\n        sum+=candidates[i];\n        lis.add(candidates[i]);\n\t\t//其实主要就是搞清楚每次从哪里开始,以及每次循环的作用\n        //可以重复选取自己，所以子递归也从i开始而不是i+1\n        combinationSum(candidates,target,i,sum,lis);\n        sum-=candidates[i];\n        lis.remove(lis.size()-1);\n    }\n}\n```\n**解法二**\n\n剪枝优化，主要是要先排个序，这样如果在循环过程中，累加和已经大于target了就直接return，如果不排序就不能return，因为无法确保后面会不会更小的元素\n\n```java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    if (candidates==null || candidates.length<=0) {\n        return res;\n    }\n    //排序,方便剪枝\n    Arrays.sort(candidates);\n    combinationSum(candidates,target,0,0,new ArrayList());\n    return res;\n}\n\nprivate List<List<Integer>> res=new ArrayList<>();\n\n//剪枝优化2\npublic void combinationSum(int[] candidates, int target,int index,int sum,List<Integer> lis) {\n    if (sum>target) {\n        return;\n    }\n    if (target==sum) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n    for (int i=index;i<candidates.length;i++) {\n        if (sum+candidates[i]>target) return;\n        sum+=candidates[i];\n        lis.add(candidates[i]);\n        //注意这里传递进去的index是i\n        combinationSum(candidates,target,i,sum,lis);\n        sum-=candidates[i];\n        lis.remove(lis.size()-1);\n    }\n}\n```\n这两天状态还可以啊，好多题都可以完全独立的写出来了😁\n\n## [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)\n\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n**说明：**\n\n- 所有数字（包括目标数）都是正整数。\n- 解集不能包含重复的组合。 \n\n**示例 1:**\n\n```java\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n```\n\n**示例 2:**\n\n```java\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n[\n  [1,2,2],\n  [5]\n]\n```\n\n**解法一**\n\n```java\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    if (candidates ==null || candidates.length<=0) {\n        return res;\n    }\n    Arrays.sort(candidates);\n    combinationSum2(candidates,target,0,new ArrayList());\n    return res;\n}\n\npublic void combinationSum2(int[] candidates, int target,int index,List<Integer> lis) {\n    /*if (target<0) {\n            return;\n        }*/\n    if (target==0) {\n        res.add(new ArrayList(lis));\n        return;\n    }\n\n    for (int i=index;i<candidates.length;i++) {\n        //注意这里i>index\n        if (i>index && candidates[i]==candidates[i-1]  ) continue;\n        //排过序的,可以直接return\n        if (target-candidates[i]<0) return;\n        lis.add(candidates[i]);\n        combinationSum2(candidates,target-candidates[i],i+1,lis);\n        lis.remove(lis.size()-1);\n    }\n}\n```\n回溯其实值得注意的就那几个点，循环的起点，下次递归的起点，回溯，出口，这几个点都搞清楚了其实就很简单了，关键的地方就是如何去重\n\n这题如果参照上面[全排列2](## 47. 全排列 II) 的第一种HashSet的去重方式的话，明显是有问题的，HashSet的去重方式只能保证**每一次循环中不会有重复的元素被选取**，但是这题即使循环中没有重复的元素被选取，结果仍然会有重复\n\n比如 `10,1,2,7,6,1,5` 遍历1的时候会得到`1 2 5`，后续遍历2的时候又会得到一个 `2 1 5` ，但是其实在第一次循环的时候就**已经找到了所有包含1的解，后面循环中包含1的解其实都重复了**，如果我们排序后就变为 `1 1 2 5 6 7 10` 把相同的元素聚集到一起，一方面可以去重，另一方面还可以剪枝，在第一次循环的时候就已经找到了所有的 带有1的解，后面的连着的1都可以跳过了，后续就不会再有包含1的解了，如果不排序，后面仍然会有包含1的解\n\n## [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)\n\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n**说明：**\n\n- 所有数字都是正整数。\n- 解集不能包含重复的组合。 \n\n**示例 1:**\n```java\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n```\n\n**示例 2:**\n\n```java\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n```\n\n**解法一**\n\n感觉比上面两题还简单一点，可以直接剪枝\n\n```golang\n//UPDATE: 2020.9.11\nfunc combinationSum3(k int, n int) [][]int {\n    var res [][]int\n    var dfs func(idx int, sum int, lis []int)\n    dfs = func(idx int, sum int, lis []int) {\n        if len(lis) > k {\n            return\n        }\n        if sum == n && len(lis) == k {\n            dest := make([]int, len(lis))\n            copy(dest, lis)\n            res = append(res, dest)\n            return\n        }\n        for i := idx; i <= 9; i++ {\n            if sum + i > n {\n                return\n            }\n            dfs(i+1, sum+i, append(lis, i))\n        }\n    }\n    dfs(1, 0, []int{})\n    return res\n}\n```\n\n**解法二（UPDATE：2020.9.11）**\n\n学了下二进制枚举子集的方法，很简洁\n```golang\nfunc combinationSum3(k int, n int) [][]int {\n    var res [][]int\n    for i := 0; i < (1<<9); i++ {\n        var sum, cnt = 0, 0\n        var lis []int\n        for j := 0; j < 9; j++ {\n            if i & (1<<j) != 0 {\n                sum += j+1\n                cnt++\n                lis = append(lis, j+1)\n            }\n        }\n        if sum == n && cnt == k {\n            res = append(res, lis)   \n        }\n    }\n    return res\n}\n```\n\n## [78. 子集](https://leetcode-cn.com/problems/subsets/)\n\n给定一组**不含重复元素**的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n**说明：**解集不能包含重复的子集。\n\n**示例:**\n\n```java\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n**解法一**\n\n```java\nprivate List<List<Integer>> res=new ArrayList<>();\n\npublic List<List<Integer>> subsets(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    subsets(nums,0,new ArrayList());\n    return res;\n}\n\npublic void subsets(int[] nums,int index,List<Integer> lis) {\n    //if (index<=nums.length) {\n        res.add(new ArrayList(lis));\n    //}\n    for (int i=index; i<nums.length;i++) {\n        lis.add(nums[i]);\n        subsets(nums,i+1,lis);\n        lis.remove(lis.size()-1);\n    }\n}\n```\n简单的回溯，注意收集结果的时机就行\n\n**Update: 2020.6.20**\n\n增加一个go的写法\n```golang\nfunc subsets(nums []int) [][]int {\n    var res [][]int\n    var lis []int\n    var dfs func(index int)\n    dfs = func(index int){\n        dest:=make([]int,len(lis))\n        copy(dest,lis)\n        res=append(res,dest)\n        for i:=index;i<len(nums);i++{\n            lis=append(lis,nums[i])\n            dfs(i+1)\n            lis=lis[:len(lis)-1]\n        }\n    }\n    dfs(0)\n    return res\n}\n```\n\n**解法二**\n\nBFS，类似于二叉树层次遍历，首先初始化一个空的list，后面每次迭代都将list中的所有元素都取出来加上当前元素，再重新加入到list中\n\n```java\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> queue=new ArrayList<>();\n    if (nums==null || nums.length<=0) {\n        return queue;\n    }\n    queue.add(new ArrayList());\n    for (int i=0;i<nums.length;i++) {\n        int next=queue.size();\n        for (int j=0;j<next;j++) {\n            List<Integer> temp=new ArrayList(queue.get(j));\n            temp.add(nums[i]);\n            queue.add(temp);\n        }\n    }\n    return queue;\n}\n```\n**解法三（UPDATE: 2020.9.11）**\n\n二进制枚举子集\n```golang\nfunc subsets(nums []int) [][]int {\n    var n = len(nums)\n    var res [][]int\n    for i := 0; i < (1<<n); i++ {\n        var lis []int\n        for j := 0; j < n; j++ {\n            if i & (1<<j) != 0 {\n                lis = append(lis, nums[j])\n            }\n        }\n        res = append(res, lis)\n    }\n    return res\n}\n```\n## [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)\n\n给定一个**可能包含重复元素**的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n**说明：**解集不能包含重复的子集。\n\n**示例:**\n\n```java\n输入: [1,2,2]\n输出:\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n```\n\n**解法一**\n\n和40题很类似，主要就是这个去重的操作，比如题目给的case，`[1,2,2]` 已经有序了，在选择第一个2的时候其实就已经将所有包含2的子集都求出来了，后面的2就可以直接跳过，当然这里1，2，2本身就是有序的，试想如果是`2,1,2` 遍历第一个2会将所有包含2的子集求出来，但是遍历到1的时候会将第三个2包含进来，也就是`1，2` 这个解，但是前面已经求出了`[2,1]` 这就重复了，排序就是为了将相同的元素聚合到一起，这样遇到相同的元素就跳过，后面的元素就不会再包含已经遍历过的元素了\n\n```java\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return res;\n    }\n    //需要先排序，便于跳过相同的元素\n    Arrays.sort(nums);\n    subsets(nums,0,new ArrayList());\n    return res;\n}\n\nprivate  List<List<Integer>> res=new ArrayList<>();\n\npublic void subsets(int[] nums,int index,List<Integer> lis) {\n    res.add(new ArrayList(lis));\n    for (int i=index;i<nums.length;i++) {\n        if (i>index && nums[i] == nums[i-1]) {\n            continue;\n        }\n        lis.add(nums[i]);\n        subsets(nums,i+1,lis);\n        lis.remove(lis.size()-1);\n    }\n}\n```\n\n**Update: 2020.6.20**\n\n用go重写了一遍，复习下\n```golang\nfunc subsetsWithDup(nums []int) [][]int {\n    sort.Ints(nums)\n    var res [][]int\n    var lis []int\n    var dfs func(index int)\n    dfs = func(index int){\n        dest:=make([]int,len(lis))\n        copy(dest,lis)\n        res=append(res,dest)\n        for i:=index;i<len(nums);i++{\n            if i>index && nums[i]==nums[i-1]{\n                continue\n            }\n            lis=append(lis,nums[i])\n            dfs(i+1)\n            lis=lis[:len(lis)-1]\n        }\n    }\n    dfs(0)\n    return res\n}\n```\n\n## [357. 计算各个位数不同的数字个数](https://leetcode-cn.com/problems/count-numbers-with-unique-digits/)\n\n给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。\n\n**示例:**\n\n```java\n输入: 2\n输出: 91 \n解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。\n```\n\n**解法一**\n\n> 这里要存个疑问，这里的回溯记忆化应该是错的，可能是数据太少了，没测试出来，但是居然真的提高了效率。。。。这就很诡异\n\n```java\n//这种可以做记忆化,0ms\nInteger[] cache=null;\n\npublic int countNumbersWithUniqueDigits2(int n) {\n    boolean[] visit=new boolean[10];\n    cache=new Integer[n+1];\n    int res=0;\n    if (n==0) return 1;\n    for (int i=1;i<=9;i++) { //不考虑0开头的\n        visit[i]=true;\n        res+=countNumbersWithUniqueDigits2(n,visit,1);\n        visit[i]=false;\n    }\n    return res+1; //加的是0这种情况\n}\n\n//[index,n](位数)区间内,能构成最多的不重复数字\npublic int countNumbersWithUniqueDigits2(int n,boolean[] visit,int index){\n    if (index==n) { //没得选,只有一种\n        return 1;\n    }\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    int count=1;\n    for (int i=0;i<=9;i++) {\n        if (!visit[i]) {\n            visit[i]=true;\n            count+=countNumbersWithUniqueDigits2(n,visit,index+1);\n            visit[i]=false;\n        }\n    }\n    return cache[index]=count;\n}\n```\n我都不好意思放到回溯专题中，开始写了个贼脑残的回溯451ms，实在不好意思放上来\n\n**解法二**\n\n```java\n//数学方法(初中数学)\npublic int countNumbersWithUniqueDigits3(int n){\n    if (n==0) return 1;\n    if (n>10) return 0;\n    int res=10,count=9; //i=1的情况\n    for (int i=2;i<=n;i++) {\n        count*=(11-i); //9*9*8*7*6*5.....\n        res+=count;\n    }\n    return res;\n}\n```\n说实话，这种方法我一开始写第一种很脑残的回溯的时候推出来了的，但是我居然没意识到。。。。\n\n## 89. 格雷编码\n\n格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。\n\n给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。\n\n**示例 1:**\n\n```java\n输入: 2\n输出: [0,1,3,2]\n解释:\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\n对于给定的 n，其格雷编码序列并不唯一。\n例如，[0,2,3,1] 也是一个有效的格雷编码序列。\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1\n```\n\n\n**示例 2:**\n\n```java\n输入: 0\n输出: [0]\n解释: 我们定义格雷编码序列必须以 0 开头。\n     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。\n     因此，当 n = 0 时，其格雷编码序列为 [0]。\n```\n\n**解法一**\n\n又一个脑残做法。。。\n\n```java\npublic List<Integer> grayCode3(int n) {\n    List<Integer> res=new ArrayList<>();\n    res.add(0);\n    int max=(1<<n)-1; //注意优先级\n    boolean[] visit=new boolean[max+1];\n    grayCode3(max,res,visit);\n    return res;\n}\n\npublic boolean grayCode3(int max,List<Integer> lis,boolean[] visit) {\n    if (lis.size()>max) { // list.size()==max+1 eg. when max=3 the list.size()=4\n        return true;\n    }\n    int last=lis.get(lis.size()-1);\n    for (int i=1;i<=max;i++) {\n        if (!visit[i] && Integer.bitCount(i^last)==1) {\n            lis.add(i);\n            visit[i]=true;\n            if(grayCode3(max,lis,visit)){\n                return true;\n            }\n            lis.remove(lis.size()-1);\n            visit[i]=false;\n        }\n    }\n    return false;\n}\n```\n\n**解法二**\n\n正常的回溯，每次修改一位，**直接生成下一个可能的格雷码**，而不是向上面一样一个个遍历。。。\n\n```java\n//常规回溯\npublic List<Integer> grayCode2(int n) {\n    List<Integer> res=new ArrayList<>();\n    boolean[] visit=new boolean[1<<n];\n    res.add(0);\n    visit[0]=true;\n    grayCode2(n,res,visit,0);\n    return res;\n}\n\npublic boolean grayCode2(int n,List<Integer> lis,boolean[] visit,int last) {\n    if (lis.size()>=(1<<n)) { // list.size()==max+1 eg. when max=3 the list.size()=4\n        return true;\n    }\n    for (int i=0;i<n;i++) {\n        //直接生成下一个\n        int next=last^(1<<i); //这一步其实就是从后往前,依次改变last一位\n        if (!visit[next]) {\n            lis.add(next);\n            visit[next]=true;\n            if(grayCode2(n,lis,visit,next)){\n                return true;\n            }\n            lis.remove(lis.size()-1);\n            visit[next]=false;\n        }\n    }\n    return false;\n}\n```\n**解法三**\n\n不停的和自己右移一位的值做异或，最终就可以的到完整的格雷码，至于原理并不想去研究😂，先记住再说\n\n```java\n//最优解,规律\npublic List<Integer> grayCode(int n) {\n    List<Integer> res=new ArrayList<>();\n    for (int i=0;i<1<<n;i++) {\n        res.add(i^(i>>1));\n    }\n    return res;\n}\n```\n看了评论区发现还有个规律，每一层的格雷码都是上一层前面加0 和逆序上一层在前面加1，感觉可能和上面的规律是一样的，一图以蔽之\n\n![leetCode题解](http://static.imlgw.top/blog/20191219/7rzdkpDvA4IN.png?imageslim)\n\n## [526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)\n\n假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：\n\n1. 第 i 位的数字能被 i 整除\n2. i 能被第 i 位上的数字整除\n\n现在给定一个整数 N，请问可以构造多少个优美的排列？\n\n**解法一**\n\n回溯法\n\n```java\npublic int countArrangement(int N) {\n    boolean[] visit=new boolean[N+1];\n    return countArrangement(N,visit,1);\n}\n\npublic int countArrangement(int N,boolean[] visit,int index) {\n    if (index > N) {\n        return 1;\n    }\n    int res=0;\n    for (int i=1;i<=N;i++) {\n        if (!visit[i] && (index%i==0 || i%index==0)) {\n            visit[i]=true;\n            res+=countArrangement(N,visit,index+1);\n            visit[i]=false;\n        }\n    }\n    return res;\n}\n```\n\n其实我是想改成记忆化递归的，不然我也不会这样写，但是后面改的时候居然出了bug，这也算是打醒了我，我一直以为这样的回溯都能改成记忆化递归。。。这里很明显无法做记忆化，因为你每次回溯的时候index相同，但是visit数组的状态是不一样的，直接记忆化肯定就错了。。。但是说到这里我发现上面的 [357.各个位数不同数字个数](##) 居然这样过了，并且还真的提高了效率。。。。\n\n## [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)\n\n给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。\n\n**示例:**\n\n```java\n输入: S = \"a1b2\"\n输出: [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]\n\n输入: S = \"3z4\"\n输出: [\"3z4\", \"3Z4\"]\n\n输入: S = \"12345\"\n输出: [\"12345\"]\n```\n\n**注意：**\n\n- S 的长度不超过12。\n- S 仅由数字和字母组成。 \n\n**解法一**\n\n一看是简单题，屁颠屁颠就开始搞，结果发现没想象中简单（主要是我太菜了）\n\n```java\nprivate List<String> res=new ArrayList<>();\n\npublic List<String> letterCasePermutation(String S) {\n    letterCasePermutation(S,0,new StringBuilder(S));\n    return res;\n}\n\npublic void letterCasePermutation(String S,int index,StringBuilder cur) {\n    res.add(cur.toString()); //变化一次就添加一次\n    for (int i=index;i<S.length();i++) {\n        char c=S.charAt(i);\n        if (c>='0' && c<='9') {\n            continue;\n        }\n        cur.replace(i,i+1,letterCase(c));\n        letterCasePermutation(S,i+1,cur);\n        cur.replace(i,i+1,letterCase(cur.charAt(i))); //状态重置\n    }\n}\n\n//这里其实有一个小技巧：c^(1<<5)就可以使大写变小写,小写变大写\npublic String letterCase(char c){\n    if (c>='a' && c<='z') { //65:A 97:a\n        c-=32;\n    }else if (c>='A' && c<='Z') {\n        c+=32;\n    }\n    return c+\"\";\n}\n```\n这里的状态重置和之前的不太一样，不过整体还是很好想的，其实也可以完全不用循环的形式\n\n## [1079. 活字印刷](https://leetcode-cn.com/problems/letter-tile-possibilities/)\n\n你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。\n\n**示例 1：**\n\n```java\n输入：\"AAB\"\n输出：8\n解释：可能的序列为 \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\"。\n```\n\n**示例 2：**\n\n```java\n输入：\"AAABBC\"\n输出：188\n```\n\n**提示：**\n\n1. `1 <= tiles.length <= 7`\n2. `tiles` 由大写英文字母组成\n\n**解法一**\n\n这道题还是挺有意思的，有点结合全排列和子集的意思，\n\n```java\npublic int numTilePossibilities(String tiles) {\n    boolean[] visit=new boolean[tiles.length()];\n    char[] cs=tiles.toCharArray();\n    Arrays.sort(cs);\n    numTilePossibilities(cs,visit);\n    return count;\n}\n\nint count=-1;\n\n//排序去重\npublic void numTilePossibilities(char[]cs,boolean[] visit) {\n    count++;\n    for (int i=0;i<cs.length;i++) {\n        //想清楚这里为啥必须是!visit[i-1]\n        if(i>0 && cs[i]==cs[i-1] && !visit[i-1]){ \n            continue;\n        }\n        if (!visit[i]) {\n            visit[i]=true;\n            numTilePossibilities(cs,visit);\n            visit[i]=false;\n        }\n    }\n}\n```\n这题收获比较大，对排列组合类型的题目又多了一层理解，同时也纠正了之前的错误观点\n\n### Bug警告！！！\n\n看一下最开始写的错误解法，唯一的区别就在这个`!visit[i-1]`上！\n\n```java\n if (i>0 && cs[i]==cs[i-1] && visit[i-1])\n```\n\n这里我之前一直理解成了保留第一个分支，上一个元素已经访问过了，后面就直接跳过，做了这一题写出问题了才知道原来这里完全理解反了😂，当时没有仔细想，其实这里细想一下就很容易发现问题，visit数组其实保证的是当前这一条**自上而下的纵向分支内不会有重复位置的元素被选取**，而这里我们**要确保的其实是横向的不重复，也就是同一层内不重复**，所以这里使用`visit[i-1]` 其实从语义上来说就是有问题的，画个图来说明下为啥会有问题\n\n![mark](http://static.imlgw.top/blog/20200625/HekOxo1dFTYw.png?imageslim)\n\n画个递归树，然后模拟一下，其实就明白了，使用`visit[i-1]`的方式，生成的第一个分支其实就不完整了，只有后面的第二个分支才会是完整的，所以**可以理解为保留最后一个分支，将前面的分支剪掉**，在全排列中因为有长度限制，第一个分支并没有达到给定的长度，所以并不会加入结果集，对结果没有影响，（其实是会影响效率的，会重复的遍历分支，这个打印一下生成全排列过程的结果集就能看出来）\n\n但是在这一题，并没有长度的限制，所以count会将第一个不完整的分支也当作结果集算进去，而后面第二个分支的时候（完整分支）又会计算一遍，结果就错了\n\n**那为什么`!visit[i-1]` 就可以呢？**\n\n其实也很好理解，visit虽然保证的是纵向的不重复，但是每遍历完一个分支后，都会回溯状态，而我们又是**按照顺序来遍历元素**的，所以如果上一个元素的 visit[i]是false，那就说明上一个元素的分支已经遍历完了！以它开头的所有排列都找完了，这个时候我们判断是否相等然后跳过，才是真正的保留了第一个分支！后面的直接跳过，减少了多余的操作，同时也不会出现bug，所以你明白以后要用那个了吧😉\n\n## [1291. 顺次数](https://leetcode-cn.com/problems/sequential-digits/)\n\n我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。\n\n请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。\n\n**示例 1：**\n\n```java\n输出：low = 100, high = 300\n输出：[123,234]\n```\n\n\n**示例 2：**\n\n```java\n输出：low = 1000, high = 13000\n输出：[1234,2345,3456,4567,5678,6789,12345]\n```\n\n**提示：**\n\n- 10 <= low <= high <= 10^9 \n\n**解法一**\n\n回溯tag下的，某一次周赛的题，我写的已经不像回溯了，尾递归，有点鸡肋\n\n```java\npublic List<Integer> sequentialDigits(int low, int high) {\n    String slow=String.valueOf(low);\n    int slen=slow.length();\n    int first=Integer.valueOf(slow.charAt(0))-'0'-1;\n    List<Integer> res=new ArrayList<>();\n    int start=first,len=slen;\n    if(first+len>9){\n        start=0;\n        len++;\n    }\n    sequentialDigits(low,high,start,len,res);\n    return res;\n}\n\nprivate String str=\"123456789\";\n\npublic void sequentialDigits(int low,int high,int start,int len,List<Integer> list) {\n    if(start+len>9) return;\n    int cur=Integer.valueOf(str.substring(start,start+len));\n    if(cur>high){\n        return;\n    }\n    if(cur>=low){\n        list.add(cur);\n    }\n    if(start+len==9){\n        sequentialDigits(low,high,0,len+1,list);    \n    }else{\n        sequentialDigits(low,high,start+1,len,list);\n    }\n}\n```\n\n其实直接暴力枚举`1~9`的所有顺序组合然后判断在不在`low~high` 之间就ok了，最再排个序就ok，一共也只有36个，个人感觉我上面的还是比单纯的暴力会好一点，首先不用排序，其次也不会从头开始遍历，会根据low的值来选取从哪里开始截取，但是这题数据量有限，体现不出来差异\n\n## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\n\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n\n例如，给出 `n = 3`，生成结果为：\n\n```java\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n```\n\n**解法一**\n\n哎，知道是回溯还是没做出来，还是太菜了啊\n\n```java\npublic List<String> generateParenthesis(int n) {\n    dfs(n,\"\",0,0);\n    return res;\n}\n\nprivate List<String> res=new LinkedList<>();\n\npublic void dfs(int n,String sb,int left,int right) {\n    if (left>n /*|| right>n*/ || right>left) {\n        return;\n    }\n    if (left==n && right ==n) {\n        res.add(sb.toString());   \n        return;\n    }\n    dfs(n,sb+\"(\",left+1,right);\n    dfs(n,sb+\")\",left,right+1);\n}\n```\n关键还是没想明白这题的递归条件，我知道是先生成 \"(“ 再生成 \")\" 但是终止条件一直没想清楚，其实我们需要给左右括号加一个计数器`left和right`，用来记录已经生成的左右括号的数量，然后我们思考终止条件是啥，首先很容易想到的就是左右括号数量 `left==right` 的时候，这是合法的终止条件，但是这样就够了么？很明显不够，`()))((` 类似这样的就并不是合法的，所以我们还需要保证生成括号的合法性，所以这种时候若是不太清楚的就可以来画一画递归树\n\n![mark](http://static.imlgw.top/blog/20191024/9uvjEQzjtKtf.png?imageslim)\n\n图画的比较魔性，但是还是很容易看懂的，通过这个递归树我还发现了上面代码的一点小问题，`right>n` 是个冗余条件，合法条件 `right< left < n`，right肯定不会超过n，正如上面三个画 ❌的地方就是对应的三个不合法的终止条件，有了这个就可以很容易的写出回溯代码，下面的是用的`StringBuilder`的，需要回溯字符串，更符合回溯的思想，上面的String是不可变对象，所以不需要手动回溯\n\n```java\npublic List<String> generateParenthesis(int n) {\n    dfs(n,new StringBuilder(),0,0);\n    return res;\n}\n\nprivate List<String> res=new LinkedList<>();\n\npublic void dfs(int n,StringBuilder sb,int left,int right) {\n    if (left>n || right>n || right>left) {\n        return;\n    }\n    if (left==n && right ==n) {\n        res.add(sb.toString());\n        return;\n    }\n    dfs(n,sb.append(\"(\"),left+1,right);\n    sb.delete(sb.length()-1,sb.length());\n    dfs(n,sb.append(\")\"),left,right+1);\n    sb.delete(sb.length()-1,sb.length());\n}\n```\n\n## [306. 累加数](https://leetcode-cn.com/problems/additive-number/)\n\n累加数是一个字符串，组成它的数字可以形成累加序列。\n\n一个有效的累加序列必须**至少**包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。\n\n给定一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是累加数。\n\n**说明:** 累加序列里的数不会以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。\n\n**示例 1:**\n\n```java\n输入: \"112358\"\n输出: true \n解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n```\n\n\n**示例 2:**\n\n```java\n输入: \"199100199\"\n输出: true \n解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199\n```\n\n**进阶:**\n\n- 你如何处理一个溢出的过大的整数输入?\n\n**解法一**\n\n在回溯专题里翻到的，说实话，case有点恶心\n\n```java\npublic boolean isAdditiveNumber(String num) {\n    LinkedList<String> list=new LinkedList<>();\n    list.add(\"-1\");\n    list.add(\"-1\");\n    return dfs(num,0,list);\n}\n\npublic boolean dfs(String num,int index,List<String> list) {\n    //System.out.println(list);\n    if (index==num.length() && list.size()>4) {\n        return true;\n    }\n    for(int i=index+1;i<=num.length();i++){\n        //0开头应该直接break,除非是单独的0....\n        if (num.charAt(index)=='0' && i>index+1) { //\"101\" .....\n            break;\n        }\n        //剪枝\n        if (i-index>num.length()/2) {\n            return false;\n        }\n        String sub=num.substring(index,i);\n        String a=list.get(list.size()-1);\n        String b=list.get(list.size()-2);\n        list.add(sub);\n        if ((\"-1\".equals(a)||\"-1\".equals(b) || addTwoStr(a,b).equals(sub)) && dfs(num,i,list)) {\n            return true;\n        }\n        list.remove(list.size()-1);\n    }\n    return false;\n}\n\n//大数相加\nprivate String addTwoStr(String a,String b){\n    StringBuilder res=new StringBuilder();\n    int aIdx=a.length()-1;\n    int bIdx=b.length()-1;\n    int temp=0; //进位\n    while(aIdx>=0 || bIdx>=0) {\n        int as=aIdx>=0?a.charAt(aIdx)-48:0;\n        int bs=bIdx>=0?b.charAt(bIdx)-48:0;\n        int sum=as+bs+temp;\n        temp=(sum)/10;\n        res.append(sum%10);\n        aIdx--;bIdx--;\n    }\n    if (temp==1) {\n        res.append(1);\n    }\n    return res.reverse().toString();\n}\n```\n\n回溯不难想到，这一类回溯咋说呢，属于 “一镜到底” 的那种，可以看看解数独的哪个解法，也是这样的（其实就是参考的那个）带一个boolean返回值，走到结尾走不通才会回溯，N皇后这种就不太一样，不管是否成功都会回溯，反正目前大致的感觉就是这样，后面遇到更多题型再来总结\n\n不过感觉这题的关键不是回溯，而是边界的处理，首先是溢出的问题，我看见有进阶的就没考虑溢出，结果还是溢出了，而且溢出了两次！！！最后没办法，也不想用`BigInteger`就自己写了大数相加的逻辑\n\n除了溢出的问题，这题需要注意 `0 ` 在这个`0` 上也WA了一发，因为回溯还是在分割字符串，但是如果有0的话就不能随便的分割了，具体看代码就懂了\n\n## [842. 将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/)\n\n给定一个数字字符串 S，比如 S = \"123456579\"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。\n\n形式上，斐波那契式序列是一个非负整数列表 F，且满足：\n\n- 0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；\n- F.length >= 3；\n- 对于所有的0 <= i < F.length - 2，都有 `F[i] + F[i+1] = F[i+2]` 成立。\n\n另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。\n\n返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 `[]`。\n\n**示例 1：**\n\n```java\n输入：\"123456579\"\n输出：[123,456,579]\n```\n\n\n**示例 2：**\n\n```java\n输入: \"11235813\"\n输出: [1,1,2,3,5,8,13]\n```\n\n**示例 3：**\n\n```jsvs\n输入: \"112358130\"\n输出: []\n解释: 这项任务无法完成。\n```\n\n**示例 4：**\n\n```java\n输入：\"0123\"\n输出：[]\n解释：每个块的数字不能以零开头，因此 \"01\"，\"2\"，\"3\" 不是有效答案。\n```\n\n\n**示例 5：**\n\n```java\n输入: \"1101111\"\n输出: [110, 1, 111]\n解释: 输出 [11,0,11,11] 也同样被接受。\n```\n\n\n**提示：**\n\n- `1 <= S.length <= 200`\n- 字符串 S 中只含有数字。\n\n**解法一**\n\n和上面那题一样，但是这题会简单一点，不用处理大数相加的情况，同时限定了数字的范围就是32位int，所以只要范围超过了int32就直接break\n\n```java\npublic List<Integer> splitIntoFibonacci(String S) {\n    LinkedList<Integer> res=new LinkedList<>();\n    dfs(S,0,res);\n    return res;\n}\n\npublic boolean dfs(String S,int index,List<Integer> lis){\n    if (index == S.length()) {\n        return lis.size()>2;\n    }\n    for (int i=index+1;i<=S.length();i++) {\n        String temp=S.substring(index,i);\n        //长度大于10,或者Long解析出来大于INT_MAX了就直接break\n        if (S.charAt(index) == '0' && i>index+1 || temp.length()>10 || Long.valueOf(temp)>Integer.MAX_VALUE) {\n            break;\n        }\n        int str=Integer.valueOf(temp);\n        int one=lis.size()>=2 ? lis.get(lis.size()-1):-1;\n        int two=lis.size()>=2 ? lis.get(lis.size()-2):-1;\n        lis.add(str);\n        if ((one==-1 || two==-1 || one+two==str) && dfs(S,i,lis)) {\n            return true;\n        }\n        lis.remove(lis.size()-1);\n    }\n    return false;\n}\n```\n\n## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n**说明：**\n\n- 拆分时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n\n**示例 1：**\n\n```java\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n\n\n**示例 2：**\n\n```java\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n\n\n**示例 3：**\n\n```java\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n**解法一**\n\n回溯DFS+记忆化\n\n```java\nBoolean[] cache=null;\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    if (s==null || s.length()<=0) {\n        return false;\n    }\n    cache=new Boolean[s.length()];\n    HashSet<String> set=new HashSet<>(wordDict);\n    return dfs(s,set,0);\n}\n\n//判断【index,s.len】中的字符是否能拆分\npublic boolean dfs(String s, HashSet<String> dict,int index) {\n    //这里的终止条件还是有点迷惑的,这里index只有在字典中存在当前元素的时候才会向后移动\n    //所以当index移动到s==length的是偶就说明前面的单词都匹配上了\n    if (index==s.length()) {\n        return true;\n    }\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    for (int i=index+1;i<=s.length();i++) {\n        //System.out.println(s.substring(index,i));\n        if (dict.contains(s.substring(index,i)) && dfs(s,dict,i)){\n            return cache[index]=true;\n        }\n    }\n    return cache[index]=false;\n}\n```\n\n很久之前做的题目，在做这题进阶版的时候发现这一题做了但是没有记录。。。可能是忘了\n\n这里回溯记忆化没啥好说的，也是属于那种 “一镜到底” 类型的\n\n**解法二**\n\nBFS\n\n```java\n//BFS,需要一个visit保证不会重复访问\npublic boolean wordBreak(String s, List<String> wordDict) {\n    if (s==null || s.length()<=0) {\n        return false;\n    }\n    HashSet<String> dict=new HashSet<>(wordDict);\n    //queue中存index\n    LinkedList<Integer> queue=new LinkedList<>();\n    boolean[] visit=new boolean[s.length()];\n    queue.add(0);\n    while(!queue.isEmpty()){\n        int index=queue.poll();\n        if (!visit[index]) {\n            for (int i=index+1;i<=s.length();i++) {\n                if(dict.contains(s.substring(index,i))){\n                    if (i==s.length()) {\n                        return true;\n                    }\n                    queue.add(i);\n                }\n            }\n            visit[index]=true;\n        }\n    }\n    return false;\n}\n```\n\n自己写的居然一点印象都没有，BFS感觉也没啥好说的\n\n**解法三**\n\n动态规划，这个当时没有写出来，今天重新看的时候发现有dp的tag就写了一下，还是挺简单的\n\n```java\npublic boolean wordBreak(String s, List<String> wordDict) {\n    if (s==null || s.length()<=0) {\n        return false;\n    }\n    HashSet<String> dict=new HashSet<>(wordDict);\n    boolean[] dp=new boolean[s.length()+1];\n    dp[0]=true;\n    for (int i=1;i<=s.length();i++) {\n        for (int j=0;j<=i;j++) {\n            if (dp[j] && dict.contains(s.substring(j,i))) {\n               dp[i]=true; //相比上面的可以break\n               break;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n```\n## [140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)\n\n给定一个**非空**字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。\n\n**说明：**\n\n- 分隔时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n\n**示例 1：**\n\n```java\n输入:\ns = \"catsanddog\"\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\n输出:\n[\n  \"cats and dog\",\n  \"cat sand dog\"\n]\n```\n\n**示例 2：**\n\n```java\n输入:\ns = \"pineapplepenapple\"\nwordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n输出:\n[\n  \"pine apple pen apple\",\n  \"pineapple pen apple\",\n  \"pine applepen apple\"\n]\n解释: 注意你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```java\n输入:\ns = \"catsandog\"\nwordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出:\n[]\n```\n\n**解法一**\n\n这题要求出所有的序列，所以dp肯定是不好整了，直接上回溯\n\n```java\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict=new HashSet<>(wordDict);\n    dfs(s,0,\"\",dict);\n    return res;\n}\n\nprivate List<String> res=new ArrayList<>();\n\npublic void dfs(String s,int index,String word,HashSet<String> dict){\n    if (index==s.length()) {\n        res.add(word.substring(0,word.length()-1));\n        return;\n    }\n    for (int i=index+1;i<=s.length();i++) {\n        String str=s.substring(index,i);\n        if (dict.contains(str)) {\n            //word.append(str+\" \"); // app#pa# \n            dfs(s,i,word+str+\" \",dict);\n            //word.delete(word.length()-(i-),i);\n        }\n    }\n}\n```\n\n很可惜，超时了，卡在了aaaaaaaa....那个case上，翻了评论区，发现很多人借用了上一题的解法，先对整个s做可行性分析，也就是看能不能拆分，能拆分然后再进行回溯，这样就刚好跳过了那个case，好像确实是可以过，但是我感觉有点面向case编程了。。。\n\n**解法二**\n\n记忆化回溯，上面的过程分析一下会发现其实有很多的重复计算，所以我们可以有针对性的做记忆化，加快搜索速度\n\n```java\n//做记忆化\nHashMap<String,List<String>> cache=new HashMap<>();\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict=new HashSet<>(wordDict);\n    return dfs(s,dict);\n}\n\npublic List<String> dfs(String s,HashSet<String> dict){\n    if (cache.containsKey(s)) {\n        return cache.get(s);\n    }\n    List<String> res=new ArrayList<>();\n    if (s.length()==0) {\n        return res;\n    }\n    for (int i=0;i<=s.length();i++) {\n        String word=s.substring(0,i);\n        if (dict.contains(word)) {\n            if (i==s.length()) {\n                res.add(word);\n            }else{\n                //剩余字符\n                List<String> temp=dfs(s.substring(i,s.length()),dict);\n                for (String tmp:temp) {\n                    res.add(word+\" \"+tmp);\n                }\n            }\n        }\n    }\n    cache.put(s,res);\n    return res;\n}\n```\n\n其实我这里也是参考了评论区的解法，我上面的那种回溯的方式要改成记忆化有点不好搞，有两个变量，另外我感觉这种**回溯分割**的方式感觉更加的直观易懂 get\n\n**UPDATE: 2020.7.8**\n\n偶然看到这个题，重写了一下，直接记忆化\n```golang\n//记忆化递归\nfunc wordBreak(s string, wordDict []string) []string {\n    var set = make(map[string]bool)\n    var cache = make(map[string][]string)\n    for i := 0; i < len(wordDict); i++ {\n        set[wordDict[i]] = true\n    }\n    return dfs(s, set, cache)\n}\n\nfunc dfs(s string, set map[string]bool, cache map[string][]string) []string {\n    if _, ok := cache[s]; ok {\n        return cache[s]\n    }\n    var res []string\n    for i := 1; i <= len(s); i++ {\n        if set[s[:i]] {\n            if i == len(s) {\n                res = append(res, s[:i])\n            } else {\n                temp := dfs(s[i:], set, cache)\n                for _, w := range temp {\n                    res = append(res, s[:i]+\" \"+w)\n                }\n            }\n        }\n    }\n    cache[s] = res\n    return res\n}\n\n```\n\n## [473. 火柴拼正方形](https://leetcode-cn.com/problems/matchsticks-to-square/)\n\n还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。\n\n输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。\n\n**示例 1:**\n\n```java\n输入: [1,1,2,2,2]\n输出: true\n\n解释: 能拼成一个边长为2的正方形，每边两根火柴。\n```\n\n**示例 2:**\n\n```java\n输入: [3,3,3,3,4]\n输出: false\n\n解释: 不能用所有火柴拼成一个正方形。\n```\n\n**注意:**\n\n1. 给定的火柴长度和在 `0` 到 `10^9`之间。\n2. 火柴数组的长度不超过15。\n\n**解法一**\n\n```java\n//等价于能否将nums分为4等分\npublic boolean makesquare(int[] nums) {\n    if(nums==null || nums.length<4){\n        return false;\n    }\n    int N=nums.length;\n    int sum=0;\n    for(int i=0;i<N;i++){\n        sum+=nums[i];\n    }\n    if(sum%4!=0) return false;\n    int[] side=new int[4];\n    Arrays.sort(nums);\n    return dfs(nums,N-1,side,sum/4);\n}\n\npublic boolean dfs(int[] nums,int index,int[] side,int avg){\n    if(index==-1){\n        return true;\n    }\n    for(int i=0;i<side.length;i++){\n        //if(side[i]+nums[index]<=avg){\n        int rest=avg-side[i]-nums[index];\n        if(rest==0 || rest>=nums[0]){ //改进剪枝方式\n            side[i]+=nums[index];\n            if(dfs(nums,index-1,side,avg)){\n                return true;\n            }\n            side[i]-=nums[index];\n        }\n    }\n    return false;\n}\n```\n一开始没想到分桶的做法，只想着这么搜索4等分，看了一眼评论区就明白了，抽象出4条边，然后遍历所有火柴，尝试将火柴放入所有的盒子，看有没有一种可能是4等分的，说白了其实就是暴力搜索，然后加上一点剪枝优化，这题就不细说了，关键看下面这题\n\n## [698. 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)\n\n给定一个整数数组  `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。\n\n**示例 1：**\n\n```java\n输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n输出： True\n说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。\n```\n\n**注意:**\n\n- `1 <= k <= len(nums) <= 16`\n- `0 < nums[i] < 10000`\n\n**解法一**\n\n[473. 火柴拼正方形](#473-火柴拼正方形)其实只是这道题的一个子问题，关键搞懂这题就行了\n\n```java\npublic boolean canPartitionKSubsets(int[] nums, int k) {\n    if(nums==null || nums.length<=0){\n        return false;\n    }\n    int sum=0;\n    for(int i=0;i<nums.length;i++){\n        sum+=nums[i];\n    }\n    if(sum%k!=0) return false;\n    Arrays.sort(nums);\n    return dfs(nums,nums.length-1,new int[k],sum);\n}\n\npublic boolean dfs(int[] nums,int index,int[] bucket,int sum){\n    //sum(bucket)==sum\n    //if条件: bucket[i]<=sum/bucket.len => bucket[i]<=sum(bucket)/bucket.len\n    //所以不用单独去判断是否都相等,直接retuen true\n    if(index==-1){\n        return true;\n    }\n    for(int i=0;i<bucket.length;i++){\n        //普通的剪枝 60ms，只判断了是否小于平均值\n        //if(bucket[i]+nums[index]<=sum/bucket.length){\n        //更好的剪枝方式1ms，判断剩余空间不为0的时候还能不能填其他元素\n        int rest=sum/bucket.length-bucket[i]-nums[index];\n        if(rest==0 || rest>=nums[0]){ //小于nums[0]就啥也填不了了\n            bucket[i]+=nums[index];\n            if(dfs(nums,index-1,bucket,sum)){\n                return true;\n            }\n            bucket[i]-=nums[index];\n        }\n    }\n    return false;\n}\n```\n\n其实总体上来说还是暴力的搜索，然后加上一些剪枝优化的手段，首先能想到的是**约束桶内元素和要小于等于`sum/k`**，这样就能减去很多无效搜索，但是仅仅这样还是无法AC这题，还有一步很关键的优化点是**排序**，排序后我们从大往小搜索，也就是优先将大的元素放入桶中，尽快满足if条件，经过上面的优化就可以成功的AC了，耗时60ms左右，但是看了评论区的大佬的解法后发现还有一种更好的剪枝方式，就是考虑放下当前元素后还能不能放下其他的元素，如果刚好放下就直接放，如果放下后还有剩余空间，且这个剩余空间很小，连`nums[0]`都放不下（前面排序了）那么这种情况也是可以直接剪掉的，时间优化到1ms\n\n> `index==-1`为什么就直接返回true了？简单推一下就行了\n>\n> 首先`index==-1`说明所有元素都已经放入`bucket`中了，所以`sum(bucket)=sum(nums)`\n>\n> 再来看我们的if条件：约束桶内元素小于等于`sum/k`，也就是`bucket[i]<=sum(nums)/k` 借助上面的结论，转换一下就是 `bucket[i]<=sum(bucket)/k`也就是`bucket[i]<=avg(bucket)`很明显，只有在每个桶内元素都相等的时候才成立，故这里可以直接返回true\n\n**解法二**\n\n官方提供了一个状压的方法，但是没看懂，自己试着压了下没过，懒得去研究了\n\n## [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)\n\nDifficulty: **中等**\n\n\n给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。\n\n**示例:**\n\n```\n输入: [4, 6, 7, 7]\n输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n```\n\n**说明:**\n\n1.  给定数组的长度不会超过15。\n2.  数组中的整数范围是 [-100,100]。\n3.  给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。\n\n**解法一**\n\n感觉今天晚上状态不太好，好久没写回溯了，写了几发思路都有问题，最后瞄了一眼评论区才反应过来，和上面[842-将数组拆分成斐波那契序列](#842-将数组拆分成斐波那契序列)很类似，都是利用lis数组上次存值判断，当时这题还是我独立写出来的，写完发的code评论还是个热评，今天写这题居然没反应过来，太菜了😥\n```golang\nfunc findSubsequences(nums []int) [][]int {\n    var n = len(nums)\n    var res [][]int\n    var dfs func(int, []int)\n    dfs = func(index int, lis []int){\n        if len(lis) >= 2{\n            dest := make([]int, len(lis))\n            copy(dest, lis)\n            res = append(res, dest)\n        }\n        //保证一次for循环中没有重复的就行了，根据取值范围做下偏移\n        var visit = make([]bool, 201)\n        for i := index; i < n; i++{\n            if !visit[nums[i]+100] && (len(lis) == 0 || nums[i] >= lis[len(lis)-1]) {\n                visit[nums[i]+100] = true\n                lis = append(lis, nums[i])\n                dfs(i+1, lis)\n                lis = lis[:len(lis)-1]\n            }\n        }\n    }\n    dfs(0, make([]int, 0))\n    return res\n}\n```\n\n## [679. 24 点游戏](https://leetcode-cn.com/problems/24-game/)\n\nDifficulty: **困难**\n\n\n你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 `*`，`/`，`+`，`-`，`(`，`)` 的运算得到 24。\n\n**示例 1:**\n\n```go\n输入: [4, 1, 8, 7]\n输出: True\n解释: (8-4) * (7-1) = 24\n```\n\n**示例 2:**\n\n```go\n输入: [1, 2, 1, 2]\n输出: False\n```\n\n**注意:**\n\n1.  除法运算符 `/` 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。\n2.  每个运算符对两个数进行运算。特别是我们不能用 `-` 作为一元运算符。例如，`[1, 1, 1, 1]` 作为输入时，表达式 `-1 - 1 - 1 - 1` 是不允许的。\n3.  你不能将数字连接在一起。例如，输入为 `[1, 2, 1, 2]` 时，不能写成 12 + 12 。\n\n**解法一**\n\n代码有点长，不过思路还是很清楚，一共4个数字，从里面任意选2个，然后做各种运算后和剩下的数字构成新的数组，然后重复该过程直到数组只剩下一个然后判断值是否是24（注意精度）\n```golang\nfunc judgePoint24(nums []int) bool {\n    var eps float32 = 1e-5\n    var Abs = func(a float32) float32 {\n        if a < 0 {\n            return -a\n        }\n        return a\n    }\n    //计数+-*/\n    var compute = func(a, b float32) []float32 {\n        return []float32{a + b, a * b, a - b, a / b}\n    }\n    var dfs func([]float32) bool\n    dfs = func(nums []float32) bool {\n        if len(nums) == 0 {\n            return false\n        }\n        if len(nums) == 1 {\n            return Abs(nums[0]-24) < eps\n        }\n        var n = len(nums)\n        //从nums中选取2个数\n        for i := 0; i < n; i++ {\n            for j := 0; j < n; j++ {\n                if i == j {\n                    continue\n                }\n                //收集剩下的数字\n                var rest []float32\n                for k := 0; k < n; k++ {\n                    if k != i && k != j {\n                        rest = append(rest, nums[k])\n                    }\n                }\n                //尝试做各种运算\n                for _, v := range compute(nums[i], nums[j]) {\n                    if dfs(append(rest, v)) {\n                        return true\n                    }\n                }\n            }\n        }\n        return false\n    }\n    var temp = make([]float32, len(nums))\n    for i := 0; i < len(nums); i++ {\n        temp[i] = float32(nums[i])\n    }\n    return dfs(temp)\n}\n```\n\n## [5526. 最多可达成的换楼请求数目](https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/)\n\nDifficulty: **困难**\n\n\n我们有 `n` 栋楼，编号从 `0` 到 `n - 1` 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。\n\n给你一个数组 `requests` ，其中 requests[i] = [from<sub style=\"display: inline;\">i</sub>, to<sub style=\"display: inline;\">i</sub>] ，表示一个员工请求从编号为from<sub style=\"display: inline;\">i</sub> 的楼搬到编号为 to<sub style=\"display: inline;\">i</sub>的楼。\n\n一开始 **所有楼都是满的**，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 **离开** 的员工数目 **等于** 该楼 **搬入** 的员工数数目。比方说 `n = 3` 且两个员工要离开楼 `0` ，一个员工要离开楼 `1` ，一个员工要离开楼 `2` ，如果该请求列表可行，应该要有两个员工搬入楼 `0` ，一个员工搬入楼 `1` ，一个员工搬入楼 `2` 。\n\n请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。\n\n**示例 1：**\n\n![0AZHr8.png](https://s1.ax1x.com/2020/09/27/0AZHr8.png)\n\n```go\n输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n输出：5\n解释：请求列表如下：\n从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。\n从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 0 。\n从楼 3 离开的员工为 c ，且他想要搬到楼 4 。\n没有员工从楼 4 离开。\n我们可以让 x 和 b 交换他们的楼，以满足他们的请求。\n我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。\n所以最多可以满足 5 个请求。\n```\n\n**示例 2：**\n\n![0AZLVg.png](https://s1.ax1x.com/2020/09/27/0AZLVg.png)\n\n```go\n输入：n = 3, requests = [[0,0],[1,2],[2,1]]\n输出：3\n解释：请求列表如下：\n从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。\n从楼 1 离开的员工为 y ，且他想要搬到楼 2 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 1 。\n我们可以满足所有的请求。\n```\n\n**示例 3：**\n\n```go\n输入：n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n输出：4\n```\n\n**提示：**\n\n*   1 <= n <= 20\n*   1 <= requests.length <= 16\n*   requests[i].length == 2\n*   0 <= from<sub style=\"display: inline;\">i</sub>, to<sub style=\"display: inline;\">i</sub> < n\n\n\n**解法一**\n\n208周赛T4，有点白给，想好怎么处理就很简单（好不容易T4这么简单，被T2，T3给干懵了）\n```java\nclass Solution {\n    public int maximumRequests(int n, int[][] requests) {\n        int[] nums = new int[n+1];\n        dfs(nums, 0, requests, 0);\n        return res;\n    }\n    \n    int res = 0;\n    \n    public void dfs(int[] nums, int idx, int[][] requests, int count){\n        if (check(nums)) {\n            res = Math.max(res, count);\n        }\n        for (int i = idx; i < requests.length; i++) {\n            nums[requests[i][0]]--;\n            nums[requests[i][1]]++;\n            dfs(nums, i+1, requests, count+1);\n            nums[requests[i][0]]++;\n            nums[requests[i][1]]--;\n        }\n    }\n    \n    public boolean check(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n## _二维平面上的回溯_\n\n## [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)\n\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n**示例:**\n\n```java\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\n给定 word = \"ABCCED\", 返回 true.\n给定 word = \"SEE\", 返回 true.\n给定 word = \"ABCB\", 返回 false.\n```\n\n**解法一**\n\n这题其实并不难，但是我一开始就钻到死胡里去了，我直接拿起来就想的是暴力dfs从（0，0）开始遍历每种情况，直到找到一个相等的。。。我真是个hapi\n\n```java\n/*\n    board =\n    [\n      ['A','B','C','E'],\n      ['S','F','C','S'],\n      ['A','D','E','E']\n    ]\n     */\n\n//方向: 右,下,左,上\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic boolean exist(char[][] board, String word) {\n    if (board==null || word==null) {\n        return false;\n    }\n    char[] words=word.toCharArray();\n    boolean[][] visit=new boolean[board.length][board[0].length];\n    for (int i=0;i<board.length;i++) {\n        for (int j=0;j<board[0].length;j++) {\n            //遍历board每个元素,以为个元素为起点都试一下\n            if(dfs(board,words,0,i,j,visit)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\npublic boolean dfs(char[][] board, char[] word,int index,int x,int y,boolean[][] visit) {\n    //遍历到word的最后一个字符了,直接比较就可以得出结果\n    if (index == word.length-1) {\n        return word[index] == board[x][y];\n    }\n    /*\n     这样写如果board只有一个元素就会错了,后面的isValid会直接false,但是有可能word就是这个board\n     if (index == word.length) {\n            return true;\n     }*/\n    \n    //当元素相等的时候才有继续的必要\n    if (board[x][y]==word[index]) {\n        visit[x][y]=true;\n        for (int i=0;i<direction.length;i++) {\n            int nx=x+direction[i][0];\n            int ny=y+direction[i][1];\n            //保证合法性\n            if (isValid(board,nx,ny)&&!visit[nx][ny]&&dfs(board,word,index+1,nx,ny,visit)) {\n                return true;\n            }\n        }\n        visit[x][y]=false;\n    }\n    return false;\n}\n\npublic boolean isValid(char[][] cs,int x,int y){\n    return x>=0 && x<cs.length && y >=0 && y< cs[0].length;\n}\n```\n## [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)\n\n给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围\n\n**示例 1:**\n\n```java\n输入:\n11110\n11010\n11000\n00000\n\n输出: 1\n```\n\n**示例 2:**\n\n```java\n输入:\n11000\n11000\n00100\n00011\n\n输出: 3\n```\n\n**解法一**\n\n和上面一题类似，很惭愧，一开始也没写出来，写了个大概，细节没有捋清楚\n\n```java\n//方向: 右,下,左,上\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic int numIslands(char[][] grid) {\n    if (grid==null||grid.length<=0) {\n        return 0;\n    }\n    boolean[][] visit=new boolean[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            if (grid[i][j]=='1'&&!visit[i][j]) {\n                dfs(grid,i,j,visit);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nprivate int res=0;\n\npublic void dfs(char[][] grid,int x,int y,boolean[][] visit) {\n    //其实整个dfs做的就是对visit[x][y]标记,标记为true代表访问过\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]=='1') {\n            dfs(grid,nx,ny,visit);\n            //无需回溯visit状态\n        }\n    }\n}\n\npublic boolean isValid(final char[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n} \n```\n## [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)\n\n给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。\n\n找到所有被 'X' 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。\n\n**示例:**\n\n```java\nX X X X\nX O O X\nX X O X\nX O X X\n```\n\n\n运行你的函数后，矩阵变为：\n\n```java\nX X X X\nX X X X\nX X X X\nX O X X\n```\n\n**解释:**\n\n被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的\n\n**解法一**\n\n这题在很久以前（看了提交记录是一年前的）开始学dfs的时候，在leetcode搜索到了这一题，当时也做出来了，只不过效率感人，放上来看看是个啥玩意\n\n```java\n// 定义4个方向（顺时针 右...）\nprivate static int[][] direction = { { 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 } };\n\nprivate static int[][] mark = null;\n\npublic static void solve(char[][] board) {\n    if(board.length==0) { return; }\n    // 根据传进来的board给mark初始化\n    mark = new int[board.length][board[0].length];\n    // 遍历边缘找出边缘的 O 的坐标\n    for (int i = 0; i < board.length; i++) {\n        if (board[i][0] == 'O') {\n            dfs(0, i, board);\n            //执行完之后再赋值当前位置的O 避免在边缘角落的问题\n            mark[i][0] = 1;\n        }\n        if (board[i][board[0].length - 1] == 'O') {\n            dfs(board[0].length, i, board);\n            mark[i][board[0].length - 1] = 1;\n        }\n    }\n    // 上边缘\n    for (int i = 0; i < board[0].length; i++) {\n        if (board[0][i] == 'O') {\n            dfs(i, 0, board);\n            mark[0][i] = 1;\n        }\n    }\n    // 下边缘\n    for (int i = 0; i < board[0].length; i++) {\n        if (board[board.length - 1][i] == 'O') {\n            dfs(i, board.length - 1, board);\n            mark[board.length - 1][i] = 1;\n        }\n    }\n\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (board[i][j] == 'O' && mark[i][j] == 0) {\n                board[i][j] = 'X';\n            }\n        }\n    }\n\n}\n\n// 实现函数\npublic static void dfs(int x, int y, char[][] board) {\n    int tx, ty;\n    // 首先判断边缘上有没有 O 有的话将与他联通的 O 都加上标记\n    for (int i = 0; i <= 3; i++) {\n        // x=x+direction[i][0]; 这样写每个点向4个方向扩展如果这样写 点的走向就有问题了\n        tx = x + direction[i][0];\n        ty = y + direction[i][1];\n        // System.out.println(tx+\" \"+ty);\n        if (tx < board[0].length && tx >= 0 && ty < board.length && ty >= 0 && board[ty][tx] == 'O'\n            && mark[ty][tx] == 0) {\n            // 代表走过了\n            mark[ty][tx] = 1;\n            // 这里没有处理好，我的dfs函数的参数是坐标但是对应到mark里面和board里面就不是坐标了就颠倒了\n            // 比如按照坐标来 2 , 1 ---->对应到数组里面就是 1 ，2\n            dfs(tx, ty, board);\n        }\n    }\n    return;\n}\n```\n21ms，8% 乍一看好像没啥问题，但是为啥这么慢呢？看看今天下午重新做的解\n\n**解法二**\n\n```java\n//方向: 右,下,左,上\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic void solve(char[][] board) {\n    if (board==null || board.length<=0) {\n        return;\n    }\n    boolean[][] visit=new boolean[board.length][board[0].length];\n    int lx=0,ly=0;\n\n    //遍历4条边的'O',将与相连的'O'都标记为true\n    while(lx<board.length) { \n        if (board[lx][0]=='O') { //左\n            dfs(board,lx,0,visit);\n        }\n        if (board[lx][board[0].length-1] == 'O') { //右\n            dfs(board,lx,board[0].length-1,visit);\n        }\n        lx++;\n    }\n\n    while(ly<board[0].length) { \n        if (board[0][ly]=='O') { //上\n            dfs(board,0,ly,visit);\n        }\n        if (board[board.length-1][ly] == 'O') { //下\n            dfs(board,board.length-1,ly,visit);   \n        }\n        ly++;\n    }\n\n    //遍历将所有visit=false的O变为X\n    for (int i=0;i<board.length;i++) {\n        for (int j=0;j<board[0].length;j++) {\n            if (board[i][j]=='O' && !visit[i][j]) {\n                board[i][j]='X';\n            }\n        }\n    }\n}\n\npublic void dfs(char[][] board,int x,int y,boolean[][] visit) {\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(board,nx,ny) && board[nx][ny]=='O' && !visit[nx][ny]) {\n            dfs(board,nx,ny,visit);\n        }\n    }\n}\n\n//是否合法\npublic boolean isValid(final char[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n2ms，比较明显的区别就是dfs给visit数组赋值的时机不同，一个是在循环里面，一个是在函数开头，也就是说第一种解法并不会立即给边缘的`'O'` 标记，这样导致的问题就是它后续的节点仍然会搜索到这个边缘的 `'O'` 这样就会造成重复的计算，所以说，一定要捋清楚这个过程，不能乱写\n\n## [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)\n\n给定一个 `m x n` 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。\n\n规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。\n\n请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标\n\n**提示：**\n\n1. 输出坐标的顺序不重要\n\n2. m 和 n 都小于150\n\n**示例：**\n\n```java\n给定下面的 5x5 矩阵:\n\n  太平洋 ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * 大西洋\n\n返回:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).\n```\n\n**解法一**\n\n其实和上面也是如出一辙，只不过最开始没想到两个visit数组来做\n\n```java\n//方向键\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic List<List<Integer>> pacificAtlantic(int[][] matrix) {\n    List<List<Integer>> res=new ArrayList<>();\n    //leetcode老是喜欢搞些幺蛾子\n    if (matrix==null || matrix.length<=0) {\n        return res;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    //太平洋\n    boolean[][] pacific=new boolean[m][n];\n    //大西洋\n    boolean[][] atlantic=new boolean[m][n];\n\n    for (int i=0;i<m;i++) {\n        dfs(matrix,i,0,pacific);\n        dfs(matrix,i,n-1,atlantic);\n    }\n\n    for (int i=0;i<n;i++) {\n        dfs(matrix,0,i,pacific);\n        dfs(matrix,m-1,i,atlantic);\n    }\n    for (int i=0;i<m;i++) {\n        for (int j=0;j<n;j++) {\n            //同时为true的就是解\n            if (pacific[i][j] && atlantic[i][j]) {\n                res.add(Arrays.asList(i,j));\n            }\n        }\n    }\n    return res;\n}\n\npublic void dfs(int[][] matrix,int x,int y,boolean[][] visit) {\n    visit[x][y]=true;\n    //向4个方向floodfill\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(matrix,nx,ny) && matrix[nx][ny]>= matrix[x][y] && !visit[nx][ny]) {\n            dfs(matrix,nx,ny,visit);\n        }\n    }\n}\n\npublic boolean isValid(final int[][] matrix,int x,int y){\n    return x>=0 && x<matrix.length && y>=0 && y<matrix[0].length;\n}\n```\n6ms，96%，还是比较ok的\n\n## [51. N皇后](https://leetcode-cn.com/problems/n-queens/)\n\n*n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击\n\n![mark](http://static.imlgw.top/blog/20191011/ac4lTcAFesSc.png?imageslim)\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 ' . ' 分别代表了皇后和空位。\n\n**示例:**\n\n```java\n输入: 4\n输出: [\n [\".Q..\",  // 解法 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n解释: 4 皇后问题存在两个不同的解法\n```\n\n**解法一**\n\nHard题，N皇后问题可以说是很经典的问题了，之前有看过，但是都是一脸懵逼，无从下手，这一次看了下提示还是自己给做出来了\n\n```java\nprivate List<List<String>> res=new ArrayList<>();\n\nprivate boolean[] col;\n//private boolean[] row;\n//两条对角线\nprivate boolean[] dia1;\nprivate boolean[] dia2;\n\npublic List<List<String>> solveNQueens(int n) {\n    if (n<=0) return res;\n    col=new boolean[n];\n    //row=new boolean[n];\n    dia1=new boolean[2*n-1];\n    dia2=new boolean[2*n-1];\n    dfs(n,0,new ArrayList());\n    return res;\n}\n\n//dfs\npublic void dfs(int n,int index,List<Integer> lis) {\n    if (index==n) {\n        res.add(generateRes(lis));\n        return;\n    }\n    //检测第index行第i列\n    for (int i=0;i<n;i++) {\n        //注意对角线的下标\n        if (!col[i] && !dia1[index-i+n-1] && !dia2[i+index]) {\n            col[i]=true;\n            dia1[index-i+n-1]=true;\n            dia2[index+i]=true;\n            //尝试添加\n            lis.add(i);\n            dfs(n,index+1,lis);\n            //回溯\n            lis.remove(lis.size()-1);\n            col[i]=false;\n            dia1[index-i+n-1]=false;\n            dia2[index+i]=false;\n        }\n    }\n}\n\n//根据lis生成解\npublic List<String> generateRes(List<Integer> lis){\n    List<String> res=new ArrayList<>();\n    for (int i=0;i<lis.size();i++) {\n        int index = lis.get(i);\n        StringBuilder sb=new StringBuilder();\n        for (int j=0;j<lis.size();j++) {\n            if (j!=index){\n                sb.append(\".\");\n            }else{\n                sb.append(\"Q\");\n            }\n        }\n        res.add(sb.toString());\n    }\n    return res;\n}\n```\n核心思路就是：一行行遍历，然后dfs尝试在每个位置放置皇后，我觉得主要的难点在于如何判断各个列，对角线是否已经有皇后，这一点需要细致的观察，有一条对角线的横纵坐标之和为常数，另一条横纵坐标之差是个常数，借此便可以唯一确定一条对角线\n\n## [52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)\n\n和上面一题不同的地方是这题只需要求解的个数，感觉这题才应该是`Ⅰ`，不用求所有的解，貌似更加简单了？\n\n**解法一**\n\n直接套用上面的代码，没啥好说的\n\n```java\npublic int totalNQueens(int n) {\n    res=0;\n    if (n<=0) return 0;\n    col=new boolean[n];\n    //row=new boolean[n];\n    dia1=new boolean[2*n-1];\n    dia2=new boolean[2*n-1];\n    dfs(n,0,new ArrayList());\n    return res;\n}\n\nprivate int res=0;\n\nprivate boolean[] col;\nprivate boolean[] dia1;\nprivate boolean[] dia2;\n\n//dfs\npublic void dfs(int n,int index,List<Integer> lis) {\n    if (index==n) {\n        res++;\n        return;\n    }\n    //检测第index行第i列\n    for (int i=0;i<n;i++) {\n        if (!col[i] && !dia1[index-i+n-1] && !dia2[i+index]) {\n            col[i]=true;\n            dia1[index-i+n-1]=true;\n            dia2[index+i]=true;\n            //不用添加到lis中\n            dfs(n,index+1,lis);\n            //回溯\n            col[i]=false;\n            dia1[index-i+n-1]=false;\n            dia2[index+i]=false;\n        }\n    }\n}\n```\n虽然提交了也是1ms，主要是这两题case都比较少，最大的case好像只到11，所以差距不是很明显，我这样做肯定不是这题的最优解，这题的最优解是利用`位图（bitmap）`作位运算，反正我不可能写出来就是了😂 [参考](http://www.ic-net.or.jp/home/takaken/e/queen/)\n\n## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)\n\n编写一个程序，通过已填充的空格来解决数独问题。\n\n一个数独的解法需遵循如下规则：\n\n数字 `1-9` 在每一行只能出现一次。\n数字 `1-9` 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。\n空白格用 `'.'` 表示。\n\n![mark](http://static.imlgw.top/blog/20191012/jvSukv6RnXFL.png?imageslim)\n\n一个数独\n\n![mark](http://static.imlgw.top/blog/20191012/XgTokVUgo5Yy.png?imageslim)\n\n答案被标成红色。\n\n**Note:**\n\n- 给定的数独序列只包含数字 `1-9` 和字符 `'.'` \n- 你可以假设给定的数独只有唯一解。\n- 给定数独永远是 `9x9` 形式的。\n\n**解法一**\n\n嗯，又是一道hard题，自己摸了半天没做出来，看了评论区做出来的\n```java\n//三个约束规则\nprivate boolean[][] col=new boolean[9][9];\nprivate boolean[][] row=new boolean[9][9];\nprivate boolean[][] block=new boolean[9][9];\n\npublic void solveSudoku(char[][] board) {\n    if (board==null || board.length<=0) {\n        return;\n    }\n    for (int i=0;i<9;i++) {\n        for (int j=0;j<9;j++) {\n            if (board[i][j]!='.') {\n                col[i][board[i][j]-48-1]=true;\n                row[j][board[i][j]-48-1]=true;\n                //块号为 i/3*3+j/3\n                block[i/3*3+j/3][board[i][j]-48-1]=true;\n            }\n        }\n    }\n    dfs(board,0,0);\n}\n\n//private  static char[][] res=new char[9][9];\n\npublic boolean dfs(char[][] board,int i,int j) {\n    //从,i,j位置向后寻找'.', i>=9说明全部填充完了\n    while(board[i][j]!='.') {\n        j++;\n        if (j==9) {\n            i++;\n            j=0;\n        }\n        //over\n        if (i==9) {\n            return true;\n        }\n    }\n    //System.out.println(i+\",\"+j);\n    for (int val=0;val<9;val++) {\n        if (!col[i][val] && !row[j][val] && !block[i/3*3+j/3][val]) {\n            col[i][val]=true;\n            row[j][val]=true;\n            block[i/3*3+j/3][val]=true;\n            //尝试填充为 val+1\n            board[i][j]=(char)(val+1+48);\n            //尝试后面的'.',这里传进去还是i,j\n            //大脑模拟下其实这个dfs过程也挺简单\n            if(dfs(board,i,j)){//这里会尝试所有解，失败后回溯\n                return true;\n            }else{\n                //回溯\n                board[i][j]='.';\n                col[i][val]=false;\n                row[j][val]=false;\n                block[i/3*3+j/3][val]=false;\n            }\n        }\n    }\n    return false;\n}\n```\n\n比上面的N皇后要更复杂，同样也是带有约束的dfs回溯，我一开始写的方法主要是思路都错了，我想的和上面n皇后一样，一层一层的搜索最后n==9就结束，但是没考虑到一层其实不只有一个`空位`，同时还要注意回溯的时机，并不是dfs之后就回溯，用大脑模拟下这个递归其实就明白了，我觉得核心还是`找'.'那一步`，这一步确实没想到\n\n> 这题有一个简单版，[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/) 挺简单的，懒得做了\n\n## [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)\n\n让我们一起来玩扫雷游戏！\n\n给定一个代表游戏板的二维字符矩阵。 'M' 代表一个未挖出的地雷，'E' 代表一个未挖出的空方块，'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（'1' 到 '8'）表示有多少地雷与这块已挖出的方块相邻，'X' 则表示一个已挖出的地雷。\n\n现在给出在所有未挖出的方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：\n\n1. 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X'。\n2. 如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的方块都应该被递归地揭露。\n3. 如果一个至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。\n4. 如果在此次点击中，若无更多方块可被揭露，则返回面板。\n\n**示例一**\n\n```java\nInput: \n\n[['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'M', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E']]\n\nClick : [3,0]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\n```\n\n**Explanation:**\n\n![扫雷](https://i.loli.net/2019/11/18/B26DWk8CrhPFtHI.png)\n\n**示例二**\n\n```java\nInput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nClick : [1,2]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'X', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n```\n\n**Explanation:**\n\n![扫雷](https://s2.ax1x.com/2019/11/18/MyccWT.png)\n\n**解法一**\n\n标准的DFS，还是挺有意思的，向8个方向扩展，遇到周围有地雷的就计数并且停止，会玩扫雷就会做😉\n\n```java\nprivate int[][] direction={{0,1},{1,0},{-1,1},{1,-1},{-1,0},{0,-1},{-1,-1},{1,1}};\n\npublic char[][] updateBoard(char[][] board, int[] click) {\n    int x=click[0];\n    int y=click[1];\n    if (board[x][y]=='M') {\n        board[x][y]='X';\n        return board;\n    }\n    boolean[][] visit=new boolean[board.length][board[0].length];\n    dfs(board,x,y,visit);\n    return board;\n}\n\npublic void dfs(char[][] board,int x,int y,boolean[][] visit){\n    visit[x][y]=true;\n    int count=getRoundBoom(board,x,y);\n    if(count!=0){\n        board[x][y]=(char)(count+'0');\n        return;\n    }\n    board[x][y]='B';\n    for (int i=0;i<8;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(board,nx,ny) && !visit[nx][ny] && board[nx][ny]!='M') {\n            dfs(board,nx,ny,visit);\n        }\n    }\n}\n\npublic int getRoundBoom(char[][] board,int x,int y){\n    int count=0;\n    for (int i=0;i<8;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(board,nx,ny) && board[nx][ny]=='M') {\n            count++;\n        }   \n    }\n    return count;\n}\n\npublic boolean isValid(final char[][] board,int x,int y){\n    return x>=0 && x<board.length && y>=0 && y<board[0].length;\n}\n```\n## [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)\n\n给定一个包含了一些 0 和 1的非空二维数组 `grid` , 一个 `岛屿` 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。\n\n找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0)\n\n**示例 1:**\n\n```java\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n```\n\n对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的 `‘1’`。\n\n**示例 2:**\n\n```java\n[[0,0,0,0,0,0,0,0]]\n```\n\n\n对于上面这个给定的矩阵, 返回 0\n\n**注意:** 给定的矩阵grid 的长度和宽度都不超过 50。\n\n**解法一**\n\n和上面 [200题岛屿的数量](#200-岛屿数量)很类似，不过还是有所不同，这里要计算的是最大的面积\n\n```java\nprivate int[][] direction={{0,1},{0,-1},{1,0},{-1,0}};\n\npublic int maxAreaOfIsland(int[][] grid) {\n    if (grid==null || grid.length<=0) {\n        return max;\n    }\n    boolean[][] visit=new boolean[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            if (grid[i][j]==1 &&!visit[i][j]) {\n                int t=dfs(grid,i,j,visit);\n                max=max>t?max:t;\n            }\n        }\n    }\n    return max;\n}\n\nprivate int max=0;\n\npublic int dfs(int[][] grid,int x,int y,boolean[][] visit) {\n    int temp=1;\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(grid,nx,ny) && grid[nx][ny]==1 && !visit[nx][ny]) {\n            //将4个方向的符合条件的数量加起来\n            temp+=dfs(grid,nx,ny,visit);\n        }\n    }\n    return temp;\n}\n\npublic boolean isValid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n最开始直接在dfs函数里面用count计数，居然还过了600多个case.....惊了，那种做法完全是错的，说实话有点不太习惯写有返回值的递归\n\n## [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)\n\n班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。\n\n给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i] [j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。\n\n**示例 1:**\n\n```java\n输入: \n[[1,1,0],\n [1,1,0],\n [0,0,1]]\n输出: 2 \n说明：已知学生0和学生1互为朋友，他们在一个朋友圈。\n第2个学生自己在一个朋友圈。所以返回2。\n```\n\n**示例 2:**\n\n```java\n输入: \n[[1,1,0],\n [1,1,1],\n [0,1,1]]\n输出: 1\n说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。\n```\n\n**注意：**\n\n- N 在[1,200]的范围内。\n- 对于所有学生，有M[i] [i] = 1。\n- 如果有M[i] [j] = 1，则有M[j] [i] = 1。\n\n**解法一**\n\n```java\npublic int findCircleNum(int[][] M) {\n    if (M==null || M.length<=0) {\n        return 0;\n    }\n    boolean[] visit=new boolean[M.length];\n    int count=0;\n    for (int i=0;i<M.length;i++) {\n        if (!visit[i]) {\n            dfs(M,visit,i);\n            count++;\n        }\n    }\n    return count;\n}\n\n//一共m.length个人\npublic void dfs(int[][] M,boolean[] visit,int index) {\n    //标记index号学生已经访问过\n    visit[index]=true;\n    for (int i=0;i<M.length;i++) {\n        //index和i是好朋友\n        if (M[index][i]==1 && !visit[i]) {\n            //递归标记i的好朋友,形成朋友圈\n            dfs(M,visit,i);\n        }\n    }\n}\n```\n这题不知道为啥，一开始题目没搞明白。。。。去纠结那个矩阵去了，没理解好题目的意思，其实跟那个N*N的矩阵没啥关系，主要是N个人，对每个人进行dfs找到与他们相关的人，做好统计就ok，和上面的 200题也很类似\n\n## [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)\n\n你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。\n\n为了使收益最大化，矿工需要按以下规则来开采黄金：\n\n- 每当矿工进入一个单元，就会收集该单元格中的所有黄金。\n- 矿工每次可以从当前位置向上下左右四个方向走。\n- 每个单元格**只能被开采（进入）一次**。\n- **不得开采**（进入）黄金数目为 0 的单元格。\n- 矿工可以从网格中 **任意一个** 有黄金的单元格出发或者是停止。  \n\n**示例 1：**\n\n```java\n输入：grid = [[0,6,0],[5,8,7],[0,9,0]]\n输出：24\n解释：\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\n一种收集最多黄金的路线是：9 -> 8 -> 7。\n```\n\n**示例 2：**\n\n```java\n输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\n输出：28\n解释：\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\n一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。\n```\n\n**提示：**\n\n- -`1 <= grid.length, grid[i].length <= 15`\n- `0 <= grid[i][j] <= 100`\n- 最多 25 个单元格中有黄金。 \n\n**解法一**\n\n这题还是挺有意思的，填补了我一点二维平面回溯的空缺，其实也很简单（改了好几个小时还好意思说这种话😂）\n\n```java\nprivate int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic int getMaximumGold(int[][] grid) {\n    int max=0;\n    boolean[][] visit=new boolean[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            if (grid[i][j]>0) {\n                max=Math.max(dfs(grid,i,j,visit),max);\n            }\n        }\n    }\n    return max;\n}\n\n//求出从x,y开始所能获得的最大的收益，记得回溯状态，后面的节点还需要遍历\npublic int dfs(int[][] grid,int x,int y,boolean[][] visit){\n    int maxGlod=grid[x][y]; //一开始这里写的0...排了半天的错\n    visit[x][y]=true;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (isValid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]>0) {\n            //求向4个方向扩展的最大值\n            maxGlod=Math.max(dfs(grid,nx,ny,visit)+grid[x][y],maxGlod);\n        }\n    }\n    visit[x][y]=false;\n    return maxGlod;\n}\n\npublic boolean isValid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n\n思路其实也很简单，对每个有金矿的点进行dfs计算路径上的金矿和就ok了，但是这题有一个很关键的条件，不能回头，下过的金矿是不能第二次再进入的，不然这题就和前面的 [695. 岛屿最大面积](##695. 岛屿的最大面积)一样了，所以很显然这题是需要状态的回溯的，访问过的节点，后面的节点还是可能需要遍历的，最开始写的一个bug就是代码中提到的，那里一开始写的0...然后排错排了好长时间。。。菜啊\n\n## [面试题13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)\n\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n**示例 1：**\n\n```java\n输入：m = 2, n = 3, k = 1\n输出：3\n```\n\n**示例 1：**\n\n```java\n输入：m = 3, n = 1, k = 0\n输出：1\n```\n\n**提示：**\n\n- `1 <= n,m <= 100`\n- `0 <= k <= 20`\n\n**解法一**\n\n一开始没认真看例子，以为是求不能回头一次能走的最多的格子，原基础上稍微改一下就可以了\n\n```java\nprivate int[][] direction={{1,0},{0,1},{0,-1},{-1,0}};\n\npublic int movingCount(int m, int n, int k) {\n    return dfs(m,n,0,0,k,new boolean[m][n]);   \n}\n\npublic int dfs(int m,int n,int x,int y,int k,boolean[][] visit){\n    visit[x][y]=true;\n    int res=1;\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if(valid(m,n,nx,ny,k) && !visit[nx][ny]){\n            //以为是求最长的距离.....\n            //res=Math.max(dfs(m,n,nx,ny,k,visit)+1,res);\n            res+=dfs(m,n,nx,ny,k,visit);\n        }\n    }\n    //visit[x][y]=false;\n    return res;\n}\n\npublic boolean valid(int m,int n,int x,int y,int k){\n    if(x<0 || x>=m || y<0 || y>=n){\n        return false;\n    }\n    int res=0;\n    //35 37\n    while(x!=0){\n        res+=(x%10);\n        x/=10;\n    }\n    while(y!=0){\n        res+=(y%10);\n        y/=10;\n    }\n    return res<=k;\n}\n```\n\n## [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)\n\n给出一个二维数组 `A`，每个单元格为 0（代表海）或 1（代表陆地）。\n\n移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。\n\n返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。\n\n**示例 1：**\n\n```java\n输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n输出：3\n解释： \n有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n```\n\n**示例 2：**\n\n```java\n输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n输出：0\n解释：\n所有 1 都在边界上或可以到达边界。\n```\n\n**提示：**\n\n1. `1 <= A.length <= 500`\n2. `1 <= A[i].length <= 500`\n3. `0 <= A[i][j] <= 1`\n4. 所有行的大小都相同\n\n**解法一**\n\ndfs搜索就完事儿了，水题\n\n```java\n//DFS\nint[][] dir={{1,0},{0,1},{-1,0},{0,-1}};\n\npublic int numEnclaves(int[][] A) {\n    if(A==null || A.length<=0) return 0;\n    int N=A.length;\n    int M=A[0].length;\n    boolean[][] visit=new boolean[N][M];\n    int a=0,b=0;\n    while(a<N){ //左右边界\n        if(A[a][0]==1 && !visit[a][0]) dfs(A,a,0,visit);\n        if(A[a][M-1]==1 && !visit[a][M-1]) dfs(A,a,M-1,visit);\n        a++;\n    }\n    while(b<M){ //上下边界\n        if(A[0][b]==1&& !visit[0][b]) dfs(A,0,b,visit);\n        if(A[N-1][b]==1&& !visit[N-1][b]) dfs(A,N-1,b,visit);\n        b++;\n    }\n    int res=0;\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<M;j++) {\n            if(A[i][j]==1 && !visit[i][j]){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\npublic void dfs(int[][] A,int x,int y,boolean[][] visit){\n    visit[x][y]=true;\n    for (int i=0;i<dir.length;i++) {\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(valid(A,nx,ny) && !visit[nx][ny] && A[nx][ny]==1){\n            dfs(A,nx,ny,visit);\n        }\n    }\n}\n\npublic boolean valid(final int[][] A,int x,int y){\n    return x>=0 && x<A.length && y>=0 && y<A[0].length;\n}\n```\n\n并查集的解法放在 [并查集专题](http://imlgw.top/2020/02/02/bing-cha-ji/) 中\n\n## [934. 最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)\n\n在给定的二维二进制数组 `A` 中，存在两座岛。（岛是由四面相连的 `1` 形成的一个最大组。）\n\n现在，我们可以将 `0` 变为 `1`，以使两座岛连接起来，变成一座岛。\n\n返回必须翻转的 `0` 的最小数目。（可以保证答案至少是 1。）\n\n**示例 1：**\n\n```java\n输入：[[0,1],[1,0]]\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：[[0,1,0],[0,0,0],[0,0,1]]\n输出：2\n```\n\n**示例 3：**\n\n```java\n输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n输出：1\n```\n\n**提示：**\n\n1. `1 <= A.length = A[0].length <= 100`\n2. `A[i][j] == 0` 或 `A[i][j] == 1`\n\n**解法一**\n\n这题还挺有意思的，dfs+bfs都要用，单纯的深搜和广搜很难搞，先dfs给一个岛做标记，然后多源bfs找距离最近的另一个岛\n\n```java\nint[] dir = {0, 1, 0, -1, 0};\n\npublic int shortestBridge(int[][] A) {\n    boolean[][] mark = new boolean[A.length][A[0].length];\n    lable:\n    for (int i = 0; i < A.length; i++) {\n        for (int j = 0; j < A[0].length; j++) {\n            if (A[i][j] == 1) {\n                dfs(A, i, j, mark);\n                break lable;\n            }\n        }\n    }\n    Queue<Pair> queue = new LinkedList<>();\n    for (int i = 0; i < A.length; i++) {\n        for (int j = 0; j < A[0].length; j++) {\n            if (A[i][j] == 1 && mark[i][j]) {\n                queue.add(new Pair(i, j, 0));\n            }\n        }\n    }\n    while (!queue.isEmpty()) {\n        Pair pair = queue.poll();\n        for (int i = 0; i < 4; i++) {\n            int nx = pair.x + dir[i];\n            int ny = pair.y + dir[i + 1];\n            if (valid(A, nx, ny) && !mark[nx][ny]) {\n                if (A[nx][ny] == 1) {\n                    return pair.step;\n                }\n                mark[nx][ny] = true;\n                queue.add(new Pair(nx, ny, pair.step + 1));\n            }\n        }\n    }\n    return 1;\n}\n\npublic void dfs(int[][] A, int x, int y, boolean[][] mark) {\n    mark[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dir[i];\n        int ny = y + dir[i + 1];\n        if (valid(A, nx, ny) && A[nx][ny] == 1 && !mark[nx][ny]) {\n            dfs(A, nx, ny, mark);\n        }\n    }\n}\n\npublic boolean valid(int[][] A, int x, int y) {\n    return x >= 0 && x < A.length && y >= 0 && y < A[0].length;\n}\n\nclass Pair {\n    int x, y;\n    int step;\n    public Pair(int x, int y, int step) {\n        this.x = x;\n        this.y = y;\n        this.step = step;\n    }\n}\n```\n\n## [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)\n\nDifficulty: **简单**\n\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n**示例 1:**\n\n```go\n输入: \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n输出: [[2,2,2],[2,2,0],[2,0,1]]\n解析: \n在图像的正中间，(坐标(sr,sc)=(1,1)),\n在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，\n因为它不是在上下左右四个方向上与初始点相连的像素点。\n```\n\n**注意:**\n\n*   `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。\n*   给出的初始点将满足 `0 <= sr < image.length` 和 `0 <= sc < image[0].length`。\n*   `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。\n\n**解法一**\n\n经典搜索，没啥好说的\n```golang\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\n    var m = len(image)\n    var n = len(image[0])\n    var dir = []int{1, 0, -1, 0, 1}\n    var visit = make([][]bool, m)\n    for i := 0; i < m; i++ {\n        visit[i] = make([]bool, n)\n    }\n    var src = image[sr][sc]\n    var valid = func(x int, y int) bool {\n        return x >= 0 && x < m && y >= 0 && y < n\n    }\n    var dfs func(x int, y int)\n    dfs = func(x int, y int) {\n        visit[x][y] = true\n        image[x][y] = newColor\n        for i := 0; i < 4; i++ {\n            var nx = x + dir[i]\n            var ny = y + dir[i+1]\n            if valid(nx, ny) && !visit[nx][ny] && image[nx][ny] == src {\n                dfs(nx, ny)\n            } \n        }\n    }\n    dfs(sr, sc)\n    return image\n}\n```\n通过染色的情况判断是否遍历过节点，节省visit数组\n```golang\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\n    var m = len(image)\n    var n = len(image[0])\n    var dir = []int{1, 0, -1, 0, 1}\n    var src = image[sr][sc]\n    var valid = func(x int, y int) bool {\n        return x >= 0 && x < m && y >= 0 && y < n\n    }\n    var dfs func(x int, y int)\n    dfs = func(x int, y int) {\n        image[x][y] = newColor\n        for i := 0; i < 4; i++ {\n            var nx = x + dir[i]\n            var ny = y + dir[i+1]\n            if valid(nx, ny) && image[nx][ny]!=newColor && image[nx][ny] == src {\n                dfs(nx, ny)\n            } \n        }\n    }\n    dfs(sr, sc)\n    return image\n}\n```\n\n## [1559. 二维网格图中探测环](https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/)\n\nDifficulty: **困难**\n\n\n给你一个二维字符网格数组 `grid` ，大小为 `m x n` ，你需要检查 `grid` 中是否存在 **相同值** 形成的环。\n\n一个环是一条开始和结束于同一个格子的长度 **大于等于 4** 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 **相同的值 **。\n\n同时，你也不能回到上一次移动时所在的格子。比方说，环  `(1, 1) -> (1, 2) -> (1, 1)` 是不合法的，因为从 `(1, 2)` 移动到 `(1, 1)` 回到了上一次移动时的格子。\n\n如果 `grid` 中有相同值形成的环，请你返回 `true` ，否则返回 `false` 。\n\n**示例 1：**\n\n![](https://i.loli.net/2020/12/16/IF9PVSHoOXtZwRr.png)\n\n```golang\n输入：grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n输出：true\n解释：如下图所示，有 2 个用不同颜色标出来的环：\n```\n![](https://i.loli.net/2020/12/16/8EJDuUPc2xMilBm.png)\n\n**示例 2：**\n\n![](https://i.loli.net/2020/12/16/eljrFPCzf4pgd6s.png)\n\n```golang\n输入：grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n输出：true\n解释：如下图所示，只有高亮所示的一个合法环：\n```\n![](https://i.loli.net/2020/12/16/9FfYxP7DSUBXEaG.png)\n\n**示例 3：**\n\n![](https://i.loli.net/2020/12/16/fAr1TEQNpumaXck.png)\n\n```golang\n输入：grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n输出：false\n```\n\n**提示：**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m <= 500`\n*   `1 <= n <= 500`\n*   `grid` 只包含小写英文字母。\n\n\n**解法一**\n\n33双周赛的T4，总体不是很难，dfs或者并查集都可以\n```golang\nfunc containsCycle(grid [][]byte) bool {\n    var m, n = len(grid), len(grid[0])\n    var dir = [4][2]int{{0,1},{1,0},{-1,0},{0,-1}}\n    var visit = make([][]bool, m)\n    for i := 0; i < m; i++ {\n        visit[i] = make([]bool, n)\n    }\n    var valid = func(x, y int) bool { return x >= 0 && x < m && y >= 0 && y < n}\n    var dfs func (int, int, int, int)\n    var res = false\n    dfs = func(preX int, preY int, x int, y int) {\n        if visit[x][y] || res{\n            res = true\n            return\n        }\n        visit[x][y] = true\n        for i := 0; i < len(dir); i++ {\n            nx := x + dir[i][0]\n            ny := y + dir[i][1]\n            //不走回头路\n            if nx == preX && ny == preY {\n                continue\n            }\n            if valid(nx, ny) && grid[nx][ny] == grid[x][y] {\n                dfs(x, y, nx, ny)\n            }\n        }\n    }\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if !visit[i][j] {\n                dfs(i,j,i,j)\n            }\n        }\n    }\n    return res\n}\n```\n**解法二**\n\n并查集的解法，留着以后再来写\n\n## [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)\n\nDifficulty: **中等**\n\n\n给定一个机票的字符串二维数组 `[from, to]`，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\n\n**提示：**\n\n1.  如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前\n2.  所有的机场都用三个大写字母表示（机场代码）。\n3.  假定所有机票至少存在一种合理的行程。\n4.  所有的机票必须都用一次 且 只能用一次。\n\n**示例 1：**\n\n```go\n输入：[[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\n输出：[\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]\n```\n\n**示例 2：**\n\n```go\n输入：[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n输出：[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n解释：另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]。但是它自然排序更大更靠后。\n```\n\n**解法一**\n\n欧拉回路，一笔画，后序遍历，先尝试完所有的子节点最后在添加当前节点，确保死胡同会被首先加入，这样res中就保持了答案的逆序\n```golang\n//欧拉回路，一笔画问题\nfunc findItinerary(tickets [][]string) []string {\n    var adj = make(map[string][]string)\n    for _, tick := range tickets {\n        adj[tick[0]] = append(adj[tick[0]], tick[1])\n    }\n    for _, toList := range adj {\n        sort.Strings(toList)\n    }\n    var res []string\n    var dfs func (cur string) \n    dfs = func (cur string) {\n        for len(adj[cur]) != 0 {\n            //删除节点，避免重复访问\n            to := adj[cur][0]\n            adj[cur] = adj[cur][1:]\n            dfs(to)\n        }\n        //后序遍历，最后将路径添加进去，保证死胡同会首先加入\n        res = append(res, cur)\n    }\n    dfs(\"JFK\")\n    //翻转下\n    for i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {\n        res[i], res[j] = res[j], res[i]\n    }\n    return res\n}\n```\n\n## [841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)\n\nDifficulty: **中等**\n\n\n有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。\n\n在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。\n\n最初，除 `0` 号房间外的其余所有房间都被锁住。\n\n你可以自由地在房间之间来回走动。\n\n如果能进入每个房间返回 `true`，否则返回 `false`。\n\n**示例 1：**\n\n```go\n输入: [[1],[2],[3],[]]\n输出: true\n解释:  \n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n```\n\n**示例 2：**\n\n```go\n输入：[[1,3],[3,0,1],[2],[0]]\n输出：false\n解释：我们不能进入 2 号房间。\n```\n\n**提示：**\n\n1.  `1 <= rooms.length <= 1000`\n2.  `0 <= rooms[i].length <= 1000`\n3.  所有房间中的钥匙数量总计不超过 `3000`。\n\n**解法一**\n\n没啥好说的\n```golang\nfunc canVisitAllRooms(rooms [][]int) bool {\n    var n = len(rooms)\n    var visit = make([]bool, n)\n    var dfs func(int)\n    var count = 0\n    dfs = func(idx int) {\n        visit[idx] = true\n        count++\n        for i := 0; i < len(rooms[idx]); i++ {\n            if !visit[rooms[idx][i]] {\n                dfs(rooms[idx][i])   \n            }\n        }\n    }\n    dfs(0)\n    return count == n\n}\n```\n\n## _分治_\n\n开个新坑，其实分治这个tag挺大的，很多题的做法都属于分治，而且涉及到分治的题目一般都还是有点难度的，不容易直接想出来\n\n## [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**示例 1:**\n\n```java\n输入: \"2-1-1\"\n输出: [0, 2]\n解释: \n((2-1)-1) = 0 \n(2-(1-1)) = 2\n```\n\n**示例 2:**\n\n```java\n输入: \"2*3-4*5\"\n输出: [-34, -14, -10, -10, 10]\n解释: \n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n```\n\n**解法一**\n\n这题咋说呢，应该不算是回溯，是在分治tag中找的一题，还是挺有意思的\n\n```java\nprivate Map<String,List<Integer>> map=new HashMap<>();\n\n//分治\npublic List<Integer> diffWaysToCompute(String input) {\n    if (input==null || input.length()<=0) {\n        return new LinkedList<>();\n    }\n    return diffWaysToCompute(input,0,input.length()-1);\n}\n\npublic List<Integer> diffWaysToCompute(String input,int left,int right) {\n    List<Integer> res=new LinkedList<>();\n    /*if (left==right) { //这一步可以去掉,最开始没考虑多位数的情况(考虑到了不知道怎么处理)\n            res.add(Integer.valueOf(input.charAt(left))-48);\n            return res;\n        }*/\n    String key=input.substring(left,right+1);\n    if (map.containsKey(key)) {\n        return map.get(key);\n    }\n    for (int i=left;i<=right;i++) { //大意了,这里一开始写成了input.length...\n        char c=input.charAt(i);\n        if (c<'0') {\n            List<Integer> leftCompute=diffWaysToCompute(input,left,i-1);\n            List<Integer> rightCompute=diffWaysToCompute(input,i+1,right);\n            for (int lc:leftCompute) {\n                for (int rc:rightCompute) {\n                    if (c=='+') \n                        res.add(lc+rc);\n                    if (c=='-') \n                        res.add(lc-rc);\n                    if (c=='*') \n                        res.add(lc*rc);\n                }\n            }\n        }\n    }\n    if (res.isEmpty()) {\n        res.add(Integer.valueOf(key));\n    }\n    map.put(key,res);\n    return res;\n}\n```\n\n第一天看了这道题，没想到思路，然后瞄了一眼评论区，看到了关键点，找到运算符，然后左右分别递归，没看到细节，第二天回忆了下思路写出了解，其实这题可以参考[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) 我在我的 [二叉树专题](http://imlgw.top/2019/11/06/leetcode-er-cha-shu/) 中也加了这道题，两者解法极为相似\n\n## [395. 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)\n\nDifficulty: **中等**\n\n找到给定字符串（由小写字符组成）中的最长子串`T`， 要求 `T` 中的每一字符出现次数都不少于 `k` 。输出 `T`的长度。\n\n**示例 1:**\n\n```go\n输入:\ns = \"aaabb\", k = 3\n\n输出:\n3\n\n最长子串为 \"aaa\" ，其中 'a' 重复了 3 次。\n```\n\n**示例 2:**\n\n```go\n输入:\ns = \"ababbc\", k = 2\n\n输出:\n5\n\n最长子串为 \"ababb\" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。\n```\n\n**解法一**\n\n以出现次数最少的字符为中点分治，但是效率感人，380ms+\n```java\npublic int longestSubstring(String s, int k) {\n    if (s == null || s.length() == 0){\n        return 0;\n    }\n    int[] count = new int[26];\n    for(int i = 0; i < s.length(); i++){\n        count[s.charAt(i)-'a']++;\n    }\n    int min = 0; //记录count最小的index\n    for(int i = 0;i < s.length(); i++){\n        min = count[s.charAt(i)-'a'] < count[s.charAt(min)-'a'] ? i : min;\n    }\n    if (count[s.charAt(min)-'a'] >= k) {\n        return s.length();\n    }\n    return Math.max(longestSubstring(s.substring(0,min),k),longestSubstring(s.substring(min+1),k));\n}\n```\n\n**解法二**\n\n参考了题解区大佬们的剪枝和优化方法，循环以每个小于k的字符为结尾，分割字符，多路分治，大大降低分治递归树的高度\n```java\n//1ms 多路分治，虽然过了，但是感觉还是有点不流畅\n//主要就是最后那个当以大于k的字符结尾的时候的额外处理，如果不wa一发不容易发现\npublic int longestSubstring(String s, int k) {\n    if (s == null || s.length() == 0){\n        return 0;\n    }\n    int[] count = new int[26];\n    for(int i = 0; i < s.length(); i++){\n        count[s.charAt(i)-'a']++;\n    }\n    int res = 0;\n    int left = 0; //分治左端点\n    boolean flag = false;\n    for(int i = 0; i < s.length(); i++){\n        if(count[s.charAt(i)-'a'] < k){\n            flag = true;\n            if(i - left >= res){ //剪枝优化\n                res = Math.max(longestSubstring(s.substring(left,i),k),res);\n            }\n            left = i+1;\n        }\n    }\n    if(!flag) return s.length();\n    //上面分治的逻辑是以left到小于k的字母i进行分治，但是如果字符不是以小于k的字母结尾就无法计算\n    //eg: aabbb k=3\n    return Math.max(res,longestSubstring(s.substring(left),k));\n}\n```\n其实还要很多分治的方法，但是感觉都大同小异","tags":["LeetCode","回溯"],"categories":["算法"]},{"title":"LeetCode栈&队列","url":"/2019/10/01/leetcode-zhan-dui-lie/","content":"\n## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\nGiven a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n**Example 1:**\n\n```java\nInput: \"()\"\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: \"()[]{}\"\nOutput: true\n```\n\n**Example 3:**\n\n```java\nInput: \"(]\"\nOutput: false\n```\n\n**Example 4:**\n\n```java\nInput: \"([)]\"\nOutput: false\n```\n\n**Example 5:**\n\n```java\nInput: \"{[]}\"\nOutput: true\n```\n\n**解法一**\n\n这道题只要学过数据结构的肯定会做，典型的利用栈的题\n\n```java\npublic boolean isValid2(String s) {\n    if(s.length()<=0){\n        return true;\n    }\n    Stack<Character> stack=new Stack();\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='(' || s.charAt(i)=='{' || s.charAt(i)=='['){\n            stack.push(s.charAt(i));\n        }else{\n            //注意这种情况，一开始就是])}\n            if(stack.isEmpty()){\n                return false;\n            }\n            char p=s.charAt(i);\n            if( (p==')' && stack.pop()!='(') || (p==']' && stack.pop()!='[') || (p=='}' && stack.pop()!='{')){\n                return false;\n            }\n        }\n    }\n    return stack.isEmpty();\n}\n```\n**解法二**\n\n其实和上面的解法是一样的，只不过是用的stack是自己用数组简单封装的栈\n\n```java\npublic class MyStack<T>{\n\n    T [] objValues=null;\n\n    int top=-1;\n\n    public MyStack(int size){\n        objValues= (T[]) new Object[size];\n    }\n\n    public void push(T obj){\n        objValues[++top]=obj;\n    }\n\n    public T peek(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        return objValues[top];\n    }\n\n    public T pop(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        //覆盖\n        return objValues[top--];\n    }\n\n    public boolean isEmpty(){\n        return top<0;\n    }\n}\n```\n\n3ms，94%，比之前快了一点，去看了下Stack的源码，它的pop是真的删除，我的只是移动了指针，所以效率会高很多\n\n> 后面的题可能还会利用这个`MyStack`\n\n**解法三**\n\n今天看面筋看到一个写这道题，要求O(1)的空间复杂度\n\n```java\npublic boolean isValid(String s) {\n    if(s.length()<=0){\n        return true;\n    }\n    while(true){\n        int len=s.length();\n        s=s.replace(\"{}\",\"\");\n        s=s.replace(\"()\",\"\");\n        s=s.replace(\"[]\",\"\");\n        if (len==s.length()) {\n            break;\n        }\n    }\n    return \"\".equals(s);\n}\n```\n100ms，效率感人，感觉应该说的是这种做法吧，当然还可以写正则表达式来匹配，但是我不太会写。。。\n\n## [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)\n\n给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：\n\n1. 任何左括号 `(` 必须有相应的右括号 `)`。\n2. 任何右括号 `)` 必须有相应的左括号 `(` 。\n3. 左括号 `(` 必须在对应的右括号之前 `)`。\n4. `*` 可以被视为单个右括号 `)` ，或单个左括号 `(` ，或一个空字符串。\n5. 一个空字符串也被视为有效字符串。\n\n**示例 1:**\n\n```java\n输入: \"()\"\n输出: True\n```\n\n\n**示例 2:**\n\n```java\n输入: \"(*)\"\n输出: True\n```\n\n\n**示例 3:**\n\n```java\n输入: \"(*))\"\n输出: True\n```\n\n\n**注意:**\n\n1. 字符串大小将在 [1，100] 范围内。\n\n**解法一**\n\n看面筋看到的这一题，还是挺有意思的，评论区有人说了双栈，然后今天来试了下\n\n```java\npublic boolean checkValidString(String s) {\n    Stack<Integer> bracketStack=new Stack<>();\n    Stack<Integer> starStack=new Stack<>();\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)=='(') {\n            bracketStack.push(i);\n        }else if(s.charAt(i)=='*'){\n            starStack.push(i);\n        }else{\n            if (bracketStack.isEmpty()) {\n                if (starStack.isEmpty()) {\n                    return false;\n                }\n                starStack.pop();\n            }else{\n                bracketStack.pop();\n            }\n        }\n    }\n    //消除左括号\n    while(!starStack.isEmpty() && !bracketStack.isEmpty()){\n        if(starStack.peek()>bracketStack.peek()){ //这里的逻辑不太好，其实可以很简单\n            bracketStack.pop();\n        }\n        starStack.pop();\n    }\n    return bracketStack.isEmpty();\n}\n```\n\n很可惜没有`bugfree`，最后对左括号的判断改了好几次，一开始写的`bracketStack.size()<=starStack().size()`  然后提交后才意识到还要 `\"*(\"` 这样的情况，然后要消除这种情况也简单，一开始我再栈中存的就是index，从star栈里面取比bracket栈index大的，然后消除，最后再看括号栈是不是空\n\n```java\n//2020.4.10重写一下\npublic boolean checkValidString(String s) {\n    Deque<Integer> stack=new ArrayDeque<>();\n    Deque<Integer> helpStack=new ArrayDeque<>();\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='('){\n            stack.push(i);\n        }else if(s.charAt(i)==')'){\n            if(!stack.isEmpty()){\n                stack.pop();\n            }else{\n                if(helpStack.isEmpty()){\n                    return false;\n                }\n                helpStack.pop();\n            }\n        }else{\n            helpStack.push(i);\n        }\n    }\n    while(!stack.isEmpty() && !helpStack.isEmpty()){\n        if(stack.pop()>helpStack.pop()){\n            return false;\n        }\n    }\n    return stack.isEmpty();\n}\n```\n## [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)\n\n给定一个由 `'('` 和 `')'` 括号组成的字符串 `S`，我们需要添加最少的括号（ `'('` 或是 `')'`，可以在任何位置），以使得到的括号字符串有效。\n\n从形式上讲，只有满足下面几点之一，括号字符串才是有效的：\n\n- 它是一个空字符串，或者\n- 它可以被写成 `AB` （`A` 与 `B` 连接）, 其中 `A` 和 `B` 都是有效字符串，或者\n- 它可以被写作 `(A)`，其中 `A` 是有效字符串。\n\n给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。\n\n**示例 1：**\n\n```java\n输入：\"())\"\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：\"(((\"\n输出：3\n```\n\n**示例 3：**\n\n```java\n输入：\"()\"\n输出：0\n```\n\n**示例 4：**\n\n```java\n输入：\"()))((\"\n输出：4\n```\n\n**提示：**\n\n1. `S.length <= 1000`\n2. `S` 只包含 `'('` 和 `')'` 字符。\n\n**解法一**\n\n没啥好说的，easy题\n\n```java\npublic int minAddToMakeValid(String S) {\n    int left=0,right=0;\n    int wa=0;\n    for(int i=0;i<S.length();i++){\n        if(S.charAt(i)=='('){\n            left++;\n        }else{\n            if(left>0){\n                left--;\n            }else{\n                wa++;\n            }\n        }\n    }\n    return wa+left;\n}\n```\n\n## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n**示例:**\n\n```java\ns = \"3[a]2[bc]\", 返回 \"aaabcbc\".\ns = \"3[a2[c]]\", 返回 \"accaccacc\".\ns = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\".\n```\n\n**解法一**\n\n借助栈直接在原字符上做改动\n\n```java\npublic String decodeString(String s) {\n    if (s==null || s.length()<=0) {\n        return \"\";\n    }\n    //转换为StringBuilder比较好处理,且效率较高\n    StringBuilder sb=new StringBuilder(s);\n    Stack<Integer>  stack=new Stack<>();\n    int i=0;//遍历索引\n    while(i<sb.length()) {\n        if (sb.charAt(i)=='[') {\n            stack.push(i);\n        }else if(sb.charAt(i)==']'){\n            int left=stack.pop();//对应左括号索引\n            String temp=sb.substring(left+1,i);//相邻括号中的字符\n            int preInt=left;\n            //'['前的数字,一开始以为只是个位数,还是挺麻烦的\n            while(preInt-1>=0 && sb.charAt(preInt-1)>='0' && sb.charAt(preInt-1) <='9'){\n                preInt--;\n            }\n            //repeat次数\n            int repeat=Integer.valueOf(sb.substring(preInt,left));\n            //删除 k[encoded_string] \n            sb.delete(preInt,Math.min(i+1,sb.length()));\n            for (int j=0;j<repeat;j++) {\n                //从k位置重新插入字符\n                sb.insert(preInt,temp);\n            }\n            //重新定位索引到尾部\n            i=preInt+(repeat*temp.length())-1;\n        }\n        i++;\n    }\n    return sb.toString();\n}\n```\n一开始是想用一个额外的String来保存结果，结果发现比较麻烦，索性直接将原字符转换为StringBuilder，然后借助api直接在原字符上做改动，因为是在原字符上做改动，所以索引的变化需要额外的注意，这也是最麻烦的一点，需要停下来稍微思考下才能确定，其他的还好，正常的思路，最初WA了一发是因为忽略了前面的数字可能是多位数😂\n\n**解法二**\n\n递归的方式，改成`StringBuilder`应该会好一点😂\n\n```java\nprivate int index=0; //字符索引下标\n\npublic String decodeString(String s) {\n    if (s==null || s.length()<=0) {\n        return \"\";\n    }\n    String sb=\"\";\n    while(index<s.length()){\n        if (s.charAt(index)==']') { //遇到右括号就结束\n            index++;//index定位到右括号下一个\n            return sb;\n        }else if(s.charAt(index)>='0' && s.charAt(index)<='9'){\n            int temp=index;\n            while(index<s.length() && s.charAt(index)!='['){\n                index++;\n            }\n            int repeat=Integer.valueOf(s.substring(temp,index));\n            index++;//跳过'['\n            String rs=decodeString(s);//从左括号开始\n            for (int i=0;i<repeat;i++) {\n                sb+=rs;\n            }\n        }else{\n            sb+=s.charAt(index++);\n        }\n    }\n    return sb;\n}\n```\n\n\n## [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n **示例 1：**\n\n```java\n输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n```\n\n**示例 2：**\n\n```java\n输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n```\n\n**解法一**\n\n很久之前做的了，本来是想单独搞一个递归专题，感觉没啥必要就直接加到一起了\n\n```java\npublic void reverseString(char[] s) {\n    if(s==null||s.length<=1)return;\n    reverseString(s,0,s.length-1);\n}\n\npublic void reverseString(char[] s,int l,int r) {\n    if(l>=r){\n        return;\n    }\n    char temp=s[l];\n    s[l]=s[r];\n    s[r]=temp;\n    reverseString(s,++l,--r);\n}\n```\n\n## [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n\n根据[逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。\n\n有效的运算符包括 `+, -, *, /` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式\n\n说明：\n\n- 整数除法只保留整数部分。\n- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n**示例 1：**\n\n```java\n输入: [\"2\", \"1\", \"+\", \"3\", \"*\"]\n输出: 9\n解释: ((2 + 1) * 3) = 9\n```\n\n\n**示例 2：**\n\n```java\n输入: [\"4\", \"13\", \"5\", \"/\", \"+\"]\n输出: 6\n解释: (4 + (13 / 5)) = 6\n```\n\n**示例 3：**\n\n```java\n输入: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\n输出: 22\n解释: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n```\n\n**解法一**\n\n```java\npublic static int evalRPN(String[] tokens) {\n    //上面自己封装的Stack\n    MyStack<Integer> stack=new MyStack<>(tokens.length);\n    for (int i=0;i<tokens.length;i++) {\n        if(\"+\".equals(tokens[i])){\n            stack.push(stack.pop()+stack.pop());\n        } else if(\"-\".equals(tokens[i])){\n            int rd1=stack.pop();\n            int rd2=stack.pop();\n            stack.push(rd2-rd1);\n        }else if(\"*\".equals(tokens[i])){\n            stack.push(stack.pop()*stack.pop());\n        }else if(\"/\".equals(tokens[i])){\n            int div1=stack.pop();\n            int div2=stack.pop();\n            stack.push(div2/div1);\n        }else{\n            stack.push(Integer.valueOf(tokens[i]));\n        }\n    }\n    return stack.peek();\n}\n```\n12ms，90%，其实一开始看到这个题我是拒绝的，我以为又是啥数学题，然后仔细看了下发现挺简单的，思路就是利用栈，每次遇到符号就pop两个出来进行运算，然后再入栈，值得注意的地方就是减法和除法的顺序\n\n## [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。\n\n在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：[Linux / Unix中的绝对路径 vs 相对路径](https://blog.csdn.net/u011327334/article/details/50355600)\n\n请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）**不能**以 / 结尾。此外，规范路径必须是表示绝对路径的**最短**字符串\n\n**示例 1：**\n\n```java\n输入：\"/home/\"\n输出：\"/home\"\n解释：注意，最后一个目录名后面没有斜杠。\n```\n\n**示例 2：**\n\n```java\n输入：\"/../\"\n输出：\"/\"\n解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。\n```\n\n\n**示例 3：**\n\n```java\n输入：\"/home//foo/\"\n输出：\"/home/foo\"\n解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n```\n\n\n**示例 4：**\n\n```java\n输入：\"/a/./b/../../c/\"\n输出：\"/c\"\n```\n\n**示例 5：**\n\n```java\n输入：\"/a/../../b/../c//.//\"\n输出：\"/c\"\n```\n\n\n**示例 6：**\n\n```java\n输入：\"/a//b////c/d//././/..\"\n输出：\"/a/b/c\"\n```\n\n**解法一**\n\n```java\npublic static String simplifyPath(String path) {\n    MyStack<String> stack=new MyStack<>(path.length());\n    StringBuilder str=new StringBuilder(path);\n    //这里划分出来有一部分是空的 \"\"\n    String[] s=path.split(\"/\");\n    for (int i=0;i<s.length;i++) {\n        if (!stack.isEmpty() && s[i].equals(\"..\")) {\n            //.. 回溯\n            stack.pop();\n        }else if (!\".\".equals(s[i]) && !\"\".equals(s[i]) && !s[i].equals(\"..\") ) {\n            //普通的英文字符abcd\n            stack.push(s[i]);\n        }\n    }\n    if (stack.isEmpty()) {\n        return \"/\";\n    }\n    StringBuilder res=new StringBuilder();\n    for (int i=0;i<stack.size(); i++) {\n        res.append(\"/\"+stack.get(i));   \n    }\n    return res.toString();\n}\n\n//自己封装的stack\npublic class MyStack<T>{\n\n    T [] objValues=null;\n\n    int top=-1;\n\n    public MyStack(int size){\n        objValues= (T[]) new Object[size];\n    }\n\n    public void push(T obj){\n        objValues[++top]=obj;\n    }\n\n    public T peek(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        return objValues[top];\n    }\n\n    public T pop(){\n        if (top<0) {\n            throw new RuntimeException(\"stack is isEmpty\");\n        }\n        //覆盖\n        return objValues[top--];\n    }\n\n    public T get(int index){\n        if (index>top || index < 0) {\n            throw new RuntimeException(\"index is wrong\");\n        }\n        return objValues[index];\n    }\n\n    public boolean isEmpty(){\n        return top<0;\n    }\n\n    public int size(){\n        return top+1;\n    }\n}\n```\n这题本来是很简单的，但是我钻到牛角尖去了，一直想着怎么在遍历过程中处理，写了一堆ifelse。。。还是太菜了啊，其实直接按照`\"/\"` 划分split字符串然后处理那个数组就可以了\n\n## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\nImplement the following operations of a stack using queues.\n\n- push(x) -- Push element x onto stack.\n- pop() -- Removes the element on top of the stack.\n- top() -- Get the top element.\n- empty() -- Return whether the stack is empty.\n\n**Example:**\n\n```java\nMyStack stack = new MyStack();\n\nstack.push(1);\nstack.push(2);  \nstack.top();   // returns 2\nstack.pop();   // returns 2\nstack.empty(); // returns false\n```\n\n**Notes:**\n\n- You must use *only* standard operations of a queue -- which means only `push to back`, `peek/pop from front`, `size`, and `is empty` operations are valid.\n- Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.\n- You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).\n\n**解法一**\n\n很经典的题\n\n```java\nclass MyStack {\n\n    private ArrayDeque<Integer> queue=null;\n\n    /** Initialize your data structure here. */\n    public MyStack() {\n        queue=new ArrayDeque();\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        queue.add(x);\n        int size=queue.size();\n        //除了新加入的元素，其他的元素都出队再入队，将新加入的元素推置队列头\n        while(size-- >1){\n            queue.add(queue.pop());\n        }\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n       return  queue.pop();\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        return queue.peek();\n    }\n\n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n```\n\n很巧妙的做法，将元素前n-1个出队后再重新入队，`1 2 --> 2 1` 直接将堆顶推置队列头 ，将每次新加入的元素都放置队列头而不是队尾，这样实际上就完成了逆序的操作\n\n这样push压栈时间复杂度`O(N)` ，`pop/peek` 时间复杂度`O(1)`\n\n**解法二**\n\n适用于push频繁的stack\n\n```java\npublic class MyStack{\n   //形式上q1是负责进栈 q2负责出栈\n    private LinkedList inQueue=new LinkedList(); \n    private LinkedList outQueue=new LinkedList();\n\n    private  void  add(Object obj){\n        inQueue.add(obj);\n    }\n\n    private Object pop(){\n        // q1 ----> q2 留一个\n        while(inQueue.size()>1){\n            outQueue.add(inQueue.poll());\n        }\n        //交换q1,q2的引用\n        LinkedList temp;\n        temp=inQueue;\n        inQueue=outQueue;\n        outQueue=temp;\n        return outQueue.poll();\n    }\n\n    private Object peek(){\n        //q1 --->q2 留一个,最后一个不poll,最后poll\n        while(inQueue.size()>1){\n            outQueue.add(inQueue.poll());\n            if(inQueue.size()==1){\n                outQueue.add(inQueue.peek());\n            }\n        }\n        //交换q1,q2的引用\n        LinkedList temp;\n        temp=inQueue;\n        inQueue=outQueue;\n        outQueue=temp;\n        return outQueue.poll();\n    }\n}\n```\n\n两个队列，push压栈时间复杂度`O(1)`，pop/push出栈时间复杂度`O(N)` ，出栈的时候将一个队列的前n-1个元素全部加入到另一个队列中作为缓存，然后将最后一个元素出栈，最后别忘了交换两个队列的引用，不然push的时候就会出问题，要保证`inQueue` 一直是入栈的队列，其中存放着所有的元素\n\n## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\nImplement the following operations of a queue using stacks.\n\n- push(x) -- Push element x to the back of queue.\n- pop() -- Removes the element from in front of queue.\n- peek() -- Get the front element.\n- empty() -- Return whether the queue is empty.\n\n**Example:**\n\n```java\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // returns 1\nqueue.pop();   // returns 1\nqueue.empty(); // returns false\n```\n\n**Notes:**\n\n- You must use *only* standard operations of a stack -- which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.\n- Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.\n- You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).\n\n**解法一**\n\n```java\nclass MyQueue {\n\n    Stack<Integer> inStack=null;\n\n    Stack<Integer> outStack=null;\n    /** Initialize your data structure here. */\n    public Stack2Queue232() {\n        inStack=new Stack<>();\n        outStack=new Stack<>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        s2s();\n        return outStack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        s2s();\n        return outStack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return outStack.isEmpty() && inStack.isEmpty();\n    }\n\n    private void s2s(){\n        if (outStack.isEmpty()) {\n            while(!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }     \n    }\n}\n```\n\n很上面一题是姊妹题，需要注意的地方就是`s2s`的时候要确保stack2栈是空的才能push\n\n## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)\n\n设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。\n\n- push(x) -- 将元素 x 推入栈中。\n\n- pop() -- 删除栈顶的元素。\n\n- top() -- 获取栈顶元素。\n\n- getMin() -- 检索栈中的最小元素。\n\n**示例:**\n\n```java\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.getMin();   --> 返回 -2.\n```\n\n**解法一**\n\n利用辅助栈，同步的push和pop\n\n```java\nclass MinStack {\n\n    /** initialize your data structure here. */\n    private Stack<Integer> stack=null;\n\n    private Stack<Integer> helpStack=null;\n\n    public MinStack() {\n        stack=new Stack<>();\n        helpStack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack.push(x);\n        if (helpStack.isEmpty()) {\n            helpStack.push(x);\n        }else{\n            if (helpStack.peek()>x) {\n                helpStack.push(x);\n            }else{\n                helpStack.push(helpStack.peek());\n            }\n        }\n    }\n    \n    public void pop() {\n        stack.pop();\n        helpStack.pop();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return helpStack.peek();\n    }\n}\n```\n\n**解法二**\n\n在上面的基础上进行空间的优化\n\n```java\nclass MinStack {\n\n    /** initialize your data structure here. */\n    private Stack<Integer> stack=null;\n\n    private Stack<Integer> helpStack=null;\n\n    public MinStack() {\n        stack=new Stack<>();\n        helpStack=new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n        if (helpStack.isEmpty()) {\n            helpStack.push(x);\n        }else if (x<=helpStack.peek()) {\n            //相等的也要入栈,不然不好控制后面出栈\n            helpStack.push(x);\n        }\n    }\n    \n    public void pop() {\n        int top=stack.pop();\n        //和辅助栈栈顶相同就出栈\n        if(top==helpStack.peek()){\n            helpStack.pop();\n        }\n        /*\n        if(stack.pop()==helpStack.peek()){\n            helpStack.pop();\n        }*/\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return helpStack.peek();\n    }\n}\n```\n\n其实这里有一个地方把我卡了一会儿，就是出栈的时候，我开始为了简洁if的条件写的\n\n`stack.pop()==helpStack.peek()` 然后卡在了一个case上，想了半天才意识到是`Integer`的问题，这里弹出来的是两个`Integer`并不会自动拆箱，而且值是不在 -128~127之间的，所以就false了\n\n**解法三**\n\n帅地上看见的解法，在栈中存一个diff差值，代表当前元素和入栈前的min的差值，空间复杂度为O(1)，但是这种做法限制比较多，比如数据的大小会有限制，同时貌似也无法做`peek()`操作\n\n```java\npublic class MinStack155_2{\n    /** initialize your data structure here. */\n    private Stack<Integer> stack=null;\n\n    private int min=0;\n\n    public MinStack155_2() {\n        stack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        if (stack.isEmpty()) {\n            min=x;\n            stack.push(0);\n        }else{\n            int diff=x-min;\n            min=diff>0?min:x;\n            stack.push(diff);\n        }\n    }\n    \n    public void pop() {\n        int diff=stack.pop();\n        //小于等于0说明 min就是当前真实的栈顶元素,也就是说 min-minPre=diff\n        min=diff<=0?min-diff:min;\n    }\n    \n    /*public int top() {\n        int diff=stack.peek();\n        return diff<=0?min:diff-min;\n    }*/\n    \n    public int getMin() {\n        return min;\n    }\n}\n```\n\n## [779. 第K个语法符号](https://leetcode-cn.com/problems/k-th-symbol-in-grammar/)\n\nOn the first row, we write a `0`. Now in every subsequent row, we look at the previous row and replace each occurrence of `0` with `01`, and each occurrence of `1` with `10`.\n\nGiven row `N` and index `K`, return the `K`-th indexed symbol in row `N`. (The values of `K` are 1-indexed.) (1 indexed).\n\n```java\nExamples:\nInput: N = 1, K = 1\nOutput: 0\n\nInput: N = 2, K = 1\nOutput: 0\n\nInput: N = 2, K = 2\nOutput: 1\n\nInput: N = 4, K = 5\nOutput: 1\n\nExplanation:\nrow 1: 0\nrow 2: 01\nrow 3: 0110\nrow 4: 01101001\n```\n\n**Note:**\n\n1. `N` will be an integer in the range `[1, 30]`.\n2. `K` will be an integer in the range `[1, 2^(N-1)]`.\n\n**解法一**\n\n找规律，前半部分和后半部分是有一定规律的，把前六行都写出来\n\n```java\n  第一行: 0\n  第二行: 01\n  第三行: 01|10\n  第四行: 01 10|10 01\n  第五行: 01 10 10 01|10 01 01 10\n  第六行: 01 10 10 01 10 01 01 10 | 10 01 01 10 01 10 10 01\n```\n\n  N%2!=0 对称, 第K个等于 2^(N-1)-K+1\n  N%2==0 互补对称\n\n```java\npublic int kthGrammar(int N, int K) {\n    if(K==1 || N==1){\n        return 0;\n    }\n    if(K==2){\n        return 1;\n    }\n    int len=1<<(N-1); //当前行长度\n    if(K>len/2){ //大于1/2\n        //结合上面的规律，找前半部分和自己等价的位置\n        if(N%2!=0){ \n            K=len-K+1;\n        }else{\n            if(K%2==0){\n                K=len-K+2;  \n            }else{\n                K=len-K;\n            }\n        }\n    }\n    //去上一行继续\n    return kthGrammar(N-1,K);\n}\n```\n\n时间复杂第O(N)，思路还算清晰，最开始没想到用`位运算`来算长度，用的`pow()`最后效率差不多，可能是底层做了优化。\n\n**解法二**\n\n这种解法实际上就是把整个序列看作一颗满二叉树，每个节点的值和父节点其实是有对应关系的，如果K是偶数那么就和父节点的值相反，否则就相同，所以我们可以递归的去找父节点对应的index的值。\n\n```java\n//01排列\n//              0\n//          /        \\   \n//      0                1\n//    /   \\            /    \\\n//  0       1        1       0\n// / \\     /  \\     /  \\    / \\ \n//0   1   1    0   1    0  0   1\n\n\npublic int kthGrammar(int N, int K) {\n    if (K==1) return 0;\n    //(K+1)/2是对应父节点的index\n    int parent=kthGrammar(N-1,(K+1)/2);\n    //取反\n    int f_parent=-(parent-1);\n    if (K%2==0) {\n        return f_parent;\n    }\n    return parent;\n}\n```\n时间复杂度依然是`O(N)` 但是比上面那种要更清晰明了\n\n**解法三**\n\n这个解法其实和上面的思路是一样的，都是利用父节点和K的奇偶来判断，其实仔细看上面的代码你会发现N其实并没有实际的意义，具体K的值只和K本身有关，下面的解法就没有用到N.\n\n```java\npublic static int kthGrammar3(int N, int K) {\n    boolean r=false;\n    while(K>1){\n        if (K%2==0) {\n            K=K/2;\n            r=!r;\n        }else{\n            K=(K+1)/2;\n        }\n    }\n    return r?1:0;\n}\n```\n这题其实还有一种解法，利用二进制，对K做奇偶检验，貌似时间复杂度是O(1)。\n\n\n## [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)\n\n实现 pow(*x*, *n*) ，即计算 x 的 n 次幂函数。\n\n**解法一**\n\n这里就要介绍一种快速幂算法了\n\n```java\npublic static double fastPow(double x,int n){\n    if(n==0){\n        return 1;\n    }\n    if(n<0){\n        x=1/x;\n        n=-n;\n    }\n    double res=fastPow(x,n/2);\n    if(n%2==0){\n        return res*res;\n    }\n    return res*res*x;\n}\n```\n\n核心思想就是 `x^n=(x^2/n)^2`，常规累乘的方式计算时间复杂度是O(N)因为要遍历所有的元素，但是其实知道了`x^n/2`之后 `x^n`就可以直接平方得到了不用继续遍历，整体时间复杂度为O(logN) \n\n2019.8.20，又写了一遍，提交然后没过。看了下给的测试用例，最后一个给的n是 `-2^31` 也就是int整数的最小值，int类型的取值范围是 `-2^31 ~ 2^31-1` 而这个负值在这里取反之后会直接溢出最后得到的还是 `-2^31` ，所以这里这样写 if会执行两次，x就又会变回来，所以结果直接就是`Infinity`无穷大了，所以为了保证if只会执行一次可以将其封装一下\n\n```java\npublic static double myPow(double x, int n) {\n    if(n<0){\n        x=1/x;\n        n=-n;\n    }\n    return fastPow(x,n);\n} \n\npublic static double fastPow(double x,int n){\n    if(n==0){\n        return 1.0;\n    }\n    double  half=fastPow(x,n/2);\n    if(n%2==0)\n        return half*half;\n    return half*half*x;\n}\n```\n\n## 5222. 分割平衡字符串\n\n在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。\n\n给出一个平衡字符串 `s`，请你将它分割成尽可能多的平衡字符串。\n\n返回可以通过分割得到的平衡字符串的最大数量\n\n**示例 1：**\n\n```java\n输入：s = \"RLRRLLRLRL\"\n输出：4\n解释：s 可以分割为 \"RL\", \"RRLL\", \"RL\", \"RL\", 每个子字符串中都包含相同数量的 'L' 和 'R'。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"RLLLLRRRLR\"\n输出：3\n解释：s 可以分割为 \"RL\", \"LLLRRR\", \"LR\", 每个子字符串中都包含相同数量的 'L' 和 'R'。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"LLLLRRRR\"\n输出：1\n解释：s 只能保持原样 \"LLLLRRRR\".\n```\n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s[i] = 'L' 或 'R'`\n\n**解法一**\n\n19.10.13的周赛的第1题，果然比赛和刷题还是不一样，差点没做出来。。。\n\n```java\npublic static int balancedStringSplit(String s) {\n    if (s.length()%2==1) {\n        return 0;\n    }\n    Stack<Character> stack=new Stack<>();\n    int count=0;\n    for(int i=0;i<s.length();i++){\n        if (!stack.isEmpty() ){\n            if(s.charAt(i)==stack.peek()) {\n                stack.push(s.charAt(i));    \n            }else{\n                stack.pop();\n                if (stack.isEmpty()) {\n                    count++;\n                }\n            }\n        }else{\n            stack.push(s.charAt(i));\n        }\n    }\n    return count;\n}\n```\n\n## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)\n\n给你一个由 '('、')' 和小写字母组成的字符串 s。\n\n你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。\n\n请返回任意一个合法字符串。\n\n有效「括号字符串」应当符合以下 **任意一条** 要求：\n\n- 空字符串或只包含小写字母的字符串\n- 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」\n- 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」\n\n**示例 1：**\n\n```java\n输入：s = \"lee(t(c)o)de)\"\n输出：\"lee(t(c)o)de\"\n解释：\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。\n```\n\n\n**示例 2：**\n\n```java\n输入：s = \"a)b(c)d\"\n输出：\"ab(c)d\"\n```\n\n\n**示例 3：**\n\n```java\n输入：s = \"))((\"\n输出：\"\"\n解释：空字符串也是有效的\n```\n\n\n**示例 4：**\n\n```java\n输入：s = \"(a(b(c)d)\"\n输出：\"a(b(c)d)\"\n```\n\n**提示：**\n\n- `1 <= s.length <= 10^5`\n- `s[i]` 可能是 `'('`、`')'` 或英文小写字母 \n\n**解法一**\n\n11.3周赛第三题，这题倒是没什么障碍，用栈就ok，不过我这里实现的不太好，replace时间复杂度略高，应该用一个数组做mark最后用StringBuilder做append应该效率会高很多\n\n```java\npublic String minRemoveToMakeValid(String s) {\n    StringBuilder sb=new StringBuilder(s);\n    Stack<Integer> stack=new Stack<>();\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)>='a' && s.charAt(i)<='z') {\n            continue;\n        }\n        if (s.charAt(i)==')') {\n            if (stack.isEmpty()) {\n                sb.replace(i,i+1,\"*\");    \n            }else{\n                stack.pop();\n            }\n        }\n        if (s.charAt(i)=='(') {\n            stack.push(i);\n        }\n    }\n    while (!stack.isEmpty()) {\n        int temp=stack.pop();\n        sb.replace(temp,temp+1,\"*\");\n    }\n    String res=sb.toString().replace(\"*\",\"\");\n    return res;\n}\n```\n\n## [856. 括号的分数](https://leetcode-cn.com/problems/score-of-parentheses/)\n\n给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：\n\n- () 得 1 分。\n- AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。\n- (A) 得 2 * A 分，其中 A 是平衡括号字符串。\n\n**示例 1：**\n\n```java\n输入： \"()\"\n输出： 1\n```\n\n\n**示例 2：**\n\n```java\n输入： \"(())\"\n输出： 2\n```\n\n\n**示例 3：**\n\n```java\n输入： \"()()\"\n输出： 2\n```\n\n\n**示例 4：**\n\n```java\n输入： \"(()(()))\"\n输出： 6\n```\n\n**提示：**\n\n1. S 是平衡括号字符串，且只含有 ( 和 ) 。\n2. 2 <= S.length <= 50\n\n**解法一**\n\n```java\npublic int scoreOfParentheses(String S) {\n    Stack<Integer> stack=new Stack<>();\n    for(int i=0;i<S.length();i++){\n        if(S.charAt(i)=='('){\n            stack.push(-11111);\n        }else{\n            //遇到右括号,下面的分支都是处理 \")\"\n            int top=stack.peek();\n            if(top == -11111){ //栈顶是左括号，将 ( --> 1\n                stack.pop();\n                stack.push(1);\n            }else{\n                int sum=0; //遇到数值了\n                while(!stack.isEmpty()){\n                    int temp=stack.pop();\n                    //弹出去,直到遇到 \"(\"就*2,其实就是把\"(1\"-->2\n                    if(temp==-11111){ \n                        sum*=2;\n                        break;\n                    }\n                    sum+=temp;\n                }\n                stack.push(sum);\n            }\n        }\n    }\n    int res=0;\n    while(!stack.isEmpty()) res+=stack.pop();\n    return res;\n}\n```\n这种解法一开始也没想出来，其实这种就类似于消消乐游戏一样，就按照题目的逻辑来写，从左向右，栈中存标识左括号的数值，这里我用的`-11111` 表示`（` ，然后向右移动，一边移动一边将`（）`给消除掉，其实上面的逻辑自己走一边就通了\n\n**解法二**\n\n这个解法就带有点技巧性了，看懂上面的注释，下面的代码就很简单了\n\n```java\n// (()(())) = 2*()+2*(())= (())+((()))\npublic int scoreOfParentheses(String S) {\n    int k=0,res=1;\n    for (int i=0;i<S.length();i++) {\n        if (S.charAt(i)=='(') {\n            k++; //k用来计算括号的深度\n        }else{\n            k--;\n            if (S.charAt(i-1)=='(') {\n                //\"()\"闭合的时候计算一波\n                res+= 1<<k; //2^k\n            }\n        }\n    }\n    return res;\n}\n```\n\n## [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)\n\n给定 `pushed` 和 `popped` 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 `push` 和弹出 pop 操作序列的结果时，返回 `true` 否则，返回 `false` \n\n**示例 1：**\n\n```java\n输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n```\n\n**示例 2：**\n\n```java\n输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。\n```\n\n**提示：**\n\n1. `0 <= pushed.length == popped.length <= 1000`\n2. `0 <= pushed[i], popped[i] < 1000`\n3. `pushed` 是 `popped` 的排列\n\n**解法一**\n\n直接用栈模拟，可惜没有bugfree...\n\n```java\npublic boolean validateStackSequences(int[] pushed, int[] popped) {\n    if(pushed==null || pushed.length<=0) return true;\n    Deque<Integer> stack=new ArrayDeque<>();\n    int popIndex=0;\n    int pushIndex=0;\n    //pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n    //[1,2,3,4,5]      [4,3,5,1,2]\n    //[1,0] [1,0]\n    while(pushIndex<pushed.length){\n        stack.push(pushed[pushIndex++]);\n        while(!stack.isEmpty()&&popped[popIndex]==stack.peek()){\n            stack.pop();\n            popIndex++;\n        }\n    }\n    return stack.isEmpty();\n}\n```\n每进一个元素就判断栈顶和出栈顺序的头是否相等，然后出栈，最后看栈中是否为空就ok\n\n## [NC560.打字](https://www.nowcoder.com/practice/7819ebf1369044e5bee2f9848d9c6c72)\n\n牛妹在练习打字，现在按照时间顺序给出牛妹按下的键（以字符串形式给出,'<'代表回退backspace，其余字符均是牛妹打的字符，字符只包含小写字母与'<'），牛妹想知道最后在屏幕上显示的文本内容是什么。\n在文本内容为空的时候也可以按回退backspace（在这种情况下没有任何效果）。\n**示例1**\n```go\n输入: \"acv<\"\n输出: \"ac\"\n说明:\n牛妹在打完\"acv\"之后按了回退，所以最后是\"ac\"\n```\n**解法一**\n\n也可以直接数组模拟\n```java\npublic String Typing (String s) {\n    // write code here\n    Deque<Integer> stack = new ArrayDeque<>();\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == '<') {\n            if (stack.isEmpty()) {\n                continue;\n            }\n            stack.pop();\n        }else{\n            stack.push(i);\n        }\n    }\n    StringBuilder sb = new StringBuilder();\n    while(!stack.isEmpty()){\n        sb.append(s.charAt(stack.pop()));\n    }\n    return sb.reverse().toString();\n}\n```\n\n## _BFS广搜_\n\n## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少\n\n**示例 1:**\n\n```java\n输入: n = 12\n输出: 3 \n解释: 12 = 4 + 4 + 4.\n```\n\n\n**示例 2:**\n\n```java\n输入: n = 13\n输出: 2\n解释: 13 = 4 + 9.\n```\n\n**解法一**\n\n这题在上一篇[dp专题](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/)中有讲过，不过是dp的解法，这里主要记录BFS的解法\n\n```java\npublic static int numSquares2(int n) {\n    Queue<Pair> queue=new LinkedList<>();\n    boolean[] visit=new boolean[n+1];\n    queue.add(new Pair(n,0));\n    visit[n]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        int num=pair.num;\n        int step=pair.step;\n        //nums=0说明找到了，并且一定是最短的\n        if (num==0) {\n            return step;\n        }\n        for (int i=1;i*i<=num;i++) {\n            int temp=num-i*i;\n            //注意不要添加重复的元素\n            if (!visit[temp]) {\n                queue.add(new Pair(temp,step+1));\n                visit[temp]=true;\n            }\n        }\n    }\n    return -1;\n}\n\nstatic class Pair{\n    public int step;\n    public int num;\n    public Pair(int num,int step){\n        this.num=num;\n        this.step=step;\n    }\n}\n```\n30ms 90%，比dp的方式会快很多，思路就是将这个问题转换为求图的最短路径的问题，找到一个最短的从n到0的以平方数为差的路径\n\n## [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)\n\nGiven two words (*beginWord* and *endWord*), and a dictionary's word list, find the length of shortest transformation sequence from *beginWord* to *endWord*, such that:\n\n1. Only one letter can be changed at a time.\n2. Each transformed word must exist in the word list. Note that *beginWord* is *not* a transformed word.\n\n**Note:**\n\n- Return 0 if there is no such transformation sequence.\n- All words have the same length.\n- All words contain only lowercase alphabetic characters.\n- You may assume no duplicates in the word list.\n- You may assume *beginWord* and *endWord* are non-empty and are not the same.\n\n**Example 1:**\n\n```java\nInput:\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput: 5\n\nExplanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n```\n\n**Example 2:**\n\n```java\nInput:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput: 0\n\nExplanation: The endWord \"cog\" is not in wordList, therefore no possible transformation.\n```\n\n**解法一**\n\n这题其实很久以前就写过了，当时是看了啊哈算法的一些BFS算法然后仿照书上的写的，书上是C语言写的，所以最后我写的时候也按照C的格式去写了😅，写的贼啰嗦，现在又用\"Java\"的方式又重新写了一遍\n\n```java\nprivate static int[] mark;\n\nint min = Integer.MAX_VALUE;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList)     {\n    // 不存在\n    mark = new int[wordList.size() + 1];\n    if (!wordList.contains(endWord)) {\n        return 0;\n    }\n    // BFS\n    int head = 0, tail = 0;\n    // 初始化队列\n    Que[] que = new Que[wordList.size() + 1];\n    // 循环促使话述祖\n    for (int i = 0; i < que.length; i++) {\n        que[i] = new Que();\n    }\n    que[tail].word = beginWord;\n    que[tail].step = 1;\n    tail++;\n    int flag=0;\n    while (head < tail) {\n        // 遍历字典\n        for (int i = 0; i < wordList.size(); i++) {\n            if (mark[i] == 0 && cmp(wordList.get(i), que[head].word)) {\n                que[tail].word = wordList.get(i);\n                //这里是从head开始的，所以应该是head的步数+1\n                que[tail].step=que[head].step+1;\n                // 标记为已经走过\n                mark[i] = 1;\n                // 统计最小步数\n               if (que[tail].word.equals(endWord)) {\n                //跳出循环\n                    flag=1;\n                   break;\n                }\n                tail++;\n            }\n        }\n        if(flag==1){\n            break;\n        }\n        // 每次检查完一个单词就将其出队列\n        head++;\n    }\n    return que[tail].step;\n}\n\n// 写一个函数判段没吃是否只变化了一个字母\nprivate boolean cmp(String s1, String s2) {\n    int count = 0;\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            count++;\n        }\n    }\n    return count == 1;\n}\n\n// 内部类\nclass Que {\n    String word;\n    int step;\n}\n```\n这就是当时写的解法，思路就是BFS，只不过写的复杂了\n\n**解法二**\n\n```java\npublic int ladderLength(String beginWord, String endWord, List<String> wordList)     {\n    //visit数组\n    boolean[] visit=new boolean[wordList.size()];\n    if (!wordList.contains(endWord)) {\n        return 0;\n    }\n\n    Queue<Pair> queue=new LinkedList<>();\n    queue.add(new Pair(beginWord,1));\n    //int flag=0;\n    while (!queue.isEmpty()) {\n        Pair pair=queue.poll();\n        // 统计最小步数,放在内循环中会快一点\n        /*if (pair.word.equals(endWord)) {\n            return pair.step;\n        }*/\n        // 遍历字典\n        for (int i = 0; i < wordList.size(); i++) {\n            if (!visit[i] && cmp(wordList.get(i),pair.word)) {\n                if (wordList.get(i).equals(endWord)) {\n                    //这里加1 是因为取的是pair的step\n                    //到当前这个单词还要多走一步\n                    return pair.step+1;\n                }\n                queue.add(new Pair(wordList.get(i),pair.step+1));\n                //标记为已经走过\n                visit[i] = true;\n            }\n        }\n    }\n    return 0;\n}\n\n//是否只变化了一个字符\nprivate boolean cmp(String s1, String s2) {\n    int count = 0;\n    for (int i = 0; i < s1.length(); i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            count++;\n            if (count>1) {\n                return false;\n            }\n        }\n    }\n    return count == 1;\n}\n\n//Pair\nclass Pair {\n    String word;\n    int step;\n    public Pair(String word,int step){\n        this.word=word;\n        this.step=step;\n    }\n}\n```\n273ms，47%中规中矩的做法，连续写了好几题BFS的，总算是对BFS的板子有点熟悉了，这题还有两个可以优化的点 ① _双端BFS_ ② _寻找下一个字符串的方式_，只不过我没咋看懂，等看懂了再来补充，那种方式时间好像可以缩减到 20ms内.....\n\n> 这题有个困难版本，需要打印出所有的最短序列，这个在我很久之前的一篇文章中也有讲，但是至今我也还没有AC，一直是TLE，现在回头看我之前的代码已经看不懂了。。。写了100多行，略复杂BFS+DFS的做法，可能是没处理好所以TLE了，感兴趣可以看看[那篇文章](http://imlgw.top/2018/10/31/yi-dao-leetcode-yin-fa-de-can-an/#2-%E5%8A%A0%E5%BC%BA%E7%89%88-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-2)\n\n## [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)\n\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 \n\n**示例 1:**\n输入:\n\n```java\n0 0 0\n0 1 0\n0 0 0\n```\n\n输出:\n\n```java\n0 0 0\n0 1 0\n0 0 0\n```\n\n**示例 2:**\n输入:\n\n```java\n0 0 0\n0 1 0\n1 1 1\n```\n\n\n输出:\n\n```java\n0 0 0\n0 1 0\n1 2 1\n```\n\n\n**注意:**\n\n- 给定矩阵的元素个数不超过 10000\n- 给定矩阵中至少有一个元素是 0\n- 矩阵中的元素只在四个方向上相邻: 上、下、左、右\n\n**解法一**\n\n憨憨的BFS解法\n\n```java\n//遍历每一个1,BFS寻找离他最近的0,一次只能确定一个1,效率略低\npublic int[][] updateMatrix(int[][] matrix) {\n    if (matrix == null || matrix.length <=0 || matrix[0].length <=0) {\n        return new int[][]{};\n    }\n    for (int i=0;i<matrix.length;i++) {\n        for (int j=0;j<matrix[0].length;j++) {\n            if (matrix[i][j] == 1) {\n                matrix[i][j]=findMinDis(matrix,i,j);   \n            }\n        }\n    }\n    return matrix;\n}\n\nprivate int[][] direction={{1,0},{0,1},{-1,0},{0,-1}};\n\npublic int findMinDis(int[][] matrix,int x,int y){\n    Queue<Pair> queue=new LinkedList<>();\n    //boolean[][] visit=new boolean[matrix.length][matrix[0].length];\n    queue.add(new Pair(x,y,0));\n    //visit[x][y]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        for (int i=0;i<direction.length;i++) {\n            int nx=pair.x + direction[i][0];\n            int ny=pair.y + direction[i][1];\n            if (isValid(matrix,nx,ny) /*&& !visit[nx][ny]*/) {\n                //visit[nx][ny]=true;\n                if (matrix[nx][ny] == 0) {\n                    return pair.step+1;\n                }\n                queue.add(new Pair(nx,ny,pair.step+1));\n            }\n        }\n    }\n    return -1; //题目说了一定有0,所以不会走到这里\n}\n\npublic boolean isValid(int[][] matrix,int x,int y){\n    return x>=0 && x<matrix.length && y>=0 && y<matrix[0].length;\n}\n\nclass Pair{\n    int x;\n    int y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n```\n可以看到代码中有很明显的改动痕迹，最开始是用visit数组保证每一个元素只会进队列一次，不会重复的进队列，但是这里为什么我去掉了呢？\n\n其实主要是一开始提交的解法超时了，把visit数组去掉就过了，在数组过大的时候每次BFS都要开辟一个matrix大小的boolean数组，这无疑会极其耗费时间，但是为什么不加visit数组不会死循环呢？\n\n确实，如果不加visit数组那么确实是有可能会导致死循环的，两个节点互相重复添加对方，但是这一题有个很关键的地方，题目说明了一定会有0，也就是说一定会解，那么就不会死循环，举一个很简单的例子\n\n`【0，1，1】` 这里我们先考虑中间的1，然后我们按照下右上左的顺序去添加周围的节点，那么队列中就为末尾的`[1]` ，当遍历到右的时候发现是0，直接return，然后我们考虑下一个1，转了一圈队列中只有一个中间的`[1]` ， 然后我们又重复刚刚的步骤会将末尾的1又加入队列，但是下一次遍历就会找到最左边的0，然后返回，所以并不会死循环，当然这样做的前提是一定要有解！\n\n**解法二**\n\n另一种更好的做法，以0作为源，向四周BFS，同时更新周围的1的值\n\n```java\n//update: 2020.4.15\nprivate int[][] dir={{1,0},{0,1},{-1,0},{0,-1}};\n\npublic int[][] updateMatrix(int[][] matrix) {\n    if(matrix==null || matrix.length<=0) return matrix;\n    boolean[][] visit=new boolean[matrix.length][matrix[0].length];\n    Queue<Pair> queue=new LinkedList<>();\n    for(int i=0;i<matrix.length;i++){\n        for(int j=0;j<matrix[0].length;j++){\n            if(matrix[i][j]==0){\n                queue.add(new Pair(i,j,0));\n                visit[i][j]=true;\n            }else{\n                matrix[i][j]=Integer.MAX_VALUE;\n            }\n        }\n    }\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        for(int i=0;i<dir.length;i++){\n            int nx=pair.x+dir[i][0];\n            int ny=pair.y+dir[i][1];\n            if(valid(matrix,nx,ny) && !visit[nx][ny]){\n                queue.add(new Pair(nx,ny,pair.step+1));\n                matrix[nx][ny]=pair.step+1; //这里不用判断是不是变小，第一次遇到的就是最近的\n                visit[nx][ny]=true;\n            }\n        }\n    }\n    return matrix;\n}\n\npublic boolean valid(final int[][] matrix,int x,int y){\n    return x>=0 && x<matrix.length && y>=0 && y<matrix[0].length;\n}\n\nclass Pair{\n    int x,y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n```\n\n核心思想就是 把所有1都置为最大值, 把所有为0的位置加入队列中, 每次从队列中poll 一个节点, 更新其四周的节点, ~~如果被更新的节点距离变小了就将其也加入队列准备更新其邻接点~~ step是递增的，第一次遇到的一定是最近的\n\n多源BFS，参考下面的 [994. 腐烂的橘子]()  和 [1162. 地图分析]()\n\n**解法三**\n\n> 这题的最优解应该是动态规划的解法，我实在是懒得写（菜），其实和哪个 不同路径有点类似，每个1离他最近的0的距离其实就是它周围的元素离0最近的距离+1\n>\n> 也就是 `matrix[i][j] =min(dp[i][j-1],dp[i-1][j],dp[i+1][j],dp[i][j+1]) + 1` 但是我们不可能同时求出是个方向的最小值，所以我们需要两次遍历，第一遍从左上到右下，第二遍从右下到左上，两次遍历就可以确定每个节点的值，代码以后有时间再来写\n\n## [1306. 跳跃游戏 III](https://leetcode-cn.com/problems/jump-game-iii/)\n\n这里有一个非负整数数组 `arr`，你最开始位于该数组的起始下标 `start` 处。当你位于下标 i 处时，你可以跳到 `i + arr[i]` 或者 `i - arr[i]`。\n\n请你判断自己是否能够跳到对应元素值为 0 的 `任意` 下标处。\n\n注意，不管是什么情况下，你都无法跳到数组之外\n\n**示例 1：**\n\n```java\n输入：arr = [4,2,3,0,3,1,2], start = 5\n输出：true\n解释：\n到达值为 0 的下标 3 有以下可能方案： \n下标 5 -> 下标 4 -> 下标 1 -> 下标 3 \n下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 \n```\n\n\n**示例 2：**\n\n```java\n输入：arr = [4,2,3,0,3,1,2], start = 0\n输出：true \n解释：\n到达值为 0 的下标 3 有以下可能方案： \n下标 0 -> 下标 4 -> 下标 1 -> 下标 3\n```\n\n**示例 3：**\n\n```java\n输入：arr = [3,0,2,1,2], start = 2\n输出：false\n解释：无法到达值为 0 的下标 1 处。 \n```\n\n**提示：**\n\n- `1 <= arr.length <= 5 * 10^4`\n- `0 <= arr[i] < arr.length`\n- `0 <= start < arr.length`\n\n**解法一**\n\nBFS，某次周赛的第3题，还是挺简单的，可惜那次没参加\n\n```java\npublic boolean canReach(int[] arr, int start) {\n    boolean[] visit=new boolean[arr.length];\n    Queue<Integer> queue=new LinkedList<>();\n    queue.add(start);\n    visit[start]=true;\n    while(!queue.isEmpty()){\n        int cur=queue.poll();\n        if (arr[cur] == 0) {\n            return true;\n        }\n        if (cur-arr[cur]>=0 && !visit[cur-arr[cur]]) {\n            queue.add(cur-arr[cur]);\n            visit[cur-arr[cur]]=true;\n        }\n        if (cur+arr[cur]<arr.length && !visit[cur+arr[cur]]) {\n            queue.add(cur+arr[cur]);\n            visit[cur+arr[cur]]=true;\n        }\n    }\n    return false;\n}\n```\n\n**解法二**\n\nDFS解法，没啥好说的\n\n```java\npublic boolean canReach(int[] arr,int start){\n    boolean[] visit=new boolean[arr.length];\n    return dfs(arr,start,visit);\n}\n\npublic boolean dfs(int[] arr,int index,boolean[] visit){\n    if (arr[index] == 0) {\n        return true;\n    }\n    visit[index]=true;\n    boolean b=false;\n    if (index-arr[index] >=0 && !visit[index-arr[index]]) {\n        b=dfs(arr,index-arr[index],visit);\n    }\n    if (index+arr[index] <arr.length && !visit[index+arr[index]]) {\n        return b|dfs(arr,index+arr[index],visit);\n    }\n    return b;\n}\n```\n## [5314. 跳跃游戏 IV](https://leetcode-cn.com/problems/jump-game-iv/)\n\n给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。\n\n每一步，你可以从下标 i 跳到下标：\n\n- i + 1 满足：i + 1 < arr.length\n- i - 1 满足：i - 1 >= 0\n- j 满足：arr[i] == arr[j] 且 i != j\n\n请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。 \n注意：任何时候你都不能跳到数组外面。\n\n**示例 1：**\n\n```java\n输入：arr = [100,-23,-23,404,100,23,23,23,3,404]\n输出：3\n解释：那你需要跳跃 3 次，下标依次为 0 --> 4 --> 3 --> 9 。下标 9 为数组的最后一个元素的下标。\n```\n\n**示例 2：**\n\n```java\n输入：arr = [7]\n输出：0\n解释：一开始就在最后一个元素处，所以你不需要跳跃。\n```\n\n\n**示例 3：**\n\n```java\n输入：arr = [7,6,9,6,9,6,9,7]\n输出：1\n解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。\n```\n\n\n**示例 4：**\n\n```java\n输入：arr = [6,1,9]\n输出：2\n```\n\n\n**示例 5：**\n\n```java\n输入：arr = [11,22,7,7,7,7,7,7,7,22,13]\n输出：3\n```\n\n**提示：**\n\n- `1 <= arr.length <= 5 * 10^4`\n- `-10^8 <= arr[i] <= 10^8`\n\n**解法一**\n\n19双周赛的最后一题，讲道理挺简单的（可我还是TLE了好长时间）\n\n```java\npublic int minJumps(int[] arr) {\n    Queue<Pair> queue=new LinkedList<>();\n    boolean[] visit=new boolean[arr.length];\n    HashMap<Integer,List<Integer>> map=new HashMap<>();\n    //构建等值的索引 连续相同的只保留头尾\n    for (int i=0;i<arr.length;i++) {\n        List<Integer> lis=map.computeIfAbsent(arr[i],k->new ArrayList<>());\n        if (!((i-1>=0&&arr[i-1]==arr[i]) && (i+1<arr.length&&arr[i+1]==arr[i]))){\n            lis.add(i);\n        }\n    }\n    queue.add(new Pair(0,0));\n    visit[0]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        if (pair.index==arr.length-1) {\n            return pair.step;\n        }\n        if(pair.index+1<arr.length && !visit[pair.index+1]){\n            queue.add(new Pair(pair.index+1,pair.step+1));\n            visit[pair.index+1]=true;\n        }\n        if (pair.index-1>=0 && !visit[pair.index-1]) {\n            queue.add(new Pair(pair.index-1,pair.step+1));\n            visit[pair.index-1]=true;\n        }\n        List<Integer> list=map.get(arr[pair.index]);\n        for (int i=list.size()-1;i>=0;i--) {\n            int idx=list.get(i);\n            if (!visit[idx]) {\n                queue.add(new Pair(idx,pair.step+1));\n                visit[idx]=true;\n            }\n        }\n    }\n    return -1;\n}\n\nclass Pair{\n    int index;\n    int step;\n    public Pair(int index,int step){\n        this.index=index;\n        this.step=step;\n    }\n}\n```\n\n看一下数据范围，直接BFS遍历跳同值的肯定不行，所以想到了用map预处理同值的索引，结果还是TLE了，后面一个case有50000个7，这里即使做了map索引但是无奈太多了，依然会超时，这里其实这么多7，只有头和尾的7是用的，其他位置的7都是无用的，可以直接忽略，所以构建索引的时候可以跳过这些中间位置，这样可以节省很多时间\n\n## [690. 员工的重要性](https://leetcode-cn.com/problems/employee-importance/)\n\n给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。\n\n比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。\n\n现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。\n\n**示例 1:**\n\n```java\n输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n输出: 11\n解释:\n员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。\n```\n\n\n**注意:**\n\n1. 一个员工最多有一个直系领导，但是可以有多个直系下属\n2. 员工数量不超过2000。\n\n**解法一**\n\nBFS，没啥好说的，憨憨题直接bugfree\n\n```java\npublic int getImportance(List<Employee> employees, int id) {\n    HashMap<Integer,Employee> map=new HashMap<>();\n    for (Employee e:employees) {\n        map.put(e.id,e);\n    }\n    Queue<Integer> queue=new LinkedList<>();\n    queue.add(id);\n    int res=0;\n    while(!queue.isEmpty()){\n        Employee cur=map.get(queue.poll());\n        res+=cur.importance;\n        List<Integer> subordinates=cur.subordinates;\n        if (!subordinates.isEmpty()) {\n            for (int eid:subordinates) {\n                queue.add(eid);\n            }\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\nDFS，本来不想写的，这类题其实都是树的题变了个说法而已\n\n```java\npublic int getImportance(List<Employee> employees, int id) {\n    HashMap<Integer,Employee> map=new HashMap<>();\n    for (Employee e:employees) {\n        map.put(e.id,e);\n    }\n    return dfs(map,id);\n}\n\npublic int dfs(HashMap<Integer,Employee> map,int id){\n    Employee cur=map.get(id);\n    int res=cur.importance;\n    for (int eid:cur.subordinates) {\n        res+=dfs(map,eid);\n    }\n    return res;\n}\n```\n## [1311. 获取你好友已观看的视频](https://leetcode-cn.com/problems/get-watched-videos-by-your-friends/)\n\n有 n 个人，每个人都有一个  0 到 n-1 的唯一 id 。\n\n给你数组 `watchedVideos`  和 `friends` ，其中 `watchedVideos[i]`  和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。\n\nLevel 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。\n\n给定你的 `id`  和一个 `level` 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按名字字典序从小到大排列。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/01/I5XJKQg3WwvaeB1.png)\n\n```java\n输入：watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n输出：[\"B\",\"C\"] \n解释：\n你的 id 为 0 ，你的朋友包括：\nid 为 1 -> watchedVideos = [\"C\"] \nid 为 2 -> watchedVideos = [\"B\",\"C\"] \n你朋友观看过视频的频率为：\nB -> 1 \nC -> 2\n```\n\n**示例 2：**\n\n![image.png](https://i.loli.net/2020/02/01/qhDZvr3sbJkgIuw.png)\n\n```java\n输入：watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n输出：[\"D\"]\n解释：\n你的 id 为 0 ，你朋友的朋友只有一个人，他的 id 为 3 。\n```\n\n**提示：**\n\n- n == watchedVideos.length == friends.length\n- 2 <= n <= 100\n- 1 <= watchedVideos[i].length <= 100\n- 1 <= watchedVideos[i][j].length <= 8\n- 0 <= friends[i].length < n\n- 0 <= friends[i][j] < n\n- 0 <= id < n\n- 1 <= level < n\n- 如果 friends[i] 包含 j ，那么 friends[j] 包含 i\n\n**解法一**\n\n170周赛的第三题，其实是一道水题，题目意思搞清楚就很简单了\n\n```java\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\n    Queue<Integer> queue=new LinkedList<>();\n    int[] levels=new int[friends.length]; //这里没必要,这里用一个变量就ok了\n    boolean[] visit=new boolean[friends.length];\n    HashMap<String,Integer> map=new HashMap<>();\n    List<Integer> flist=new ArrayList<>(); //level层的朋友\n    queue.add(id);\n    visit[id]=true;\n    while(!queue.isEmpty()){\n        int cur=queue.poll();\n        int[] cfs=friends[cur];\n        for (int i=0;i<cfs.length;i++) {\n            if (!visit[cfs[i]]) {\n                queue.add(cfs[i]);\n                levels[cfs[i]]=levels[cur]+1;   \n                visit[cfs[i]]=true;\n                if (levels[cfs[i]] == level) {\n                    flist.add(cfs[i]);\n                }\n            }\n        }\n    }\n    for (int i=0;i<flist.size();i++) {\n        List<String> videos=watchedVideos.get(flist.get(i));\n        for (String v:videos) {\n            map.put(v,map.getOrDefault(v,0)+1); //map记录videos出现的次数\n        }\n    }\n    //下面几步还是挺老道的\n    List<String> res=new ArrayList(map.keySet());\n    res.sort((v1,v2)->{\n        int c1=map.get(v1);\n        int c2=map.get(v2);\n        return c1==c2?v1.compareTo(v2):c1-c2; //相等的时候按照字典序列排序\n    });\n    return res;\n}\n```\n\n## [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)\n\n给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。\n\n示例 :\n\n```java\n给定 a / b = 2.0, b / c = 3.0\n问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \n返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]\n```\n\n输入为: `vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries(方程式，方程式结果，问题方程式)`， 其中 `equations.size() == values.size()`，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回`vector<double>`类型。\n\n基于上述例子，输入如下：\n\n```java\nequations(方程式) = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\nvalues(方程式结果) = [2.0, 3.0],\nqueries(问题方程式) = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \n```\n\n输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。\n\n**解法一**\n\n建立图，然后BFS，这样就简单多了，比并茶集的方法直白多了，随便也学了一下如何建图\n\n```java\n//构造图 + BFS/DFS\nprivate Map<String,Map<String,Double>> graph = new HashMap<>();\n\npublic void buildGraph(List<List<String>> equations, double[] values){\n    for (int i = 0; i < values.length; i++) {\n        graph.computeIfAbsent(equations.get(i).get(0), k -> new HashMap<>()).put(equations.get(i).get(1), values[i]);\n        graph.computeIfAbsent(equations.get(i).get(1), k -> new HashMap<>()).put(equations.get(i).get(0), 1 / values[i]);\n    }\n}\n\nclass Pair{\n    String key;\n    double val;\n    public Pair(String key,double val){\n        this.key=key;\n        this.val=val;\n    }\n}\n\npublic double bfs(String a,String b){\n    //讲道理,不管a,b是否在graph中,只要想等都应该返回1吧,这里是考虑了0的情况?\n    if (!graph.containsKey(a) || !graph.containsKey(b)) {\n        return -1.0;\n    }\n    if (a.equals(b)) {\n        return 1.0;\n    }\n    Queue<Pair> queue=new LinkedList<>();\n    queue.add(new Pair(a,1.0));\n    HashSet<String> visit=new HashSet<>();\n    while(!queue.isEmpty()){\n        Pair cur=queue.poll();\n        if (!visit.contains(cur.key)) {\n            visit.add(cur.key);\n            Map<String,Double> map=graph.get(cur.key);\n            for (String next:map.keySet()) {\n                if (b.equals(next)) {\n                    return cur.val*map.get(next);\n                }\n                queue.add(new Pair(next,cur.val*map.get(next)));\n            }\n        }\n    }\n    return -1.0;\n}\n\npublic double dfs(String a,String b,HashSet<String> visit){\n    if (!graph.containsKey(a)) {\n        return -1;\n    }\n    if (a.equals(b)) {\n        return 1;\n    }\n    visit.add(a);\n    Map<String,Double> nextMap=graph.get(a);\n    for (String next:nextMap.keySet()) {\n        if (!visit.contains(next)) {\n            double subres=dfs(next,b,visit);\n            if (subres!=-1) {\n                return subres*nextMap.get(next);\n            }\n        }\n    }\n    return -1;\n}\n\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n    buildGraph(equations,values);\n    double[] res=new double[queries.size()];\n    int index=0;\n    for (List<String> query:queries) {\n        HashSet<String> visit=new HashSet<>();\n        //res[index++]=bfs(query.get(0),query.get(1),visit); \n        res[index++]=bfs(query.get(0),query.get(1));\n    }\n    return res;\n}\n```\n\n## [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)\n\n删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。\n\n**说明:** 输入可能包含了除 ( 和 ) 以外的字符。\n\n**示例 1:**\n\n```java\n输入: \"()())()\"\n输出: [\"()()()\", \"(())()\"]\n```\n\n\n**示例 2:**\n\n```java\n输入: \"(a)())()\"\n输出: [\"(a)()()\", \"(a())()\"]\n```\n\n\n**示例 3:**\n\n```java\n输入: \")(\"\n输出: [\"\"]\n```\n\n**解法一**\n\nBFS解法\n\n```java\npublic List<String> removeInvalidParentheses(String s) {\n    List<String> res=new ArrayList<>();\n    Queue<String> queue=new LinkedList<>();\n    HashSet<String> visit=new HashSet<>();\n    visit.add(s);\n    queue.add(s);\n    boolean flag=false;\n    while(!queue.isEmpty()){\n        String cur=queue.poll();\n        if (isValid(cur)) {\n            res.add(cur);\n            flag=true;\n        }\n        if (flag) {\n            continue;\n        }\n        for (int i=0;i<cur.length();i++) {\n            if (cur.charAt(i)=='(' || cur.charAt(i)==')') {\n                String temp=cur.substring(0,i)+cur.substring(i+1,cur.length());\n                if (!visit.contains(temp)) {\n                    queue.add(temp);\n                    visit.add(temp);\n                }\n            }\n        }\n    }\n    if(res.isEmpty()) res.add(\"\");\n    return res;\n}\n\npublic boolean isValid(String s){\n    int left=0,right=0;\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)=='(') {\n            left++;\n        }else if (s.charAt(i)==')') {\n            if (left>0) {\n                left--;\n            }else{\n                return false;\n            }\n        }\n    }\n    return left==0;\n}\n```\n\n还是比较简单，dfs的解法比较难搞，容易TLE，这里懒得写了\n\n## [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)\n\n在给定的网格中，每个单元格可以有以下三个值之一：\n\n- 值 0 代表空单元格；\n- 值 1 代表新鲜橘子；\n- 值 2 代表腐烂的橘子。\n\n每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。\n\n返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。\n\n**示例 1：**\n\n![mark](http://static.imlgw.top/blog/20200304/YGBajce2liDs.png?imageslim)\n\n```java\n输入：[[2,1,1],[1,1,0],[0,1,1]]\n输出：4\n```\n\n**示例 2：**\n\n```java\n输入：[[2,1,1],[0,1,1],[1,0,1]]\n输出：-1\n解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n```\n\n**示例 3：**\n\n```java\n输入：[[0,2]]\n输出：0\n解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n```\n\n**提示：**\n\n1. `1 <= grid.length <= 10`\n2. `1 <= grid[0].length <= 10`\n3. `grid[i][j]` 仅为 `0`、`1` 或 `2`\n\n**解法一**\n\nBFS打卡题，这种解法应该算是比较好的了，2ms\n\n```java\nprivate int[][] diretion={{0,1},{1,0},{0,-1},{-1,0}};\n\npublic int orangesRotting(int[][] grid) {\n    Queue<Pair> queue=new LinkedList<>();\n    int time=0;\n    int count=0;\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==1) count++; //统计好橘子的数量\n            if(grid[i][j]==2){\n                queue.add(new Pair(i,j));\n            }\n        }\n    }\n    if(count==0) return 0;\n    while(!queue.isEmpty()){\n        //每一轮的坏橘子数量\n        int size=queue.size();\n        time++;\n        while(size-- >0){\n            Pair pair=queue.poll();\n            for (int i=0;i<4;i++) {\n                int nx=pair.x+diretion[i][0];\n                int ny=pair.y+diretion[i][1];\n                if(valid(grid,nx,ny) && grid[nx][ny]==1){\n                    grid[nx][ny]=2;\n                    count--;//好橘子--\n                    queue.add(new Pair(nx,ny));\n                }\n            }\n            if(count==0) return time;\n        }\n    }\n    return -1;\n}\n\nclass Pair{\n    int x,y;\n    public Pair(int x,int y){\n        this.x=x;\n        this.y=y;\n    }\n}\n\npublic boolean valid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n**解法二**\n\n一开始的解法，虽然效率稍微低一点点 4ms，但是bugfree了\n\n```java\nprivate int[][] diretion={{0,1},{1,0},{0,-1},{-1,0}};\n\nclass Pair{\n    int x,y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n\npublic int orangesRotting(int[][] grid) {\n    Queue<Pair> queue=new LinkedList<>();\n    int max=0;\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==2){\n                queue.add(new Pair(i,j,0));\n            }\n        }\n    }\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        //统计一个最大的步数作为结果\n        //max=Math.max(max,pair.step);\n        max=pair.step; //最后弹出的哪个就是最大的，这是个递增(非单调)的过程\n        for (int i=0;i<4;i++) {\n            int nx=pair.x+diretion[i][0];\n            int ny=pair.y+diretion[i][1];\n            if(valid(grid,nx,ny) && grid[nx][ny]==1){\n                grid[nx][ny]=2;\n                queue.add(new Pair(nx,ny,pair.step+1));\n            }\n        }\n    }\n    return check(grid)?max:-1;\n}\n\npublic boolean check(int[][] grid){\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==1){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\npublic boolean valid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n经过勘误，发现有一处地方有点小问题，已经修改，`pair.step` 在队列中是一个递增（不单调，会相等）的过程，所以最后弹出的就是最大的\n\n## [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)\n\n你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。\n\n我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。\n\n如果我们的地图上只有陆地或者海洋，请返回 -1。\n\n**示例 1：**\n\n![GVuO3Q.png](https://s1.ax1x.com/2020/03/29/GVuO3Q.png)\n\n```java\n输入：[[1,0,1],[0,0,0],[1,0,1]]\n输出：2\n解释： \n海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。\n```\n\n**示例 2：**\n\n![GVKSH0.png](https://s1.ax1x.com/2020/03/29/GVKSH0.png)\n\n```java\n输入：[[1,0,0],[0,0,0],[0,0,0]]\n输出：4\n解释： \n海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。\n```\n\n**提示：**\n\n1. `1 <= grid.length == grid[0].length <= 100`\n2. `grid[i][j]` 不是 `0` 就是 `1`\n\n**解法一**\n\n这题的意思其实求**离陆地最远的海洋是那一块，然后返回这个最远的距离**，这个题目描述的确实让人迷惑，一会儿最远，一会儿最近，其实题目意思搞懂了就很简单了，其实和上面腐烂的橘子是一样的。多源的BFS，曼哈顿距离其实就是上下左右走的step\n\n```java\nprivate int[][] diretion={{1,0},{-1,0},{0,1},{0,-1}};\n\npublic int maxDistance(int[][] grid) {\n    int maxDis=-1;\n    int m=grid.length,n=grid[0].length;\n    boolean[][] visit=new boolean[m][n];\n    Queue<Pair> queue=new LinkedList<>();\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(grid[i][j]==1){\n                queue.add(new Pair(i,j,0));\n                visit[i][j]=true;\n            }\n        }\n    }\n    if(queue.size()==0 || queue.size()==m*n)return -1;\n    int step=0;\n    int res=-1;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        res=pair.step;\n        for (int i=0;i<4;i++) {\n            int nx=pair.x+diretion[i][0];\n            int ny=pair.y+diretion[i][1];\n            if(valid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]==0){\n                queue.add(new Pair(nx,ny,pair.step+1));\n                visit[nx][ny]=true;\n            }\n        }\n    }\n    return res;\n}\n\nclass Pair{\n    int x,y;\n    int step;\n    public Pair(int x,int y,int step){\n        this.x=x;\n        this.y=y;\n        this.step=step;\n    }\n}\n\npublic boolean valid(final int[][] grid,int x,int y){\n    return x>=0 && x<grid.length && y>=0 && y<grid[0].length;\n}\n```\n## [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)\n\n你这个学期必须选修 `numCourse` 门课程，记为 0 到 `numCourse-1` 。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`\n\n给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n\n**示例 1:**\n\n```java\n输入: 2, [[1,0]] \n输出: true\n解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。\n```\n\n\n**示例 2:**\n\n```java\n输入: 2, [[1,0],[0,1]]\n输出: false\n解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n```\n\n**提示：**\n\n1. 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n2. 你可以假定输入的先决条件中没有重复的边。\n3. `1 <= numCourses <= 10^5`\n\n**解法二**\n\n学习下拓扑排序，其实核心在于邻接表的构建\n\n```java\npublic boolean canFinish(int numCourses, int[][] prerequisites) {\n    int[] indegree=new int[numCourses];\n    List<List<Integer>> adjacency=new ArrayList<>();\n    for(int i=0;i<numCourses;i++){\n        adjacency.add(new ArrayList<>());\n    }\n    for(int[] p:prerequisites){\n        indegree[p[0]]++; //每个节点的入度值\n        //邻接表,注意这里别搞反了,这里记录的是p[1]所有的出度节点\n        adjacency.get(p[1]).add(p[0]); \n    }\n    //课程id\n    Queue<Integer> queue=new LinkedList<>();\n    for(int i=0;i<numCourses;i++){\n        if(indegree[i]==0){\n            queue.add(i);\n        }\n    }\n    while(!queue.isEmpty()){\n        int cid=queue.poll();\n        numCourses--;\n        for (int id:adjacency.get(cid)) { //cid --> id\n            //该节点的所有邻接节点入度--\n            indegree[id]--;\n            if(indegree[id]==0){\n                queue.add(id);\n            }\n        }\n    }\n    return numCourses==0;\n}\n```\n## [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)\n\n现在你总共有 *n* 门课需要选，记为 `0` 到 `n-1`。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`\n\n给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。\n\n可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n\n**示例 1:**\n\n```java\n输入: 2, [[1,0]] \n输出: [0,1]\n解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。\n```\n\n**示例 2:**\n\n```java\n输入: 4, [[1,0],[2,0],[3,1],[3,2]]\n输出: [0,1,2,3] or [0,2,1,3]\n解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n```\n\n**说明:**\n\n1. 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。\n2. 你可以假定输入的先决条件中没有重复的边。\n\n**提示:**\n\n1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。\n2. [通过 DFS 进行拓扑排序](https://www.coursera.org/specializations/algorithms) - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。\n3. 拓扑排序也可以通过 [BFS](https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&fromid=2148012&fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2) 完成。\n\n**解法一**\n\nBFS做法，和上面一样\n\n```java\n//BFS拓扑排序\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] indegree=new int[numCourses]; //入度数\n    List<List<Integer>> adjacency=new ArrayList<>();\n    for(int i=0;i<numCourses;i++){\n        adjacency.add(new ArrayList<>());\n    }\n    for(int[] pre:prerequisites){\n        indegree[pre[0]]++;\n        adjacency.get(pre[1]).add(pre[0]);\n    }\n    int k=0;\n    int[] res=new int[numCourses];\n    Queue<Integer> queue=new LinkedList<>();\n    for(int i=0;i<numCourses;i++){\n        if(indegree[i]==0){\n            queue.add(i);\n        }\n    }\n    while(!queue.isEmpty()){\n        int cur=queue.poll();\n        res[k++]=cur;\n        for(int c:adjacency.get(cur)){\n            indegree[c]--;\n            if(indegree[c]==0){\n                queue.add(c);\n            }\n        }\n    }\n    return k==numCourses?res:new int[0];\n}\n```\n\n**解法二**\n\nDFS的做法，比BFS更有意思一点，其实就是个不断判环的过程，图相关的还是不太熟悉啊\n\n```java\n//DFS的解法\nint k=0;\n\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> adjacency=new ArrayList<>();\n    for(int i=0;i<numCourses;i++){\n        adjacency.add(new ArrayList<>());\n    }\n    int[] mark=new int[numCourses];\n    int[] res=new int[numCourses];\n    for(int[] pre:prerequisites){\n        adjacency.get(pre[0]).add(pre[1]); //注意这个区别\n    }\n    for (int i=0;i<numCourses;i++) {\n        if(dfs(adjacency,i,mark,res)) return new int[0];\n    }\n    return res;\n}\n\npublic boolean dfs(List<List<Integer>> adj,int cur,int[] mark,int[] res){\n    if(mark[cur]==1) return true;  //正在访问\n    if(mark[cur]==2) return false; //节点已经访问完（之前已经学了）\n    mark[cur]=1;\n    for(int c:adj.get(cur)){\n        if(dfs(adj,c,mark,res)){\n            return true;\n        }\n    }\n    mark[cur]=2;\n    //cur的先决课程是没环的，所以可以学cur\n    res[k++]=cur; \n    return false;\n}\n```\n\n## [365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)\n\nDifficulty: **中等**\n\n\n有两个容量分别为 _x_升 和 _y_升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 _z_升 的水？\n\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 _z升 _水。\n\n你允许：\n\n*   装满任意一个水壶\n*   清空任意一个水壶\n*   从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n**示例 1:** (From the famous )\n\n```go\n输入: x = 3, y = 5, z = 4\n输出: True\n```\n\n**示例 2:**\n\n```go\n输入: x = 2, y = 6, z = 5\n输出: False\n```\n\n\n**解法一**\n\n暴力BFS的解法\n```java\npublic boolean canMeasureWater(int x, int y, int z) {\n    Queue<int[]> queue = new LinkedList<>();\n    int capX = x;\n    int capY = y;\n    queue.add(new int[]{x, y});\n    while(!queue.isEmpty()) {\n        int[] cur = queue.poll();\n        int cx = cur[0];\n        int cy = cur[1];\n        if (cx==z || cy==z || cx+cy==z) {\n            return true;\n        }\n        //清空x\n        addQueue(0, cy, queue);\n        //清空y\n        addQueue(cx, 0, queue);\n        //装满x\n        addQueue(capX, cy, queue);\n        //装满y\n        addQueue(cx, capY, queue);\n        //x-->y\n        addQueue(Math.max(0, cx-capY+cy), Math.min(capY, cy+cx), queue);\n        //y-->x\n        addQueue(Math.min(capX, cy+cx), Math.max(0, cy-capY+cx), queue);\n    }\n    return false;\n}\n\npublic void addQueue(int x, int y, Queue<int[]> queue){\n    long hashCode = x * (long)1e9+7 + y;\n    if (!visit.contains(hashCode)) {\n        queue.add(new int[]{x, y});\n        visit.add(hashCode);\n    }\n}\n```\n**解法二**\n数学解法，涉及到一些数学定理（贝祖定理），我也不是很懂（就是搞懂过两天也忘了）\n```java\npublic boolean canMeasureWater(int x, int y, int z) {\n    if(x+y<z) return false;\n    if(x==0 || y==0) return z==0 || x+y==z;\n    return z%gcd(x,y)==0;\n}\n\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n```\n\n## _单调栈_\n\n> 单独开辟出新的专题 [LeetCode单调栈](http://imlgw.top/2020/08/28/leetcode-dan-diao-zhan/)","tags":["LeetCode"],"categories":["算法"]},{"title":"AQS源码解析（上）","url":"/2019/09/24/abstractqueuedsynchronizer/","content":"\n## AbstractQueuedSynchronized\n\n`AbstractQueuedSynchronized` 简称AQS，这个类是整个并发包的基础工具类， ReentrantLock、CountDownLatch、Semaphore、FutureTask 等并发工具类底层都是通过它来实现的\n\nAQS定义了两种资源共享的方式：\n\n- Exclusive：独占式，只有一个线程能获取资源并执行，比如ReentrantLock。\n- Share：共享式，多个线程获取资源，多个线程可以同时执行，比如CountDownLatch，ReentrantReadWriteLock的ReadLock等\n\n### AQS结构\n\n#### 属性\n\n主要的就是这三个volatile修饰的Node对象，还有一些对应的偏移量(用于CAS的)\n\n```java\n/**\n * Head of the wait queue, lazily initialized.  Except for\n * initialization, it is modified only via method setHead.  Note:\n * If head exists, its waitStatus is guaranteed not to be\n * CANCELLED.\n * 头节点，可以理解为当前持有锁的节点\n * 在分析的过程中不要将它算作队列的一部分！它只是一个空节点\n */\nprivate transient volatile Node head;\n\n/**\n * Tail of the wait queue, lazily initialized.  Modified only via\n * method enq to add new wait node.\n * 尾节点\n */\nprivate transient volatile Node tail;\n\n/**\n * The synchronization state.\n * 同步状态，0代表没有被占用，1代表被一个线程占用，>1 代表被同一个线程多次占用（可重入）\n */\nprivate volatile int state;\n```\n\n#### Node节点\n\n```java\nstatic final class Node {\n    /** Marker to indicate a node is waiting in shared mode */\n    //共享模式\n    static final Node SHARED = new Node();\n    /** Marker to indicate a node is waiting in exclusive mode */\n    //独占模式\n    static final Node EXCLUSIVE = null;\n\n    /** waitStatus value to indicate thread has cancelled */\n    //取消抢锁\n    static final int CANCELLED =  1;\n    \n    /** waitStatus value to indicate successor's thread needs unparking */\n    //代表当前节点的后续节点需要被unparking，也就是说后继节点状态是parking\n    static final int SIGNAL    = -1;\n    \n    /** waitStatus value to indicate thread is waiting on condition */\n    //在condition上等待\n    static final int CONDITION = -2;\n    \n    /**\n     * waitStatus value to indicate the next acquireShared should\n     * unconditionally propagate\n     */\n    static final int PROPAGATE = -3;\n\n\t//上面的那些状态\n    volatile int waitStatus;\n\n    //前驱节点    \n    volatile Node prev;\n    //后继节点\n    volatile Node next;\n\n    /**\n     * The thread that enqueued this node.  Initialized on\n     * construction and nulled out after use.\n     */\n    volatile Thread thread;\n\n    /**\n     * Link to next node waiting on condition, or the special\n     * value SHARED.  Because condition queues are accessed only\n     * when holding in exclusive mode, we just need a simple\n     * linked queue to hold nodes while they are waiting on\n     * conditions. They are then transferred to the queue to\n     * re-acquire. And because conditions can only be exclusive,\n     * we save a field by using special value to indicate shared\n     * mode.\n     */\n    Node nextWaiter;\n\n    /**\n     * Returns true if node is waiting in shared mode.\n     */\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n\n    //返回前驱节点\n    final Node predecessor() throws NullPointerException {\n        Node p = prev;\n        if (p == null)\n            throw new NullPointerException();\n        else\n            return p;\n    }\n\n    Node() {    // Used to establish initial head or SHARED marker\n    }\n\n    Node(Thread thread, Node mode) {     // Used by addWaiter\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n```\n\n## ReentrantLock分析\n\n我们知道ReentrantLock内部有两个锁，一个是公平锁(FairSync)🔒，一个是非公平锁(NonFairSync)🔒，这两个锁都是独占锁，两者实现的差异其实并不大，我们先从`公平锁`开始说起。\n\n```java\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        acquire(1);\n    }\n    \n    /**\n     * Fair version of tryAcquire.  Don't grant access unless\n     * recursive call or no waiters or is first.\n     */\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n### Lock()\n\n🔔 **这里我们为了模拟真实的情况，我们假设有两个线程`Thread0` 和`Thread1` 过来执行了`Lock()` 方法，且`Thread0` 比`Thread1` 要先执行。**\n\n`Lock()`方法中调用了父类的`acquire(1)`\n\n#### acquire()\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n首先尝试tryAcquire(1)，这个tryLock()在AQS中没有具体实现是交给子类去实现的，所以这里就会调用FairSync的，tryAquire(1)\n\n#### tryAquire()\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取同步状态\n    int c = getState();\n    if (c == 0) { //0代表还没有线程占用\n        //判断有没有前驱节点（除head节点外），没有则进行CAS设置同步状态获取锁\n        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { \n            //设置当前线程为独占线程\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //到这里就说明已经有线程占用了，所以下面是为了重入\n    else if (current == getExclusiveOwnerThread()) {\n        //这里不用担心并发的问题，因为是独占锁，同时只有一个线程会到达这里\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n#### hasQueuedPredecessors()\n\n公平锁和非公平锁的tryAcquire方法区别就在这里，这个方法就是判断有没有前驱节点(不包含头节点head，也就是)存在，有的话为了保证公平性就是需要等待，返回true。\n\n```java\npublic final boolean hasQueuedPredecessors() {\n    // The correctness of this depends on head being initialized\n    // before tail and on head.next being accurate if the current\n    // thread is first in queue.\n    Node t = tail; // Read fields in reverse initialization order\n    Node h = head;\n    Node s;\n    // 头不等于尾，并且队列的第一个节点所持有线程非当前线程返回true\n    return h != t &&\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n```\n\n💡 到这里我们分析下`Thread0` 和`Thread1` 的执行情况\n\n🔸 首先`Thread0`先执行了`tryAcquire(1)`  没有任何阻碍，执行成功直接retrurn\n\n🔸 `Thread1` 此时有多种情况：\n\n- 还没有获取state ，`Thread0`执行完后获取State==1 ，由于是独占锁直接return false ，获取锁失败。\n\n-  已经`getState()==0`了，执行`hasQueuedPredecessors` 方法，注意，此时head和tail都还没有初始化，都还是null（官方的注释中也提到head和tail是 lazily initialized ）所以这里会直接 return false，然后继续执行CAS，由于前面`Thread0` 已经将state设置为了 1 ，所以这里CAS肯定失败了，最终`Thread1`的tryAcquire失败返回false。\n\n🔸 既然`tryAcquire()` 失败了，那`Thread1` 就会转头继续执行后面的方法\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n首先执行的就是`AddWaiter()` \n\n#### addWaiter()\n\n这个方法的作用就是将Thread和mode包装成Node然后添加到链表尾部然后返回这个Node\n\n```java\nprivate Node addWaiter(Node mode) {\n    //将当前线程和模式封装进Node\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    //如果尾节点不为空\n    if (pred != null) {\n        //将node连接在当前tail后面\n        node.prev = pred;\n        //cas设置当前tail为node\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    // 其实前面看似会有并发的问题其实并没有\n    // 上面抢锁失败的线程会直接进入enq方法自旋重新设置，直到成功\n    enq(node);\n    return node;\n}\n```\n\n💡 根据前面分析head和tail都还没有初始化都还是null，所以这里会直接进入 `enq()`方法\n\n####  enq()\n\n```java\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n🔸 可以看到这里是一个循环，因为head和tail都还是空的所以这里进入第一个循环，CAS设置一个空的Node()为头节点head，然后将tail也指向这个head，到这里head和tail才算是初始化完成了(lazily initialized )。\n\n🔸 循环，进入else，这里就将当前node连接到tail后面并且利用CAS自旋设置tail为当前node也就是包含`Thread1` 的node，然后return 当前节点的前驱节点(这里返回值并没有用到)。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n下一步就是执行`acquireQueued()`\n\n❓ **为什么不直接在构造器里面就初始化头节点head？而要采用懒加载的方式？**\n\n> CLH queues need a dummy header node to get started. Butwe don't create them on **construction**, because it would be wasted  effort if there is **never contention**. Instead, the nodeis constructed and head and tail pointers are set up **on first contention**.\n\n以上摘自**Doug Lea** 大师的注释解释，根据我们的上面的分析，其实我们也看到了，第一个线程`Thread0` 过来的时候并没有去初始化head，后面的线程`Thread1`过来的时候 有了竞争才初始化了这个头节点head，如果直接初始化这个head，然后又没有锁竞争，这个head节点就被浪费了。 大师就是大师，太强了 😮\n\n#### acquireQueued()\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            //获取当前节点的前置节点\n            final Node p = node.predecessor();\n            //如果前置节点是head就尝试去获取锁\n            if (p == head && tryAcquire(arg)) {\n                //设置头节点为当前节点\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        //发生异常取消抢锁\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n💡 因为前置节点是head，所以这里作为队列第一个可以去尝试获取锁，可以看到这里是个死循环，会一直尝试获取锁，其实类似与CAS的自旋，但是相比CAS自旋又有很大不同，它并不会一直自旋，详细可以继续往下看。\n\n🔸 前面传递过来的node前继节点正好就是head，所以执行tryAcquire() 但是由于`Thread0` 还没有释放锁所以这里仍然失败。\n\n🔸 进入第二个if 执行 `shouldParkAfterFailedAcquire(p,node)`\n\n#### shouldParkAfterFailedAcquire()\n\n看名字就知道是干啥的了，获取失败是否Park？\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    //前置节点的状态\n    int ws = pred.waitStatus;\n    \n    if (ws == Node.SIGNAL)\n        //前置节点状态为-1，代表当前节点的后续节点需要被挂起\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {\n        // 前驱节点 waitStatus大于0，说明前驱节点取消了排队。\n        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。\n        // 所以下面这块代码说的是将当前节点的prev指向waitStatus<=0的节点，\n        // 简单说，就是为了找个正常的前驱节点，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，就无法唤醒你了\n        // 同时这个操作也会将那些 ws>0 的节点移除掉\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        //设置前驱节点状态为 -1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n\n注意这个里面回剔除不正常的节点，为下面的唤醒操作考虑\n\n💡 分析`Thread1`，我们先看看当前队列的状态\n\n![mark](http://static.imlgw.top/blog/20190809/jOs2WA3R7lGR.png?imageslim)\n\n🔸 因为前面的操作并没有对state进行操作，所以这里会直接进入最后的else，设置前驱节点的状态为 `SIGNAL`\n\n然后renturn  false回到acquireQueued的内循环\n\n🔸 再次尝试获取锁，`Thread0` 仍然没有释放锁，失败，再次进入shouldParkAfterFailedAcquire，这一次由于已经将前继节点的状态设置为`SIGNAL` 所以直接return true，进入后面的 `parkAndCheckInterrupt()` 方法\n\n**此时状态变为**\n\n![mark](http://static.imlgw.top/blog/20190809/pQ5NOkN5mQTY.png?imageslim)\n\n#### parkAndCheckInterrupt()\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n到这里我们的线程`Thread1`就会被阻塞住，也不会继续自旋获取锁了。\n\n> LockSupport.park()实际上调用的是Unsafe提供的指令属于`线程阻塞原语`，可以理解为二元信号量（只有一个permit），这个方法也会响应Interrupt  [参考](https://segmentfault.com/a/1190000008420938)\n\n🔔 **假设此时又有一个线程`Thread2`过来了，并且`Thread0` 依然没有释放锁**\n\n🔸 tryAcquire失败\n\n🔸addWaiter()， 将`Thread2`和模式包装成Node添加到队尾（这个时候就不会进入enq了，因为tail此时为`Thread1`已经不为空了）然后返回包含`Thread2`的节点，队列状态变为：\n\n![mark](http://static.imlgw.top/blog/20190809/yniIvx1sgpXa.png?imageslim)\n\n🔸acquireQueued()，根据上面的状态图，这里前置节点并不是head，直接进入shouldParkAfterFailedAcquire()\n\n🔸shouldParkAfterFailedAcquire()，明显前驱节点状态并不是`SIGNAL` 而是0，所以直接利用CAS设置前驱节点为`SIGNAL`  状态变为：\n\n![mark](http://static.imlgw.top/blog/20190809/R7GmOQ4V8ESm.png?imageslim)\n\n回到 `acquireQueued()` 继续自旋\n\n🔸 前置节点不是head，调用shouldParkAfterFailedAcquire(NodeT1，mode)，成功，调用parkAndCheckInterrupt阻塞，至此，`Thread1`，`Thread2` 都在这里park住了。\n\n### unLock()\n\n🔔 继续上面的模拟，此时`Thread0`释放锁 ，调用`unlock()` 方法，unlock()会调用AQS中的`release(1)`方法\n\n#### release()\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        //获取头节点\n        Node h = head;\n        //头节点不为空，并且头节点的waitStatus不是0\n        if (h != null && h.waitStatus != 0)\n            //unpark后继节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n首先执行`tryRelease(1)` ，和`tryAcquire()` 一样，这个方法最后是交给子类去实现的\n\n#### tryRelease()\n\n```java\nprotected final boolean tryRelease(int releases) {\n    //同步状态减1\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        //解锁线程不是当前线程，解铃还须系铃人\n        throw new IllegalMonitorStateException();\n    //和上面一样这里不用担心并发的问题，因为是独占锁，同时只有一个线程会到达这里\n    boolean free = false;\n    //不为0则代表被重入了，需要多次release直到0才会释放锁\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\ntryRelease()成功继续执行后面的语句，看一下当前AQS队列的状态\n\n![mark](http://static.imlgw.top/blog/20190809/R7GmOQ4V8ESm.png?imageslim)\n\n🔸 头节点head ! =null 并且head.waitState不是0，执行unparkSuccessor().\n\n#### unparkSuccessor()\n\n```java\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus;\n    if (ws < 0)\n        //如果当前节点的ws小于0就设置为0，允许失败\n        //其实是独占锁的话这里肯定不会失败，因为只有一个线程\n        //release执行完之后，这个节点就会被移除掉。然后被GC\n        compareAndSetWaitStatus(node, ws, 0);\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    //获取后继节点\n    Node s = node.next;\n    //后继节点为空，或者已经撤销了，取消抢锁（1>0）\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        //从后往前遍历找到正数第一个waitStatus<0的\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        //然后释放它\n        LockSupport.unpark(s.thread);\n}\n```\n\n🔸 `Thread1` 被`unpark()` 继续执行。\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n返回`Thread1`的 中断标志位，并复原为false，结束`parkAndCheckInterrupt()`方法，再次回到`acquireQueued()` 的循环中执行第一个if\n\n```java\nfor (;;) {\n    final Node p = node.predecessor();\n    if (p == head && tryAcquire(arg)) {\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted; //返回中断状态\n    }\n    if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n        interrupted = true;\n}\n```\n\n🔸 由于`Thread0` 已经释放锁，同步状态已经变为0，`Thread1` 可以直接`tryAcquire`获取到锁，然后设置头节点为当前节点，将之前的head节点**移除**，返回中断状态，由于之前park期间没有被中断直接`return false`，acquire成功！！！ `Thread1` 获得锁！！！\n\n❓ **为什么要从后往前遍历？**\n\n> 这里看了一些博客介绍，大概有两个说法，一个是在`enq()` 方法里面，先设置的`node.prev = pred;`再执行的CAS最后执行的`t.next = node;` CAS成功后next也许还没有设置成功，从前往后遍历有可能找不到这个刚加入的节点；其次，在`cancelAcquire(node);` 的最后一步有一个`node.next=node`的操作，如果这个时候从前往后遍历会导致死循环。\n\n❓ **从后往前遍历找到最前面第一个waitStatus<0的节点，这个操作如果返回的是个中间节点怎么办？**\n\n> 不要怕，我们继续执行，首先它是个中间节点而且是公平锁，它有前驱节点，unpark后肯定获取不到锁(公平锁需要检测是否有前驱节点)，然后执行`shouldParkAfterFailedAcquire()`，还记得这个方法里面的一个操作么？？如果前驱节点状态>0，他就会清除这些不正常的节点，返回false，不park自旋，下一次循环这个节点在获取锁就可以获取到了，妙哉！！！\n\n注意**setHead**是这样的\n\n```java\nprivate void setHead(Node node) {\n    head = node;\n    node.thread = null; //设置线程为null\n    node.prev = null; //设置前驱为空\n}\n```\n\n此时队列状态变为：\n\n![mark](http://static.imlgw.top/blog/20190809/wFDlbQTu417I.png?imageslim)\n\n再往后就是重复前面的过程啦。\n\n### 非公平锁公平锁区别\n\n上面是介绍的公平锁，所谓的公平就是先来后到FIFO。\n\n我们来看一下非公平锁的lock和nonfairTryAcquire()的实现，这两个锁的区别其实就是这两个方法。\n\n#### lock()\n\n```java\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n```\n\n可以看到非公平锁`lock()`的时候，不管三七二十一先CAS试一下能不能获取到锁，获取到就直接返回\n\n#### nonfairTryAcquire()\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n对比公平锁的实现，会发现少了`hasQueuedPredecessors()` 这个方法，所以如果前面`lock()` 的时候没有CAS成功，到这里后如果之前持有锁的线程释放了锁，它又会再次尝试CAS获取锁，这里其实就体现了非公平锁的特点，**先等待锁的线程不一定能先获取到锁，中间允许有人`\"插队\"`**，如果这一次还是失败了，就会和公平锁一样老老实实去等待队列中排队\n\n一般而言，非公平锁的性能会比公平锁好，而非公平锁可能会导致排在后面的线程饥饿\n\n### 流程图\n\n![mark](http://static.imlgw.top/blog/20190810/6FEWGydOmVzm.png?imageslim)\n\n## 参考\n\n**《Java并发编程之美》**\n\n[一行一行源码分析清楚AbstractQueuedSynchronizer](https://javadoop.com/2017/06/16/AbstractQueuedSynchronizer/)\n\n[AbstractQueuedSynchronizer源码剖析（六）- 深刻解析与模拟线程竞争资源](https://blog.csdn.net/pfnie/article/details/53191892)\n\n[[浅谈Java并发编程系列（八）—— LockSupport原理剖析]](https://segmentfault.com/a/1190000008420938)\n\n[Java同步器——AQS学习](https://brightloong.github.io/2018/06/21/Java%E5%90%8C%E6%AD%A5%E5%99%A8%E2%80%94%E2%80%94AQS%E5%AD%A6%E4%B9%A0/)\n\n","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"LeetCode查找","url":"/2019/09/15/leetcode-cha-zhao/","content":"\n## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:**\n\n```java\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n> 平生不识**TwoSum**，做遍LeetCode也枉然\n\n**解法一**\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    int length = nums.length;\n    for (int i = 0; i < length - 1; i++) {\n        for (int j = 1; j < length - i; j++) {\n            int result = nums[i] + nums[i + j];\n            if (result == target) {\n                return new int[] { i, i + j };\n            }\n        }\n    }\n    return null;\n}\n```\n\n最开始的做法，直接暴力求解，简单，但是效率很低，50ms，41% beats，其实在笔试或者其它对效率要求没那么严格的地方用暴力法也没毛病节约很多时间，能直接写出最优解肯定好，但是实在没办法了暴力法也不失为一种好方法，最优解可以下来后再研究。\n\n**解法二**\n\nhash查找\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    //第一遍把所有的元素和索引存到hashMap中\n    for (int i=0;i<nums.length;i++) {\n        map.put(nums[i],i);\n    }\n    //再查找hash\n    for (int i=0;i<nums.length;i++) {\n        //不能重复所以 下标需要限制下\n        if(map.containsKey(target-nums[i]) && map.get(target-nums[i])!=i){\n            return new int[]{i,map.get(target-nums[i])};\n        }\n    }\n    return new int[]{};\n}\n```\n\n其实可以只hash一遍，hash两遍主要考虑顺序的问题。直接利用hashMap查找，效率很高。\n\n```java\npublic int[] twoSum2(int[] nums, int target) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        //不能重复所以 下标需要限制下\n        if(map.containsKey(target-nums[i]) && map.get(target-nums[i])!=i){\n            return new int[]{i,map.get(target-nums[i])};\n        }\n        map.put(nums[i],i);\n    }\n\n    return new int[]{};\n}\n```\n\n提交记录上最快的做法\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    int index;\n    int indexArrayMax=2047;\n    int[] indexArrays=new int[indexArrayMax+1];\n    int diff;\n    for(int i=1;i<nums.length;i++){\n        diff=target-nums[i];\n        //i=0时索引无效,所以单独处理\n        if(diff==nums[0]){\n            return new int[]{0,i};\n        }\n        index=diff&indexArrayMax;\n        if(indexArrays[index]!=0){\n            return new int[]{indexArrays[index],i};\n        }\n        indexArrays[nums[i]&indexArrayMax]=i;   \n    }   \n    return new int[2];\n}\n```\n\n没看懂。。。群里问了下，手动hash。。。。以后再来研究吧.\n\n## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n**示例 1:**\n\n```java\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2]\n```\n\n**示例 2:**\n\n```java\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [9,4]\n```\n\n**说明:**\n\n- 输出结果中的每个元素一定是唯一的。\n- 我们可以不考虑输出结果的顺序。\n\n**解法一**\n\n```java\npublic int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> s1=new HashSet<>();\n    ArrayList<Integer> res=new ArrayList<>();\n    int index=0;\n    for (int a:nums1 ) {\n        s1.add(a);\n    }\n\n    for (int i=0;i<nums2.length;i++) {\n        if(s1.contains(nums2[i])){\n            res.add(nums2[i]);\n            s1.remove(nums2[i]);//别忘了remove掉\n        }\n    }\n\n    int [] res2=new int[res.size()];\n    for (int i=0;i<res.size();i++) {\n        res2[i]=res.get(i);\n    }\n    return res2;\n}\n```\n没啥好说的，这种题确实不难，仔细想想就可以\n\n## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n**示例 1:**\n\n```java\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2,2]\n```\n\n**示例 2:**\n\n```java\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [4,9]\n```\n\n**说明：**\n\n- 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n- 我们可以不考虑输出结果的顺序。\n\n**进阶:**\n\n- 如果给定的数组已经排好序呢？你将如何优化你的算法？\n- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？\n- 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n**解法一**\n\n这题和上面的区别就是需要输出所有的交集，重复的也算，所以可以用map的结构记录字符出现的次数\n\n```java\npublic int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<nums1.length;i++) {\n        map.put(nums1[i],map.getOrDefault(nums1[i],0)+1);\n    }\n    ArrayList<Integer> res=new ArrayList<>();\n    for (int i=0;i<nums2.length;i++) {\n        if (map.containsKey(nums2[i])) {\n            if (map.get(nums2[i])!=0) {\n                //有交集\n                res.add(nums2[i]); //添加到结果中\n                map.put(nums2[i],map.get(nums2[i])-1); //map映射减一\n            }\n        }\n    }\n    int []res2=new int[res.size()];\n    for (int i=0;i<res2.length;i++) {\n        res2[i]=res.get(i);\n    }\n    return res2;\n}\n```\n\n思路也很直白，和上一题的做法类似\n\n**进阶**\n\n**Q1:** 排好序的话就可以直接利用双指针，两个指针分别指向两个数组的头，相等就加入list，不相等就移动小的哪一个，直到有一个指针走到末尾\n\n**Q2:** 这个就很明显了，肯定先把小的哪一个用map映射起来，这样map查找的效率会更高 ？\n\n**Q3:** 这个参考英文版的 [讨论区](https://leetcode.com/problems/intersection-of-two-arrays-ii/discuss/82243/Solution-to-3rd-follow-up-question) \n\n## [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)\n\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n**示例 1:**\n\n```java\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入: s = \"rat\", t = \"car\"\n输出: false\n```\n\n**说明:**\n\n- 你可以假设字符串只包含小写字母。\n\n**进阶:**\n\n- 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n**解法一**\n\n```java\npublic boolean isAnagram(String s, String t) {\n    if (s.length()!=t.length())return false;\n    int[] freq=new int[256];\n    for (int i=0;i<s.length();i++) {\n        freq[s.charAt(i)]++;\n    }\n    int count=0,match=0;\n    for (int a:freq) {\n        if(a!=0){\n            count++;\n        }\n    }\n    for (int i=0;i<t.length();i++) {\n        if(freq[t.charAt(i)]>0){\n            freq[t.charAt(i)]--;\n            if(freq[t.charAt(i)]==0){\n                match++;\n            }\n        }\n    }\n    return match==count;\n}\n```\n\n这里其实空间还可以优化，题目说了字符串只包含小写字符所以只需要26个int就行了，可以在freq操作的时候 `-'A'` 优化空间\n\n**进阶**\n\n字符包含`unicode` 的话如果再使用int数组就不合适了，这个范围会变得很大，更加通用的方式是采用`HashMap`\n\n## [1160. 拼写单词](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)\n\n给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n\n**注意：**每次拼写时，chars 中的每个字母都只能用一次。\n\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n\n**示例 1：**\n\n```java\n输入：words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\n输出：6\n解释： \n可以形成字符串 \"cat\" 和 \"hat\"，所以答案是 3 + 3 = 6。\n```\n\n**示例 2：**\n\n```java\n输入：words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\n输出：10\n解释：\n可以形成字符串 \"hello\" 和 \"world\"，所以答案是 5 + 5 = 10。\n```\n\n**提示：**\n\n- `1 <= words.length <= 1000`\n- `1 <= words[i].length, chars.length <= 100`\n- 所有字符串中都仅包含小写英文字母\n\n**解法一**\n\n大晚上题目都没看清就开始写！！题目说的是每次只能使用一次！！！\n\n```java\npublic int countCharacters(String[] words, String chars) {\n    int[] hash=new int[26];\n    for (int i=0;i<chars.length();i++) {\n        hash[chars.charAt(i)-'a']++;\n    }\n    int res=0;\n    int[] temp=new int[26];\n    for (int i=0;i<words.length;i++) {\n        String word=words[i];\n        Arrays.fill(temp,0);\n        boolean flag=true;\n        for (int j=0;j<word.length();j++) {\n            temp[word.charAt(j)-'a']++;\n            if(temp[word.charAt(j)-'a']>hash[word.charAt(j)-'a']){\n                flag=false;\n                break;\n            }\n        }\n        res+=flag?word.length():0;\n    }\n    return res;\n}\n```\n一开始用的arraycopy然后减减，差不多\n\n## [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)\n\n编写一个算法来判断一个数是不是“快乐数”。\n\n一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。\n\n**示例:** \n\n```java\n输入: 19\n输出: true\n解释: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n```\n\n**解法一**\n\n```java\npublic static boolean isHappy(int n) {\n    char[] nums=null;\n    int sum=n;\n    while(true) {\n        nums=String.valueOf(sum).toCharArray();\n        sum=0;\n        for (int i=0;i<nums.length;i++) {\n            sum+=(nums[i]-48)*(nums[i]-48);\n        }\n        if (sum==4) {\n            return false;\n        }else if (sum==1) {\n            return true;\n        }\n    }\n}\n```\n\n找到了规律，所有不快乐的数(😅，都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环，可以直接在sum和这些值相等的时候就return我懒得写那么多，比较取巧但是效率还是挺高的\n\n**解法二**\n\n```java\npublic static boolean isHappy(int n) {\n    char[] nums=null;\n    int sum=n;\n    HashSet<Integer> set=new HashSet<>();\n    while(true) {\n        nums=String.valueOf(sum).toCharArray();\n        sum=0;\n        for (int i=0;i<nums.length;i++) {\n            sum+=(nums[i]-48)*(nums[i]-48);\n        }\n        if (sum==1) {\n            return true;\n        }else if (set.contain(sum)){\n            return false;\n        }else{\n            set.add(sum);    \n        }\n    }\n}\n```\n这种做法就比较常规，也是符合这篇主题**查找**的解法，代码比较简单就不啰嗦了\n\n## [290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)\n\n给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。\n\n这里的 **遵循** 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。\n\n**示例1:**\n\n```java\n输入: pattern = \"abba\", str = \"dog cat cat dog\"\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入:pattern = \"abba\", str = \"dog cat cat fish\"\n输出: false\n```\n\n**示例 3:**\n\n```java\n输入: pattern = \"aaaa\", str = \"dog cat cat dog\"\n输出: false\n```\n\n**示例 4:**\n\n```java\n输入: pattern = \"abba\", str = \"dog dog dog dog\"\n输出: false\n```\n\n**说明:**\n你可以假设 `pattern` 只包含小写字母， `str` 包含了由单个空格分隔的小写字母\n\n**解法一**\n\n```java\npublic static boolean wordPattern(String pattern, String str) {\n    HashMap<Character,String> map=new LinkedHashMap<>();\n    String[] strs=str.split(\" \");\n    char[] p=pattern.toCharArray();\n    if (strs.length!=p.length) {\n        return false;\n    }\n    for (int i=0;i<p.length;i++) {\n        if (map.containsKey(p[i])) {\n            if (!map.get(p[i]).equals(strs[i])) {\n                return false;\n            }\n        }else{\n            //这里直接和前一个比较的，正确做法是用map.containsValue判断是否已经添加\n            /*if (strs[i].equals(strs[i-1])) {\n                return false;\n            }*/\n            if (map.containsValue(strs[i])) {\n                return false;           \n            }\n            map.put(p[i],strs[i]);\n        }\n    }\n    return true;\n}\n```\n很简单的题，需要对两个字符串的模式进行匹配，借助Hash表直接将两个String进行一对一的映射，既然要匹配那么`同一个key字符对应的value字符肯定是一样的`，还有一点需要注意的是在遇到一个新的key字符的时候，需要判断对应位置的value字符出现过没有，出现过就直接return false，这一点第一遍的时候没考虑到，`不同的key字符对应的value字符肯定是不一样的`\n\n> 因为第一次没考虑到第二种情况，提交后竟然跑过了`31/33` 个case，然后就感觉这题case可能有点问题，然后自己写了个错的算法居然也跑过了，具体的代码在上面的注释中，感兴趣的可以去试试，我已经提交case了但是还没回应我\n\n## [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)\n\n给定两个字符串 s 和 t，判断它们是否是同构的。\n\n如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n**示例 1:**\n\n```java\n输入: s = \"egg\", t = \"add\"\n输出: true\n```\n\n\n**示例 2:**\n\n```java\n输入: s = \"foo\", t = \"bar\"\n输出: false\n```\n\n**示例 3:**\n\n```java\n输入: s = \"paper\", t = \"title\"\n输出: true\n```\n\n**说明:**\n\n- 你可以假设 s 和 t 具有相同的长度。\n\n**解法一**\n\n这题和上面一模一样，Hash表的解法就不写了，这题都是单个的字符，可以不用Hash表，可以用数组优化\n\n```java\npublic boolean isIsomorphic2(String s, String t) {\n    if (s.length()!=t.length()) {\n        return false;\n    }\n    int[] key=new int[256];\n    int[] value=new int[256];\n\n    for (int i=0;i<s.length();i++) {\n        int cs=s.charAt(i);\n        int ct=t.charAt(i);\n        if(key[cs]!=0){ //cs出现过\n            if (key[cs]!=ct) {\n                return false;\n            }\n        }else{//cs没出现过\n            if (value[ct]!=0) {\n                return false;\n            }\n            key[cs]=ct;\n            value[ct]=cs;\n        }\n    }\n    return true;\n}\n```\n\n💬 同样的，这题和上面的290一样，case也有问题，直接和前一个字符比较就可以过\n\n## [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)\n\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 `0 ≤ N ≤ 500` 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n\n**例如:**\n\n```java\n输入:\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\n输出:\n2\n\n解释:\n两个元组如下:\n\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n```\n\n**解法一**\n\n这题其实看数据规模就知道应该写一个什么样复杂度的算法了`0~500`，暴力的话会很恐怖`O(N^4)`，这里可以考虑将其中一个放到hash表中，然后遍历其他的3个，时间复杂度优化到了`O(N^3)`，但是时间复杂度还是很恐怖，所以可以考虑将两个数组的和放到hash表中，这样就可以将时间复杂度优化到`O(N^2)`\n\n```java\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<C.length;i++) {\n        for (int j=0;j<D.length;j++) {\n            int key=C[i]+D[j];\n            map.put(key,map.getOrDefault(key,0)+1);\n        }\n    }\n    int res=0;\n    for (int i=0;i<A.length;i++) {\n        for (int j=0;j<B.length;j++) {\n            int key=A[i]+B[j];\n            if(map.containsKey(-key)){\n                res+=map.get(-key);\n            }\n        }\n    }\n    return res;\n}\n```\n\n## [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)\n\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n**示例 1:**\n\n```java\n输入:\n\"tree\"\n\n输出:\n\"eert\"\n\n解释:\n'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n```\n\n**示例 2:**\n\n```java\n输入:\n\"cccaaa\"\n\n输出:\n\"cccaaa\"\n\n解释:\n'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n```\n\n**示例 3:**\n\n```java\n输入:\n\"Aabb\"\n\n输出:\n\"bbAa\"\n\n解释:\n此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n```\n\n**解法一**\n\n```java\npublic static String frequencySort(String s) {\n    if (s==null || s.length()<1) {\n        return s;\n    }\n    HashMap<Character,Integer> map=new HashMap<>();\n    for (int i=0;i<s.length();i++) {\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\n    }\n    ArrayList<HashMap.Entry> list=new ArrayList<>();\n    for(HashMap.Entry entry:map.entrySet()){\n        list.add(entry);\n    }\n    list.sort((e1,e2)->(Integer)e2.getValue()-(Integer)e1.getValue());\n    StringBuilder res=new StringBuilder();\n    for (int i = 0; i < list.size(); i++) {\n        Integer value = (Integer)list.get(i).getValue();\n        while (value>0){\n            res.append(list.get(i).getKey());\n            value--;\n        }\n    }\n    return res.toString();\n}\n```\n这题其实也是TopK问题，直接的想法就是用hashMap统计各个字符出现的个数，然后排序再拼接为结果，其实这题一开始是TLE了的，一开始没注意直接用的String拼接的，效率很低，改用StringBuilder后就过了，虽然效率还是很低 138ms，垫底\n\n**解法二**\n\n```java\npublic  static String frequencySort2(String s) {\n    if (s==null || s.length()<1) {\n        return s;\n    }\n    int[] freq=new int[256];\n    for (int i=0;i<s.length();i++) {\n        freq[s.charAt(i)]++;\n    }\n    int[] freq_bak=freq.clone();\n    Arrays.sort(freq);\n    StringBuilder res=new StringBuilder();\n    //从大到小\n    for (int i = 255; i>=0 && freq[i]!=0; i--) {\n        for (int j=0;j<255;j++) {\n            //找到原数组中对应的字符\n            //只要出现次数一样的就行了\n            if(freq_bak[j]==freq[i]){\n                //根据freq_bak[j]构造结果\n                while(freq_bak[j]>0){\n                    res.append((char)j);\n                    freq_bak[j]--;\n                }\n                break;\n            }\n        }\n    }\n    return res.toString();\n}\n```\n15ms，90% 其实思路和上面是一样的，都是统计数量后进行排序，然后重建字符串，但是用数组的方式明显会比HashMap效率会更高的多，后面的两层循环都是在常数时间内，主要是重建字符串和排序消耗时间，时间复杂度应该是`O(NlogN)`\n\n**解法三**\n\n```java\npublic  static String frequencySort3(String s) {\n    if (s==null || s.length()<1) {\n        return s;\n    }\n    ArrayList<Character> [] bucket=new ArrayList[s.length()+1];\n\n    int[] freq=new int[256];\n\n    for (int i=0;i<s.length();i++) {\n        freq[s.charAt(i)]++;\n    }\n\n    for (int i=0;i<s.length();i++) {\n        if (bucket[freq[s.charAt(i)]]==null) {\n            bucket[freq[s.charAt(i)]]=new ArrayList<>();\n        }\n        //每个元素只进入一次\n        if (!bucket[freq[s.charAt(i)]].contains(s.charAt(i))) {\n            bucket[freq[s.charAt(i)]].add(s.charAt(i));\n        }\n    } \n    //printArray(bucket);\n    StringBuilder res=new StringBuilder();\n    for (int i=bucket.length-1;i>=0;i--) {\n        //过滤0\n        if (bucket[i]==null) {\n            continue;\n        }\n        //出现i次的字符list\n        ArrayList<Character> temp=bucket[i];\n        //遍历出现次数相同的list()\n        for (int j=0;j<temp.size();j++) { \n            //遍历出现的次数\n            for (int count=0;count<i;count++) {\n                res.append(temp.get(j));\n            }\n        }\n    }\n    return res.toString();\n}\n```\n50ms，50% 这个是根据 [前k个高频元素](http://imlgw.top/2019/05/04/leetcode-shu-zu-tag/#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0) 中桶排序的解法来的，当然这里并不是最优解，只是一种思路，其实写起来还是挺麻烦的，时间复杂度略高，主要是在桶排序的时候添加元素做不到O(N)需要判断元素是否添加，一个元素只能在list中添加一次，否则后面重建字符串的时候就会有问题\n\n## [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n**示例:**\n\n```java\n输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n输出:\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\n\n**说明：**\n\n- 所有输入均为小写字母\n- 不考虑答案输出的顺序\n\n**解法一**\n\n算是暴力法了，借助上面的同构题思路来遍历判断\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    ArrayList<List<String>> res=new ArrayList<>();\n    for (int i=0;i<strs.length;i++) {\n        if (\"7\"==strs[i]) {\n            continue;\n        }\n        ArrayList<String> group=new ArrayList<String>();\n        group.add(strs[i]);\n        for (int j=i+1;j<strs.length;j++) {\n            if (\"7\"==strs[j]) {\n                continue;\n            }\n            if(isAnagram(strs[i],strs[j])){\n                group.add(strs[j]);\n                //有分组了\n                strs[j]=\"7\";\n            }\n        }\n        res.add(group);\n    }\n    return res;\n}\n\npublic boolean isAnagram(String str1,String str2){\n    if(str1.length()!=str2.length()){\n        return false;\n    }\n    int[] freq=new int[26];\n    for (int i=0;i<str1.length();i++) {\n        freq[str1.charAt(i)-'a']++;\n    }\n    for (int i=0;i<str2.length();i++) {\n        freq[str2.charAt(i)-'a']--;\n    }\n    for (int i=0;i<freq.length;i++) {\n        if (freq[i]!=0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n可以看到里面有一个`7` 其实没什么含义就是为了表示这个字符已经有分组了，这里一开始我是用的equals来比较的这个7结果超时了，然后换成了==勉强跑过了，可能是个例，因为我后来用boolean数组也没跑过。。。\n\n> 这里用==可以比较的原因可能是strs和字面量 \"7\"都在字符常量池中，但是这里并不建议这样比较，这里可以说是个反例了，比较字符串请用`equals` ！！！\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    ArrayList<List<String>> res=new ArrayList<>();\n    boolean[] flag=new boolean[strs.length()];\n    for (int i=0;i<strs.length;i++) {\n        if (flag[i]) continue;\n        ArrayList<String> group=new ArrayList<String>();\n        group.add(strs[i]);\n        for (int j=i+1;j<strs.length;j++) {\n            if(flag[j])continue;\n            if(isAnagram(strs[i],strs[j])){\n                group.add(strs[j]);\n                flag[j]=true;\n            }\n        }\n        res.add(group);\n    }\n    return res;\n}\n```\n**解法二**\n\n利用排序结果来作为key，将排序结果相同的str映射到一起\n\n```java\n//排序解法\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<String,List<String>> map=new HashMap<>();\n    for (int i=0;i<strs.length;i++) {\n        char[] strs_i=strs[i].toCharArray();\n        //排序，将结果作为key\n        Arrays.sort(strs_i);\n        String key=String.valueOf(strs_i);\n\n        if(map.containsKey(key)){\n            //存在同构的key，直接添加进去\n            map.get(key).add(strs[i]);\n        }else{\n            //不存在就创建一个，然后将自己添加进去\n            map.put(key,new ArrayList<>());\n            map.get(key).add(strs[i]);\n        }\n    }\n    return new ArrayList(map.values());\n}\n```\n时间复杂度`O(NKlogK)`，K为字符数组中最长的字符串，`O(KlogK)` 是给这个字符串排序的结果\n\n**解法三**\n\n根据出现频次构成的字符串作为key，比如`aba`以及所有的异位词都会被映射为`2#1#` \n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<String,List<String>> map=new HashMap<>();\n    int[] freq=new int[26];\n    for (int i=0;i<strs.length;i++) {\n        //Arrays.fill(freq,0);\n        //统计字符出现的频次\n        for (int j=0;j<strs[i].length();j++) {\n            freq[strs[i].charAt(j)-'a']++;\n        }\n        //构建唯一映射的key\n        StringBuilder key=new StringBuilder();\n        //这个其实类似桶排序,依次取abcde...\n        for (int j=0;j<26;j++) {\n            key.append(freq[j]);\n            //这个#很关键,为了防止重复,因为有的字符可能出现两位数的次数,仅仅对比数字是无法确定的\n            key.append(\"#\");\n            //重置为0方便后面重复使用\n            freq[j]=0;\n        }\n        String skey=key.toString();\n        if(map.containsKey(skey)){\n            map.get(skey).add(strs[i]);\n        }else{\n            map.put(skey,new ArrayList());\n            map.get(skey).add(strs[i]);\n        }\n    }\n    return new ArrayList(map.values());\n}\n```\n45ms，21% 时间复杂度`O(NK)` K为字符数组中最长的字符串的长度，很玄学，讲道理应该不会这么慢，看了leetcode上前几名跟我的差不多，开始做的时候直接用 `StringBuilder` 对象作为了key结果肯定不对，StringBuilder没有覆盖equals方法，key永远不会相等，每次都是新的key\n\n**解法四**\n\n**算术基本定理**，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<Integer, List<String>> hash = new HashMap<>();\n    //每个字母对应一个质数\n    int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103 };\n    for (int i = 0; i < strs.length; i++) {\n        int key = 1;\n        //累乘得到 key\n        for (int j = 0; j < strs[i].length(); j++) {\n            key *= prime[strs[i].charAt(j) - 'a'];\n        } \n        if (hash.containsKey(key)) {\n            hash.get(key).add(strs[i]);\n        } else {\n            List<String> temp = new ArrayList<String>();\n            temp.add(strs[i]);\n            hash.put(key, temp);\n        }\n    }\n    return new ArrayList<List<String>>(hash.values());\n}\n```\n\n时间复杂度`O(NK)`，强的8行\n\n> 分析完上面三种解法后其实很同意得出这题的关键：`给同组的异位词找到一个相同的映射key`，尽量的缩短求这个映射的时间就可优化整个算法\n\n## [447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)\n\n给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 `(i, j, k)` ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（**需要考虑元组的顺序**）\n\n找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 `[-10000, 10000]` 中。\n\n**示例:**\n\n```java\n输入:\n[[0,0],[1,0],[2,0]]\n\n输出:\n2\n\n解释:\n两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n```\n\n**解法一**\n\n```java\npublic static int numberOfBoomerangs(int[][] points) {\n    int res=0;\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for (int i=0;i<points.length;i++) {\n        for (int j=0;j<points.length;j++) {\n            if (i!=j){\n                int dis=dis(points[i],points[j]);\n                map.put(dis,map.getOrDefault(dis,0)+1);\n            }\n        }\n        //C2m 组合问题\n        for (Integer count:map.values()) {\n            if (count>1) {\n                res+=count*(count-1);\n            }\n        }\n        map.clear();\n    }\n    return res;\n}\n\npublic static int dis(int[] a,int[] b){\n    return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\n}\n```\n看一下给的数据量`500`就知道复杂度只能是`O(N^2)` 的，用Hash表统计到当前点的距离相同的点有多少个，然后利用组合数求多少种组合，一开始并没有想到这种方法，我想的是利用坐标系的对称来做，太菜了\n\n这里还有个小细节，一开始将HashMap的创建放在内循环中，发现效率很低，300ms左右，然后将创建HashMap移出去后用clear清空，瞬间快了100ms左右，创建HashMap的成本果然还是挺大的\n\n这题其实还可以减少内循环的数量，\n\n## [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n\n**示例 1:**\n\n```java\n输入: [1,2,3,1]\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入: [1,2,3,4]\n输出: false\n```\n\n**示例 3:**\n\n```java\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n```\n\n**解法一**\n\n借助Hash表，很简单的题\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    if (nums==null) return false;\n    HashSet<Integer> set=new HashSet<>();\n    for (int i=0;i<nums.length;i++) {\n        if (set.contains(nums[i])) {\n            return true;\n        }\n        set.add(nums[i]);\n    }\n    return false;\n}\n```\n其实还可以优化下\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    if (nums==null) return false;\n    HashSet<Integer> set=new HashSet<>();\n    for (int i=0;i<nums.length;i++) {\n        if (!set.add(nums[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n`set.add()` 本身就带有返回值，可以减少很多判断，这题还有一个进阶版 [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/) 也不难，我放到 [滑动窗口专题](http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou-tag/#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2) 中去了\n\n## [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)\n\n给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 `nums [i]` 和 `nums [j]` 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 k\n\n**示例 1:**\n\n```java\n输入: nums = [1,2,3,1], k = 3, t = 0\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入: nums = [1,0,1,1], k = 1, t = 2\n输出: true\n```\n\n**示例 3:**\n\n```java\n输入: nums = [1,5,9,1,5,9], k = 2, t = 3\n输出: false\n```\n\n**解法一**\n\n这里其实可以算难题了，通过率只有20%，利用Java中提供的TreeMap，有顺序而且插入和删除等操作效率都很高（logN），然后查找指定范围的元素，看符不符合题目要求\n\n```java\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Integer> set=new TreeSet<>();\n    for (int i=0;i<nums.length;i++) {\n        //大于nums[i]的最小元素\n        Integer ceiling=set.ceiling(nums[i]);\n        //小于nums[i]的最大元素\n        Integer floor=set.floor(nums[i]);\n        //防止溢出\n        long temp1=Long.valueOf(nums[i])+Long.valueOf(t);\n        long temp2=Long.valueOf(nums[i])-Long.valueOf(t);\n        if((ceiling!=null && ceiling<=temp1) || (floor!=null && floor>=temp2)) {\n            return true;\n        }\n        set.add(nums[i]);\n        if (set.size()>k) {\n            //移除左边界\n            set.remove(nums[i-k]);\n        }\n    }\n    return false;\n}\n```\n72ms，5%左右，整体时间复杂度`O(NlogN)` \n\n**解法二**\n\n看了下评论区，发现其实可以直接比较两个边界，这样可以少一次查找的操作，效率有很大提升\n\n```java\npublic boolean containsNearbyAlmostDuplicate2(int[] nums, int k, int t) {\n    TreeSet<Long> set=new TreeSet<>();\n    for (int i=0;i<nums.length;i++) {\n        //大于nums[i]-t的最小元素\n        Long ceil=set.ceiling((long)nums[i]-(long)t);\n        if(ceil!=null && ceil<=(long)nums[i]+(long)t) {\n            return true;\n        }\n        set.add((long)nums[i]);\n        if (set.size()>k) {\n            set.remove((long)nums[i-k]);\n        }\n    }\n    return false;\n}\n```\n43ms，56%左右，依然要注意溢出的问题\n\n## [1282. 用户分组](https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to/)\n\n有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。\n\n你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。\n\n**示例 1：**\n\n```java\n输入：groupSizes = [3,3,3,3,3,1,3]\n输出：[[5],[0,1,2],[3,4,6]]\n解释： \n其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。\n```\n\n**示例 2：**\n\n```java\n输入：groupSizes = [2,1,3,3,3,2]\n输出：[[1],[0,5],[2,3,4]]\n```\n\n**提示：**\n\n- `groupSizes.length == n`\n- `1 <= n <= 500`\n- `1 <= groupSizes[i] <= n`\n\n**解法一**\n\n12.8周赛的题，我是模拟做的，看了别人的做法还是感觉这种比较优雅\n\n```java\npublic List<List<Integer>> groupThePeople(int[] groupSizes) {\n    HashMap<Integer,List<Integer>> map=new HashMap<>();\n    List<List<Integer>> res=new LinkedList<>();\n    for (int i=0;i<groupSizes.length;i++) {\n        if (!map.containsKey(groupSizes[i])) {\n            List<Integer> list=new LinkedList();\n            map.put(groupSizes[i],list);\n        }\n        List<Integer> gl=map.get(groupSizes[i]);\n        gl.add(i);\n        if (gl.size()==groupSizes[i]) {\n            res.add(gl);\n            map.remove(groupSizes[i]);\n        }\n    }\n    return res;\n}\n```\n时间复杂度`O(N)`\n\n**解法二**\n\n模拟的解法，时间复杂度`O(N^2)`\n\n```java\npublic List<List<Integer>> groupThePeople(int[] groupSizes) {\n    boolean[] visit=new boolean[groupSizes.length];\n    List<List<Integer>> res=new LinkedList<>();\n    for (int i=0;i<groupSizes.length;i++) {\n        if (visit[i]) {\n            continue;\n        }\n        List<Integer> list= new LinkedList<>();\n        list.add(i);\n        for (int j=i+1;j<groupSizes.length;j++) {\n            if (visit[j]) {\n                continue;\n            }\n            if (list.size()==groupSizes[i]) {\n                break;\n            }\n            if (groupSizes[j]==groupSizes[i]) {\n                list.add(j);\n                visit[j]=true;\n            }\n        }\n        res.add(list);\n    }\n    return res;\n}\n```\n\n## [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n给定一个未排序的整数数组，找出最长连续序列的长度。\n\n要求算法的时间复杂度为 `O(n)`。\n\n**示例:**\n\n```java\n输入: [100, 4, 200, 1, 3, 2]\n输出: 4\n解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。\n```\n\n**解法一**\n\n借助Hash表的暴力解法\n\n```java\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int n:nums) {\n        set.add(n);\n    }\n    int max=0;\n    for (int i=0;i<nums.length;i++) {\n        int num=nums[i];\n        int res=1;\n        while(set.contains(num+1)){\n            res++;\n            num++;\n        }\n        max=Math.max(max,res);\n    }\n    return max;\n}\n```\n\n对于每个元素在Hash表中查找它的下一个连续的元素`num+1` 有没有，有的话就继续往下找，最后求的以每个元素开头的最长子序列长度，时间复杂度`O(N^2)`不符合题目的要求\n\n所以我们需要优化我们的算法，其实上面的过程我们很容易就看出啦里面会有重复的计算\n\n`eg. 5，4，6，7，8`  我们在第一个5的时候计算了以5开头的 5，6，7，8这条路径，然后转而计算第二个4，计算了以4开头的4，5，6，7，8这里其实就发生了重复的计算，那么我们这里求的是最长的序列，所以我们需要舍弃第一个，也就是说我们遍历第一个5的时候直接跳过，跳过的依据就是判断 5-1 在不在集合中，如果在那么以它开头的序列一定不是不会是最长的，反之则有可能是最长的，我们统计所有这样的序列长度，最后求一个最大值就可以了\n\n**解法二**\n\n每个元素最多遍历2次，所以时间复杂度为O(N)符合要求\n\n```java\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int n:nums) {\n        set.add(n);\n    }\n    int max=0;\n    for (int i=0;i<nums.length;i++) {\n        int num=nums[i];\n        if (!set.contains(num-1)) {\n            int res=1;\n            while(set.contains(num+1)){\n                res++;\n                num++;\n            }\n            max=Math.max(max,res);\n        }\n    }\n    return max;\n}\n```\n\n**解法三**\n\n并查集的解法，略微麻烦点，但是毕竟这题的tag就是并查集，还是实现一下\n\n```java\n//并查集\nHashMap<Integer,Integer> parent;\n\nHashMap<Integer,Integer> size;\n\nint max=1;\n\npublic int find(int index){\n    while(parent.get(index)!=index){\n        //parent[index]=parent[parent[index]];\n        parent.put(index,parent.get(index));\n        index=parent.get(index);\n    }\n    return index;\n}\n\npublic void union(int p,int q){\n    int pID=find(p);\n    int qID=find(q);\n    if (pID==qID) {\n        return;\n    }\n    int pSize=size.get(pID);\n    int qSize=size.get(qID);\n    if (pSize > qSize) {\n        //parent[qID]=pID;\n        parent.put(qID,pID);\n        //size[pID]+=size[qID];\n        size.put(pID,pSize+qSize);\n    }else{\n        //parent[pID]=qID;\n        parent.put(pID,qID);\n        //size[qID]+=size[pID];\n        size.put(qID,pSize+qSize);\n    }\n    max=Math.max(max,pSize+qSize); //统计最大值\n}\n\npublic void initUnionFind(int[]nums){\n    parent=new HashMap<>();\n    size=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        parent.put(nums[i],nums[i]);\n        size.put(nums[i],1);\n    }\n}\n\npublic int longestConsecutive(int[] nums) {\n    if (nums ==null || nums.length<=0) {\n        return 0;\n    }\n    HashSet<Integer> set=new HashSet();\n    for (int i=0;i<nums.length;i++) {\n        set.add(nums[i]);\n    }\n    initUnionFind(nums);\n    for (int i=0;i<nums.length;i++) {\n        if (set.contains(nums[i]-1)) { //判断-1或者+1都可以\n            union(nums[i],nums[i]-1);\n        }\n    }\n    return max;\n}\n```\n\n## [1002. 查找常用字符](https://leetcode-cn.com/problems/find-common-characters/)\n\nDifficulty: **简单**\n\n给定仅有小写字母组成的字符串数组 `A`，返回列表中的每个字符串中都显示的全部字符（**包括重复字符**）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。\n\n你可以按任意顺序返回答案。\n\n**示例 1：**\n\n```\n输入：[\"bella\",\"label\",\"roller\"]\n输出：[\"e\",\"l\",\"l\"]\n```\n\n**示例 2：**\n\n```\n输入：[\"cool\",\"lock\",\"cook\"]\n输出：[\"c\",\"o\"]\n```\n\n**提示：**\n\n1.  `1 <= A.length <= 100`\n2.  `1 <= A[i].length <= 100`\n3.  `A[i][j]` 是小写字母\n\n**解法一**\n\n范围小，随便搞\n```golang\nfunc commonChars(A []string) []string {\n    var m = make(map[int]map[byte]int)\n    \n    var max = 0\n    for i := 0; i < len(A); i++ {\n        m[i] = make(map[byte]int)\n        for j := 0; j < len(A[i]); j++ {\n            m[i][A[i][j]]++\n        }\n        if len(A[i]) > len(A[max]) {\n            max = i\n        }\n    }\n    var res []string\n    for i := 0; i < len(A[max]); i++ {\n        var flag = true\n        for j := 0; j < len(A); j++ {\n            if j == max {\n                continue\n            }\n            if m[j][A[max][i]] == 0 {\n                flag = false\n                break\n            }\n            m[j][A[max][i]]--\n        }\n        if flag {\n            res = append(res, string(A[max][i]))\n        }\n    }\n    return res\n}\n```\n\n## _前缀和相关_\n\n## [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)\n\n给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。\n\n**示例 1 :**\n\n```java\n输入:nums = [1,1,1], k = 2\n输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。\n```\n\n\n**说明 :**\n\n- 数组的长度为 [1, 20,000]。\n- 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。\n\n**解法一**\n\n前缀和 + hash表\n\n```java\npublic int subarraySum(int[] nums, int k) {\n    HashMap<Integer,Integer> map = new HashMap<>();\n    map.put(0,1);//初始化头哨兵,避免下标转换\n    int sum=0,res=0;\n    for (int i=0;i<nums.length;i++) {\n        sum+=nums[i];\n        //-1 -1 1 | 0\n        if (/*sum>=k && */map.containsKey(sum-k)) {\n            res+=map.get(sum-k);\n        }\n        map.put(sum,map.getOrDefault(sum,0)+1);\n    }\n    return res;\n}\n```\n我们将各个位置的前缀和作为键，这个前缀和在**当前位置之前出现的次数作为键** (这一点保证了连续，不会找到后面去)\n\n然后我们的目标就是找到和为k区间有多少个，区间和利用前缀和可以直接算出，也就是 \n\n`sum[i~j] = sum[j] -sum[i]= k` 然后这个问题就可以转换为，当我们遍历到某个元素的时候，我们在map中查找前缀和为`sum[j] - k`的元素有几个，这样就可以得到区间和为k的区间有多少个！\n\n值得注意的地方就是，需要添加一个初始的`sum=0`的值，避免下标的转换\n\n画个图就像下面这样：\n\n![img](http://static.imlgw.top/blog/20191104/ECiyYqso8i2K.png?imageslim)\n\n## [1248. 统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)\n\n给你一个整数数组 nums 和一个整数 k。\n\n如果某个子数组中恰好有 k 个奇数数字，我们就认为这个子数组是**「优美子数组」**。\n\n请返回这个数组中「优美子数组」的数目。\n\n**示例 1：**\n\n```java\n输入：nums = [1,1,2,1,1], k = 3\n输出：2\n解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。\n```\n\n\n**示例 2：**\n\n```java\n输入：nums = [2,4,6], k = 1\n输出：0\n解释：数列中不包含任何奇数，所以不存在优美子数组。\n```\n\n\n**示例 3：**\n\n```java\n输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2\n输出：16\n```\n\n**提示：**\n\n- `1 <= nums.length <= 50000`\n- `1 <= nums[i] <= 10^5`\n- `1 <= k <= nums.length`\n\n**解法一**\n\n11.3 周赛第二题，没做出来，以为是滑动窗口，滑了半天没滑出来，后来看了解答知道了是利用前缀和 + Hash，其实和上面一题是类似的，相当于上一题的进阶\n\n```java\npublic int numberOfSubarrays(int[] nums, int k) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    int sum=0,res=0;\n    map.put(0,1);\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]%2==1) {\n            sum++;\n        }\n        //题目说了都是正数，所以可以优化下\n        if (sum>=k && map.containsKey(sum-k)) {\n            res+=map.get(sum-k);\n        }\n        map.put(sum,map.getOrDefault(sum,0)+1);\n    }\n    return res;\n}\n```\n其实这里就是把奇数都看作 1，偶数都看作0，这样问题就变成了求和为k的区间个数有多少个，然后在根据上面的前缀和+Hash表，就可以很容易的得到答案，还有一点就是题目说了数据都是正数，所以在判断的时候可以加一个`sum>=k` 来减少一点判断，当然这题题目指定了数据的范围，所以还可以直接用数组做map映射\n\n```java\n//update: 2020.4.21 之前的数组开大了，开了10w。。。\npublic int numberOfSubarrays(int[] nums, int k) {\n    int[] map=new int[50001];  \n    map[0]=1;\n    int sum=0;\n    int res=0;\n    for(int i=0;i<nums.length;i++){\n        sum+=nums[i]&1;\n        map[sum]++;\n        //sum-x=k\n        if(sum-k >=0 && map[sum-k]!=0){\n            res+=map[sum-k];\n        }\n    }\n    return res;\n}\n```\n\n> 这题还有其他的数学解法，暂时不太想写，后面有时间再写吧，大致思路就是\n>\n> [2，2，1，1，2，2，2] res=3*4=12\n\n## [1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)\n\n给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。\n\n**示例 1：**\n\n```java\n输入：s = \"eleetminicoworoep\"\n输出：13\n解释：最长子字符串是 \"leetminicowor\" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"leetcodeisgreat\"\n输出：5\n解释：最长子字符串是 \"leetc\" ，其中包含 2 个 e 。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"bcbcbc\"\n输出：6\n解释：这个示例中，字符串 \"bcbcbc\" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。\n```\n\n**提示：**\n\n- `1 <= s.length <= 5 x 10^5`\n- `s` 只包含小写英文字母。\n\n**解法一**\n\n这题挺好的，反正我是想不出来这样的解法，一开始以为是滑动窗口，写了几行代码发现行不通，数据范围这么大，感觉不是很简单，然后就直接看答案了，涉及到**前缀和**以及**状态压缩**，前缀和维护元音字符出现的奇偶性，并压缩成一个整数，核心思想就是`奇数-奇数=偶数`，`偶数-偶数=偶数`，所以如果两个不同位置的状态相同，那么中间的部分出现次数一定是偶数，具体的不想多解释了看看 [官方题解](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-z-2/) 就行了\n\n```java\npublic int findTheLongestSubstring(String s) {\n    //a e i o u\n    //32种状态\n    int[] pre=new int[1<<5];\n    Arrays.fill(pre,-1);\n    pre[0]=0;\n    int res=0;\n    int state=0;\n    for (int i=0;i<s.length();i++) {\n        if(s.charAt(i)=='a') state^=16;\n        if(s.charAt(i)=='e') state^=8;\n        if(s.charAt(i)=='i') state^=4;\n        if(s.charAt(i)=='o') state^=2;\n        if(s.charAt(i)=='u') state^=1;\n        if(pre[state]!=-1){\n            res=Math.max(res,i+1-pre[state]);\n        }else{\n            pre[state]=i+1; //前i个字符的状态\n        }\n    }\n    return res;\n}\n```\n\n## [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)\n\n给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。\n\n**示例：**\n\n```java\n输入：A = [4,5,0,-2,-3,1], K = 5\n输出：7\n解释：\n有 7 个子数组满足其元素之和可被 K = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n```\n\n**提示：**\n\n1. `1 <= A.length <= 30000`\n2. `-10000 <= A[i] <= 10000`\n3. `2 <= K <= 10000`\n\n**解法一**\n\n```java\n//同余定义 (b-a)%k=0 => b%k==a%k\npublic int subarraysDivByK(int[] A, int K) {\n    int[] pre=new int[K];\n    int sum=0;\n    pre[sum]=1;\n    int res=0;\n    for(int a:A){\n        sum=(sum+a)%K;\n        //Java被除数为负数的时候取模也是负数\n        //这里应该纠正，避免负数的模\n        if(sum<0) sum+=K;\n        res+=pre[sum];\n        pre[sum]++;\n    }\n    return res;\n}\n```","tags":["LeetCode","查找"],"categories":["算法"]},{"title":"深入理解Java虚拟机(三)","url":"/2019/09/05/shen-ru-li-jie-java-xu-ni-ji-san/","content":"\n> 这一篇主要记录JVM相关的Class文件结构\n\n## Class类文件的结构\n\n Class文件是一组以**8个字节**为基础单位的二进制流，根据Java虚拟机规范，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号数和表** \n\n**无符号数**\n\n无符号数属于基本的数据类型，以u1，u2，u4，u8来分别表示1，2，4，8个字节大小的无符号数，无符号数用来描述数字，索引引用，数量值，或者按照UTF-8编码构成字符串值\n\n**表（数组）**\n\n表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性的以`_info` 结尾，表用于描述有程池关系的复合结构的数据，整个Class文件本质上就是一张表\n\n### Class文件整体结构\n\n```java\nClassFile{\n    u4                  magic(魔数0xCAFFBABE)\n    u2                  minor_version(次版本号)\n    u2                  major_version(主版本号)\n    u2                  constant_pool_count(常量池个数)\n    cp_info             constant_pool(常量池表)\n    u2                  access_flags(类或接口的访问权限)\n    u2                  this_class(类名)\n    u2                  super_class(父类名)\n    u2                  interfaces_count(接口个数)\n    u2                  interfaces(接口名)\n    u2                  fields_count(字段个数)\n    field_info          fields(字段表)\n    u2                  methods_count(方法数)\n    method_info         methods(方法表)\n    u2                  attributes_count(附加属性个数)\n    attribute_info      attributes(附加属性表)\n}\n```\n\n> 在网上看了[国外的大佬](https://www.infoq.cn/article/Secrets-of-the-Bytecode-Ninjas)的一张图，挺有意思的![mark](http://static.imlgw.top/blog/20190902/4JDgENgQ9eIo.png?imageslim)\n\n\n\n**魔数和Class文件的版本**\n\n每个Class文件的**头4个字节**称为魔数，他唯一的作用是确定这个文件是否为一个能被虚拟机接收的Class文件，这个值为`0xCAFFBABE` ，紧跟着魔数的**4个字节**存储的是Class文件的版本号，高版本的JDK能兼容低版本的字节码，而低版本JVM的无法兼容高版本的Class文件\n\n## 常量池\n\n紧跟着版本号之后的就是常量池入口，一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作Class文件的资源仓库，比如说Java类中定义的方法和变量信息，都是存储在常量池中，常量池中主要存储的两类常量：\n\n- **字面量：** 文本字符串，Java中声明为final的常量值等\n- **符号引用：**类和接口的全限定名，字段的名称和描述符，方法的名称和描述符等\n\n> 关于符号引用，其实在之前的文章中有介绍过，Java代码在编译的时候并不像C++/C一样有连接的步骤，而是在虚拟机加载Class文件的时候进行**动态链接**，也就是说，在Class文件中不会保存各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用无法直接被虚拟机使用，当虚拟机运行的时候，需要从常量池中获得对应得符号引用，在类创建或运行得时候解析，翻译到具体的内存地址中。\n\n### 常量池项目类型\n\n常量池的每一项都是一个表，JDK1.7之前一共有11种**结构不同**的表结构，也就是下面的11种，JDK1.7之后为了更好的支持动态语言的调用，又额外的增加了3种（CONSTANT_MethodHandle_info，CONSTANT_MethodType_info，CONSTANT_InvokeDynamic_info）这些表结构都有一个共同的特点，**表开始的第一位都是一个`u1`类型的标志位`tag`，目的就是区分这个常量属于那种类型的常量**，后面的内容都各有各的结构，`index`代表的是常量池中的对应的常量索引，`bytes`代表的就是字节数据\n\n### cp_info\n\n![常量池表结构](http://static.imlgw.top/blog/20190829/vjjWxwvrt0qg.png)\n\n这张表上的数据不用记住，用的时候知道去哪里查就行了（虽然用的机会很少😂），下面我们编译一段代码，看一下字节码长啥样\n\n```java\npublic class Test1 {\n    \n    private int a=1;\n    \n    public int getA(){\n        return a;\n    }\n    public void setA(int a){\n        this.a=a;\n    }\n}\n```\n\n🎯**编译完成后用16进制的编译器(winHex)打开Class文件**\n\n![mark](http://static.imlgw.top/blog/20190901/EOnrpm9sx8wE.png?imageslim)\n\n⚡ 这里前面的4个字节`0xCAFEBABE` 代表的就是魔数，后面的4个字节`0x00000034`代表的就是版本号，再往后2个字节`0x0018`就是常量池的入口，对应的就是常量池的大小（constant_pool_count），转换为10进制就是24，但是实际上并不是24个，常量池计数是从1而不是0开始的，设计者将0位置的项空出来目的是为了表示后面某些指向常量池的索引值的数据在特定情况下表示**不引用任何一个常量池项目**（大师就是大师，各种细节都能考虑到）\n\n⚡ 再往后看，`0x0A`，这个就是我们前面说的`tag`标志位，转换为10进制就是`10` ，查一下表对应的常量类型是`CONSTANT_Methodref_info`，紧跟着的两个字节`0x0004`是一个`index`类型的数据，指向声明方法描述符`CONSTANT_Class_info` 的索引项，也就是常量池的第4项，再往后两个字节`0x0014`代表的就是指向类型描述符`CONSTANT_NameAndType`的索引项，也就是常量池的第20项\n\n这里我们就不一一的去分析了，我们借助`javap` 来看看反编译的结果和我们分析的是不是一致的\n\n```java\nLast modified 2019-9-1; size 485 bytes\n  MD5 checksum e8148a01ff25087c42827d62a9b827b0\n  Compiled from \"Test1.java\"\npublic class jvmstudy.classfile_stu.Test1\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#20         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #3.#21         // jvmstudy/classfile_stu/Test1.a:I\n   #3 = Class              #22            // jvmstudy/classfile_stu/Test1\n   #4 = Class              #23            // java/lang/Object\n   #5 = Utf8               a\n   #6 = Utf8               I\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               Ljvmstudy/classfile_stu/Test1;\n  #14 = Utf8               getA\n  #15 = Utf8               ()I\n  #16 = Utf8               setA\n  #17 = Utf8               (I)V\n  #18 = Utf8               SourceFile\n  #19 = Utf8               Test1.java\n  #20 = NameAndType        #7:#8          // \"<init>\":()V\n  #21 = NameAndType        #5:#6          // a:I\n  #22 = Utf8               jvmstudy/classfile_stu/Test1\n  #23 = Utf8               java/lang/Object\n{\n  public jvmstudy.classfile_stu.Test1();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: aload_0\n         5: iconst_1\n         6: putfield      #2                  // Field a:I\n         9: return\n      LineNumberTable:\n        line 7: 0\n        line 9: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      10     0  this   Ljvmstudy/classfile_stu/Test1;\n\n  public int getA();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field a:I\n         4: ireturn\n      LineNumberTable:\n        line 12: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Ljvmstudy/classfile_stu/Test1;\n\n  public void setA(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=2\n         0: aload_0\n         1: iload_1\n         2: putfield      #2                  // Field a:I\n         5: return\n      LineNumberTable:\n        line 16: 0\n        line 17: 5\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       6     0  this   Ljvmstudy/classfile_stu/Test1;\n            0       6     1     a   I\n}\nSourceFile: \"Test1.java\"\n\n```\n\n可以看到和我们分析结果是一致的，那这个`Methodref`是表示的那个方法呢？其实根据反编译的结果也可以看出来，这个方法是我们默认的无参构造方法\n\n## 访问标志\n\n| 标志名称       | 标志值   | 含义                                                         |\n| -------------- | -------- | ------------------------------------------------------------ |\n| ACC_PUBLIC     | 0x00 01  | 是否为Public类型                                             |\n| ACC_FINAL      | 0x00 10  | 是否被声明为final，只有类可以设置                            |\n| ACC_SUPER      | 0x00 20  | 是否允许使用invokespecial字节码指令的新语义．jdk1.0.2之后都为真 |\n| ACC_INTERFACE  | 0x02 00  | 标志这是一个接口                                             |\n| ACC_ABSTRACT   | 0x04 00  | 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |\n| ACC_SYNTHETIC  | 0x10 00  | 标志这个类并非由用户代码产生                                 |\n| ACC_ANNOTATION | 0x20 00  | 标志这是一个注解                                             |\n| ACC_ENUM       | ０x40 00 | 标志这是一个枚举                                             |\n\n在常量池结束之后，紧接着的**两个字节**代表访问标志（`access_flags`），这个标志用于识别类或接口层次的访问信息，包括：这个Class是接口还是方法?是否定义为public类型？是否定义为abstract？等，两个字节16个标志位，可以表示2^16种状态，但是当前只定义了8个标志位没有使用到的一律要求为0\n\n还是参考上面的字节码，常量池是图中从`0A~74` 的紫色部分，紧跟着后面的两个字节`0x0021`对应的就是访问标志位，也就是 `ACC_PUBLIC | ACC_SUPER` 的值\n\n## 类索引，父类索引接口索引集合\n\n类索引(`this_class`)和父类索引(`super_class`)都是一个u2类型的数据，而接口索引集合(`interfaces`)是一组`u2` 类型的**数据的集合**，Class文件中由这三项数据来表示这个类的继承关系\n\n类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。\n\n类索引、父类索引和接日索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为`CONSTANT_Class_info`的类描述符常量，通过`CONSTANT_Class_info`类型的常量中的索引值以找到定义在`CONSTANT_Utf8_info`类型的常量中的全限定名字符串\n\n我们接着上面的字节码文件分析，紧接着访问标志符后面的u2是`0x0003` 也就是`this_class`在常量池中的索引，再往后的`0x0004`对应的就是`super_class`在常量池的索引`0x0000` 说明没有父接口，后面的集合也就没有了\n\n```java\nConstant pool:\n   #1 = Methodref          #4.#20         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #3.#21         // jvmstudy/classfile_stu/Test1.a:I\n   #3 = Class              #22            // jvmstudy/classfile_stu/Test1\n   #4 = Class              #23            // java/lang/Object\n   #5 = Utf8               a\n   #6 = Utf8               I\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               Ljvmstudy/classfile_stu/Test1;\n  #14 = Utf8               getA\n  #15 = Utf8               ()I\n  #16 = Utf8               setA\n  #17 = Utf8               (I)V\n  #18 = Utf8               SourceFile\n  #19 = Utf8               Test1.java\n  #20 = NameAndType        #7:#8          // \"<init>\":()V\n  #21 = NameAndType        #5:#6          // a:I\n  #22 = Utf8               jvmstudy/classfile_stu/Test1\n  #23 = Utf8               java/lang/Object\n```\n\n结合反编译的结果，常量池第三项和第四项都对应了一个`CONSTANT_Class_info`的索引常量，其最终指向了一个`CONSTANT_Utf8_info` 的常量，这个常量的值就是我们的`this_class`和`super_class` 的全限定名\n\n## 字段表集合\n\n紧跟着上面类索引等信息后面的`u2`类型的数据`0x0001`就是代表的`fields_count`，这里只有一个字段a所以这里是`1`\n\n### field_info\n\n字段表（`field_info`）用于描述接口或者类中声明的变量。字段（`field`）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量\n\n字段的各种修饰符其实都是个布尔值，要么有要么没有，所以很好表示适合用标志位来表示，但是字段的类型，名字这些就很难固定\n\n| 类型           | 名称             | 数量             |\n| -------------- | ---------------- | ---------------- |\n| u2             | access_flags     | 1                |\n| u2             | name_index       | 1                |\n| u2             | descriptor_index | 1                |\n| u2             | attributes_count | 1                |\n| attribute_info | attributes       | attributes_count |\n\n前三项分别代表，访问修饰符，名字的索引以及_描述符_（**对字段来说就是字段的类型**）的索引，这三项就可以构成一个字段的完整的信息了，这里我们重点看的也是前三项的信息，字段修饰符`access_flags`其实和类中的`access_flags` 类似，只不过可以设置的修饰符不太一样\n\n**字段访问标志**\n\n| 标志名称      | 标志值 | 含义                       |\n| ------------- | ------ | -------------------------- |\n| ACC_PUBLIC    | 0x0001 | 字段是否public             |\n| ACC_PRIVATE   | 0x0002 | 字段是否private            |\n| ACC_PROTECTED | 0x0004 | 字段是否protected          |\n| ACC_STATIC    | 0x0008 | 字段是否static             |\n| ACC_FINAL     | 0x0010 | 字段是否final              |\n| ACC_VOLATILE  | 0x0040 | 字段是否volatile           |\n| ACC_TRANSIENT | 0x0080 | 字段是否transient          |\n| ACC_SYNTHETIC | 0x1000 | 字段是否由编译器自动产生的 |\n| ACC_ENUM      | 0x4000 | 字段是否enum               |\n\n🎯**继续接着上面的类索引分析**\n\n![mark](http://static.imlgw.top/blog/20190902/s5dWhYXNIuxq.png?imageslim)\n\n⚡`0x0001` 对应`fields_count`，值为1字段的数量为 1，后面的`field_info`数量为1\n\n⚡`0x0002` 对应字段的`access_flags`，为`ACC_PRIVATE`\n\n⚡`0x0005` 对应字段的名字的索引，在常量池中的第5项，结合上面反编译的结果第5项为  `#5 = Utf8    a`\n\n⚡`0x0006` 对应字段的描述符索引，在常量池中第6项，为`#6 = Utf8   I`\n\n到这里其实我们就可以推断出这个变量的定义为 `private int a`\n\n> 字段表集合中不会列出从超类或者父接口中继承而来的字段，但是有可能会列出原本Java代码中没有的字段，比如内部类中自动添加指向外部类的字段。从所周知，在**Java**中字段是不能重载的，只要两个字段的名字是不能一样的，必须使用不同的名称，注意，这是**Java的语言规范**，其实在Class字节码来讲，只要两个字段的描述符不一样，重名就是合法的。\n\n再往后两个字节`0x0000`代表`attributes_count`，其值为0所以后面的属性表就没有了，如果这里将字段改为`static final int a` 那么`attributes_count` 将为1，后面会多出一条指向常量池`ConstantValue`数据的index(下文会演示)\n\n## 方法表集合\n\n紧跟着字段表之后的u2类型的数据 `0x0003`代表的就是`method_count` ，值为3代表有三个方法，这里面包含了JVM自动生成的默认无参数构造器方法，所以是3个\n\n### method_info\n\n方法表的结构其实和字段表的结构是一样的\n\n| 类型           | 名称             | 数量             |\n| -------------- | ---------------- | ---------------- |\n| u2             | access_flags     | 1                |\n| u2             | name_index       | 1                |\n| u2             | descriptor_index | 1                |\n| u2             | attributes_count | 1                |\n| attribute_info | attributes       | attributes_count |\n\n但是具体的`access_flags` 和`attributes`集合不太一样\n\n**方法访问标志**\n\n| 标志名称          | 标志值  | 含义                             |\n| ----------------- | ------- | -------------------------------- |\n| ACC_PUBLIC        | 0x00 01 | 方法是否为public                 |\n| ACC_PRIVATE       | 0x00 02 | 方法是否为private                |\n| ACC_PROTECTED     | 0x00 04 | 方法是否为protected              |\n| ACC_STATIC        | 0x00 08 | 方法是否为static                 |\n| ACC_FINAL         | 0x00 10 | 方法是否为final                  |\n| ACC_SYHCHRONRIZED | 0x00 20 | 方法是否为synchronized           |\n| ACC_BRIDGE        | 0x00 40 | 方法是否是由编译器产生的桥接方法 |\n| ACC_VARARGS       | 0x00 80 | 方法是否接受参数                 |\n| ACC_NATIVE        | 0x01 00 | 方法是否为native                 |\n| ACC_ABSTRACT      | 0x04 00 | 方法是否为abstract               |\n| ACC_STRICTFP      | 0x08 00 | 方法是否为strictfp               |\n| ACC_SYNTHETIC     | 0x10 00 | 方法是否是有编译器自动产生的     |\n\n🎯**我们继续接着上面的字段表后面分析**\n\n![mark](http://static.imlgw.top/blog/20190902/BuNVfOyD3mJy.png?imageslim)\n\n⚡`0x0003` 方法表的入口，代表`methods_count` 方法的数量，值为3，有三个方法（包括了编译器自动生成的`<init>`方法）\n\n⚡ `0x0001` 第一个方法的访问标志值，代表`ACC_PUBLIC`\n\n⚡ `0x0007` 方法名的`name_index`，值为7代表常量池中第7项常量，结合反编译的结果其值为\n\n`#7 = Utf8  <init>`  也就是我们的实例构造方法（编译器自动帮我们生成的）\n\n⚡ `0x0008` 方法描述符的`descriptor_index` ，值为8代表常量池中第8项常量，其值为\n\n`#8 = Utf8  ()V`  自动生成的无参构造器的描述\n\n⚡ `0x0001` 方法属性表(`attribute_info`)的入口，代表`attributes_count` ，值为1代表有一个属性表\n\n⚡ `0x0009` 属性名称的索引，常量池中为 `#9 = Utf8   Code`说明此属性是方法的字节码描述，也就是方法中的代码\n\n> 在方法表中，如果子类没有重写父类的方法就不会出现父类的方法信息，但是会出现编译器自动添加的方法，最典型的就是`<clinit>`和`<init>`，这里并没有 静态变量的赋值和静态语句块所以并没有生成`<clinit>` 方法，另外一点和上面字段表的一样，Java语言中重载是不能以返回值来界定的，但是在Class文件格式中，只要描述符不一致，就是可以共存的，而方法的描述符就包括了参数列表和返回值\n\n## 属性表集合\n\n属性表（attribute_info），Class文件，字段表，方法表中可以携带自己的属性表，说有attribute_info的前两项都是u2类型的`attribute_name_index`和u4类型的`attribute_length`分别代表属性名字的索引和属性值的大小 ，Java虚拟机中预定义了一些属性，这些属性都各有各的含义和结构\n\n| 属性名称                             | 使用位置           | 含义                                                         |\n| :----------------------------------- | ------------------ | :----------------------------------------------------------- |\n| Code                                 | 方法表             | Java 代码编译成的字节码指令                                  |\n| ConstantValue                        | 字段表             | final 关键字定义的常量值                                     |\n| Deprecated                           | 类、方法表、字段表 | 被声明为 `deprecated` 的方法和字段                           |\n| Exceptions                           | 方法表             | 方法抛出的异常                                               |\n| EnclosingMethod                      | 类文件             | 仅当一个类为局部类或匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 |\n| InnerClasses                         | 类文件             | 内部类列表                                                   |\n| LineNumberTable                      | Code 属性          | Java 源码的行号与字节码指令的对应关系                        |\n| LocalVariableTable                   | Code 属性          | 方法的局部变量描述                                           |\n| StackMapTable                        | Code 属性          | JDK 6 新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 |\n| Signature                            | 类、方法表、字段表 | JDK 5 新增的属性，用于支持泛型情况下的方法签名，在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。由于 Java 的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息 |\n| SourceFile                           | 类文件             | 记录源文件名称                                               |\n| SourceDebugExtension                 | 类文件             | JDK 6 新增属性，用于存储额外的调试信息。譬如在进行 JSP 文件调试时，无法通过 Java 堆栈来定位到 JSP 文件的行号，JSR-45 规范为这些非 Java 语言编写，却需要编译成字节码并运行在 Java 虚拟机中的程序提供了一个进行调试的标准机制，使用该属性就可以存储这个标准所新加入的调试信息 |\n| Synthetic                            | 类、方法表、字段表 | 表示方法或字段是由编译器自动生成的                           |\n| LocalVariableTypeTable               | 类                 | JDK 5 新增属性，它使用特征签名代替描述符，为了引入泛型语法之后能描述泛型参数化类型而添加 |\n| RuntimeVisibleAnnotations            | 类、方法表、字段表 | JDK 5 新增属性，为动态注解提供支持。该属性指明哪些注解是运行时（实际上运行时就是进行反射调用）可见的 |\n| RuntimeInvisibleAnnotations          | 类、方法表、字段表 | JDK 5 新增属性，与 `RuntimeVisibleAnnotations` 作用相反，用于指明哪些注解运行时不可见 |\n| RuntimeVisibleParameterAnnotations   | 方法表             | JDK 5 新增属性，作用与 `RuntimeVisibleAnnotations` 作用相似，只不过作用对象为方法参数 |\n| RuntimeInvisibleParameterAnnotations | 方法表             | JDK 5 新增属性，作用与 `RuntimeInvisibleAnnotations` 作用相似，只不过作用对象为方法参数 |\n| AnnotationDefault                    | 方法表             | JDK 5 新增属性，用于记录注解类元素的默认值                   |\n| BootstrapMethods                     | 类文件             | JDK 7 新增属性，用于存储 `invokedynamic` 指令引用的引导方法限定符 |\n\n### Code属性\n\nJava程序方法体中的代码经过Javac编译器处理过后，最终变为字节码指令存储在Code属性内\n\nCode属性出现在**方法表的属性集合**中，但是并非所有的方法表都必须存在这个Code属性，**像接口和抽象类中的方法就不存在Code属性**\n\n**Code属性结构**\n\n| 类型            | 名称                   | 数量                   |\n| --------------- | ---------------------- | ---------------------- |\n| u2              | attribute_name_index   | 1                      |\n| u4              | attribute_length       | 1                      |\n| u2              | max_stack              | 1                      |\n| u2              | max_locals             | 1                      |\n| u4              | code_length            | 1                      |\n| u1              | code                   | code_length            |\n| u2              | exception_table_length | 1                      |\n| exception_info  | exception_table        | exception_table_length |\n| u2              | attributes_count       | 1                      |\n| attributes_info | attributes             | attributes_count       |\n\n🎯**紧接着上面的方法表分析**\n\n_这里分析的还是方法表第一个方法（`<init>`）所携带的属性表_\n\n![mark](http://static.imlgw.top/blog/20190904/Gd5cWl6Yr84x.png?imageslim)\n\n⚡ `0x0009` 对应`attribute_name_index`，属性名称的索引，常量池中为 `#9 = Utf8   Code`说明此属性是方法的字节码描述，也就是方法中的代码\n\n⚡ `0x00000038` 代表`attribute_length` 顾名思义就是属性值的长度，这里是56（不包含attribute_name_index和attribute_length）\n\n⚡`0x0002`代表`max_stack` 操作数栈（Operand Stacks）深度的最大值，虚拟机运行的时候会根据这个值来分配栈帧（StackFrame）中的操作栈深度\n\n⚡`0x0001`代表`max_locals` 代表了**局部变量表**所需的存储空间，这里的内存分配单位是`Slot`\n\n> `Slot`是虚拟机为局部变量分配内存所使用的最小单位，对于byte，char，float，int，short，boolean等长度不超过32位的数据类型，每个局部变量占用一个`Slot` ，但是对于double和long等64位的数据类型则需要两个`Slot` \n>\n> 方法参数（包括实例方法中的this引用），trycatch语句中catch中定义的异常，方法体中定义的局部变量 都需要使用局部变量表来存放，但是最后并不是把所有这些局部变量占用的`Slot`加起来就是`max_locals` 因为**局部变量表中的Slot是可以复用的**，当代码执行超过一个局部变量的作用域时，这个变量占用的Slot就可以被其他局部变量所使用，所以编译器会根据作用域来分配`Slot` 给各个局部变量使用\n\n⚡`0x0000000A`u4类型的`code_length` 代表的就是字节码的长度，这里是10，说明后面有10个字节长度的字节码指令流\n\n⚡u1类型的`code` 就是具体用字节码指令，每个指令都是一个u1的单字节指令，也就是说最多有256个指令，目前Java虚拟机已经定义了其中约200条编码值对应的指令，这里有连续的10个单字节指令，构成了`<init>`方法的字节码指令\n\n⚡`0x0000`代表`exception_table_length` 异常表的长度，这里`<init>`方法没有异常抛出所以为0\n\n⚡ `exception_info`类型的`exception_table` 异常表，存放处理异常的信息（try-catch中的异常），前面的长度为0所以这里不存在这一项数据\n\n**异常表结构**\n\n| 类型 | 名称       | 数量 |\n| ---- | ---------- | ---- |\n| u2   | start_pc   | 1    |\n| u2   | end_pc     | 1    |\n| u2   | handler_pc | 1    |\n| u2   | catch_type | 1    |\n\n每个exception_table表项由start_pc，end_pc，handler_pc，catch_type（指向常量池中CONSTANT_Class_info类型的常量）组成\n\n当字节码在start_pc到end_pc之间出现了类型为catch_type或者其子类的异常，就转到handler_pc行继续执行，当catch_type为0时表示处理所有的异常\n\n⚡`0x0002` 代表`attributes_count` 是`Code` 属性表的**附加属性**的入口（一层套一层啊😂），值为2意味着附加属性表的数量为2\n\n### LineNumberTable属性\n\n这个就是上面**`<init>`方法Code属性附加的第一个属性**，这个属性用于描述Java源代码行号和字节码行号（偏移量）之间的对应关系，他并不是运行的必须属性，但是默认会生成到Class文件中，可以使用`-g:none`或`-g:lines`取消生成这个属性，取消之后程序抛异常的时候不会显示出错的行号，并且在调试的时候，也无法按照源码行来设置断点，其结构如下表\n\n| 类型             | 名称                     | 数量                     |\n| ---------------- | ------------------------ | ------------------------ |\n| u2               | attribute_name_index     | 1                        |\n| u4               | attribute_length         | 1                        |\n| u2               | line_number_table_length | 1                        |\n| line_number_info | line_number_table        | line_number_table_length |\n\n🎯**我们再接着上面的Code属性的属性表分析，看看Code的属性表是啥**\n\n![mark](http://static.imlgw.top/blog/20190904/O7MuBcPXNPKT.png?imageslim)\n\n⚡`0x000A` attributes_info的第一项，对应的是atttibute的名字的索引，常量池中对应第10项的索引是 \n\n `#10 = Utf8   LineNumberTable` 说明这个属性是LineNumberTable属性，然后根据上面给出的表格继续分析\n\n⚡`0x0000000A` 对应attribute_length，说明该属性值长度为10\n\n⚡`0x0002`对应line_number_table_length，说明有两处对应关系\n\n⚡ 后面紧跟的字节就对应的`line_number_table` 该属性又有两个属性，分别为`start_pc`和`line_number`两个u2类型的数据项，前者是字节码行号，后者是源码行号，前面line_number_table_length为2，所以这里后面有两个line_number_table\n\n### LocalVariableTable属性\n\n这个就是上面**`<init>` 方法Code属性附加的第二个属性**，这个属性主要用于描述**栈帧中局部变量表**中的变量和Java源代码中定义的变量之间的关系，没有这项属性当在其他地方使用该方法的时候关于参数的名称都会丢失，最典型的就是IDE中有时候反编译一些框架的代码就会看见一些方法参数什么的都是arg0，arg1什么的\n\n**LocalVariableTable属性结构**\n\n| 类型                | 名称                        | 数量                        |\n| ------------------- | --------------------------- | --------------------------- |\n| u2                  | attribute_name_index        | 1                           |\n| u4                  | attribute_length            | 1                           |\n| u2                  | local_variable_table_length | 1                           |\n| local_variable_info | local_variable_table        | local_variable_table_length |\n\n🎯 **我们接着上面的LineNumberTable属性分析`LocalVariableTable`**\n\n![mark](http://static.imlgw.top/blog/20190905/TafXz1oMkG4d.png?imageslim)\n\n⚡`0x000B`和之前所有的attributes_info一样，这个第一项代表该属性的名字在常量池的索引值，这里对应常量池第11项 `#11 = Utf8   LocalVariableTable` \n\n⚡`0x0000000C` 对应attribute_length，说明该属性值长度为12\n\n⚡`0x0001`对应local_variable_table_length，值为1说明只有一个局部变量\n\n> 其实到现在我们分析的属性表都还是在分析这个类的第一个方法，JVM自动生成的`<init>`方法所对应的属性表，而这个`<init>`很明显是没有参数的，是一个无参的空构造器，那么问题来了，这里的局部变量是从哪里来的？为什么不是0？\n>\n> 其实这很好解释，平常编码的时候大家肯定都使用过`this` 这个关键字，通过这个关键字可以在实例方法中拿到当前的实例对象，这个1代表其实就是这个`this`，在Javac编译的时候会将对this的访问转换为对一个方法参数的访问，而这个方法参数会在运行这个实例方法的时候由JVM自动的传入，所以局部变量表中至少会存在一个指向当前实例的局部变量\n\n我们继续分析后面的`local_variable_info` \n\n**local_variable_info属性结构**\n\n| 类型 | 名称             | 数量 |\n| ---- | ---------------- | ---- |\n| u2   | start_pc         | 1    |\n| u2   | length           | 1    |\n| u2   | name_index       | 1    |\n| u2   | descriptor_index | 1    |\n| u2   | index            | 1    |\n\n⚡`0x0000` 代表`start_pc`，这个局部变量的生命周期开始的字节码偏移量\n\n⚡`0x000A`代表`length`代表这个局部变量其作用范围覆盖的长度\n\n⚡`0x000C`代表`name_index` 是这个局部变量的名字索引，指向常量池中第12项常量 `#12 = Utf8   this`符合我们前面的分析\n\n⚡`0x000D`代表`decriptor_index` 局部变量描述符（对变量来说就是变量的类型）的索引，指向常量池第13项常量\n\n`#13 = Utf8    Ljvmstudy/classfile_stu/Test1;` 当前实例对象的**全限定名**\n\n⚡`0x0000` 对应`index` 代表这个局部变量在**栈帧局部变量表**中Slot的位置\n\n> _**⏳ 到这里我们的方法表的第一个方法`<init>`的Code属性就结束了，由于`<init>`方法不包含其他的属性所以`<init>`方法在字节码中也已经结束了**_，后面的方法就不再逐个字节的分析了，都是一样的，主要的是要搞清楚这些属性的层级和包含关系，不要搞混了\n\n### Exceptions属性\n\n`Exceptions` 属性和上面Code属性是平级的，和Code属性附带的`exception_table`并不是一个东西，不要搞混了，Exceptions属性的作用是列举出方法中可能抛出的受检查异常，也就是方法描述时在`throws`关键字后面列举的异常，结构如下\n\n| 类型 | 名称                  | 数量                 |\n| ---- | --------------------- | -------------------- |\n| u2   | attribute_name_index  | 1                    |\n| u4   | attribute_length      | 1                    |\n| u2   | number_of_exceptions  | 1                    |\n| u2   | exception_index_table | number_of_exceptions |\n\n`number_of_exceptions`表示可能抛出多少种受检查异常，每种异常都是一个`exception_index_table` 很明显这个是一个索引，指向常量池中对应的Exception的描述符\n\n这里我们的`<init>` 方法并没有抛出异常，所以这一项属性并不存在，那我们找一个有异常的来看看\n\n```java\npublic class Test2 {\n\n    private static int bbbb = 99;\n\n    private final static int aaaa = 99;\n\n    private List<Integer> list=null;\n\n    public Test2(int a) {\n        bbbb = a;\n    }\n\n    public int inc() throws ArithmeticException{\n        int x;\n        try {\n            x=1;\n            return  x;\n        }catch (Exception e){\n            x=2;\n            return x;\n        }finally {\n            x=3;\n        }\n    }\n\n    @Deprecated\n    public void deprecatedMethod(){\n\n    }\n}\n```\n\n![mark](http://static.imlgw.top/blog/20190905/uG5AQrVoHphH.png?imageslim)\n\n可以看到`exception_table` 里面记录了这个方法的异常处理表，也就是`try-catch`里面的异常处理，这也是Java代码的一部分，编译器使用了异常处理表去处理异常和finally机制，在jdk1.4之前使用的是简单的跳转指令来实现，而Exceptions属性和Code平级，只是列举了一些可能抛出的异常\n\n```java\nExceptions:\n  throws java.lang.ArithmeticException\n```\n## SourceFile属性\n\n这个属性是属于Class文件的属性，很明显是用来记录生成这个Class文件的源代码名称，其值指向一个CONSTANT_Utf8_info的索引，值就是源文件的名字\n\n## ConstantValue属性\n\n这个属性在前一篇 [类加载器](http://imlgw.top/2019/08/17/shen-ru-li-jie-java-xu-ni-ji-er/#%E5%87%86%E5%A4%87) 中提到过， `ConstantValue`属性的作用是通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量（类变量）可以使用这项属性\n\n如果**同时使用final和static来修饰一个变量**，并且这个变量的数据类型是基本类型或者`java.lang.String`的话，就生成`ConstantValue`属性，用于在**准备阶段**给变量赋初始值，如果这个变量没有被final修饰或者并非基本类型及字符串，则在准备阶段会被初始化为默认的零值，在`<clinit>`方法中进行真正的初始化\n\n**依然是上面Exceptions的Demo**\n\n![mark](http://static.imlgw.top/blog/20190905/U8zwbs2c0n8a.png?imageslim)\n\n可以看到`aaaa` 这个常量字段附带了 `ConstantValue` 属性其值就是指向常量池中99的一个索引\n\n> 🎯 后面还有一些属性就不再详细介绍了\n>\n> Signature用来记录泛型的信息，StackMapTable用来验证字节码，BootstarapMethods用来保存动态调用的引导方法限定符，Deprecated和Synthetic两个boolean属性......\n\n## Synchnorized字节码分析\n\n**synchnorized**关键字可以用来修饰方法体，或者方法体内的代码块，修饰方法体的时候同步是隐式的，无需通过字节码指令来控制，它实现在方法调用和返回中，为了看到字节码的变化，这里我们不讨论这种（两种方式的底层实现其实还是一样的）\n\n```java\npublic class Test4 {\n    public static Integer a = 0;\n\n    public void setA(int x) {\n        synchronized (this) {\n            a = x;\n        }\n    }\n}\n```\n\n编译后利用工具查看setA方法内生成的字节码指令（省略了次要的一些信息）\n\n```java\n0: aload_0           //对象引用this入栈\n1: dup\t             //复制栈顶元素(this)\n2: astore_2          //将栈顶元素(this)存入局部变量表Slot索引为2的位置\n3: monitorenter      //以栈顶元素(this)为锁进入同步块\n4: iload_1\t         //局部变量Slot 1位置的元素(x)入栈\n5: invokestatic  #2  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n8: putstatic     #3  // Field a:Ljava/lang/Integer; 用x给a赋值\n11: aload_2          //局部变量表Slot 2元素(this)入栈\n12: monitorexit      //退出同步\n13: goto          21 //跳转到21行结束\n16: astore_3         //到这里说明异常了，将栈顶元素（异常对象）存入局部变量表Slot 3位置\n17: aload_2          //局部变量表Slot 2元素(this)位置入栈\n18: monitorexit      //退出同步\n19: aload_3          //局部变量表Slot 3位置元素入栈\n20: athrow           //抛出异常\n21: return           //方法正常返回\nException table:\n    from    to  target type\n       4    13    16   any\n      16    19    16   any\n\n```\n最开始没有学字节码的时候一直很纳闷为啥有两个`monitorexit` ，现在算是明白了，这是为了保证synchnorized在方法异常的情况下仍然可以正常的释放锁，而不至于导致锁泄露，这也是比较推荐使用synchnorized的原因之一\n\n通过字节码可以看到，编译器为我们自动的生成了一个异常表，也就是前面Code属性中携带的exception_table属性，如果在指定的程序段内发生异常，会按照异常表指定的target进行跳转，无论如何都会释放这个锁\n\n## 总结 & 参考\n\n这一部分主要记录了Class字节码的文件结构相关的内容，也算是是逐个字节的分析了一遍，收获还是挺大的，对JVM平台的理解又加深了，当然这一篇也是给下一篇**虚拟机节码的执行引擎**做铺垫\n\n**_《深入理解Java虚拟机》——周志明_**\n\n","tags":["Class结构","JVM"],"categories":["JVM"]},{"title":"LeetCode动态规划","url":"/2019/09/01/leetcode-dong-tai-gui-hua/","content":"\n## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n\nYou are climbing a stair case. It takes *n* steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n**Note:** Given *n* will be a positive integer.\n\n**Example 1:**\n\n```java\nInput: 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n\n1. 1 step + 1 step\n2. 2 steps\n```\n\n**Example 2:**\n\n```java\nInput: 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n```\n\n**解法一**\n\n没啥好说的，可以说是最经典的dp题了\n\n```java\npublic static int climbStairsDp(int n){\n    int []dp=new int[n+1];\n    dp[0]=1;\n    dp[1]=1;\n    for (int i=2;i<=n;i++) {\n        dp[i]=dp[i-1]+dp[i-2];\n    }\n    return dp[n];\n}\n```\n\n## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n**Example 1:**\n\n```java\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n             Total amount you can rob = 1 + 3 = 4.\n```\n\n**Example 2:**\n\n```java\nInput: [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n             Total amount you can rob = 2 + 9 + 1 = 12.\n```\n\n**解法一**\n\n简单的dp题，dp方程很容易得到，`dp[i]=max(dp[i-2]+nums[i],dp[i-1])` （2020.3.22更新了代码）\n\n```java\n//  Max[i]=max(nums[i-2]+nums[i],nums[i-1])\npublic int rob(int[] nums) {\n    if(nums==null || nums.length<=0) return 0;\n    int[] dp=new int[nums.length];\n    dp[0]=nums[0];\n    for(int i=1;i<nums.length;i++){\n        dp[i]=Math.max(i>=2?dp[i-2]+nums[i]:nums[i],dp[i-1]);\n    }\n    return dp[nums.length-1];\n}\n```\n\n时间空间都是O(N)，需要注意边界条件\n\n**解法二**\n\n空间复杂度的优化\n\n```java\n// Max[i]=max(pre+nums[i],cur);  \npublic int rob(int[] nums) {\n    if(nums==null||nums.length<=0){\n        return 0;\n    }\n    int pre= 0; //前一天\n    int cur= 0; //当天，其实就是为了保存前后两天的dp[i]\n    for (int i=0;i<nums.length;i++) {\n        int temp=cur;\n        cur=Math.max(pre+nums[i],cur);\n        //向后走\n        pre=temp;\n    }\n    return cur;\n}\n```\n\n## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈**，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n示例 1:\n\n```java\n输入: [2,3,2]\n输出: 3\n解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n```\n\n示例 2:\n\n```java\n输入: [1,2,3,1]\n输出: 4\n解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n**解法一**\n\n与上一题相比房屋都围成一圈了，其实围成一圈也就说明`nums[0]`和`nums[len-1]`不能同时偷，所以就可以分两种情况分别求最大值，然后求最终的最大值\n\n```java\npublic int rob(int [] nums){\n    if(nums==null||nums.length<=0){\n        return 0;\n    }\n    if(nums.length==1){\n        return nums[0];\n    }\n    if(nums.length==2){\n        return Math.max(nums[0],nums[1]);\n    }\n    int n=nums.length;\n    return Math.max(rob(nums,1,n),rob(nums,0,n-1));\n}\n\npublic int rob(int[] nums,int start,int end) {\n    int pre=0; //前一家最大值\n    int cur=0; //当前最大值\n    for (int i=start;i<end;i++) {\n        int temp=cur;\n        cur=Math.max(pre+nums[i],cur);\n        pre=temp;\n    }\n    return cur;\n}\n```\n\n## [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明**：每次只能向下或者向右移动一步。\n\n**示例**:\n\n```java\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n```\n\n很经典的DP题。\n\n递推公式：`dp[i][j]  = grid[i][j] + Math.min(dp[i-1][j],dp[i][j-1])`\n\ndp[i] [j] 为每个格子到`左上角`最短路径 ，每个格子到左上角的最小距离等于，左边格子最小值和上边格子最小值的最小值加上当前格子的值。\n\n```java\npublic int minPathSum(int[][] grid) {\n    int[][] dp=new int[grid.length][grid[0].length];\n    for (int i=0;i<grid.length;i++) {\n        for (int j=0;j<grid[0].length;j++) {\n            //第一行\n            if(i==0 && j!=0){\n                dp[i][j]=grid[i][j]+dp[i][j-1];\n            }else if(i!=0 && j==0){\n                dp[i][j]=grid[i][j]+dp[i-1][j];\n            }else if(i!=0 && j!=0){\n                dp[i][j]=grid[i][j]+Math.min(dp[i-1][j],dp[i][j-1]);\n            }else{\n                dp[i][j]=grid[i][j];\n            }\n        }\n    }\n    return dp[grid.length-1][grid[0].length-1];\n}\n```\n\n**UPDATE: 2020.7.20**\n\n写下面的[path-sum-three-ways](#path-sum-three-ways)的时候看了这题之前的代码，发现写的不太好，一堆if-else，重写下\n```golang\nfunc minPathSum(grid [][]int) int {\n    var m = len(grid)\n    var n = len(grid[0])\n    var dp = make([][]int, m)\n    for i := 0; i < m; i++{\n        dp[i] = make([]int, n)\n    }\n    dp[0][0] = grid[0][0]\n    for i := 1; i < m; i++{\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    for j := 1; j < n; j++{\n        dp[0][j] = dp[0][j-1] + grid[0][j];\n    }\n    for i := 1; i < m; i++{\n        for j := 1; j < n; j++{\n            dp[i][j] = grid[i][j] + Min(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1]\n}\n\nfunc Min(a, b int) int{\n    if a > b{\n        return b\n    }\n    return a\n}\n```\n\n## [Path sum: three ways](https://projecteuler.net/problem=82)\n\nThe minimal path sum in the 5 by 5 matrix below, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right, is indicated in red and bold; the sum is equal to 994.\n\n![UhOJw6.png](https://s1.ax1x.com/2020/07/20/UhOJw6.png)\n\nFind the minimal path sum from the left column to the right column in matrix.txt (right click and \"Save Link/Target As...\"), a 31K text file containing an 80 by 80 matrix.\n\n**解法一**\n\n来源 https://leetcode-cn.com/circle/discuss/BNvWBP/ 从这里看见qc大佬贴了出处，所以特地注册了这个网站试了下，这个网站还是挺有意思的，只验证答案，时间复杂度啥的都不管\n\n和上面的最小路径和很类似，但是这里起点和终点都不确定，而且有3个方向可以选择，所以这里我们可以遍历2次，`dp[i][j]`代表从第一列到当前`matrix[i][j]`的最小路径和，先统计单纯的向上或者向下的最小值，然后再统计相反的方向的值，总之要保证3个方向的值都是计算过的\n```java\nimport java.util.*;\nimport java.io.*;\n//https://projecteuler.net/problem=82  answer:260324\npublic class PathSum_threeWays_projecteuler{\n    public static void main(String[] args) throws Exception{\n        BufferedReader reader = new BufferedReader(new FileReader(\"/usr/p082_matrix.txt\"));\n        int index = 0;\n        int m = 80, n = 80;\n        int[][] matrix = new int[m][n];\n        while (index < 80) {\n            String[] line = reader.readLine().split(\",\");\n            for (int j = 0; j < 80; j++) {\n                matrix[index][j] = Integer.valueOf(line[j]);\n            }\n            index++;\n        }\n        int INF = 0x3f3f3f3f;\n        int[][] dp = new int[m][n];\n        for (int j = 0; j < m; j++) {\n            dp[j][0] = matrix[j][0];\n        }\n        for (int j = 1; j < m; j++) {\n            //首先只考虑向右走和向下走\n            for (int i = 0; i < m; i++) {\n                if (i==0){ //第一行，只能从左边转移\n                    dp[i][j] = matrix[i][j] + dp[i][j-1];\n                }else{ //从左边或者上边转移\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\n                }\n            }\n            for (int i = m-1; i >= 0; i--) {\n                //三目写的太长看着挺不舒服...\n                //dp[i][j] = i==m-1?dp[i][j]:Math.min(dp[i][j], matrix[i][j]+dp[i+1][j]);\n                if (i<m-1) { //从下面转移和从上/左面转移的最小值\n                    dp[i][j] = Math.min(dp[i][j], matrix[i][j]+dp[i+1][j]);\n                }\n                //最后一行，只能从左边或者上面转移，也是就是第一个循环的值\n                //dp[i][j] = dp[i][j]\n            }\n        }\n        int res = INF;\n        for (int i = 0; i < m; i++) {\n            res = Math.min(res, dp[i][m-1]);\n        }\n        System.out.println(res);\n    }\n}\n```\n> 一开始写了个3目，改了半天的bug，发现是3目和前面的值混到一起了。。。\n\n## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n![mark](http://static.imlgw.top/blog/20190818/DfwXk3ObWxX8.png?imageslim)\n\n**说明：**m 和 n 的值均不超过 100。\n\n**示例 1:**\n\n```java\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n```\n\n**示例 2:**\n\n```java\n输入: m = 7, n = 3\n输出: 28\n```\n\n**动态规划解法**\n\n这题算是我第一道自己做出来的DP题了，虽然和上面的一题一样的思路，但是还是挺开心的\n\n```java\npublic int uniquePaths(int m, int n) {\n    if(m<0||n<0){\n        return 0;\n    }\n    int[][] dp=new int[n][m];\n    for (int i=0;i<n;i++) {\n        for (int j=0;j<m;j++) {\n            if(i==0&&j!=0){\n                dp[i][j]=1;\n            }else if(j==0 && i!=0){\n                dp[i][j]=1;\n            }else if(j!=0&&i!=0){\n                dp[i][j]=dp[i][j-1]+dp[i-1][j];\n            }else{\n                dp[i][j]=1;\n            }\n        }\n    }\n    return dp[n-1][m-1];\n}\n```\n时间复杂度`O(m*n)`，空间复杂度`O(m*n)`可以看出来完全是按照前一题的模板来的，代码写的不好，可以把 if-else合并起来，这题空间复杂度其实还可以优化成 O(m)或O(n)的，按行来向下走\n\n**空间复杂度优化**\n\n![leetCode题解](http://static.imlgw.top/blog/20190824/7uacSvsRMaWq.png?imageslim)\n\n```java\npublic static int uniquePaths2(int m, int n) {\n    if(m<0||n<0){\n        return 0;\n    }\n    int[] dp=new int[n]; \n    Arrays.fill(dp,1); //第一行，第一列均为 1\n    for (int i=1;i<m;i++) { //一行一行向下走\n        for (int j=1;j<n;j++) {\n            //这里的dp[j]和dp[j-1]分别就代表了 上边 和 左边的元素\n            dp[j]=dp[j]+dp[j-1]; //求每一行每个元素的dp值\n        }\n    }\n    return dp[n-1]; //最后一行最后一个dp值就是结果\n}\n```\n\n**组合数公式**\n\n这题其实就是我们初中还是高中学的排列组合的问题，机器人一共走`m+n-2` 步，向下会走`m-1` 步，向下会走`n-1` 步，所以实际上就是求一个组合数的结果 `C(n-1，m+n-2)` ，\n\n```java\npublic int uniquePaths(int m, int n) {\n    if(m<0||n<0){\n        return 0;\n    }\n    int step=m+n-2;\n    int down=n-1;\n    long res=1;\n    for (int i=1;i<=down;i++) {\n        res=res*(step-down+i)/i; //递推\n    }\n    return (int)res;\n}\n```\n\n## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n![mark](http://static.imlgw.top/blog/20190818/DfwXk3ObWxX8.png?imageslim)\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n**说明：**m 和 n 的值均不超过 100。\n\n**示例 1:**\n\n```java\n输入:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n输出: 2\n解释:\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n```\n\n**解法一**\n\n看到这种路径的题，首先想到的可能是递归回溯\n\n```java\n//dfs回溯 , TLE\nprivate int[][] direction={{0,1},{1,0}};\n\nprivate int count=0;\n\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    if (obstacleGrid==null || obstacleGrid.length<=0 || obstacleGrid[0][0]==1) {\n        return 0;\n    }\n    boolean[][] visit=new boolean[obstacleGrid.length][obstacleGrid[0].length];\n    dfs(obstacleGrid,visit,0,0);\n    return count;\n}\n\npublic void dfs(int[][] obstacleGrid,boolean[][] visit,int x,int y) {\n    //!=1 是为了coner case\n    if (x==obstacleGrid.length-1 && y==obstacleGrid[0].length-1 && obstacleGrid[x][y]!=1) {\n        count++;\n        return;\n    }\n    for (int i=0;i<direction.length;i++) {\n        int nx=x+direction[i][0];\n        int ny=y+direction[i][1];\n        if (nx<obstacleGrid.length && ny<obstacleGrid[0].length && !visit[nx][ny] && obstacleGrid[nx][ny] !=1) {\n            visit[nx][ny]=true;\n            dfs(obstacleGrid,visit,nx,ny);\n            visit[nx][ny]=false;\n        }\n    }\n}\n```\n结果很惨，TLE了，只跑了不到一半的case就TLE了\n\n**解法二**\n\n动态规划的解法，其实和上面一题是一样的，只不过需要注意障碍物位置的dp值\n\n```java\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    if (obstacleGrid==null || obstacleGrid.length<=0 || obstacleGrid[0][0]==1) {\n        return 0;\n    }\n    int[][] dp=new int[obstacleGrid.length][obstacleGrid[0].length];\n    for (int i=0;i<obstacleGrid.length;i++) {\n        for (int j=0; j<obstacleGrid[0].length;j++) {\n            if (obstacleGrid[i][j]==1) {\n                dp[i][j]=0;\n            }else if (i==0 && j==0) {\n                dp[0][0]=1;\n            }else if(i==0 && j!=0){\n                dp[0][j]=dp[0][j-1];\n            }else if (j==0 && i!=0) {\n                dp[i][0]=dp[i-1][0];\n            }else{\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\n            }\n        }\n    }\n    return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\n}\n```\n和上面一样也可以进行空间上的优化\n\n```java\n//一维dp\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    if (obstacleGrid==null || obstacleGrid.length<=0 || obstacleGrid[0][0]==1) {\n        return 0;\n    }\n    //以行为单位向下走\n    int[] dp=new int[obstacleGrid[0].length];\n    dp[0]=1;\n    for (int i=0;i<obstacleGrid.length;i++) {\n        for (int j=0; j<obstacleGrid[0].length;j++) {\n            if (obstacleGrid[i][j]==1) {\n                dp[j]=0;\n            }else if(i==0 && j!=0){ //第一行\n                dp[j]=dp[j-1];\n            }else if(i!=0 && j!=0){ \n                dp[j]=dp[j]+dp[j-1];\n            }\n            //每一行第一列的dp[j]=dp[j],和上一行的第一列保持一致就行\n        }\n    }\n    return dp[obstacleGrid[0].length-1];\n}\n```\n**UPDATE: 2020.7.6**\n\n想对简洁的做法\n```golang\nfunc uniquePathsWithObstacles(grid [][]int) int {\n    var m = len(grid)\n    var n = len(grid[0])\n    var dp = make([][]int, m+1)\n    for i := 0; i <= m; i++ {\n        dp[i] = make([]int, n+1)\n    }\n    dp[0][1] = 1 //初始值\n    for i := 1; i <= m; i++ {\n        for j := 1; j <= n; j++ {\n            if grid[i-1][j-1] != 1 {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n    }\n    return dp[m][n]\n}\n\n```\n## [576. 出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)\n\n给定一个 **m × n** 的网格和一个球。球的起始坐标为 **(i,j)** ，你可以将球移到**相邻**的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你**最多**可以移动 **N** 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。\n\n**示例 1：**\n\n```java\n输入: m = 2, n = 2, N = 2, i = 0, j = 0\n输出: 6\n解释:\n```\n\n**示例 2：**\n\n```java\n输入: m = 1, n = 3, N = 3, i = 0, j = 1\n输出: 12\n解释:\n```\n\n**说明:**\n\n1. 球一旦出界，就不能再被移动回网格内。\n2. 网格的长度和高度在 [1,50] 的范围内。\n3. N 在 [0,50] 的范围内。\n\n**解法一**\n\n首先写出来的解法，自顶向下，记忆化递归\n\n```java\nint[][] dir={{0,1},{1,0},{-1,0},{0,-1}};\n\nint mod=(int)1e9+7;\n\nLong[][][] dp=null;\n\npublic int findPaths(int m, int n, int N, int i, int j) {\n    dp=new Long[m][n][N+1];\n    return (int)(dfs(m,n,i,j,N)%mod);\n}\n\npublic long dfs(int m,int n,int x,int y,int k){\n    if(k==0) return 0;\n    if(dp[x][y][k]!=null){\n        return dp[x][y][k];\n    }\n    long count=0;\n    for(int i=0;i<dir.length;i++){\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(!valid(m,n,nx,ny)){\n            count++;\n            continue;\n        }\n        count=(count+dfs(m,n,nx,ny,k-1))%mod;\n    }\n    return dp[x][y][k]=(count)%mod;\n}\n\npublic boolean valid(int m,int n,int x,int y){\n    return x>=0 && x<m && y>=0 && y<n;\n}\n```\n\n有一点需要注意，这里不需要visit，因为有K的限制，不用担心死循环，感觉加了visit反而会错？\n\n**解法二**\n\n整体上来说还是属于比较简单的动态规划，至少递推方程好想\n\n```java\n//自底向上递推\npublic int findPaths(int m, int n, int N, int i, int j) {\n    int mod=(int)1e9+7;\n    //群里偷学到的\n    int[] dir={0,1,0,-1,0};\n    long[][][] dp=new long[m][n][N+1];\n    for (int k=1;k<=N;k++) { //想想K为什么在最外层\n        for (int r=0;r<m;r++) {\n            for (int c=0;c<n;c++) {\n                for (int d=0;d<4;d++) {\n                    int nx=r+dir[d];\n                    int ny=c+dir[d+1];\n                    if(nx<0 || ny<0 || nx>=m ||ny>=n){\n                        dp[r][c][k]++;\n                    }else{\n                        dp[r][c][k]=(dp[r][c][k]+dp[nx][ny][k-1])%mod;\n                    }\n                }\n                //提前结束，只需要i,j,N就行了(貌似没有快多少)\n                if(k==N && r==i && c==j){\n                    return (int)(dp[i][j][N]);\n                }\n            }\n        }\n    }\n    //return (int)(dp[m-1][n-1][N]); md一开始返回错了，看了半天\n    return 0;\n}\n```\nK放在最外层的原因其实很容易想到，我们求某一个点的时候，我们需要周围4个方向的`K-1`的值，这些值必须是已经计算过的，所以K肯定是要放在最外层的\n\n## [688. “马”在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)\n\n已知一个 `N`x`N` 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 `(0, 0)`，最右下角的记为 `(N-1, N-1)`。 \n\n现有一个 “马”（也译作 “骑士”）位于 `(r, c)` ，并打算进行 `K` 次移动。 \n\n如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。\n\n![YsAXFS.png](https://s1.ax1x.com/2020/05/15/YsAXFS.png) \n\n现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 `K` 次或跳到了棋盘外面。\n\n求移动结束后，“马” 仍留在棋盘上的概率。\n\n**示例：**\n\n```java\n输入: 3, 2, 0, 0\n输出: 0.0625\n解释: \n输入的数据依次为 N, K, r, c\n第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。\n所以 “马” 在结束后仍在棋盘上的概率为 0.0625。\n```\n\n**注意：**\n\n- `N` 的取值范围为 [1, 25]\n- `K` 的取值范围为 [0, 100]\n- 开始时，“马” 总是位于棋盘上\n\n**错误解法一**\n\n首先采用了和上一题类似做法，明显是不行的\n\n```java\n//小数据可以过，大数据过不了\n//K[0,100]直接8^100就爆了，所以肯定不能像上面那样求，dp得存概率\npublic double knightProbability(int N, int K, int r, int c) {\n    int[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n    int[][][] dp=new int[N][N][K+1];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            //这题如果反着求出界路径就错了，得正向求\n            dp[i][j][0]=1; \n        }\n    }\n    for(int k=1;k<=K;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                for(int d=0;d<dir.length;d++){\n                    int nx=i+dir[d][0];\n                    int ny=j+dir[d][1];\n                    if(nx>=0 && nx<N && ny>=0 && ny<N){\n                        dp[i][j][k]+=(dp[nx][ny][k-1]);\n                    }\n                }\n            }\n        }\n    }\n    return dp[r][c][K]/Math.pow(8,K);\n}\n```\n> 多说一点，这里为什么不和上面一样，算出界的路径数，然后用`8^K`减去出界数量，然后除以`8^K`？其实主要是出界的这里并不好算，这里要求的是概率，出界的路径并不能完全包含出界的方式（可以理解为出界后仍然可以走）\n\n**解法二**\n\n标准的dp解法，注意概率的计算就行了\n\n```java\n//DP存概率AC解法\npublic double knightProbability(int N, int K, int r, int c) {\n    int[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n    double[][][] dp=new double[N][N][K+1];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            dp[i][j][0]=1;\n        }\n    }\n    for(int k=1;k<=K;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                for(int d=0;d<dir.length;d++){\n                    int nx=i+dir[d][0];\n                    int ny=j+dir[d][1];\n                    if(nx>=0 && nx<N && ny>=0 && ny<N){\n                        //md，一开始不知道为啥想到求独立事件P(A U B)上去了\n                        //但是其实两者并不是独立事件，是互斥事件直接P(A)+P(B)就行了\n                        dp[i][j][k]+=(dp[nx][ny][k-1])/8;\n                    }\n                }\n                //提前返回\n                if(i==r && j==c && k==K){\n                    return dp[i][j][k];\n                }\n            }\n        }\n    }\n    return dp[r][c][K];\n}\n```\n\n**解法三**\n\n记忆化的方式，其实会比上面递推的会快一点，上面递推的会有很多无用状态\n\n```java\n//自顶向上\nDouble[][][] dp=null;\n\nint[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n\npublic double knightProbability(int N, int K, int r, int c) {\n    dp=new Double[N][N][K+1];\n    return dfs(N,K,r,c);\n}\n\npublic double dfs(int N,int k,int x,int y){\n    if(k==0) return 1.0;\n    if(dp[x][y][k]!=null){\n        return dp[x][y][k];\n    }\n    double p=0;\n    for (int i=0;i<dir.length;i++) {\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(nx>=0 && nx<N && ny>=0 && ny<N){\n            p+=dfs(N,k-1,nx,ny)/8;\n        }\n    }\n    return dp[x][y][k]=p;\n}\n```\n\n## [935. 骑士拨号器](https://leetcode-cn.com/problems/knight-dialer/)\n\n国际象棋中的骑士可以按下图所示进行移动：\n\n![YsAXFS.png](https://s1.ax1x.com/2020/05/15/YsAXFS.png) .         ![YcP3o8.png](https://s1.ax1x.com/2020/05/16/YcP3o8.png)\n\n\n这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。\n\n每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 `N` 位数字。\n\n你能用这种方式拨出多少个不同的号码？\n\n因为答案可能很大，**所以输出答案模 10^9 + 7**。\n\n**示例 1：**\n\n```java\n输入：1\n输出：10\n```\n\n**示例 2：**\n\n```java\n输入：2\n输出：20\n```\n\n**示例 3：**\n\n```java\n输入：3\n输出：46\n```\n\n**提示：**\n\n- `1 <= N <= 5000`\n\n**解法一**\n\n先上一个极其粗糙的解法，也是最开始的解法\n\n```java\nint[][] dir={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\n\nint mod=(int)1e9+7;\n\nInteger[][][] dp=null;\n\npublic int knightDialer(int N) {\n    int[][] grid={{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\n    int res=0;\n    dp=new Integer[4][3][N];\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]!=-1){\n                res=(res+dfs(grid,i,j,N-1))%mod;\n            }\n        }\n    }\n    return res;\n}\n\npublic int dfs(int[][] grid,int x,int y,int N){\n    if(N==0) return 1;\n    if(dp[x][y][N]!=null) return dp[x][y][N];\n    int res=0; //一开始赋值成1了。。从当前位置起跳，所以当前位置不应该有初始值\n    for(int i=0;i<dir.length;i++){\n        int nx=x+dir[i][0];\n        int ny=y+dir[i][1];\n        if(valid(grid,nx,ny)){\n            res=(res+dfs(grid,nx,ny,N-1))%mod;\n        }\n    }\n    return dp[x][y][N]=res;\n}\n\npublic boolean valid(int[][] grid,int x,int y){\n    return x>=0 && y>=0 && x<grid.length && y<grid[0].length && grid[x][y]!=-1;\n}\n```\n\n**解法二**\n\n小巧精致的解法\n\n```java\nint mod=(int)1e9+7;\n\nInteger[][] dp=null;\n\npublic int knightDialer(int N) {\n    //直接看图建立对应关系\n    int[][] next={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\n    int res=0;\n    dp=new Integer[10][N];\n    for(int i=0;i<=9;i++){\n        res=(res+dfs(i,N-1,next))%mod;\n    }\n    return res;\n}\n\npublic int dfs(int num,int N,int[][] next){\n    if(N==0) return 1;\n    if(dp[num][N]!=null) return dp[num][N];\n    int res=0; //注意别写成1了\n    for(int i=0;i<next[num].length;i++){\n        res=(res+dfs(next[num][i],N-1,next))%mod;\n    }\n    return dp[num][N]=res;\n}\n```\n\n**解法三**\n\n递推的方式\n\n```java\n//递推的方式\npublic int knightDialer(int N) {\n    //next[i]: i下一步能跳到的位置\n    int[][] next={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\n    int[][] dp=new int[N][10];\n    Arrays.fill(dp[0],1); //base dp[0]\n    int mod=(int)1e9+7;\n    int res=0;\n    for (int i=1;i<N;i++) {\n        for (int num=0;num<=9;num++) {\n            for (int j=0;j<next[num].length;j++) {\n                dp[i][num]=(dp[i][num]+dp[i-1][next[num][j]])%mod;   \n            }\n        }\n    }\n    for(int i=0;i<=9;i++) res=(res+dp[N-1][i])%mod;\n    return res;\n}\n```\n\n## [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)\n\n给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。\n\n**示例：**\n\n```java\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n```\n\n**说明:**\n\n- 你可以假设数组不可变。\n- 会多次调用 sumRange 方法。\n\n**解法一**\n\n这题其实一开始就是想的缓存一下之前调用产生的值，没有理解到这题的要点。\n\n```java\nclass NumArray {\n\n    private int[] sums=null;\n\n    public NumArray(int[] nums) {\n        if (nums!=null && nums.length>0) {\n            sums=new int[nums.length];\n            sums[0]=nums[0];\n            for (int i=1;i<sums.length;i++) {\n                sums[i]=sums[i-1]+nums[i];\n            }    \n        }\n        \n    }\n    \n    public int sumRange(int i, int j) {\n        if(i==0){\n            return sums[j];\n        }\n        return sums[j]-sums[i-1];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(i,j);\n */\n```\n\n这题关键有两个地方，一个是 `sumRange(i , j) = sumRange(0, j)-sumRange(0, i-1)` ，另一个关键就是在构造器里面将所有的 `sumRange(0 , i)` 给预先求出来，这样在后面的调用时时间复杂度就是`O(1)`的了。\n\n这里求`sumRange(0, i)`的过程就是一个很简单的dp.\n\n## [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)\n\n如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。\n\n例如，以下数列为等差数列:\n\n```java\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n```\n\n\n以下数列不是等差数列。\n\n```java\n1, 1, 2, 5, 7\n```\n\n\n数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。\n\n如果满足以下条件，则称子数组(P, Q)为等差数组：\n\n元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。\n\n函数要返回数组 A 中所有为等差数组的子数组个数。\n\n **示例:**\n\n```java\nA = [1, 2, 3, 4]\n\n返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。\n```\n\ndp的题啊，答案一看就明白，就是自己想不到。。。\n\n```java\npublic int numberOfArithmeticSlices(int[] A) {\n    if(A.length<3){\n        return 0;\n    }\n    //dp[i]=dp[i-1]+1;\n    int []dp=new int[A.length]; //以 A[i] 结尾的等差数列有多少个\n    for (int i=2;i<A.length;i++) {\n        if(A[i]-A[i-1]==A[i-1]-A[i-2]){\n            dp[i]=dp[i-1]+1;\n        }\n    }\n    int res=0;\n    for (int i=0;i<dp.length;i++) {\n        res+=dp[i];\n    }\n    return res;\n}\n```\n\n就是没想到要对以当前元素结尾的动态数组数量做dp，当然上面的做法的空间还可以优化成O(1)的\n\n```java\npublic int numberOfArithmeticSlices2(int[] A) {\n    if(A.length<3){\n        return 0;\n    }\n    //dp[i]=dp[i-1]+1;\n    int dp=0;\n    int res=0;\n    for (int i=2;i<A.length;i++) {\n        if(A[i]-A[i-1]==A[i-1]-A[i-2]){\n            dp=dp+1;\n            res+=dp;\n        }else{\n            dp=0;\n        }\n    }\n    return res;\n}\n```\n\n只需要根据上一次的dp值更新就行，如果break等差数列，就置为0\n\n------\n\n## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)\n\n给定一个正整数 n，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n\n**示例 1:**\n\n```java\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1。\n```\n\n**示例 2:**\n\n```java\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n```\n\n**说明:** 你可以假设 n 不小于 2 且不大于 58。\n\n**解法一**\n\n别问，问就是暴力\n\n![leetCode题解97wgl](http://static.imlgw.top/blog/20190822/BKqmfoXMVq3Q.png?imageslim)\n\n**递推式：** `F(n) = max {i * F(n - i)}，i = 1，2，...，n - 1`  \n\n穷举每一种分解情况，求最大值\n\n```java\npublic static int integerBreak(int n) {\n    //递归出口\n    if (n==2) {\n        return 1;\n    }\n    int res=-1;\n    for (int j=1;j<n;j++) {\n        //第一个Max求最大值，第二个Max主要是为了考虑 只分两个数就是最大值的情况（<=7的情况）\n        res=Math.max(res, Math.max((n-j)*j,integerBreak(n-j)*j));\n    }\n    return res;\n}\n```\n\n需要注意的就是第二个Max 别忘了**只分为两个数就到达最大值**的情况，比如n<=7的时候，`integerBreak(n-j)*j)`  至少是三个，下面的DP也是一样的要注意别忘了两个数的情况\n\n递归的时间复杂度应该是`O(N!)` ，后面的case会超时，其实很明显，递归过程中会有很多的重复计算所以可以采用记忆化递归缓存一下之前的值。\n\n```java\nprivate  Integer[] cache=null;\n//只顶向下,记忆化递归\npublic  int integerBreak(int n) {\n    cache=new Integer[n+1];\n    return breakInteger(n);\n}\npublic  int breakInteger(int n) {\n    if (cache[n]!=null) {\n        return cache[n];\n    }\n    //递归出口\n    if (n==2) {\n        return 1;\n    }\n    int res=-1;\n    for (int j=1;j<n;j++) {\n        res=Math.max(res, Math.max((n-j)*j,breakInteger(n-j)*j));\n    }\n    cache[n]=res;\n    return res;\n}\n```\n这样的解法是可以AC的，缓存之前计算的结果，避免了重复的计算\n\n**解法二**\n\n动态规划，结合上面的递归得到`递推方程`\n\n`dp[i] = max(dp[i]，max(dp[ i-j ] * j ，(i-j) * j));`\n\n```java\npublic static int integerBreak2(int n) {\n    if (n==2) {\n        return 1;\n    }\n    int [] dp=new int[n+1];\n    dp[2]=1; //0,1不考虑\n    for (int i=3;i<=n;i++) {\n        for (int j=1;j<i;j++) {\n            dp[i]=Math.max(dp[i],Math.max(dp[i-j]*j,(i-j)*j));\n        }\n    }\n    return dp[n];\n}\n```\n**解法三**\n\n打板找规律，笔试的时候能直接一眼看出来规律的肯定优先找规律了\n\n```java\npublic static int integerBreak3(int n) {\n    int[] base={1,2,4,6,9,12};\n    if(n<=7){\n        return base[n-2];\n    }\n    int[] dp=new int[n+1];\n    dp[2]=base[0];\n    dp[3]=base[1];\n    dp[4]=base[2];\n    dp[5]=base[3];\n    dp[6]=base[4];\n    dp[7]=base[5];\n    for (int i=8;i<=n;i++) {\n        dp[i]=dp[i-3]*3; //N>7之后 dp[N]=dp[N-3]*3\n    }\n    return dp[n];\n}\n```\n\n**解法四**\n\n数学分析，其实分析一下会发现，只有2和3是分解后值比**本身还要小**的，4分解后相等，这样一分析，从整体上来看其实就清楚了，只要分到2或者3的时候就不再分就行了，此时的值一定是最大值，如果2，3继续分值就会减小\n\n```java\npublic int integerBreak(int n) {\n    int[] base={1,2,4};\n    if(n<=4){\n        return base[n-2];\n    }\n    int res=1;\n    while(n>=5){\n        res*=3;\n        n-=3;\n    }\n    res*=n;\n    return res;\n}\n```\n\n取模写法，这里其实涉及到取模的一个规则，`(a*b)%mod=(a%mid * b%mid) % mod` \n\n```java\npublic int cuttingRope(int n) {\n    if(n<=3) return n-1;\n    long res=1;\n    while(n>=5){\n        n-=3;\n        res=(res*3)%1000000007;\n    }\n    return (int)(res*n%1000000007);\n}\n```\n\n## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n**示例 1:**\n\n```java\n输入: n = 12\n输出: 3 \n解释: 12 = 4 + 4 + 4.\n```\n\n**示例 2:**\n\n```java\n输入: n = 13\n输出: 2\n解释: 13 = 4 + 9.\n```\n\n**解法一**\n\n动态规划，不容易啊，自己推出了DP方程，没看答案，其实也借鉴了上一题的思路\n\n`dp[i] =min(dp[i]，dp[i-j*j]+1)` \n\n其实也是将整数拆分，不过拆分的时候按照 **完全平方数** 来拆分，完全平方数的肯定是 1所以最后要加个 1\n\n```java\npublic static int numSquares(int n) {\n    int[] dp=new int[n+1];\n    dp[0]=0;\n    for (int i=1;i<=n;i++) {\n        dp[i]=Integer.MAX_VALUE; //dp[i]初始化\n        for (int j=1;i>=j*j;++j){\n            dp[i]=Math.min(dp[i],dp[i-j*j]+1);\n        }\n    }\n    return dp[n];\n}\n```\n50%左右，看了下时间复杂度应该是 `O(N^1.5)`  还是挺高的（评论区用Py的都超时了）\n\n**解法二**\n\nBFS，将数字按照完全平方数连接为一个图，然后BFS求一个从n到0的最短的路径\n\n```java\npublic static int numSquares(int n) {\n    Queue<Pair> queue=new LinkedList<>();\n    boolean[] visit=new boolean[n+1];\n    queue.add(new Pair(n,0));\n    visit[n]=true;\n    while(!queue.isEmpty()){\n        Pair pair=queue.poll();\n        int num=pair.num;\n        int step=pair.step;\n        if (num==0) {\n            return step;\n        }\n        for (int i=1;i*i<=num;i++) {\n            int temp=num-i*i;\n            if (!visit[temp]) {\n                queue.add(new Pair(temp,step+1));\n                visit[temp]=true;\n            }\n        }\n    }\n    return -1;\n}\n\nstatic class Pair{\n    public int step;\n    public int num;\n    public Pair(int num,int step){\n        this.num=num;\n        this.step=step;\n    }\n}\n```\n\n这题最快的做法应该是利用 **四平方和定理** 我也不太清楚，所以暂时先不研究这种做法\n\n## [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)\n\n一条包含字母 A-Z 的消息通过以下方式进行了编码：\n\n```java\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n```\n\n\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n\n**示例 1:**\n\n```java\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n```\n\n**示例 2:**\n\n```java\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n```\n\n**解法一**\n\n哇，这题我吐了，好不容易看出来了递推公式，被边界给整死了。。。面向测试用例编程。。\n\n```java\npublic static int numDecodings(String s) {\n    if (s.startsWith(\"0\")) {\n        return 0;\n    }\n    int[] s_nums=new int[s.length()];\n    for (int i=0;i<s.length();i++) {\n        s_nums[i]=Integer.valueOf(s.charAt(i)-48);\n    }\n\n    int[] dp =new int[s_nums.length];\n    Arrays.fill(dp,1);\n    dp[0]=1;\n    int res=1;\n    for (int j=1;j<s_nums.length;j++) {\n        if(s_nums[j]==0 && s_nums[j-1]==0 || (s_nums[j]==0 && s_nums[j-1]>2)){\n            //直接return\n            return 0;\n        }\n        if( s_nums[j]==0 || s_nums[j-1]==0 || (j<s_nums.length-1 &&s_nums[j+1]==0)){\n            //为了处理 12120这种情况\n            res*=dp[j-1];\n            continue;\n        }\n        if(s_nums[j-1]*10+s_nums[j]<=26){\n            if(j==1){\n                dp[j]=2;\n            }else{\n                dp[j]=dp[j-1]+dp[j-2];    \n            }\n        }else{\n            //划分点。。。\n            res*=dp[j-1];\n            dp[j-1]=1;\n            dp[j]=1;\n        }\n    }\n    //最后一段\n    res*=dp[s_nums.length-1];\n    return res;\n}\n```\n\n首先要推出这题的递推公式，我也是在纸上画了半天才看出来，如果这个数组前后两个元素之和都是小于26的那么这一段的编码方式就是一个**斐波拉契数列** ，也就是 `dp[i]=dp[i-1]+dp[i-2]`\n\n80%左右，这题其实一开始并不是这样做的，我觉得我开始的思路还是挺好的，将字符串分段，当前一个和后一个无法合并的时候就作为一个分界点，最后将每一段的编码方式相乘就是结果了。\n\n但是 ！！！ 我忽略了0这个东西了，这题后面给的case里面都是带有0的！！！！处理这个边界处理了一上午终于跑过了。。。代码也没什么好说的，写的太烂了，这种代码没啥意义，都是走一步看一步。\n\n**解法二**\n\n```java\npublic static int numDecodings2(String s) {\n    if (s.startsWith(\"0\")) {\n        return 0;\n    }\n    int[] s_nums=new int[s.length()];\n    for (int i=0;i<s.length();i++) {\n        s_nums[i]=Integer.valueOf(s.charAt(i)-48);\n    }\n    int[] dp=new int[s.length()+1];\n    dp[0]=1;\n    dp[1]=1;\n    for (int i=2;i<=s.length();i++) {\n        int a=s_nums[i-1];\n        if(a!=0){\n            //到这里dp[i]==0,没有初始化,默认就是0\n            //其实等价于dp[i]=dp[i-1],延续前一个字符的状态\n            dp[i]+=dp[i-1];\n        }\n\n        if(s_nums[i-2]==0){\n            //如果前前一个字符为0那么就不用dp了,保持i-1的状态就OK\n            continue;\n        }\n\n        //前前一个字符和\n        int b=s_nums[i-2]*10+s_nums[i-1];\n        if(b<=26){\n            dp[i]+=dp[i-2]; //上下这两个dp必须执行一个否则最后就 return 0\n        }\n    }\n    return dp[s_nums.length];\n}\n```\n\n这种写法就清晰多了，分析各种情况，dp代表截至字符的编码方式\n\n💬  `s_num[i-1]!=0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] <=26`  \n\n类似于 **112**  这样的，这就是正常dp的情况符合斐波拉契数列\n\n💬  `s_num[i-1]==0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] <=26`\n\n类似于 **102** 这样的，这样就直接`继承 dp[i-2]的状态`就行了，相当于`dp[i]=dp[i-2]`\n\n💬  `s_num[i-1]!=0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] >26`\n\n类似于 **132** 这样的，这样就直接`继承 dp[i-2]的状态`就行了，相当于`dp[i]=dp[i-2]`\n\n💬 `s_num[i-1]!=0 && s_num[i-2]==0 && s_num[i-2]+s_num[i-1] <=26`\n\n类似于 **...012**这样的，`dp[i]=dp[i-1]`\n\n💬 `s_num[i-1]==0 && s_num[i-2]==0` 或者`s_num[i-1]==0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1]>26`\n\n类似于**00** 和**30** 这样的， 这样就代表这个字符串无法编码了 **dp[i]=0** 最后返回的就是0\n\n## [面试题46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)\n\n给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n\n**示例 1:**\n\n```java\n输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\"\n```\n\n**提示：**\n\n- `0 <= num < 231`\n\n**解法一**\n\n代码比较丑，逻辑还是比较清晰，其实这题算是上面 [91. 解码方法](#91-解码方法)的弱化没有了0的限制，0是合法的数字，这样就舒服多了，上面解码方法确实做的脑壳疼\n\n```java\npublic int translateNum(int num) {\n    String s=String.valueOf(num);\n    int len=s.length();\n    if(len==0 || len==1) return 1;\n    int[] dp=new int[len];\n    //1 2 2 5 8\n    //1 2 3 5 5\n    dp[0]=1;\n    dp[1]=Integer.valueOf(s.substring(0,2))>25?1:2;\n    for(int i=2;i<len;i++){\n        int pre=Integer.valueOf(s.charAt(i-1))-48;\n        int cur=Integer.valueOf(s.charAt(i))-48;\n        if(pre!=0 && Integer.valueOf(pre*10+cur)<=25){\n            dp[i]=dp[i-1]+dp[i-2];\n        }else{\n            dp[i]=dp[i-1];\n        }\n    }\n    return dp[len-1];\n}\n```\n\n## [5375. 恢复数组](https://leetcode-cn.com/problems/restore-the-array/)\n\n某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。\n\n给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。\n\n按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。\n\n由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。\n\n**示例 1：**\n\n```java\n输入：s = \"1000\", k = 10000\n输出：1\n解释：唯一一种可能的数组方案是 [1000]\n```\n\n**示例 2：**\n\n```java\n输入：s = \"1000\", k = 10\n输出：0\n解释：不存在任何数组方案满足所有整数都 >= 1 且 <= 10 同时输出结果为 s 。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"1317\", k = 2000\n输出：8\n解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]\n```\n\n\n**示例 4：**\n\n```java\n输入：s = \"2020\", k = 30\n输出：1\n解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 > 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。\n```\n\n\n**示例 5：**\n\n```java\n输入：s = \"1234567890\", k = 90\n输出：34\n```\n\n**提示：**\n\n- 1 <= s.length <= 10^5.\n- s 只包含数字且不包含前导 0 。\n- 1 <= k <= 10^9.\n\n**解法一**\n\n24th双周赛的T4，其实dp的状态转换还是想出来了，我想的是从左向右，但是细节没理清楚，瞄了一眼评论区，发现从右往左比较简单\n\n```java\npublic int numberOfArrays(String s, int k) {\n    int mod=1_000_000_000 + 7;\n    int[] dp=new int[s.length()+1];        \n    dp[0]=1;\n    //dp[i]=dp[i-1]+dp[i-2]+...+dp[0];\n    for (int i=1;i<=s.length();i++) {\n        for (int j=i-1;j>=0 && i-j<=9;j--) {\n            if(s.charAt(j)!='0' && valid(s,j,i,k)){ //验证右边是否满足\n                dp[i]=(dp[i]+dp[j])%mod;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n\n//10 0000 0000\npublic boolean valid(String s,int j,int i,int k){\n    long value=Long.valueOf(s.substring(j,i));\n    return value<=k && value>=1;\n}\n```\n我开始以为时间复杂度是`O(N^2)`会T掉，后来写出来才发现其实时间复杂度其实是`O(10N)` ，并不难，还是题目写少了啊！！！\n\n**解法二**\n\n一点小优化\n\n```java\npublic int numberOfArrays(String s, int k) {\n    int mod=1_000_000_000 + 7;\n    int[] dp=new int[s.length()+1];        \n    dp[0]=1;\n    for (int i=1;i<=s.length();i++) {\n        for (int j=i-1;j>=0 && i-j<=9;j--) {\n            if(s.charAt(j)=='0') continue;\n            long value=Long.valueOf(s.substring(j,i));\n            if(value>k) break; //这一步其实是对上面解法的优化\n            dp[i]=(dp[i]+dp[j])%mod;\n        }\n    }\n    return dp[s.length()];\n}\n```\n## [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n**示例:**\n\n```java\n输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n```\n\n**说明:**\n\n- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n- 你算法的时间复杂度应该为 O(n2) 。\n- 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?\n\n**解法一**\n\nLIS，这题好像在很多地方见到过了，还是要好好理解下，**dp[i]表示以当前元素结尾的最长上升子序列的长度**\n\n```java\npublic static int lengthOfLIS(int[] nums) {\n    if (nums==null||nums.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[nums.length];\n    //Arrays.fill(dp,1);\n    dp[0]=1;\n    for (int i=1;i<nums.length;i++) {\n        dp[i]=1; //初始化dp[i]=1\n        for (int j=0;j<i;j++) {\n            if(nums[i]>nums[j]){\n                //遍历i之前的元素,找一个最大的dp[j]+1\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n    }\n    int res=-1;\n    for (int i=0;i<dp.length;i++) {\n        res=res>dp[i]?res:dp[i];\n    }\n    return res;\n}\n```\n\n一开始题目就没看清楚就开始做，以为是连续的，心想这不是O(N)的么，为啥要我写O(N^2)的🤣 \n\n![mark](http://static.imlgw.top/blog/20190824/86VLMN8VWcpI.png?imageslim)\n\n灵魂画手，其实也是一道很简单的DP(然而我还是没想出来)，但是时间复杂度比较高O(N^2)，可以优化成O(NlogN)\n\n**解法二**\n\n`贪心+二分`  这个贪心还是有点骚的，核心思想：\n\n**如果前面的数越小，后面接上一个随机数，就会有更大的可能性构成一个更长的“上升子序列”。**\n\n定义`tail`数组，`tail[i]`中存储长度为 `i + 1` 的最长递增子序列的最后一个元素，所以我们要做的就是维护tail数组，使得各个长度的`tail[i]`的尽可能地小，这样后面能接的长度就越长，很明显tail是个单调递增的数组（反证）所以我们可以在遍历nums的时候在tail数组中二分寻找第一个大于nums[i]的元素，用nums[i]替换该位置的元素，这样就使得`tail[i]`是当前nums[i]之前，长度为i+1的递增序列最小的结尾元素，当我们遍历完所有的元素，tail数组的长度就是我们要求的最长递增子序列长度（注意tail不一定是合法的最长递增子序列，如果要求出子序列可以在长度增加的时候拷贝一份长度为`i-1`的数组，然后再操作）\n\n2020.3.20\n\n```java\npublic static int lengthOfLIS(int[] nums) {\n    int[] top = new int[nums.length];\n    int len = 0;\n    for (int num : nums) {\n        //寻找左侧最小的堆顶\n        int index=binarySearch(top,len,num);\n        if (index == len) {\n            len++;\n        }\n        top[index] = num;\n    }\n    return len;\n}\n\n//可以搜索\nprivate static int binarySearch(int[] nums, int len, int target) {\n    int left=0,right=len;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]<target){\n            left=mid+1;\n        }else {\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n首先是记住了这个套路，然后优化了二分的写法\n\n![mark](http://static.imlgw.top/blog/20200320/zhcxcxmK4Amt.png?imageslim)\n\n\n（copy自从liweiwei大佬 [题解](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/)）\n\n## [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)\n\n给定一个未排序的整数数组，找到最长递增子序列的个数。\n\n**示例 1:**\n\n```java\n输入: [1,3,5,4,7]\n输出: 2\n解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。\n```\n\n**示例 2:**\n\n```java\n输入: [2,2,2,2,2]\n输出: 5\n解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。\n```\n\n**注意:** 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。\n\n**解法一**\n\n一开始还没想到，属实菜鸡\n\n```java\npublic int findNumberOfLIS(int[] nums) {\n    int n=nums.length;\n    //dp[i][0]结尾的最长递增子序列,dp[i][1]代表个数\n    int[][] dp=new int[n][2];\n    int max=0;\n    for(int i=0;i<n;i++){\n        dp[i][1]=1;\n        for(int j=0;j<i;j++){\n            if(nums[i]>nums[j]){\n                if(dp[j][0]+1==dp[i][0]){\n                    dp[i][1]+=dp[j][1];\n                }else if(dp[j][0]+1>dp[i][0]){\n                    dp[i][1]=dp[j][1];\n                    dp[i][0]=dp[j][0]+1;\n                }\n            }\n        }\n        max=Math.max(max,dp[i][0]);\n    }\n    int res=0;\n    for(int i=0;i<nums.length;i++) {\n        res+=dp[i][0]==max?dp[i][1]:0;   \n    }\n    return res;\n}\n```\n\n\n## [1016. 使序列递增的最小交换次数（LintCode）](https://www.lintcode.com/problem/minimum-swaps-to-make-sequences-increasing/description)\n\n\n有两个具有相同非零长度的整数序列A和B。可以交换它们的一些元素A[i]和B[i]。 注意，两个可交换的元素在它们各自的序列中处于相同的索引位置。进行一些交换之后，A和B需要严格递增。 （当且仅当A[0] < A[1] < A[2] < ... < A[A.length - 1]时，序列严格递增。）\n\n给定A和B，返回使两个序列严格递增的最小交换次数。 保证给定的输入经过交换可以满足递增的条件。\n\n**注意**\n- A, B 是长度相同的数组, 它们的长度范围为 [1, 1000]。\n- A[i], B[i] 是在 [0, 2000]范围内的整数。\n\n**样例 1**\n```go\n输入: A = [1,3,5,4], B = [1,2,3,7]\n输出: 1\n解释: 交换A[3] and B[3]. 两个序列变为:\n  A = [1,3,5,7] 和 B = [1,2,3,4],\n  此时它们都是严格递增的。\n```\n**样例 2:**\n```go\n输入: A = [2,4,5,7,10], B = [1,3,4,5,9]\n输出: 0\n```\n\n**解法一**\n\n直接抄答案，很巧妙的双序列型dp，不看答案真想不出来\n```java\npublic int minSwap(int[] A, int[] B) {\n    if (A == null || B == null || A.length <=0 || B.length <= 0){\n        return 0;\n    }\n    // Write your code here\n    int n = A.length;\n    int INF = 0x3f3f3f3f;\n    //dp[i][0]: A和B前i个字符都保持有序，并且不交换第i个元素的最小交换次数\n    //dp[i][1]: A和B前i个字符都保持有序，并且交换第i个元素的最小交换次数\n    int[][] dp = new int[n][2];\n    for(int i = 0; i < n; i++){\n        Arrays.fill(dp[i], INF);\n    }\n    dp[0][0] = 0; dp[0][1] = 1;\n    for(int i = 1; i < n; i++){\n        //很巧妙的分类讨论\n        if(A[i] > A[i-1] && B[i] > B[i-1]){\n            //前后都不交换\n            dp[i][0] = dp[i-1][0];\n            //前后都交换\n            dp[i][1] = dp[i-1][1]+1; \n        }\n        if(A[i] > B[i-1] && B[i] > A[i-1]){\n            //当前不交换，交换前面的\n            dp[i][0] = Math.min(dp[i][0], dp[i-1][1]);\n            //当前交换，前面不交换\n            dp[i][1] = Math.min(dp[i][1], dp[i-1][0]+1);\n        }\n    }\n    int res = Math.min(dp[n-1][0],dp[n-1][1]);\n    return  res == INF ? 0 : res;\n}\n```\n\n## [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)\n\n给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 `(w, h)` 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。\n\n请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。\n\n**说明:**\n不允许旋转信封。\n\n**示例:**\n\n```java\n输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n输出: 3 \n解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。\n```\n\n**解法一**\n\n```java\npublic int maxEnvelopes(int[][] envelopes) {\n    int [] dp=new int[envelopes.length];\n    //lamdba会比较慢\n    Arrays.sort(envelopes,(a,b)->(a[0]-b[0])); //保证后面的不会被前面的装进去就行了\n    int res=0;\n    for (int i=0;i<envelopes.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if (envelopes[i][0]>envelopes[j][0] && envelopes[i][1]>envelopes[j][1]){\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n        res=Math.max(res,dp[i]);\n    }\n    return res;\n}\n```\n其实和上面的LIS是一样的，所以我放在了一起，差点bugfree，被空输入坑了一发，可惜这个解法并不是最优解，而且也不符合这题的困难tag，这题的最优解应该是利用上面的贪心+二分的做法，这里实在是能力时间都有限，没法去研究那种解法，暂且先用这个解法吧\n\n**解法二**\n\n2020.3.20 阿里笔试考了这一题，dp超时了。。。。\n\n```java\npublic int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes,(a,b)->a[0]!=b[0]?a[0]-b[0]:b[1]-a[1]); //这个排序很关键\n    int N=envelopes.length;\n    int[] top=new int[N];\n    int len=0;\n    for(int i=0;i<N;i++){\n        int cur=envelopes[i][1];\n        //二分搜索堆顶，找第一个小于当前牌的\n        int index=binarySearch(top,cur,len);\n        if(index==len){ //没找到合适的位置\n            len++; //新建牌堆，牌堆++\n        }\n        top[index]=cur;\n    }\n    return len;\n}\n\npublic int binarySearch(int[] top,int target,int len){\n    int left=0,right=len;\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(top[mid]<target){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return left;\n}\n```\n\n第一步的排序很关键，如果只按照宽度排好序之后，对高度求一次最长递增子序列就是我们的答案，但是有一个问题就是题目说了：宽度和高度都比当前信封大的时候才能装进去，如果有两个信封是`(1,3) (1,5)`那么前者是不能被后者装进去的，所以我们需要在这里做一下处理，在宽度相同的时候，让高度降序排列，这样在对高度求最递增子序列的时候就不会出现错误了\n\n**UPDATE: 2020.7.13**\n```golang\nfunc maxEnvelopes(env [][]int) int {\n    sort.Slice(env, func(i int, j int) bool {\n        if env[i][0] == env[j][0]{\n            return env[i][1] > env[j][1]\n        }\n        return env[i][0] < env[j][0]\n    })\n    var tail = make([]int, len(env))\n    var tlen = 0\n    for i := 0; i < len(env); i++{\n        idx := search(tail, env[i][1], tlen)\n        if idx == tlen{\n            tlen++\n        }\n        tail[idx] = env[i][1]\n    }\n    return tlen\n}\n\nfunc search(nums []int, target int, tlen int) int {\n    var left = 0\n    var right = tlen-1\n    var res = tlen\n    for left <= right{\n        mid := left+(right-left)/2\n        if nums[mid] >= target{\n            res = mid\n            right = mid - 1\n        }else{\n            left = mid + 1\n        }\n    }\n    return res\n}\n```\n\n## [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n\n给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**示例:**\n\n```java\n输入: [-2,1,-3,4,-1,2,1,-5,4],\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n**进阶:**\n\n如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。\n\n**解法一**\n\n动态规划递推的解法，没啥好说的，这题其实还有一道姊妹题，要求出最大子序列，不仅仅是最大值，[我放到了滑动窗口专题中]((http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou-tag/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC)) \n\n```java\n//这次是直接在Web上写的\npublic int maxSubArray(int[] nums) {\n    if(nums==null || nums.length==0){\n        return 0;\n    }\n    int[] dp=new int[nums.length];\n    //一开始没处理好Wa了一发\n    int max=dp[0]=nums[0];\n    for(int i=1;i<nums.length;i++){\n        if(dp[i-1]<=0){\n            dp[i]=nums[i];\n        }else{\n            dp[i]=dp[i-1]+nums[i];\n        }\n        max=Math.max(max,dp[i]);\n    }\n    return max;\n}\n```\n**解法二**\n\n根据二维改一维\n\n```java\npublic int maxSubArray(int[] nums) {\n    if(nums==null || nums.length==0){\n        return 0;\n    }\n    int dp1=nums[0],dp2=0,max=nums[0];\n    for (int i=1;i<nums.length;i++) {\n        if (dp1<=0) {\n            dp2=nums[i];\n        }else{\n            dp2=dp1+nums[i];\n        }\n        dp1=dp2;\n        max=Math.max(max,dp2);\n    }\n    return max;\n}\n```\n\n感觉一维的不用去理解含义，能根据二维改出来就ok了，重点是理解多维的\n\n## [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)\n\n给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。\n\n现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。\n\n给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。\n\n**示例 :**\n\n```java\n输入: [[1,2], [2,3], [3,4]]\n输出: 2\n解释: 最长的数对链是 [1,2] -> [3,4]\n```\n\n**注意：**\n\n- 给出数对的个数在 [1, 1000] 范围内。\n\n**解法一**\n\n动态规划\n\n```java\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs,(a,b)->a[0]-b[0]);\n    int[] dp=new int[pairs.length];\n    int res=0;\n    for (int i=0;i<pairs.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if (pairs[i][0]>pairs[j][1]) {\n                dp[i]=Math.max(dp[i],dp[j]+1);\n            }\n        }\n        res=res>dp[i]?res:dp[i];\n    }\n    return res;\n}\n```\n注意这里没有要求顺序，所以先给他排个序，然后再进行DP，如果不排序很难dp，dp[i]表示当前数对能构成的最长链，dp过程和上面的最长上升子序列相同\n\n**解法二**\n\n贪心，也是最优解，同样先排序，不过是按照第二个元素来排序，核心思想\n\n`每次都在列表中找第二个元素最小的数对依次组成链，最后得到的一定是最长的链`\n\n```java\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs,(a,b)->a[1]-b[1]);\n    int res=1;\n    int tail=pairs[0][1];\n    for (int i=1;i<pairs.length;i++) {\n        if (pairs[i][0]>tail) {\n            res++;\n            tail=pairs[i][1];\n        }\n    }\n    return res;\n}\n```\n**解法三**\n\n也就是上面说的分治法，分治法在这里并不是最优解，时间复杂度`O(NlogN)`，但是思路还是很巧妙，首先也是讲数组一分为二，然后最大序列和就有三种情况\t\n\n1. 全在左边\n2. 全在右边\n3. 跨中点，两边都有\n\n然后统计三个值得最大值，递归子过程求解，代码就不写了，后面想起来有时间再补\n\n## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n\n例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n\n**示例 1:**\n\n```java\n输入: [1,7,4,9,2,5]\n输出: 6 \n解释: 整个序列均为摆动序列。\n```\n\n**示例 2:**\n\n```java\n输入: [1,17,5,10,13,15,10,5,16,8]\n输出: 7\n解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。\n```\n\n**示例 3:**\n\n```java\n输入: [1,2,3,4,5,6,7,8,9]\n输出: 2\n```\n\n**进阶:**\n\n- 你能否用 O(n) 时间复杂度完成此题?\n\n**解法一**\n\nO(N^2 )动态规划，dp[i]代表目前为止以 nums[i]结尾的最长的`上升摇摆序列`，down[i]代表目前为止以nums[i]结尾的最长的`下降摇摆序列`，后面过程就和上面的`LIS`的解法类似了\n\n```java\npublic int wiggleMaxLength(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int []up=new int[nums.length]; \n    int []down=new int[nums.length]; \n    for (int i=0;i<nums.length;i++) {\n        up[i]=1; down[i]=1; //初始化\n        for (int j=0;j<i;j++) {\n            if(nums[i]>nums[j]){\n                //找一个最大的下降沿\n                up[i]=Math.max(up[i],down[j]+1);\n            }else if(nums[i]<nums[j]){\n                //找一个最大的上升沿\n                down[i]=Math.max(down[i],up[j]+1);\n            }\n        }\n    }\n    return Math.max(up[nums.length-1],down[nums.length-1]);\n}\n```\n**解法二**\n\n线性动态规划，其实上面的循环找最大操作有点多余，如果`nums[i]>nums[i-1]` 那么以nums[i]为上升沿结尾（摆动上升）的最长摇摆序列 `up[i]=down[i-1]+1`\n\n```java\npublic int wiggleMaxLength2(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int []up=new int[nums.length];\n    int []down=new int[nums.length];\n    up[0]=down[0]=1;\n    for (int i=1;i<nums.length;i++) {\n        if(nums[i]>nums[i-1]){\n            up[i]=down[i-1]+1;\n            down[i]=down[i-1];\n        }else if(nums[i]<nums[i-1]){\n            down[i]=up[i-1]+1;\n            up[i]=up[i-1];\n        }else{\n            //相等的时候别忘了继承前面的状态\n            down[i]=down[i-1];\n            up[i]=up[i-1];\n        }\n    }\n    return Math.max(up[nums.length-1],down[nums.length-1]);\n}\n```\n\n我感觉能写出O(1)的前提是先写出O(N)的，写出O(N)的之后再改成O(1)会比较简单\n\n```java\npublic int wiggleMaxLength(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int up=1;\n    int down=1;\n    for (int i=1;i<nums.length;i++) {\n        if (nums[i]>nums[i-1]) {\n            up=down+1;\n        }else if (nums[i]>nums[i-1]){\n            down=up+1;\n        }//else就是不变\n    }\n    return Math.max(up,down);\n}\n```\n\n## [978. 最长湍流子数组](https://leetcode-cn.com/problems/longest-turbulent-subarray/)\n\n当 `A` 的子数组 `A[i], A[i+1], ..., A[j]` 满足下列条件时，我们称其为*湍流子数组*：\n\n- 若 `i <= k < j`，当 `k` 为奇数时， `A[k] > A[k+1]`，且当 `k` 为偶数时，`A[k] < A[k+1]`；\n- **或** 若 `i <= k < j`，当 `k` 为偶数时，`A[k] > A[k+1]` ，且当 `k` 为奇数时， `A[k] < A[k+1]`。\n\n也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。（上面的是废话）\n\n返回 `A` 的最大湍流子数组的**长度**。\n\n**示例 1：**\n\n```java\n输入：[9,4,2,10,7,8,8,1,9]\n输出：5\n解释：(A[1] > A[2] < A[3] > A[4] < A[5])\n```\n\n**示例 2：**\n\n```java\n输入：[4,8,12,16]\n输出：2\n```\n\n**示例 3：**\n\n```java\n输入：[100]\n输出：1\n```\n\n**提示：**\n\n1. `1 <= A.length <= 40000`\n2. `0 <= A[i] <= 10^9`\n\n**解法一**\n\n在滑窗tag里发现的，一直没往dp上想，看了评论区才发现😂，这题其实是上面[376. 摆动序列](#376-摆动序列)的弱化，这里是要求连续的，但是做法还是一样的\n\n```java\n//动态规划，从滑窗tag过来的...没往dp上想，看了评论区才想起来\npublic int maxTurbulenceSize(int[] A) {\n    if(A==null || A.length<=0){\n        return 0;\n    }\n    int up=1,down=1;\n    int res=1;\n    for (int i=1;i<A.length;i++) {\n        if(A[i]>A[i-1]){\n            up=down+1;\n            down=1;\n        }else if (A[i]<A[i-1]){\n            down=up+1;\n            up=1;\n        }else{\n            up=1;down=1;\n        }\n        res=Math.max(res,Math.max(up,down));\n    }\n    return res;\n}\n```\n\n**解法二**\n\n滑窗，也是一开始的做法，比较简单\n\n```java\n//优化if条件\npublic int maxTurbulenceSize(int[] A) {\n    if(A==null || A.length<=0){\n        return 0;\n    }\n    int left=0;\n    int res=1;\n    for(int right=left+1;right<A.length;right++){\n        if(A[right]==A[right-1]){ //跳过相等的\n            left=right;\n            continue;\n        }\n        //优化了if条件，之前看别人题解学到的\n        if(right>=2 && (A[right]>A[right-1])==(A[right-1]>A[right-2])){\n            left=right-1; //left跳到中间值\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n## [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)\n\nGiven *n*, how many structurally unique **BST's** (binary search trees) that store values 1 ... *n*?\n\n**Example:**\n\n```java\nInput: 3\nOutput: 5\nExplanation:\nGiven n = 3, there are a total of 5 unique BST's:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n**解法一**\n\n这个解法实际上来自 [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n```java\npublic static int numTrees(int n) {\n    return generateTree(1,n).size();\n}\n\npublic static List<TreeNode> generateTree(int start,int end){\n    List<TreeNode> res=new ArrayList<>();\n    if (start>end) {\n        res.add(null);\n        return res;\n    }\n    for (int i=start;i<=end;i++) {\n        List<TreeNode> left=generateTree(start,i-1);\n        List<TreeNode> right=generateTree(i+1,end);\n        for (TreeNode l:left) {\n            for (TreeNode r:right) {\n                TreeNode currentNode=new TreeNode(i);\n                currentNode.left=l;\n                currentNode.right=r;\n                res.add(currentNode);\n            }\n        }\n    }\n    return res;\n}\n```\n这种写法很明显过不了这题，时间复杂度太高了，但是这个方法可以求出所有的BST集合。\n\n**解法二**\n\n动态规划，`dp[i]`代表长度为 `i` 的递增序列构成的不同的BST的数量（序列从`1 到 i` 递增）\n\n递推公式: `dp[i]=dp[i-1]* dp[n-i]`\n\n```java\npublic int numTrees(int n) {\n    if (n<=1) {\n        return 1;\n    }\n    int []dp=new int[n+1];\n    dp[0]=1;\n    dp[1]=1;\n    for (int i=2;i<=n;i++) { //控制序列长度 直到我们求得 n\n        for (int j=1;j<=i;j++) { //控制根的选择\n            //累加和，j为根节点 dp[j-1]代表左子树数量，dp[i-j]代表右子树数量\n            dp[i]+=dp[j-1]*dp[i-j];\n        }\n    }\n    return dp[n];\n}\n```\n\n以 `i` 位置元素为根节点，可以得出可能的 BST数量为，`[1 ~ i-1]` 可以构成的BST数量 乘以  `[i+1，n]`可以构成的BST数量，也就是_左子树  *  右子树_  ，再推广到整个序列的BST总数，其实也就是 **以每个元素为根节点构成的BST的数量之和** ，需要理解的地方就是`dp[i]` 的含义，明确本题中`dp[i]` 其实**只和长度 `i`有关**而和内容无关，比如1，2，3和4，5，6所能构成的BST数量其实是相同的\n\n**解法三**\n\n卡塔兰数，递推式 `Gn+1 =2(2n+1)/ n+2  *  Gn`\n\n```java\npublic int numTrees3(int n) {\n    long C = 1;\n    for(int i = 0; i < n; ++i){\n        C = C * 2 * (2 * i + 1) /(i + 2);\n    }\n    return (int) C;\n}\n```\n\n\n## [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n```java\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\n\n自顶向下的最小路径和为 `11`（即，2 + 3 + 5 + 1 = 11）。\n\n**说明：**\n\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分\n\n**解法一**\n\n二维dp，emmm，一开始写成贪心了。。贪心明显是错的\n\n```java\n//dp做法 O(N^2)空间\npublic int minimumTotal(List<List<Integer>> triangle) {\n    int rows=triangle.size();\n    //dp[i][j]代表的是每i层第j个元素到最底层的最短距离\n    int[][] dp=new int[rows+1][rows+1]; //row+1\n    /*for (int i=0;i<triangle.get(rows-1).size();i++) {\n        //给最后一行赋初始值\n        dp[rows-1][i]=triangle.get(rows-1).get(i);\n    }\n    for (int i=rows-2;i>=0;i--) {\n        for (int j=0;j<triangle.get(i).size();j++) {\n            //核心递推式 dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle(i)(j)\n            dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+triangle.get(i).get(j);\n        }\n    }*/\n    //直接从最后一行开始,这样就不用手动给最后一行赋初始值了\n    for (int i=rows-1;i>=0;i--) {\n        for (int j=0;j<triangle.get(i).size();j++) {\n            //核心递推式 dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle(i)(j)\n            dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+triangle.get(i).get(j);\n        }\n    }\n    return dp[0][0];\n}\n```\n**解法二**\n\n记忆化递归，也很快\n\n```java\n//记忆化递归\npublic int minimumTotal2(List<List<Integer>> triangle) {\n    //用Integer比较好,方便判空\n    Integer [][] cache=new Integer[triangle.size()][triangle.size()];\n    return minimumTotal(triangle,0,0,cache);\n}\n\npublic int minimumTotal(List<List<Integer>> triangle,int cen,int index,Integer[][]cache) {\n    if (cache[cen][index]!=null) {\n        return cache[cen][index];\n    }\n    if (cen==triangle.size()-1) {\n        return triangle.get(cen).get(index);\n    }\n    int left=minimumTotal(triangle,cen+1,index,cache);\n    int right=minimumTotal(triangle,cen+1,index+1,cache);\n    return cache[cen][index]=triangle.get(cen).get(index)+(left<right?left:right);\n}\n```\n**解法三**\n\n```java\n//dp O(N)空间\npublic int minimumTotal(List<List<Integer>> triangle) {\n    int rows=triangle.size();\n    //dp[i]代表的是每一层第i个元素到最底层的最短距离\n    //上面二维dp实际上也只和下一层的状态有关,所以我们可以重复的使用这个数组保存每一层的状态\n    int[] dp=new int[rows+1];\n    for (int i=rows-1;i>=0;i--) {\n        for (int j=0;j<triangle.get(i).size();j++) {\n            //到这里其实Math.min()里面的都是上一次循环的结果\n            //也就是下一层的,对应当前j位置左右两个相邻节点的最小距离\n            dp[j]=Math.min(dp[j+1],dp[j])+triangle.get(i).get(j);\n        }\n    }\n    return dp[0];\n}\n```\nO(N)空间复杂度，只和下面那一层的每一个元素的dp[i]有关，所以可以直接改成一维dp\n\n**UPDATE: 2020.7.14**\n\n今天的打卡题，写了一个从上而下的dp，需要处理边界会麻烦一点，和之前的反着的，果然刷题主要还是刷一个感觉，想记住题目解法是不可能的，能锻炼一些思考的能力才是关键\n```golang\nfunc minimumTotal(triangle [][]int) int {\n    if len(triangle) <= 0{\n        return 0\n    }\n    var INF = 1<<31\n    var n = len(triangle)\n    var dp = make([]int, n)\n    for i := 0; i < n; i++{\n        dp[i] = INF\n    }\n    dp[0] = triangle[0][0]\n    var res = INF\n    for i := 1; i < n; i++{\n        for j :=i; j >=0; j--{\n            if j == 0{\n                dp[j] = dp[j] + triangle[i][j]\n            }else if j == i{\n                dp[j] = dp[j-1] + triangle[i][j]\n            }else{\n                dp[j] = Min(dp[j], dp[j-1]) + triangle[i][j]\n            }\n            if i == n-1{\n                res = Min(res, dp[j])\n            }\n        }\n    }\n    if res == INF{\n        return triangle[0][0]\n    }\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a < b{\n        return a\n    }\n    return b\n}\n```\n\n## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你**最多只允许完成一笔交易**（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n注意你不能在买入股票前卖出股票。\n\n**示例 1:**\n\n```java\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5  ，注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n```\n\n**示例 2:**\n\n```java\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n**解法一**\n\n非动态规划的思路，还是挺简单的，求个最大的差值就ok，因为只能买一次\n\n```java\n//非递归的思路\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int min=Integer.MAX_VALUE,max=0;\n    for (int i=0;i<prices.length;i++) {\n        //当天价格减去 *之前* 价格最低的买入时机\n        max=Math.max(max,prices[i]-min);\n        //统计价格最低的买入时机\n        min=Math.min(min,prices[i]);\n    }\n    return max;\n}\n```\n**解法二**\n\n既然是动态规划的题，自然得写个动态规划的版本\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]= -prices[0];\n    for (int i=1;i<prices.length;i++) {\n        dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+[i]);\n        dp[i][1]=Math.max(dp[i-1][1],-prices[i]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n其实改成一维的就和上面的一模一样了\n\n## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。**你可以尽可能地完成更多的交易**（多次买卖一支股票）。\n\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**示例 1:**\n\n```java\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n```\n\n**示例 2:**\n\n```java\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n**示例 3:**\n\n```java\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n**解法一**\n\n正常的思路（非动态规划），注意审题，上面的只能买一次，这里是不限制次数的\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int ans=0;\n    for (int i=1;i<prices.length;i++) {\n        if (prices[i]>prices[i-1]) {\n            ans+=prices[i]-prices[i-1];\n        }\n    }\n    return ans;\n}\n```\n这里的代码还是很有迷惑性的，实际上分了三种情况，有两种合并了\n\n>**单独交易日**：明天比今天价格高，今天买，明天卖\n>\n>**连续上涨交易日**：开始的第一天买 , 涨停的最后一天卖最有利，或者也可以转换成说`除了第一天，每天都卖了又买`，也就是`pn-p1 = (p2-p1)+(p3-p2)+....(pn-pn-1)`  很自然的就转换成了单独交易日的情况\n>**连续下降交易日**：不买卖最有利\n\n如果还是不明白可以看看官方的图\n\n![mark](http://static.imlgw.top/blog/20191017/Wpsvs09EmnmF.png?imageslim)\n\nA->D是一段连续上涨日，`D-A的差值` 就是A->D各个相邻节点差值之和\n\n**解法二**\n\n我们的主角，动态规划\n\n```java\n//dp的思路\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);\n        dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n第一眼看可能觉得看不懂，熟悉了就知道了，其实都是套路，股票题特有的套路，先考虑题目有几种状态，这题说了不限制次数，那么就不考虑次数的问题，然后剩下的状态就是：那一天，和是否持有股票，所以我们用一个二维的数组来表述这两种状态 比如`dp[i][0]` 则代表第i天不持有股票的最大收益，`dp[i][1]`则代表第i天持有股票的最大收益，然后我们再看看状态转换的过程\n\n![mark](http://static.imlgw.top/blog/20191017/J7tfvKDvqC2b.png?imageslim)\n\n其实无非就是这两个状态之间的转换，然后根据这个状态转换的过程就可以很轻易的写出我们的状态转换方程\n\n```java\ndp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);\ndp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);\n```\n不过这里其实也很容易就可以改成一唯的dp，空间复杂度变为O(1)，因为当天的最大收益只和前一天的最大收益相关，两个变量就是足够表示\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int hlod=-prices[0];\n    int empty=0;\n    for (int i=1;i<prices.length;i++) {\n        //保存前一天的状态\n        int temp=empty;\n        empty=Math.max(empty,hlod+prices[i]);\n        hlod=Math.max(hlod,temp-prices[i]);\n    }\n    return empty;\n}\n```\n这里我感觉leetcode的case有问题，我开始没有缓存前一天的empty值，直接将empty带到hold去了，结果还过了。。。不过我懒得去想case了，反正提交了leecode也不会理我😅\n\n## [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)\n\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n\n**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**示例 1:**\n\n```java\n输入: [3,3,5,0,0,3,1,4]\n输出: 6\n解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n```\n\n\n**示例 2:**\n\n```java\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n**示例 3:**\n\n```java\n输入: [7,6,4,3,1] \n输出: 0 \n解释: 在这个情况下, 没有交易完成, 所以最大利润为 0\n```\n\n**解法一**\n\n二维动态规划，定义出每个状态，然后转换就可以了\n\n```java\npublic int maxProfit(int[] prices){\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    //状态定义：\n    //j=0 什么都不做\n    //j=1 第一次买入\n    //j=2 第一次卖出\n    //j=3 第二次买入\n    //j=4 第二次卖出\n    int[][] dp=new int[prices.length][5];\n    //这样会溢出\n    //Arrays.fill(dp[0],Integer.MIN_VALUE);\n    //这样可以过,但是感觉还是判断一下好\n    //Arrays.fill(dp[0],-0x3f3f3f3f);\n    int INF=Integer.MIN_VALUE,n=prices.length;\n    Arrays.fill(dp[0],INF); //不可达状态\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for(int i=1;i<n;i++){\n        dp[i][0]=0;\n        dp[i][1]=Math.max(-prices[i],dp[i-1][1]);\n        dp[i][2]=Math.max(dp[i-1][1]+prices[i],dp[i-1][2]);\n        dp[i][3]=Math.max(dp[i-1][2]!=INF?dp[i-1][2]-prices[i]:INF,dp[i-1][3]);\n        dp[i][4]=Math.max(dp[i-1][3]!=INF?dp[i-1][3]+prices[i]:INF,dp[i-1][4]);\n    }\n    return Math.max(Math.max(dp[n-1][0],dp[n-1][2]),dp[n-1][4]);\n}\n```\n> 因为题目的数据不是特别大，没有超过`10^9` 直接初始化为 `-0x3f3f3f3f` 就不用判断前面的状态是否可达了，\n\n**解法二**\n\n优化成一维的\n\n```java\npublic int maxProfit(int[] prices){\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[] dp=new int[5];\n    int n=prices.length;\n    Arrays.fill(dp,-0x3f3f3f3f);\n    dp[0]=0;\n    dp[1]=-prices[0];\n    for(int i=1;i<n;i++){\n        //逆序递推避免覆盖(其实正着写也是对的,这题相邻的状态不会同时更新,但是为了规范最好还是逆序写)\n        dp[4]=Math.max(dp[3]+prices[i],dp[4]);\n        dp[3]=Math.max(dp[2]-prices[i],dp[3]);\n        dp[2]=Math.max(dp[1]+prices[i],dp[2]);\n        dp[1]=Math.max(-prices[i],dp[1]);\n        dp[0]=0;\n    }\n    return Math.max(Math.max(dp[0],dp[2]),dp[4]);\n}\n```\n## [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)\n\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n\n注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**示例 1:**\n\n```java\n输入: [2,4,1], k = 2\n输出: 2\n解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n```\n\n\n**示例 2:**\n\n```java\n输入: [3,2,6,5,0,3], k = 2\n输出: 7\n解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n```\n\n**解法一**\n\n这题其实就是求上面一题的通解，上面的代码规律已经非常明显了，`j`为奇数的时候买入，偶数的时候卖出，我们统计最后偶数的最大值就可以\n\n```java\npublic int maxProfit(int k, int[] prices) {\n    if (prices==null || prices.length<=0 || k<=0) {\n        return 0;\n    }\n    if(k>prices.length/2){\n        return maxProfit(prices);\n    }\n    //k次交易,2*k+1种状态\n    int[] dp=new int[2*k+1];\n    int n=prices.length;\n    int res=0;\n    Arrays.fill(dp,-0x3f3f3f3f);\n    dp[0]=0;\n    dp[1]=-prices[0];\n    for(int i=1;i<n;i++){\n        //注意倒推\n        for(int j=2*k;j>0;j--){\n            if((j&1)==1){\n                dp[j]=Math.max(dp[j-1]-prices[i],dp[j]);\n            }else{\n                dp[j]=Math.max(dp[j-1]+prices[i],dp[j]);\n                res=Math.max(dp[j],res);\n            }\n        }\n    }\n    return res;\n}\n\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int ans=0;\n    for (int i=1;i<prices.length;i++) {\n        if (prices[i]>prices[i-1]) {\n            ans+=prices[i]-prices[i-1];\n        }\n    }\n    return ans;\n}\n```\n**解法二**\n\n正常的DP通解\n\n```java\n//常规2维解法\npublic int maxProfit(int k, int[] prices) {\n    if (prices==null || prices.length<=0 || k<=0) {\n        return 0;\n    }\n    if(k>prices.length/2){\n        return maxProfit(prices);\n    }\n    //第k次交易,持股/不持股\n    int[][] dp=new int[k+1][2];\n    int n=prices.length;\n    int res=0;\n    int INF=-0x3f3f3f3f;\n    for(int i=0;i<=k;i++){\n        Arrays.fill(dp[i],INF);\n    }\n    //其实这题难搞的就是对于初始状态的init\n    //第一天没有交易和第一天有一次交易的初始值\n    dp[0][0]=0;dp[0][1]=INF;\n    dp[1][0]=0;dp[1][1]=-prices[0];\n    for(int i=1;i<n;i++){\n        //注意倒推\n        for(int j=k;j>0;j--){\n            //这里将买入和卖出作为一个状态,所以这里买入新股票，肯定就是属于下一次交易了\n            //所以这里的j需要减一，代表上一次交易卖出时候的收益\n            dp[j][0]=Math.max(dp[j][1]+prices[i],dp[j][0]);\n            dp[j][1]=Math.max(dp[j-1][0]-prices[i],dp[j][1]);\n            res=Math.max(dp[j][0],res);\n        }\n    }\n    return res;\n}\n\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int ans=0;\n    for (int i=1;i<prices.length;i++) {\n        if (prices[i]>prices[i-1]) {\n            ans+=prices[i]-prices[i-1];\n        }\n    }\n    return ans;\n}\n```\n## [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\n\n给定一个整数数组 `prices`，其中第 i 个元素代表了第 i 天的股票价格 ，非负整数 fee 代表了交易股票的手续费用\n\n你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n**示例 1:**\n\n```java\n输入: prices = [1, 3, 2, 8, 4, 9], fee = 2\n输出: 8\n解释: 能够达到的最大利润:  \n在此处买入 prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n```\n\n**注意:**\n\n- `0 < prices.length <= 50000.`\n- `0 < prices[i] < 50000.`\n- `0 <= fee < 50000.`\n\n**解法一**\n\n我起了，一枪秒了，有什么好说的？\n\n```java\npublic int maxProfit(int[] prices, int fee) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]-fee);\n        dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n改为O(1)空间\n\n```java\n//改为O(1)\npublic int maxProfit(int[] prices, int fee) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int empty=0;\n    int hold=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        int temp=empty;\n        empty=Math.max(empty,hold+prices[i]-fee);\n        hold=Math.max(hold,temp-prices[i]);\n    }\n    return empty;\n}\n```\n## [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n\n给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 \n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）\n- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)\n\n**示例:**\n\n```java\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n```\n\n**解法一**\n\n依然是上面题的升级版，相比上一题又多了个限制条件，加了cd，买卖一次后有一天的cd，当天不能再买\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    //dp[i][0] 代表第i天不持有股票的最大利润\n    //dp[i][1] 代表第i天持有股票的最大利润\n    int[][] dp=new int[prices.length][2];\n    dp[0][0]=0;\n    dp[0][1]=-prices[0];\n    for (int i=1;i<prices.length;i++) {\n        //这些玩意想起还是蛮打脑阔的\n        dp[i][0]=Math.max(dp[i-1][1]+prices[i],dp[i-1][0]);\n        //dp[i][1]=Math.max(i<2?-prices[i]:dp[i-2][0]-prices[i],dp[i-1][1]);\n        //这里i<2就是第一次循环，i=1,也就是第二天持有股票，所以肯定是首次买股票，直接初始化为 -prices[1]\n        //昨天有股票，或者昨天冷冻前天卖出\n        dp[i][1]=Math.max(i<2?-prices[1]:dp[i-2][0]-prices[i],dp[i-1][1]);\n    }\n    return dp[prices.length-1][0];\n}\n```\n评论区很多的解法都是用了三个状态数组，相比这种多了一个 冷冻期的最大值，感觉挺迷惑的。。。虽然结果是对的，但是总时感觉别扭，所以我们还是按照上面的思路，用两个状态表示，状态转换图和上面是一样的\n\n![mark](http://static.imlgw.top/blog/20191017/J7tfvKDvqC2b.png?imageslim)\n\n当天持有股票的最大收益，就是你当天买股票，或者rest啥也不干延续前一天的状态，两者的最大值\n\n这里和上面不同的就是从`不持有股票` 到`持有股票`（也就是买股票）的情况， 因为有冷冻期的存在，**所以你当天买股票的最大值不再是昨天不持有股票的最大值，而是前天不持有股票的最大值**\n\n**解法三**\n\n改为空间复杂度O(1)的\n\n```java\npublic int maxProfit(int[] prices) {\n    if (prices==null || prices.length<=0) {\n        return 0;\n    }\n    int hold=-prices[0];\n    int empty=0;\n    //前一天买出的最大收益\n    int prePre=0;\n    for (int i=1;i<prices.length;i++) {\n        int temp=empty;\n        empty=Math.max(hold+prices[i],empty);\n        hold=Math.max(i<2?-prices[1]:prePre-prices[i],hold);\n        //到这里pre就变成了前一天\n        prePre=temp;\n    }\n    return empty;\n}\n```\n> 看了下评论区还是蛮多争议的，感觉这里根据dp[i-2]转换有点不好理解，然后翻了翻评论区看见了大神的回答\n>\n> `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`\n>\n> `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`\n>\n> 添加 “冷冻期” 条件后，买入的前一天是不能卖的，而`dp[i-1][0] - prices[i]`并不能确保 `i-1天不卖出`   \n>\n> 所以进一步拆解`dp[i-1][0]`， 套用上面的转换方程可以得到\n>\n> `dp[i-1][0] = max(dp[i-2][0], dp[i-2][1] + prices[i-1])` \n>\n> 再带入原式子，则可以得到\n>\n> `dp[i][1] = max(dp[i-1][1], max(dp[i-2][0], dp[i-2][1] + prices[i-1]) - prices[i])`\n>\n> 其中`dp[i-2][1] + prices[i-1]` 代表着 `“i-1发生了卖出行为”`，有违题意，应予删除，得下式，最终和上面的状态转换方程一致\n>\n> `dp[i][1] = max(dp[i-1][1], max(dp[i-2][0]) - prices[i])`\n>\n> 这样一证明就很清楚了\n\n\n\n## [1269. 停在原地的方案数](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/)\n\n有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。\n\n每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。\n\n给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。\n\n由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。\n\n**示例 1：**\n\n```java\n输入：steps = 3, arrLen = 2\n输出：4\n解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动\n```\n\n**示例  2：**\n\n```java\n输入：steps = 2, arrLen = 4\n输出：2\n解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动\n```\n\n**示例 3：**\n\n```java\n输入：steps = 4, arrLen = 2\n输出：8\n```\n\n**提示：**\n\n- `1 <= steps <= 500`\n- `1 <= arrLen <= 10^6`\n\n**解法一**\n\n11.24 的周赛最后一题，很可惜没做出来。。。要是把这题放在第三题我可能就做出来了。。。。还是菜啊\n\n```java\npublic int numWays(int steps, int arrLen) {\n    int mod=1_000_000_007;\n    long[][] dp=new long[steps+1][steps+1];\n    dp[0][0]=1; //dp[i][j]的含义是i步之后处于j位置的方案数\n    for (int i=1;i<=steps;i++) {\n        //i步能达到的最大距离就是i,所以我们这里取一个最小值\n        int k=Math.min(i,arrLen-1);\n        for (int j=0;j<=k;j++) {\n            if (j==0) {\n                dp[i][j]=(dp[i-1][j+1]+dp[i-1][j])%mod;\n            }else if (j<k) {\n                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j+1]+dp[i-1][j])%mod;\n            }else{ //大于k就只能是从右边过来的\n                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%mod;\n            }\n        }\n    }\n    return (int)dp[steps][0];\n}\n```\n**解法二**\n\n我比较喜欢的记忆化递归😁，10ms甚至比上面还快一点\n\n```java\nint mod=1_000_000_007;\n\n//cache\nLong[][] cache;\n\npublic int numWays(int steps, int arrLen) {\n    int maxIndex=Math.min(steps,arrLen-1);\n    cache=new Long[steps+1][maxIndex+1];\n    return (int)dfs(steps,0,maxIndex);\n}\n\npublic long dfs(int steps, int index,int maxIndex) {\n    if (steps==0) {\n        return index==0?1:0;\n    }\n    if (index<0 || index > maxIndex )  {\n        return 0;\n    }\n\n    if (cache[steps][index]!=null) {\n        return cache[steps][index];\n    }\n    //steps一直在递减,steps最多走到steps位置\n    //为了节约时间可以在这里优化下\n    maxIndex=Math.min(steps,maxIndex);\n    //不动\n    long res=dfs(steps-1,index,maxIndex);\n    //向左\n    res+=dfs(steps-1,index-1,maxIndex);\n    //向右\n    res+=dfs(steps-1,index+1,maxIndex);\n    return cache[steps][index]=res%mod;\n}\n```\n\n## [152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)\n\n给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。\n\n**示例 1:**\n\n```java\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n```\n\n\n**示例 2:**\n\n```java\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n**解法一**\n\n自己最开始自己写出来的脑瘫dp\n\n```java\npublic static int maxProduct(int[] nums) {\n    int[] dp1=new int[nums.length];\n    int[] dp2=new int[nums.length];\n    //最大值\n    dp1[0]=nums[0]>=0?nums[0]:0;\n    //最小值\n    dp2[0]=nums[0]>=0?0:nums[0];\n    int max=nums[0]>0?dp1[0]:dp2[0];\n    for(int i=1;i<nums.length;i++){\n        if (nums[i]>0) {\n            if (nums[i-1]<0) {\n                dp1[i]=dp1[i-1]!=0?nums[i]*dp1[i-1]:nums[i];\n                dp2[i]=dp2[i-1]*nums[i];\n            }else if(nums[i-1]>0){\n                dp1[i]=dp1[i-1]*nums[i];\n                dp2[i]=dp2[i-1]!=0?nums[i]*dp2[i-1]:0;\n            }else{\n                dp1[i]=nums[i];\n                dp2[i]=0;\n            }\n        }else if (nums[i]<0) {\n            if (nums[i-1]<0) {\n                dp1[i]=dp2[i-1]*nums[i];\n                dp2[i]=dp1[i-1]!=0?dp1[i-1]*nums[i]:nums[i];\n            }else if(nums[i-1]>0){\n                dp1[i]=dp1[i-1]!=0?nums[i]*dp2[i-1]:0;\n                dp2[i]=dp1[i-1]*nums[i];\n            }else{\n                dp1[i]=0;\n                dp2[i]=nums[i];\n            }\n        }else{\n            dp1[i]=0;\n            dp2[i]=0;\n        }\n        //System.out.println(dp1[i]+\",\"+dp2[i]);\n        max=Math.max(max,dp1[i]);\n    }\n    return max;\n}\n\n/**\n    //     -2  2  3   -4        \n    //dp1:  0  2  6   48        \n    //dp2: -2 -4 -12 -24 \n    //\n    // 2 -5   -2  -4   3\n    // 2  0   20   8   24\n    // 0 -10  -2  -80 -240\n*/\n```\n不想解释太多，虽然过了，但是确实有点蠢\n\n**解法二**\n\n`max[i],min[i]` 代表的就是以`nums[i]` 结尾的**最大**乘积和**最小**乘积\n\n```java\npublic static int maxProduct(int[] nums) {\n    int[] min=new int[nums.length];\n    int[] max=new int[nums.length];\n    int res=max[0]=min[0]=nums[0];\n    for (int i=1;i<nums.length;i++) {\n        max[i]=Math.max(nums[i]*min[i-1],Math.max(nums[i],nums[i]*max[i-1]));\n        min[i]=Math.min(nums[i]*min[i-1],Math.min(nums[i],nums[i]*max[i-1]));\n        res=Math.max(res,max[i]);\n    }\n    return res;\n}\n```\n为什么要记录最小乘积相信不需要我多说了吧，其实只要想清楚一点就ok，每个位置的`max[i]`其实只有三种来源（纸上写写就明白了）\n\n- `nums[i] >= 0` 并且`max[i-1] > 0`，`max[i] = max[i-1] * nums[i]`\n-  `nums[i] >= 0` 并且`max[i-1] < 0`，此时如果和前边的数累乘的话，会变成负数，所以`max[i] = nums[i]`\n-  `nums[i] < 0`，如果是负数就不应该再和前面`max[i]`相乘，而是考虑`min[i]`\n  - `当min[i-1] < 0，max[i] = min[i-1] * nums[i]`\n  - `当min[i-1] >= 0，max[i] = nums[i]`\n\n 然后我们直接求这三种情况的最大值就ok了，不用考虑那些分支，我上面的第一种解法其实就是考虑了所有分支，结果才写出了那样的dp， `min[i]` 的过程和上面一样，就不赘述\n\n\n## [1567. 乘积为正数的最长子数组长度](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)\n\nDifficulty: **中等**\n\n给你一个整数数组 `nums` ，请你求出乘积为正数的最长子数组的长度。\n\n一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。\n\n请你返回乘积为正数的最长子数组长度。\n\n**示例  1：**\n\n```go\n输入：nums = [1,-2,-3,4]\n输出：4\n解释：数组本身乘积就是正数，值为 24 。\n```\n\n**示例 2：**\n\n```go\n输入：nums = [0,1,-2,-3,-4]\n输出：3\n解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。\n注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。\n```\n\n**示例 3：**\n\n```go\n输入：nums = [-1,-2,-3,0,1]\n输出：2\n解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。\n```\n\n**示例 4：**\n\n```go\n输入：nums = [-1,2]\n输出：1\n```\n\n**示例 5：**\n\n```go\n输入：nums = [1,2,3,5,-6,4,0,10]\n输出：4\n```\n\n**提示：**\n\n*   `1 <= nums.length <= 10^5`\n*   `-10^9 <= nums[i] <= 10^9`\n\n**解法一**\n\n一开始想歪了，和上面一题最开始一样写了个贼蠢的dp，好在后面还是自己想出来了，下面的是后面想出来的简单解法\n```golang\nfunc getMaxLen(nums []int) int {\n    var n = len(nums)\n    //dp[i][0]: \n    var dp = make([][2]int, n+1)\n    var res = 0\n    for i := 1; i <= n; i++ {\n        if nums[i-1] > 0 {\n            dp[i][0] = dp[i-1][0] + 1\n            if dp[i-1][1] != 0 {\n                dp[i][1] = dp[i-1][1] + 1   \n            }\n        } else if nums[i-1] < 0 {\n            if dp[i-1][1] != 0 {\n                dp[i][0] = dp[i-1][1] + 1   \n            }\n            dp[i][1] = dp[i-1][0] + 1\n        }\n        if dp[i][0] > res {\n            res = dp[i][0]\n        }\n    }\n    return res\n}\n```\n\n**解法二**\n\n贼蠢的DP，面向case编程\n```golang\n//垃圾DP，面向case编程，没有case一辈子改不出来（居然还被我改对了）\n//100+ms 时间复杂度O(N^2)，lc的case没能卡掉，但是应该是可以构造出一组特殊case卡掉的，懒得想了\nfunc getMaxLen(nums []int) int {\n    var n = len(nums)\n    var dp = make([]int, n+1)\n    if nums[0] > 0 {\n        dp[0] = 1\n    }\n    var res = dp[0]\n    for i := 1; i < n; i++ {\n        if nums[i] > 0 {\n            dp[i] = dp[i-1] + 1\n        } else if nums[i] < 0 {\n            if i-dp[i-1]-1 >= 0 && nums[i-dp[i-1]-1] < 0 {\n                dp[i] = dp[i-1] + 2\n                if i-dp[i-1]-2 >= 0 {\n                    dp[i] += dp[i-dp[i-1]-2]\n                }   \n            } else {\n                //从i-dp[i-1]开始找负数，然后从这个负数截断\n                var cnt = 0\n                for k := i-dp[i-1]; k < i; k++ {\n                    if nums[k] < 0 {\n                        dp[i] = dp[i-1]-cnt\n                        break\n                    }\n                    cnt++\n                }\n            }\n        }\n        if dp[i] > res {\n            res = dp[i]\n        }\n    }\n    return res\n}\n```\n## [1594. 矩阵的最大非负积](https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/)\n\nDifficulty: **中等**\n\n\n给你一个大小为 `rows x cols` 的矩阵 `grid` 。最初，你位于左上角 `(0, 0)` ，每一步，你可以在矩阵中 **向右** 或 **向下** 移动。\n\n在从左上角 `(0, 0)` 开始到右下角 `(rows - 1, cols - 1)` 结束的所有路径中，找出具有 **最大非负积** 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。\n\n返回 **最大非负积** 对**`10<sup>9</sup> + 7`** **取余** 的结果。如果最大积为负数，则返回`-1` 。\n\n**注意，**取余是在得到最大积之后执行的。\n\n**示例 1：**\n\n```go\n输入：grid = [[-1,-2,-3],\n             [-2,-3,-3],\n             [-3,-3,-2]]\n输出：-1\n解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1\n```\n\n**示例 2：**\n\n```go\n输入：grid = [[1,-2,1],\n             [1,-2,1],\n             [3,-4,1]]\n输出：8\n解释：最大非负积对应的路径已经用粗体标出 (1 * 1 * -2 * -4 * 1 = 8)\n```\n\n**示例 3：**\n\n```go\n输入：grid = [[1, 3],\n             [0,-4]]\n输出：0\n解释：最大非负积对应的路径已经用粗体标出 (1 * 0 * -4 = 0)\n```\n\n**示例 4：**\n\n```go\n输入：grid = [[ 1, 4,4,0],\n             [-2, 0,0,1],\n             [ 1,-1,1,1]]\n输出：2\n解释：最大非负积对应的路径已经用粗体标出 (1 * -2 * 1 * -1 * 1 * 1 = 2)\n```\n\n**提示：**\n\n*   `1 <= rows, cols <= 15`\n*   `-4 <= grid[i][j] <= 4`\n\n\n\n\n**解法一**\n\n和上面两题一样，非常套路的DP，但是我一开始想把初始化给省掉，调了半天发现不太好搞。。。外围的dp取值会影响内部的取值，所以还是老老实实手动初始化，老是想偷懒有时候可能会适得其反（好未来笔试）\n```golang\nfunc maxProductPath(grid [][]int) int {\n    var m, n = len(grid), len(grid[0])\n    var MOD = int(1e9+7)\n    var dp = make([][][2]int, m)\n    var Max = func(a, b int) int {if a < b {return b}; return a}\n    var Min = func(a, b int) int {if a > b {return b}; return a}\n    for i := 0; i < m; i++ {\n        dp[i] = make([][2]int, n)\n    }\n    dp[0][0][1] = grid[0][0]\n    dp[0][0][0] = grid[0][0]\n    for i := 1; i < m; i++ {\n        dp[i][0][0] = grid[i][0] * dp[i-1][0][0]\n        dp[i][0][1] = dp[i][0][0]\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j][0] = grid[0][j] * dp[0][j-1][0]\n        dp[0][j][1] = dp[0][j][0]\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            if grid[i][j] > 0 {\n                dp[i][j][0] =  grid[i][j] * Max(dp[i][j-1][0], dp[i-1][j][0])\n                dp[i][j][1] =  grid[i][j] * Min(dp[i][j-1][1], dp[i-1][j][1])\n            }else if grid[i][j] < 0 {\n                dp[i][j][0] =  grid[i][j] * Min(dp[i][j-1][1], dp[i-1][j][1])\n                dp[i][j][1] =  grid[i][j] * Max(dp[i][j-1][0], dp[i-1][j][0])\n            }\n        }\n    }\n    if dp[m-1][n-1][0] < 0 {\n        return -1\n    }\n    return dp[m-1][n-1][0] % MOD\n}\n```\n\n\n## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)\n\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n\n**示例:**\n\n```java\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n```\n\n**解法一**\n\n递推公式：`dp[i][j]=1+min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])`  有的类似短板理论，取决于最小的哪一个正方形\n\n```java\npublic int maximalSquare(char[][] matrix) {\n    if (matrix==null || matrix.length<=0) {\n        return 0;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    //这里+1处理边界\n    int[][] dp=new int[m+1][n+1];\n    int max=0;\n    for (int i=1;i<=m;i++) {\n        for (int j=1;j<=n;j++) {\n            if (matrix[i-1][j-1]=='1') {\n                dp[i][j]=1+Math.min(dp[i-1][j-1],Math.min(dp[i][j-1],dp[i-1][j]));\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n    return max*max;\n}\n```\n\n这题还有个需要注意的地方就是边界的处理，这里实现的代码中`dp[i][j]` 其实表示的是以 `matrix[i-1][j-1]` 作为右下角结尾的正方形的最大边长，这样的话就不用考虑上下两条边的边界case，相当于在dp数组上下边界之外又加了一层 0\n\n> 到这里我也大致明白了一些动态规划的题目的递推写法为都是从1开始了，比如上面的编辑距离\n\n## [1277. 统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)\n\n给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。\n\n示例 1：\n\n```java\n输入：matrix =\n[\n  [0,1,1,1],\n  [1,1,1,1],\n  [0,1,1,1]\n]\n输出：15\n解释： \n边长为 1 的正方形有 10 个。\n边长为 2 的正方形有 4 个。\n边长为 3 的正方形有 1 个。\n正方形的总数 = 10 + 4 + 1 = 15.\n```\n\n**示例 2：**\n\n```java\n输入：matrix = \n[\n  [1,0,1],\n  [1,1,0],\n  [1,1,0]\n]\n输出：7\n解释：\n边长为 1 的正方形有 6 个。 \n边长为 2 的正方形有 1 个。\n正方形的总数 = 6 + 1 = 7.\n```\n\n**提示：**\n\n- `1 <= arr.length <= 300`\n- `1 <= arr[0].length <= 300`\n- `0 <= arr[i][j] <= 1`\n\n**解法一**\n\n12.1的周赛题目，其实先做的上面的最大正方形，然后发现这一题和上面的一样。\n\n```java\npublic int countSquares(int[][] matrix) {\n    if (matrix==null || matrix.length<=0) {\n        return 0;\n    }\n    int m=matrix.length;\n    int n=matrix[0].length;\n    int [][]dp=new int[m+1][n+1];\n    int res=0;\n    for (int i=1;i<=m;i++) {\n        for (int j=1;j<=n;j++) {\n            if (matrix[i-1][j-1]==1) {\n                dp[i][j]=Math.min(dp[i-1][j-1],Math.min(dp[i][j-1],dp[i-1][j]))+1;\n                res+=dp[i][j];\n            }\n        }\n    }\n    return res;\n}\n```\n\n一摸一样，理解一点就ok，**以`matrix[i][j]` 为右下角的最大正方形的边长，就是以这个点为右下角的正方形的数量！！！**\n\n## [1139. 最大的以 1 为边界的正方形](https://leetcode-cn.com/problems/largest-1-bordered-square/)\n\nDifficulty: **中等**\n\n\n给你一个由若干 `0` 和 `1` 组成的二维网格 `grid`，请你找出边界全部由 `1` 组成的最大 **正方形** 子网格，并返回该子网格中的元素数量。如果不存在，则返回 `0`。\n\n**示例 1：**\n\n```golang\n输入：grid = [[1,1,1],[1,0,1],[1,1,1]]\n输出：9\n```\n\n**示例 2：**\n\n```golang\n输入：grid = [[1,1,0,0]]\n输出：1\n```\n\n**提示：**\n\n*   `1 <= grid.length <= 100`\n*   `1 <= grid[0].length <= 100`\n*   `grid[i][j]` 为 `0` 或 `1`\n\n**解法一**\n\n这个题目还是挺有意思的，第一次看了以后没啥思路，看了题解对dp数组的的定义后就明白了，今天来实现下，WA了2次，都WA的有理有据，很舒服，做这种题就很舒服\n\n```java\npublic int largest1BorderedSquare(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    //dp[i][j][0]: i,j左边连续的1的个数\n    //dp[i][j][1]: i,j上边连续的1的个数\n    int[][][] dp = new int[m+1][n+1][2];\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (grid[i-1][j-1] == 1){\n                dp[i][j][0] = 1 + dp[i][j-1][0];\n                dp[i][j][1] = 1 + dp[i-1][j][1];\n            }\n        }\n    }\n    int res = 0;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            //WA点2：最短的那条边不一定是边长，可以更短所以需要遍历所有小于最短边长的长度\n            //所以题目的数据范围是不会骗人的，给的100那么时间复杂度一定不是N2的\n            for (int side = Math.min(dp[i][j][0], dp[i][j][1]); side >= 1; side--){\n                //WA点1：大于等于\n                if (dp[i][j-side+1][1] >= side && dp[i-side+1][j][0] >= side){\n                    res = Math.max(res, side);\n                    break; //更短的就没必要考虑了\n                }\n            }\n        }\n    }\n    return res * res;\n}\n```\n其实这个题目的关键就在于状态的定义，如何去构造一个正方形，一图胜千言（PPT画图还是挺方便）\n![mark](http://static.imlgw.top/blog/20200730/2NpjXbbGcEjQ.png?imageslim)\n（之前的图有点小问题，改了下）\n\n求以某个点为右下角的正方形，首先我们考虑这个点为右下角可能构成的最大正方形边长是多大\n\n很明显应该是该点左边和上边连续1个数的最小值，如上图的（6，5）点，最大的可能边长就应该是6，然后我们枚举所有的小于等于6大于等于1的边长side，验证side能否构成正方形\n\n验证side是否合法也很容易，如上图，我们只需要考虑（6，5）上边距离为side的点的左边连续1的个数是否大于等于side（`dp[i-side+1][j][0] >= side`），以及左边距离为side的点的上边连续的1的个数是否大于等于side（`dp[i][j-side+1][1] >= side`），如果都大于等于side那么该side就是合法的，我们统计这些合法的side的最大值就ok了\n\n\n> 在lc上水了一发[题解](https://leetcode-cn.com/problems/largest-1-bordered-square/solution/java-dong-tai-gui-hua-by-resolmi/)\n\n## [44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)\n\n给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。\n\n```java\n'?' 可以匹配任何单个字符。\n'*' 可以匹配任意字符串（包括空字符串）。\n```\n\n两个字符串完全匹配才算匹配成功。\n\n**说明:**\n\n- s 可能为空，且只包含从 a-z 的小写字母。\n- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n\n**示例 1:**\n\n```java\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n**示例 2:**\n\n```java\n输入:\ns = \"aa\"\np = \"*\"\n输出: true\n解释: '*' 可以匹配任意字符串。\n```\n\n**示例 3:**\n\n```java\n输入:\ns = \"cb\"\np = \"?a\"\n输出: false\n解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。\n```\n\n**示例 4:**\n\n```java\n输入:\ns = \"adceb\"\np = \"*a*b\"\n输出: true\n解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 \"dce\".\n```\n\n**示例 5:**\n\n```java\n输入:\ns = \"acdcb\"\np = \"a*c?b\"\n输入: false\n```\n\n**解法一**\n\n其实这题还有一道类似的题，[10. 正则表达式生成](http://imlgw.top/2019/10/10/leetcode-hui-su/#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D) 我放在回溯里了，因为dp的解法暂时还没花时间去看，感觉递归好理解一点，后面有时间再加进来\n\n```java\npublic boolean isMatch(String s, String p) {\n    //dp[i][j]代表s[0,i-1](s的前i个字符),p[0,j-1](p的前j个字符)是否匹配\n    boolean[][] dp=new boolean[s.length()+1][p.length()+1];        \n    //dp[i][0]=false dp[0][j] p[j]==\"*\"|\"?\"\n    dp[0][0]=true;\n    for (int j=1;j<=p.length();j++) {\n        if (p.charAt(j-1)=='*') {\n            dp[0][j]=dp[0][j-1]; //dp[0][j]=true是错的\n        }\n    }\n    //1. p[i]=p[j] dp[i][j]=dp[i-1][j-1]\n    //2. p[j]=\"?\"  dp[i][j]=dp[i-1][j-1]\n    //3. p[j]=\"*\"  dp[i][j]=dp[i-1][j] | dp[i][j-1]\n    for (int i=1;i<=s.length();i++) {\n        for (int j=1;j<=p.length();j++) {\n            if (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1)=='?') {\n                dp[i][j]=dp[i-1][j-1];\n            }else if (p.charAt(j-1)=='*') { //abcd ab* | ab ab*\n                dp[i][j]=dp[i-1][j]|dp[i][j-1];\n            }\n        }\n    }\n    return dp[s.length()][p.length()];\n}\n```\n\n思路都在注释里面了，比正则那个要简单，比较不好想的一点就是 `dp[i][j]=dp[i-1][j]|dp[i][j-1]`其实分别对应的就是 `*` **匹配任意字符**的情况和**匹配空字符**的情况，匹配任意字符为什么不是`dp[i-1][j-1]`? 因为`*` 不仅仅只可以匹配一个字符，它可以匹配任意个数的任意字符，就比如这样的` abcd，ab* ` 的，这种情况其实最终还是转换成了匹配空字符的情况，这也是动态规划的思想所在。\n\n## [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n\n给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。\n\n```java\n'.' 匹配任意单个字符\n'*' 匹配零个或多个前面的那一个元素\n```\n\n\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n**说明:**\n\n- s 可能为空，且只包含从 a-z 的小写字母。\n- p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n\n**示例 1:**\n\n```java\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n**示例 2:**\n\n```java\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n```\n\n**示例 3:**\n\n```java\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n```\n\n**示例 4:**\n\n```java\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n```\n\n**示例 5:**\n\n```java\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n```\n\n**解法一**\n\ndfs回溯，暴力解法，挺难搞\n\n```java\npublic boolean isMatch(String s, String p) {\n    return match(s,0,p,0);\n}\n\npublic boolean match(String s,int sIdx, String p,int pIdx) {\n    if (sIdx>=s.length() && pIdx>=p.length()) {\n        return true;\n    }\n    if (pIdx>=p.length()) {\n        return false;\n    }\n    //这里的判断其实不太对,也不能说不对,会稍微慢一点,因为题目中是不会给**这样的case的\n    //可以直接一次跳两步判断是不是*\n    if (sIdx == s.length()) {\n        //后面没有*的情况 aaa aaaa\n        if (pIdx==p.length()-1 && p.charAt(pIdx)!='*') { //p也到尽头,并且不为*\n            return false;\n        }\n        while(pIdx<p.length()){ //p没到尽头,检查后面的是否有两个连续的非*\n            if (p.charAt(pIdx) != '*' && (pIdx+1<p.length() && p.charAt(pIdx+1)!='*')) {\n                return false;\n            }\n            pIdx++;\n        }\n        //aaa aaa*c\n        return p.charAt(pIdx-1)=='*';\n    }\n\n    if (pIdx+1 < p.length() && p.charAt(pIdx+1) =='*') { //pIdx下一个是 *\n        //*匹配至少一个\n        if ((s.charAt(sIdx) == p.charAt(pIdx) || p.charAt(pIdx)=='.') && match(s,sIdx+1,p,pIdx)) {\n            return true;\n        }\n        //*匹配0个\n        return match(s,sIdx,p,pIdx+2);\n    }else{\n        //pIdx下一个不是*\n        if ((p.charAt(pIdx) == s.charAt(sIdx) || p.charAt(pIdx)=='.') && match(s,sIdx+1,p,pIdx+1)) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n这题还是挺麻烦的，毕竟是hard题，我也是看了题解才写出来，核心就是要把题目意思理解对，我这里没有做记忆化，懒得写\n\n**解法二**\n\n他来了他来了，他带着dp解法来了，终于还是把dp的解法补上来了，参考[题解 ](https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-si-yao-su-by-a380922457-5/) ，注意下标的转换，这里容易被绕进去，详细的都在注释中了\n\n```java\n//update: 2020.4.12\npublic boolean isMatch(String text, String pattern) {\n    //dp[i][j]代表 text[0,i)和pattern[0,j)是否匹配\n    boolean[][] dp=new boolean[text.length()+1][pattern.length()+1];\n    //都为空的时候肯定是匹配的\n    dp[0][0]=true;\n    //pattern为空，text不为空肯定是无法匹配,默认false,不用处理\n    //text为空,pattern不为空需要额外判断\n    for(int i=2;i<=pattern.length();i++){\n        dp[0][i]=pattern.charAt(i-1)=='*'&&dp[0][i-2];\n    }\n\n    for(int i=1;i<=text.length();i++){\n        for(int j=1;j<=pattern.length();j++){\n            if(singleMatch(text,pattern,i-1,j-1)){\n                dp[i][j]=dp[i-1][j-1];\n            }else if(pattern.charAt(j-1)=='*'){\n                //j一定是>=2的,p如果是*开头就是错误的语法,不过lc其实也没有这样的case\n                if(j<2) return false;\n                //ab abb*    --> '*'匹配0个b\n                //abbbbb ab* --> '*'匹配多个b\n                //注意dp[i-1][j]和text.charAt(i-1)的i-1含义是不一样的\n                //text.charAt(i-1)的i-1其实指的是当前元素,而dp[i-1][j]中的i-1是前一个元素\n                //abc ab*\n                dp[i][j]=dp[i][j-2] || (singleMatch(text,pattern,i-1,j-2) && dp[i-1][j]);\n            }\n        }\n    }\n    return dp[text.length()][pattern.length()];\n}\n\npublic boolean singleMatch(String s,String p,int i,int j){\n    return s.charAt(i)==p.charAt(j) || p.charAt(j)=='.';\n}\n```\n\n果然还是动态规划简洁，而且搞懂之后也很好理解~~\n\n## [1326. 灌溉花园的最少水龙头数目](https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/) \n\n在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。\n\n花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。\n\n给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i -  ranges[i], i + ranges[i]] 。\n\n请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/03/kAPc2ELusMa9qJZ.png)\n\n```java\n输入：n = 5, ranges = [3,4,1,1,0,0]\n输出：1\n解释：\n点 0 处的水龙头可以灌溉区间 [-3,3]\n点 1 处的水龙头可以灌溉区间 [-3,5]\n点 2 处的水龙头可以灌溉区间 [1,3]\n点 3 处的水龙头可以灌溉区间 [2,4]\n点 4 处的水龙头可以灌溉区间 [4,4]\n点 5 处的水龙头可以灌溉区间 [5,5]\n只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。\n```\n\n**示例 2：**\n\n```java\n输入：n = 3, ranges = [0,0,0,0]\n输出：-1\n解释：即使打开所有水龙头，你也无法灌溉整个花园。\n```\n\n**示例 3：**\n\n```java\n输入：n = 7, ranges = [1,2,1,0,2,1,0,1]\n输出：3\n```\n\n**示例 4：**\n\n```java\n输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]\n输出：2\n```\n\n**示例 5：**\n\n```java\n输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]\n输出：1\n```\n\n**提示：**\n\n- `1 <= n <= 10^4`\n- `ranges.length == n + 1`\n- `0 <= ranges[i] <= 100`\n\n**解法一**\n\n172周赛的最后一题\n\n```java\npublic int minTaps(int n, int[] ranges) {\n    int[] dp=new int[n+1]; //浇溉i位置前需要最少的水龙头\n    Arrays.fill(dp,Integer.MAX_VALUE);\n    dp[0]=0;\n    for (int i=0;i<=n;i++) {\n        int left=Math.max(0,i-ranges[i]);\n        int right=Math.min(n,i+ranges[i]);\n        if (dp[left]==Integer.MAX_VALUE) { //左边界不可达\n            continue;\n        }\n        for (int j=left+1;j<=right;j++) {\n            dp[j]=Math.min(dp[j],dp[left]+1); //范围内的区域dp值\n        }\n    }\n    return dp[n]==Integer.MAX_VALUE?-1:dp[n];\n}\n```\n\n动态规划的解法，对每个水龙头所覆盖的区域进行递推，dp[i]代表浇灌`0 ~ i` 位置区域所需要的最少的水头所以很容易得到递推公式`dp[j]=Math.min(dp[j],dp[left]+1)`  ，整体还是很好理解的\n\n**解法二**\n\n贪心算法，和[贪心专题](http://imlgw.top/2020/01/21/leetcode-tan-xin/)中的 [1024. 视频剪辑](http://imlgw.top/2020/01/21/leetcode-tan-xin/#1024-%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5)是一样的题目\n\n有时间再来补吧\n\n## [1335. 工作计划的最低难度](https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/)\n\n你需要制定一份 d 天的工作计划表。工作之间存在依赖，要想执行第 i 项工作，你必须完成全部 j 项工作（ `0 <= j < i`）。\n\n你每天 **至少** 需要完成一项任务。工作计划的总难度是这 `d` 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。\n\n给你一个整数数组 `jobDifficulty` 和一个整数 d，分别代表工作难度和需要计划的天数。第 i 项工作的难度是 `jobDifficulty[i]`。\n\n返回整个工作计划的 **最小难度** 。如果无法制定工作计划，则返回 -1 。\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/01/27/ipKvNZQASOhVmdI.png)\n\n```java\n输入：jobDifficulty = [6,5,4,3,2,1], d = 2\n输出：7\n解释：第一天，您可以完成前 5 项工作，总难度 = 6.\n第二天，您可以完成最后一项工作，总难度 = 1.\n计划表的难度 = 6 + 1 = 7 \n```\n\n**示例 2：**\n\n```java\n输入：jobDifficulty = [9,9,9], d = 4\n输出：-1\n解释：就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。\n```\n\n**示例 3：**\n\n```java\n输入：jobDifficulty = [1,1,1], d = 3\n输出：3\n解释：工作计划为每天一项工作，总难度为 3 。\n```\n\n**示例 4：**\n\n```java\n输入：jobDifficulty = [7,1,7,1,7,1], d = 3\n输出：15\n```\n\n**解法一**\n\n173周赛的最后一道dp题，事后一个小时左右独立的ac，还是挺舒服的，希望以后能更快ac\n\n```java\npublic int minDifficulty(int[] jobDifficulty, int d) {\n    int jlen=jobDifficulty.length;\n    if(jlen<d){\n        return -1;\n    }\n    //dp[i][j]   第i天完成前j项任务的最低难度\n    int[][] dp=new int[d][jlen];\n    for(int i=0;i<dp.length;i++){\n        Arrays.fill(dp[i],Integer.MAX_VALUE);\n    }\n    int max=0;\n    for(int j=0;j<jlen;j++){\n        max=Math.max(max,jobDifficulty[j]);\n        dp[0][j]=max;\n    }\n    for(int i=1;i<d;i++){\n        for(int j=0;j<jlen;j++){\n            for(int k=j-1;k>=i-1;k--){\n                dp[i][j]=Math.min(dp[i][j], dp[i-1][k]+maxDifficulty(jobDifficulty,k+1,j));\n            }\n        }\n    }\n    return dp[d-1][jlen-1];\n}\n\npublic int maxDifficulty(int[] jobDifficulty,int left,int right){\n    int max=jobDifficulty[left];\n    for(int i=left;i<=right;i++){\n        max=Math.max(max,jobDifficulty[i]);\n    }\n    return max;\n}\n```\n\n核心的递推公式： `dp[i][j]=min(dp[i][j],dp[i-1][0~k]+max(k+1,j))` \n\n其实也不是一开始就想到了这个递推公式，首先需要确定的是用几维数组和递推数组的含义，这个题目两个变量：天数和工作量；所以应该是二维的结构，`dp[i][j]` 然后对应题目所要求的东西，其实就可以确定dp数组的含义\n\n`dp[i][j]` 的含义是前`i`天完成前`j`项工作的最低难度，最后返回的结果就是`dp[d-1][jlen-1]`\n\n但是上面这个解法时间复杂度比较高，`O(dN^3)`，其实可以做一下预处理降低时间复杂度\n\n**解法二**\n\n预处理的地方也写成了动态规划hahaha~ 其实就是求一个**区间和**\n\n```java\npublic int minDifficulty(int[] jobDifficulty, int d) {\n    int jlen=jobDifficulty.length;\n    if(jlen<d){\n        return -1;\n    }\n    //dp[i][j]   前i天完成前j项任务的最低难度\n    int[][] dp=new int[d][jlen];\n    for(int i=0;i<dp.length;i++){\n        Arrays.fill(dp[i],Integer.MAX_VALUE);\n    }\n    //预处理\n    int[][] maxRange=new int[jlen][jlen];\n    for(int i=0;i<jlen;i++){\n        maxRange[i][i]=jobDifficulty[i];\n        for (int j=i+1;j<jlen;j++) {\n            //这里也是个动态规划hahaha~\n            maxRange[i][j]=Math.max(maxRange[i][j-1],jobDifficulty[j]);\n        }\n    }\n    for(int j=0;j<jlen;j++){\n        dp[0][j]=maxRange[0][j];\n    }\n    for(int i=1;i<d;i++){\n        for(int j=0;j<jlen;j++){\n            for(int k=j-1;k>=i-1;k--){ //注意这里k>=i-1的含义\n                dp[i][j]=Math.min(dp[i][j], dp[i-1][k]+maxRange[k+1][j]);\n            }\n        }\n    }\n    return dp[d-1][jlen-1];\n}\n```\n\n这样时间复杂度就降低为`O(dN^2)` ，当然还是有一点不完美，就是对边界的处理可以通过对dp数组+1来规避，这个问题我之前也说过，这我尝试改了下，没改好，不改了，哈哈哈~\n\n## [5331. 跳跃游戏 V](https://leetcode-cn.com/problems/jump-game-v/)\n\n给你一个整数数组 arr 和一个整数 d 。每一步你可以从下标 i 跳到：\n\n- `i + x` ，其中 `i + x < arr.length 且 0 < x <= d` 。\n- `i - x` ，其中 `i - x >= 0 且 0 < x <= d` 。\n\n除此以外，你从下标 i 跳到下标 j 需要满足：`arr[i] > arr[j] 且 arr[i] > arr[k]` ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) < k < max(i, j)）。\n\n你可以选择数组的任意下标开始跳跃。请你返回你 **最多** 可以访问多少个下标。\n\n请注意，任何时刻你都不能跳到数组的外面\n\n**示例 1：**\n\n![image.png](https://i.loli.net/2020/02/02/lroNpJhPkVc46Ya.png)\n\n```java\n输入：arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n输出：4\n解释：你可以从下标 10 出发，然后如上图依次经过 10 --> 8 --> 6 --> 7 。\n注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 > 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 > 9 。\n类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。\n```\n\n**示例 2：**\n\n```java\n输入：arr = [3,3,3,3,3], d = 3\n输出：1\n解释：你可以从任意下标处开始且你永远无法跳到任何其他坐标。\n```\n\n**示例 3：**\n\n```java\n输入：arr = [7,6,5,4,3,2,1], d = 1\n输出：7\n解释：从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。\n```\n\n**提示：**\n\n- `1 <= arr.length <= 1000`\n- `1 <= arr[i] <= 10^5`\n- `1 <= d <= arr.length`\n\n**解法一**\n\n预处理+回溯+记忆化\n\n```java\nprivate Integer[] cache=null;\n\npublic int maxJumps(int[] arr, int d) {\n    int[][] max=new int[arr.length][arr.length];\n    cache=new Integer[arr.length];\n    for (int i=0;i<arr.length;i++) {\n        max[i][i]=arr[i];\n        for (int j=i+1;j<arr.length;j++) {\n            max[i][j]=Math.max(max[i][j-1],arr[j]);\n        }\n    }\n    int res=0;\n    for (int i=0;i<arr.length;i++) {\n        res=Math.max(jump(arr,d,i,max),res);\n    }\n    return res+1;\n}\n\npublic int jump(int[] arr,int d,int index,int[][] max){ //从index起跳能跳多远\n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    int res=0;\n    for (int i=Math.max(index-d,0);i<index;i++) {\n        if (arr[index]>arr[i] && arr[index]>max[i+1][index-1]) {\n            res=Math.max(jump(arr,d,i,max)+1,res);\n        }\n    }\n    //index=0, i=1 , i<=1\n    for (int i=index+1;i<=Math.min(index+d,arr.length-1);i++) {\n        if (arr[index]>arr[i] && arr[index]>max[index+1][i-1]) {\n            res=Math.max(jump(arr,d,i,max)+1,res);\n        }\n    }\n    return cache[index]=res;\n}\n```\n\n其实已经在超时的边缘了。。。没有必要做预处理，一开始被题括号里面的信息给迷惑了，不然也不会搞个预处理，其实题目的意思就是只能向低处跳，我开始还搞了两个区间值haha，脑壳有点不亲白\n\n**解法二**\n\n改良后的回溯+记忆化\n\n```java\nprivate Integer[] cache=null;\n\npublic int maxJumps(int[] arr, int d) {\n    cache=new Integer[arr.length];\n    int res=0;\n    for (int i=0;i<arr.length;i++) {\n        res=Math.max(jump(arr,d,i),res);\n    }\n    return res+1;\n}\n\npublic int jump(int[] arr,int d,int index){ \n    if (cache[index]!=null) {\n        return cache[index];\n    }\n    int res=0;\n    //挨个跳,有一个跳不到,后面所有的就都跳不到了\n    for (int i=index-1;i>=Math.max(index-d,0) && arr[index]>arr[i];i--) {\n        res=Math.max(jump(arr,d,i)+1,res);\n    }\n    for (int i=index+1;i<=Math.min(index+d,arr.length-1) && arr[index]>arr[i];i++) {\n        res=Math.max(jump(arr,d,i)+1,res);\n    }\n    return cache[index]=res;\n}\n```\n\n**解法三**\n\n自底向上动态规划\n\n```java\npublic int maxJumps(int[] arr, int d) {\n    int res=0,len=arr.length;\n    Pair[] pair=new Pair[len];\n    int[] dp=new int[len];\n    Arrays.fill(dp,1);\n    for (int i=0;i<len;i++) pair[i]=new Pair(i,arr[i]);\n    Arrays.sort(pair,(p1,p2)->p1.value-p2.value);\n    for (int i=0;i<len;i++) {\n        int index=pair[i].index;\n        //向左\n        for (int j=index-1;j>=Math.max(index-d,0) && arr[index]>arr[j];j--) {\n            dp[index]=Math.max(dp[j]+1,dp[index]);\n        }\n        //向右\n        for (int j=index+1;j<=Math.min(index+d,arr.length-1) && arr[index]>arr[j];j++) {\n            dp[index]=Math.max(dp[j]+1,dp[index]);\n        }\n        res=Math.max(dp[index],res);\n    }\n    return res;\n}\n\nclass Pair{\n    int index;\n    int value;\n    public Pair(int index,int value){\n        this.index=index;\n        this.value=value;\n    }\n}\n```\n\n这里其实动态规划还有麻烦一点，因为需要从高向低跳，所以我们需要先保证低处的dp值先计算完成，所以我们需要先排序，同时要保留原索引，所以我们需要建立一个`Pair`数组来辅助，跳的方式和上面回溯的一样\n\n## [1262. 可被三整除的最大和](https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/)\n\n给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。\n\n**示例 1：**\n\n```java\n输入：nums = [3,6,5,1,8]\n输出：18\n解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。\n```\n\n\n**示例 2：**\n\n```java\n输入：nums = [4]\n输出：0\n解释：4 不能被 3 整除，所以无法选出数字，返回 0。\n```\n\n**示例 3：**\n\n```java\n输入：nums = [1,2,3,4,4]\n输出：12\n解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。\n```\n\n**提示：**\n\n- `1 <= nums.length <= 4 * 10^4`\n- `1 <= nums[i] <= 10^4`\n\n**解法一**\n\n动态规划的解法，很久之前的一次周赛的题，好像是第一次双周赛的题？\n\n```java\npublic int maxSumDivThree(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    //dp[i][k] 0~i 之间/3余k的最大元素和\n    int[][] dp=new int[nums.length+1][3]; \n    dp[0][0]=0; //初始状态定义\n    dp[0][1]=Integer.MIN_VALUE;\n    dp[0][2]=Integer.MIN_VALUE;\n    for (int i=1;i<=nums.length;i++) {\n        if (nums[i-1]%3==0) {\n            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][0]+nums[i-1]);\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][1]+nums[i-1]);\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][2]+nums[i-1]);\n        }\n        if (nums[i-1]%3==1) {\n            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]+nums[i-1]);\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+nums[i-1]);\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+nums[i-1]);   \n        }\n        if (nums[i-1]%3==2) {\n            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+nums[i-1]);\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][2]+nums[i-1]);\n            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][0]+nums[i-1]);   \n        }\n    }\n    return  Math.max(0,dp[nums.length][0]);\n}\n```\n\n看一下数据的范围`40000`，所以时间复杂度肯定是`O(N)` 或`O(NlogN)`的，`O(N^2)`的肯定超时啦\n\n想了很久没想出来，然后瞄了一眼评论区，发现dp数组定义的是和余数相关的，然后就反应过来了，余0余1余2， 他们的组合就可以得到新的最大余数和，我们最后要求的就是最后`[0,nums.length]` 余数为0的最大和\n\n递推公式就不用多说了，看代码就行了，递推公式很容易得到，关键就是初始的状态定义，第一步的递推，我一开始没有设置边界，直接开始dp然后后面怎么改都不对，一开始定义的base dp\n\n```java\ndp[0][0]=nums[0]%3==0?nums[0]:Integer.MIN_VALUE;\ndp[0][1]=nums[0]%3==1?nums[0]:Integer.MIN_VALUE;\ndp[0][2]=nums[0]%3==2?nums[0]:Integer.MIN_VALUE;\n```\n\n然后过了几十后卡在了个case上\n\n```java\n[2,19,6,16,5,10,7,4,11,6]\n```\n\n递推到第二个其实就有问题了\n\n```java\n      0     1      2 \n2    MIN   MIN     2 \n19   21    MIN+19  2\n```\n\n这里的19的1明显应该就是19，这里直接根据`dp[i-1][1]+19`递推得到的，后面的肯定都不对了，那我们这里将初始值设置为0可以么？\n\n```java\ndp[0][0]=nums[0]%3==0?nums[0]:0;\n```\n\n对这个case确实可以，但是对于其他的就不对了，这容易想到，你设置为0下一层的dp值就可以从这个值递推过来，但是这明显是不对的，举个例子： `3，4` 你将第一个3的余2最大值设置为0，那么下一个4就可以通过上一个余2的最大值来更新当前的余0最大值，变成4，这很明显就不对了，4根本就不能被3整除\n\n所以这里我们最好的处理方式是添加一个边界，相当于在数组的最前面添加一个0，0%3=0\n\n然后我们只需要将`dp[0][0]`设置为0就可以了，而1和2就设置为`INT_MIN`，让下一层不能通它来转移\n\n> dp边界的处理方式还是要多练啊\n\n**解法二**\n\n优化空间为O(1)\n\n```java\npublic int maxSumDivThree2(int[] nums) {\n    int[] dp=new int[3];\n    dp[1]=Integer.MIN_VALUE;\n    dp[2]=Integer.MIN_VALUE;\n    for (int i=1;i<=nums.length;i++) {\n        if (nums[i-1]%3==0) {\n            dp[0]=Math.max(dp[0],dp[0]+nums[i-1]);\n            dp[1]=Math.max(dp[1],dp[1]+nums[i-1]);\n            dp[2]=Math.max(dp[2],dp[2]+nums[i-1]);\n        }\n        if (nums[i-1]%3==1) {\n            int temp0=dp[0];\n            dp[0]=Math.max(dp[0],dp[2]+nums[i-1]);\n            dp[2]=Math.max(dp[2],dp[1]+nums[i-1]); //按依赖关系调整顺序,减少变量\n            dp[1]=Math.max(dp[1],temp0+nums[i-1]);\n        }\n        if (nums[i-1]%3==2) {\n            int temp0=dp[0];\n            dp[0]=Math.max(dp[0],dp[1]+nums[i-1]);\n            dp[1]=Math.max(dp[1],dp[2]+nums[i-1]);\n            dp[2]=Math.max(dp[2],temp0+nums[i-1]);\n        }\n    }\n    return dp[0];\n}\n```\n\n可以看出代码还是可以简化的很短的，为了表达的清晰就不改了\n\n**解法三**\n\n贪心，放在 [贪心专题](http://imlgw.top/2020/01/21/leetcode-tan-xin/#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97) 中\n\n## [面试题60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n**示例 1:**\n\n```java\n输入: 1\n输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n```\n\n**示例 2:**\n\n```java\n输入: 2\n输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n```\n\n**限制：**\n\n`1 <= n <= 11`\n\n**解法一**\n\n很有意思的题，看返回值还不容易想到用动态规划\n\n```java\npublic double[] twoSum(int n) {\n    //dp[i][j]代表i枚色子和为j的概率\n    double[][] dp=new double[n+1][6*n+1];\n    double probability=1.0/6.0;\n    //base初始化\n    for(int i=1;i<=6;i++) dp[1][i]=probability;\n    for(int i=2;i<=n;i++){ //枚举色子\n        for(int j=i;j<=i*6;j++){ //枚举点数\n            for(int k=1;k<=j && k<=6;k++){ //枚举当前色子的点数\n                dp[i][j]+=(probability*dp[i-1][j-k]);\n            }\n        }\n    }\n    double[] res=new double[5*n+1];//\n    System.arraycopy(dp[n],n,res,0,res.length);\n    return res;\n}\n```\n\n`dp[i][j]`代表**i**枚色子和为**j**的概率 递推公式很容易想到 `dp[i][j]= 1/6(dp[i-1][j-1]+dp[i-1][j-2]+dp[i-1][j-3]...dp[i-1][j-6])` 然后我们枚举各个状态就ok了\n\n## [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)\n\n编写一个程序，找出第 n 个丑数。\n\n丑数就是只包含质因数 2, 3, 5 的正整数。\n\n**示例:**\n\n```java\n输入: n = 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n```\n\n\n**说明:**  \n\n1. 是丑数。\n2. n 不超过1690。\n\n**解法一**\n\n小根堆，将base每次乘2乘3乘5的结果放入小根堆，然后将堆顶拿出来base，继续重复这个过程，中间要注意去重\n\n```java\npublic int nthUglyNumber3(int n) {\n    PriorityQueue<Long> queue=new PriorityQueue<>();\n    n-=1;\n    long base=1;\n    while(n-- >0){\n        queue.add(base*2);\n        queue.add(base*3);\n        queue.add(base*5);\n        base=queue.poll();\n        //去重\n        while(!queue.isEmpty()&&base==queue.peek()){\n            queue.poll();\n        }\n    }\n    return (int)base;\n}\n```\n\n用`HashSet`去重\n\n```java\npublic int nthUglyNumber(int n) {\n    PriorityQueue<Long> queue=new PriorityQueue<>();\n    HashSet<Long> set=new HashSet<>();\n    long base=1;\n    long[] ugly={2,3,5};\n    n-=1;\n    set.add(1L);\n    while(n-->0){\n        for(int i=0;i<3;i++){\n            if (!set.contains(ugly[i]*base)) {\n                queue.add(ugly[i]*base);\n                set.add(ugly[i]*base);\n            }\n        }\n        base=queue.poll();\n    }\n    return (int)base;\n}\n```\n\n**解法二**\n\n这个解法还是很有技巧性的，其实就是按顺序生成丑数，一开始观察的时候就发现了但是确实想不到三指针的解法\n\n```java\npublic int nthUglyNumber4(int n) {\n    int[] dp=new int[n];\n    dp[0]=1;\n    int index1=0,index2=0,index3=0;\n    for (int i=1;i<n;i++) {\n        dp[i]=Math.min(dp[index1]*2,Math.min(dp[index2]*3,dp[index3]*5));\n        index1+=(dp[index1]*2==dp[i]?1:0);\n        index2+=(dp[index2]*3==dp[i]?1:0);\n        index3+=(dp[index3]*5==dp[i]?1:0);\n    }\n    return dp[n-1];\n}\n```\n## [面试题62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) \n\n0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n**示例 1：**\n\n```java\n输入: n = 5, m = 3\n输出: 3\n```\n\n\n**示例 2：**\n\n```java\n输入: n = 10, m = 17\n输出: 2\n```\n\n**限制：**\n\n- 1 <= n <= 10^5\n- 1 <= m <= 10^6\n\n**解法一**\n\n用链表模拟的解法，在数据太大的时候会TLE\n\n```java\n/*\n链表模拟解法\n0 1 2 3 4 5 m=3\n3 4 5 0 1\n*/\npublic int lastRemaining(int n, int m) {\n    Deque<Integer> queue=new LinkedList<>();\n    for(int i=0;i<n;i++)\n        queue.addLast(i);\n    while(queue.size()>1){\n        for(int i=0;i<m;i++){\n            int temp=queue.removeFirst();\n            if(i!=m-1){\n                queue.addLast(temp);\n            }\n        }\n    }\n    return queue.getFirst();\n}\n```\n**解法二**\n\n数学归纳法，加上一点递推dp\n\n```java\n/*\n    0 ~ n-1 每次kill第k个人\n    k=(m-1)%n\n\n    kill k之后, 在n-1个人中重建新索引\n    原始索引   新的index\n    k+1         0\n    k+2         1\n    k+3         2\n    ...         ...\n    n-1         n-k-2\n    0           n-k-1\n    1           n-k\n    2           n-k+1\n    ...         ...\n    k-1         n-2\n\n    新索引(x) ---> 原始索引(y)\n    y=(x+k+1)%n  eg. (n-2+k+1)%n=(n+k-1)%n=k-1\n    设在n-1个人中最后剩下的人是 f(n-1,m)按照上面的公式转换成原始索引就是\n    f(n,m)=(f(n-1,m)+k+1)%n\n */\n//数学解法\npublic int lastRemaining(int n, int m) {\n    int last=0;//一个人的时候存活者index f(1,m)=0\n    for(int i=2;i<=n;i++){ //枚举人数\n        last=(last+m)%i;\n    }\n    return last;\n}\n```\n参考了LeetCode的[大佬题解](https://leetcode-cn.com/u/yuanninesuns/)，讲的挺好的\n\n**递归解法**\n\n```java\n//递归的挺好理解\npublic int lastRemaining(int n, int m) {\n    if(n==0) return 0;\n    return (lastRemaining(n-1,m)+m)%n;\n}\n```\n## [1014. 最佳观光组合](https://leetcode-cn.com/problems/best-sightseeing-pair/)\n\n给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。\n\n一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。\n\n返回一对观光景点能取得的最高分。\n\n**示例：**\n\n```java\n输入：[8,1,5,2,6]\n输出：11\n解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n```\n\n**提示：**\n\n- `2 <= A.length <= 50000`\n- `1 <= A[i] <= 1000`\n\n**解法一**\n\n暴力解法，`O(N^2)`，这题数据5w，肯定会T\n\n```java\n//A[i] + A[j] + i - j (i<j)\npublic int maxScoreSightseeingPair(int[] A) {\n    int res=-1;\n    for (int i=0;i<A.length;i++) {\n        for (int j=i+1;j<A.length;j++) {\n            res=Math.max(A[i]+A[j]+i-j,res);\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n```java\n// A[i]+A[j] - (j-i) i<j\n// A[i]+i + (A[j]-j)\npublic int maxScoreSightseeingPair(int[] A) {\n    int res=-1;\n    int maxPre=A[0]+0;\n    for (int j=1;j<A.length;j++) {           \n        res=Math.max(maxPre+A[j]-j,res);\n        maxPre=Math.max(maxPre,A[j]+j);\n    }\n    return res;\n}\n```\n我们把式子合并一下 `(A[i]+i)+(A[j]-j)` ，然后发现其实上面的暴力解法中，我们想要结果最大实际上就是要两部分都最大，然后内层循环里面，`A[j]-j` 是个变量，而`A[i]+i`不变的，代表`j`位置之前，所有的`A[i]+i` 但是我们只需要最大的，所以我们完全可以用一个变量来保存这个最大值，然后遍历的过程中不断的更新它就ok了\n\n## [983. 最低票价](https://leetcode-cn.com/problems/minimum-cost-for-tickets/)\n\n在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 `days` 的数组给出。每一项是一个从 `1` 到 `365` 的整数。\n\n火车票有三种不同的销售方式：\n\n- 一张为期一天的通行证售价为 `costs[0]` 美元；\n- 一张为期七天的通行证售价为 `costs[1]` 美元；\n- 一张为期三十天的通行证售价为 `costs[2]` 美元。\n\n通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。\n\n返回你想要完成在给定的列表 `days` 中列出的每一天的旅行所需要的最低消费。\n\n**示例 1：**\n\n```java\n输入：days = [1,4,6,7,8,20], costs = [2,7,15]\n输出：11\n解释： \n例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：\n在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。\n在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。\n在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。\n你总共花了 $11，并完成了你计划的每一天旅行。\n```\n\n**示例 2：**\n\n```java\n输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\n输出：17\n解释：\n例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： \n在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。\n在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 \n你总共花了 $17，并完成了你计划的每一天旅行。\n```\n\n**提示：**\n\n1. `1 <= days.length <= 365`\n2. `1 <= days[i] <= 365`\n3. `days` 按顺序严格递增\n4. `costs.length == 3`\n5. `1 <= costs[i] <= 1000`\n\n**解法一**\n\n这题的递推关系其实很容易就想到：`dp[i]=Min(dp[i-dt[k]]+costs[k],dp[i])`，可是菜鸡的我还是搞了半天才AC\n\n```java\npublic int mincostTickets(int[] days, int[] costs) {\n    int n=days.length;\n    int[] dp=new int[days[n-1]+1];\n    boolean[] visit=new boolean[days[n-1]+1];\n    for (int i:days) {\n        visit[i]=true;\n    }\n    Arrays.fill(dp,0x3f3f3f3f);\n    int [] dt = {1,7,30};\n    dp[days[0]-1]=0;//初始状态\n    //枚举所有的day\n    for (int d=days[0];d<=days[n-1];d++) {\n        //一开始没想到这里，dubug的时候才看出来，不在旅游计划中的应该直接延续前面的\n        if (!visit[d]) { \n            dp[d]=dp[d-1];\n            continue;\n        }\n        //三种票\n        for (int k=0;k<3;k++) {\n            dp[d]=Math.min((d-dt[k]>=days[0]-1?dp[d-dt[k]]:0)+costs[k],dp[d]);\n        }\n    }\n    return dp[days[n-1]];\n}\n```\n一开始写了二维的，然后发现一维的状态并没有用，改成一维之后又dubug了半天，主要就在那个非旅行计划中的`d`没处理好，这题的状态定义不是特别清晰，然后搞混了，把非旅行计划内的也算进去了\n\n## [837. 新21点](https://leetcode-cn.com/problems/new-21-game/)\n\n爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：\n\n爱丽丝以 `0` 分开始，并在她的得分少于 `K` 分时抽取数字。 抽取时，她从 `[1, W]` 的范围中随机获得一个整数作为分数进行累计，其中 `W` 是整数。 每次抽取都是独立的，其结果具有相同的概率。\n\n当爱丽丝获得不少于 `K` 分时，她就停止抽取数字。 爱丽丝的分数不超过 `N` 的概率是多少？\n\n**示例1**\n\n```java\n输入：N = 10, K = 1, W = 10\n输出：1.00000\n说明：爱丽丝得到一张卡，然后停止。\n```\n\n**示例** **2**\n\n```java\n输入：N = 6, K = 1, W = 10\n输出：0.60000\n说明：爱丽丝得到一张卡，然后停止。\n在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。\n```\n\n**示例**3\n\n```java\n输入：N = 21, K = 17, W = 10\n输出：0.73278\n```\n\n**提示：**\n\n1. `0 <= K <= N <= 10000`\n2. `1 <= W <= 10000`\n3. 如果答案与正确答案的误差不超过 `10^-5`，则该答案将被视为正确答案通过。\n4. 此问题的判断限制时间已经减少。\n\n**解法一**\n\n题目意思都得理解好久，面试应该不会考，参考评论区大佬题解写的一个类似背包的做法\n\n```java\npublic double new21Game(int N, int K, int W) {\n    if(K==0) return 1;\n    //随机抽牌和为i的概率，背包问题\n    double[] dp=new double[N+1];\n    dp[0]=1;\n    dp[1]=1.0/W;\n    // i<=K\n    //dp[i] = 1/W(dp[i-1]+dp[i-2]+...+dp[i-W]);\n    //dp[i-1] = 1/W(dp[i-2]+dp[i-3]+...+dp[i-W-1])\n    //==> dp[i]=(1 + 1/W)*dp[i-1]-(1/W)*dp[i-W-1]\n    for(int i=2;i<=K;i++){\n        if(i-W-1>=0){\n            dp[i]=(1+1.0/W)*dp[i-1]-1.0/W*dp[i-W-1];\n        }else{\n            dp[i]=(1+1.0/W)*dp[i-1];\n        }\n    }\n    // i>K 从i-W ~ i区间选小于K的部分\n    //和剑指offer的骰子哪一题有点像\n    //dp[i] = 1/W(dp[K-1]+dp[K-2]+...+dp[i-W]) or dp[i]=1/W(dp[i-W]+dp[i-W+1]+..+dp[K-1])\n    //dp[i-1] = 1/W(dp[k-1]+dp[K-2]+...+dp[i-W-1]) or dp[i+1] = 1/W(dp[i-W+1]+dp[i-W+2]...+dp[K-1])\n    //==> dp[i] = dp[i-1]-1/W*dp[i-W-1] or dp[i]=1/W*dp[i-W]+dp[i+1] 两个是等价的\n    for (int i=K+1;i<=N;i++) {\n        if(i-W-1>=0){\n            dp[i]=dp[i-1]-1.0/W*dp[i-W-1];  \n        }else{\n            dp[i]=dp[i-1]; //1/W\n        }\n    }\n    double res=0;\n    for (int i=K;i<=N;i++) {\n        res+=dp[i];\n    }\n    return res;\n}\n```\n\n下一次碰到就不一定会做了，理解的不是很透彻，不过对背包公式的推导倒是理解多了一点\n\n## [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)\n\nDifficulty: **困难**\n\n给定一个整数矩阵，找出最长递增路径的长度。\n\n对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。\n\n**示例 1:**\n\n```go\n输入: nums = \n[\n  [9,9,4],\n  [6,6,8],\n  [2,1,1]\n] \n输出: 4 \n解释: 最长递增路径为 [1, 2, 6, 9]。\n```\n\n**示例 2:**\n\n```go\n输入: nums = \n[\n  [3,4,5],\n  [3,2,6],\n  [2,2,1]\n] \n输出: 4 \n解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。\n```\n**解法一**\n\n记忆化递归，这题如果递推的话需要保证子问题都已经被计算过，所以需要进行排序预处理，确保大的先求出来，然后再进行转移，参考上面 [5331-跳跃游戏-V](#5331-跳跃游戏-V)\n```java\nint [][] dir ={{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nInteger [][] cache = null;\n\n//记忆化递归，数组递推的方式状态转移方向不明确，需要排序\npublic int longestIncreasingPath(int[][] matrix) {\n    if (matrix == null || matrix.length <=0){\n        return 0;\n    }\n    int m = matrix.length;\n    int n = matrix[0].length;\n    cache = new Integer[m][n];\n    int res = 0;\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            res = Math.max(res, dfs(matrix, i, j));\n        }\n    }\n    return res;\n}\n\npublic int dfs(int[][] matrix, int x, int y){\n    if (cache[x][y] != null){\n        return cache[x][y];\n    }\n    int res = 1;\n    for (int i = 0; i < dir.length; i++){\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (valid(matrix, nx, ny) && matrix[nx][ny] > matrix[x][y]){\n            res = Math.max(res, dfs(matrix, nx, ny)+1);\n        }\n    }\n    return cache[x][y] = res;\n}\n\npublic boolean valid(int[][] matrix, int x, int y){\n    return x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length; \n}\n```\n\n##  _字符串类型的动态规划_\n\n## [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)\n\n给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。\n\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0 \n\n> 最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用\n\n**示例 1:**\n\n```java\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\"，它的长度为 3。\n```\n\n**示例 2:**\n\n```java\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\"，它的长度为 3。\n```\n\n**示例 3:**\n\n```java\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0。\n```\n\n**解法一**\n\n2019.10.19力扣终于有这题了，重新来做一遍，这题也就是经常说的LCS，dp的经典问题\n\n```java\npublic int longestCommonSubsequence(String A, String B) {\n    int[][] dp=new int[A.length()+1][B.length()+1];\n    for (int i=1;i<=A.length();i++) {\n        for (int j=1;j<=B.length();j++) {\n            if (A.charAt(i-1)==B.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1]+1;\n            }else{\n                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[A.length()][B.length()];\n}\n```\n其实看见这种什么最长的多半和dp有关系，这题只要明白几个要点就可以推出dp方程\n\n- `dp[i][j]` 代表A序列前`i`个字符（记为`Ai`）， 和B序列前`j`个字符（记为`Bj`） 的LCS\n\n- 两层for循环遍历两个序列，当`A[i]==B[j]`的时候，LCS长度就会增加 1，进而得到dp方程\n\n  `dp[i][j]=dp[i-1][j-1]+1`   dp[i-1] [j-1]代表的就是不包含`Ai/Bj`的`Ai-1`和`Bj-1` 的LCS\n\n- `A[i]!=B[j]`的时候就有两种情况了，首先`A[i]`和`B[j]`已经**不可能同时出现在最终的LCS里面**了，所以我们考虑另外的两种情况`dp[i][j-1]`和`dp[i-1][j]`取个最大值\n\n除此之外，还有一个值得注意的小细节，这里循环都是从1开始的，这样就不用处理初始值，如果从0开始的话，处理初始情况（i，j=0的情况）会麻烦一点\n\n**解法二**\n\n2019.10.19重写了一种记忆化递归的方法，没有dp快，但是思路其实是类似的\n\n```java\nInteger[][] cache=null;\n\npublic int longestCommonSubsequence(String text1, String text2) {\n    if(text2==null || text1==null || text1.length()<=0 ||text2.length()<=0){\n        return 0;\n    }\n    int len1=text1.length();\n    int len2=text2.length();\n    cache=new Integer[len1][len2];\n    return lcs(text1,len1-1,text2,len2-1);\n}\n\n//lcs定义: 求text1[0,a]和text2[0,b]的最长公共子序列\npublic int lcs(String text1, int a,String text2,int b) {\n    if(a==-1 || b==-1){\n        return 0;\n    }\n    if (cache[a][b]!=null) {\n        return cache[a][b];\n    }\n    if (text1.charAt(a)==text2.charAt(b)) {\n        cache[a][b]=lcs(text1,a-1,text2,b-1)+1;\n        return cache[a][b];\n    }else{\n        cache[a][b]=Math.max(lcs(text1,a-1,text2,b),lcs(text1,a,text2,b-1));\n        return cache[a][b];\n    }\n}\n```\n## [AtCoder-LCS](https://atcoder.jp/contests/dp/tasks/dp_f)\n\n题目就不copy了，这里就是求出lcs具体的字符串，而不是求长度\n\n我这里是参考了leetcode上一个大佬的[文章](https://leetcode-cn.com/circle/article/CwZVuV/) 利用back数组，从后向前递推，但是实际上有点多余，直接根据dp数组也可以推回去，但是这样写比较通用，逻辑比较清楚。\n\n```java\npublic static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    while(sc.hasNext()){\n        String A=sc.next();\n        String B=sc.next();\n        System.out.println(longestCommonSubsequence(A,B));\n    }\n}\n\npublic static String longestCommonSubsequence(String A, String B) {\n    int lenA=A.length();\n    int lenB=B.length();\n    int[][] dp=new int[lenA+1][lenB+1];\n    int[][] back=new int[lenA+1][lenB+1];\n    for (int i=1;i<=lenA;i++) {\n        for (int j=1;j<=lenB;j++) {\n            if (A.charAt(i-1)==B.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1]+1;\n                back[i][j]=1; //左上\n            }else if(dp[i-1][j]>dp[i][j-1]){\n                dp[i][j]=dp[i-1][j];\n                back[i][j]=2; //上\n            }else{\n                dp[i][j]=dp[i][j-1];\n                back[i][j]=0; //左\n            }\n        }\n    }\n    int i=lenA,j=lenB;\n    StringBuilder res=new StringBuilder();\n    while(i>0 && j>0){\n        if (back[i][j]==1) {\n            i--;j--;\n            res.append(A.charAt(i));\n        }else if(back[i][j]==2){\n            i--;\n        }else{\n            j--;\n        }\n    }\n    return res.reverse().toString();\n}\n```\n\n了解即可。\n\n## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n**示例 1:**\n\n```java\n输入:\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n输出: 3\n解释: \n长度最长的公共子数组是 [3, 2, 1]。\n```\n\n**说明:**\n\n1. 1 <= len(A), len(B) <= 1000\n2. 0 <= A[i], B[i] < 100\n\n**解法一**\n\n简单的递推，注意别写成上面的lcs了，这里的`dp[i][j]` 代表的其实是**公共子串**以`A[i]`和`B[i]` 结尾的最长重复子数组长度，如果`A[i]`和`B[i]`不相等那就是0\n\n```java\npublic int findLength(int[] A, int[] B) {\n    int lenA=A.length;\n    int lenB=B.length;\n    int[][] dp=new int[lenA+1][lenB+1];\n    int res=0;\n    for(int i=1;i<=lenA;i++){\n        for(int j=1;j<=lenB;j++){\n            if(A[i-1]==B[j-1]){\n                dp[i][j]=dp[i-1][j-1]+1;\n                res=Math.max(dp[i][j],res);\n            }\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n> 本来是想练练二分，在二分的tag里面看见的这题，结果发现这题dp似乎更容易，看了官方的二分的解法，其实就是二分公共子串的长度，然后检查，检查这一步有一些操作，不是很理解，以后有机会再来补充。\n> _已补充_，见 [Rabin-Karp专题](http://imlgw.top/2020/07/01/rabinkarp-suan-fa/#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84)\n\n## [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)\n\n给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n**示例 1:**\n\n```java\n输入: word1 = \"horse\", word2 = \"ros\"\n输出: 3\n解释: \nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n\n**示例 2:**\n\n```java\n输入: word1 = \"intention\", word2 = \"execution\"\n输出: 5\n解释: \nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n**解法一**\n\n很经典的动态规划的问题，做之前看了动态规划的思路，然后很快写出了递归的解法。。。\n\n```java\nInteger[][] cache=null;\n\npublic int minDistance(String word1, String word2) {\n    cache=new Integer[word1.length()][word2.length()];\n    return minDistance(word1,word1.length()-1,word2,word2.length()-1);\n}\n\n//递归的定义: word1[0,idx1] 和 word2[0,idx2] 的最短编辑距离\npublic int minDistance(String word1,int idx1,String word2,int idx2) {\n    if (idx1<0) {\n        return idx2+1;\n    }\n    if (idx2<0) {\n        return idx1+1;\n    }\n    if (cache[idx1][idx2]!=null) {\n        return cache[idx1][idx2];\n    }\n    if (word1.charAt(idx1) == word2.charAt(idx2)) {\n        return cache[idx1][idx2]=minDistance(word1,idx1-1,word2,idx2-1);\n    }else{\n        return cache[idx1][idx2]=1+Math.min(minDistance(word1,idx1-1,word2,idx2),Math.min(minDistance(word1,idx1,word2,idx2-1),minDistance(word1,idx1-1,word2,idx2-1)));\n    }\n}\n```\n核心的递推公式就是 \n\n`minDis(i,j)=minDis(i-1,j-1)  word1[i]==word2[j]`\n\n`minDis(i,j)=min(minDis(i-1,j),minDis(i,j-1),minDis(i-1,j-1))+1  word1[i]!=word2[j]`\n\n第一个公式好说，相等时候就别动，延续之前的状态，关键是第二个，不相等的时候，简单来说就是求对应的三种操作增，删，改的最小值，但是这里，第二种删的操作，这里要想清楚，其实word1删除一个其实就等价于word2增加一个，所以是`minDis(i,j-1)`，虽然题目说的是从word1转换为word2，但是其实结果都是一样的，这个转换的过程其实是可逆的\n\n**解法二**\n\n标准的动态规划写法，感觉还是上面的记忆化递归好写，动态规划要考虑的边界比递归要多\n\n```java\npublic int minDistance2(String word1, String word2) {\n    if (word1.length()<=0 || word2.length()<=0) {\n        return word2.length()==0?word1.length():word2.length();\n    }\n    //dp[i][j]: word1前i个和word2前j个的最短编辑距离\n    int[][] dp=new int[word1.length()+1][word2.length()+1];\n    for (int i=1;i<=word2.length();i++) {\n        dp[0][i]=i;\n    }\n    for (int i=1;i<=word1.length();i++) {\n        dp[i][0]=i;\n    }\n    for (int i=1; i<=word1.length();i++) {\n        for (int j=1;j<=word2.length();j++) {\n            if (word1.charAt(i-1)==word2.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1];\n            }else{\n                dp[i][j]=1+Math.min(dp[i-1][j],Math.min(dp[i][j-1],dp[i-1][j-1]));\n            }\n        }\n    }\n    return dp[word1.length()][word2.length()];\n}\n```\n\n## [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)\n\n给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。\n\n**示例 1:**\n\n```java\n输入: \"abc\"\n输出: 3\n解释: 三个回文子串: \"a\", \"b\", \"c\".\n```\n\n**示例 2:**\n\n```java\n输入: \"aaa\"\n输出: 6\n说明: 6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n```\n\n\n**注意:**\n\n1. 输入的字符串长度不会超过1000。\n\n**解法一**\n\n动态规划的解法，其实我是没想到的，`dp[i][j]`代表的是`s[i,j]` 是不是回文子串\n\n```java\npublic int countSubstrings(String s) { \n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    //aaaba\n    //dp[i][j] i~j 是不是回文\n    boolean [][] dp=new boolean[n][n];\n    int res=n; //下面的循环没有统计单个字符的情况\n    for (int i=n-1;i>=0;i--) {\n        for (int j=i+1;j<n;j++) { //统一写法，这里改成j=i就可以统计到单个字符的情况\n            if (s.charAt(i) == s.charAt(j) && (j-i<=2 || dp[i+1][j-1])) {\n                dp[i][j]=true;\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\n**解法二**\n\n很熟悉的解法，没错就是我们之前 [最长回文子串中](https://leetcode-cn.com/problems/longest-palindromic-substring/) 的解法，比上面的动态规划会快很多，也比较自然\n\n```java\n//中心扩展法\npublic int countSubstrings(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int count=0;\n    for (int i=0;i<n;i++) {\n        count+=spread(s,i,i+1)+spread(s,i,i);\n    }\n    return count;\n}\n\npublic int spread(String s,int i,int j){\n    int res=0;\n    while(i>=0 && j<s.length()){\n        if (s.charAt(i)==s.charAt(j)) {\n            i--;j++;\n            res++;\n        }else{\n            return res;\n        }\n    }\n    return res;\n}\n```\n\n\n## [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n**示例 1:**\n\n```java\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n```\n\n**示例 2:**\n\n```java\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n```\n\n**解法一**\n\n栈+dp的思路\n\n```java\npublic int longestValidParentheses(String s) {\n    if (s==null || s.length()<=0) {\n        return  0;\n    }\n    Stack<Integer> stack=new Stack<>();\n    int[] dp=new int[s.length()]; //以i位置括号结尾的最长有效括号\n    dp[0]=0;\n    int res=0;\n    for (int i=0;i<s.length();i++) {\n        if (s.charAt(i)=='(') {\n            stack.push(i); //dp[i]=0\n        }else{\n            if(!stack.isEmpty()){\n                int left=stack.pop();\n                dp[i]= left==0?i-left+1:dp[left-1]+i-left+1;\n                res=Math.max(res,dp[i]);\n            }//else dp[i]=0  \n        }\n    }\n    return res;\n}\n```\n\n首先想到的就是这种解法，感觉还是很好理解的，栈中存索引，`dp[i]` 代表以`i`位置括号结尾的最长有效括号，当遇到右括号的时候将栈顶的左括号的索引`left`弹出来，两者形成的括号长度再加上左括号索引前一个元素`dp[left-1]`就是当前位置的`dp[i]`\n\n**Update**\n\n回头做第二遍地时候竟然写了个不一样的dp思路hahaha~，还是挺有意思的，遇到右括号不是直接用`i-left+1` 算长度，而是直接根据前一个字符`dp[i-1]` 进行转化，其实是一样的，只不过是累加的，前面的是一次就全算出来了\n\n```java\n//update: 2020.4.13\npublic int longestValidParentheses(String s) {\n    if(s==null || s.length()<=0) return 0;\n    Deque<Integer> stack=new ArrayDeque<>();\n    int[] dp=new int[s.length()];\n    int res=0;\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='('){\n            stack.push(i);\n        }else{\n            if(!stack.isEmpty()){\n                int left=stack.pop();\n                //dp[i]=(left>1?dp[left-1]+dp[i-1]:dp[i-1])+2;\n                dp[i]=dp[i-1]+(left>1?dp[left-1]:0)+2;\n            }\n            res=Math.max(res,dp[i]);\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n纯dp解法，上面的解法虽然也用到了一点动态规划，但是还不够纯粹\n\n```java\npublic int longestValidParentheses(String s) {\n    if (s==null || s.length()<=0) {\n        return  0;\n    }\n    int[] dp=new int[s.length()];\n    dp[0]=0;\n    int res=0;\n    for (int i=1;i<s.length();i++) {\n        if (s.charAt(i)==')') {\n            if (s.charAt(i-1)=='(') { //前一个是左括号\n                dp[i]=i-2>=0?dp[i-2]+2:2;\n            }else{ //前一个是右括号 ()(())\n                if (i-dp[i-1]-1>=0 && s.charAt(i-dp[i-1]-1)=='(') {//前一个右括号的合法序列的前一个是'('\n                    //前一个的前一个的dp[i-dp[i-1]-2]+dp[i-1]+2\n                    dp[i]=(i-dp[i-1]-2>=0?dp[i-dp[i-1]-2]:0)+dp[i-1]+2; \n                }\n                //前一个右括号的合法序列的前一个是')',没救了\n            }\n        }\n        res=Math.max(res,dp[i]);\n    }\n    return res;\n}\n```\n\n解释都在代码注释中，~~感觉没那么容易直接想到，毕竟hard题~~\n\n**Update: 2020.7.4**\n\n今天的打卡题，之前的做法只记得栈+dp的做法，dp的方法忘了，现场写了下纯dp的方法，发现其实纯dp的好像更简单啊，状态定义出来后，转移方程就呼之欲出了（是我变强了么🤣）\n\n```golang\n//和前面的写法不一样，感觉我的更好理解\nfunc longestValidParentheses(s string) int {\n    var dp = make([]int, len(s)) //以s[i]结尾的最长有效括号\n    //dp[0] = 0\n    var res = 0\n    for i := 1; i < len(s); i++{\n        if s[i] == ')' {\n            if i - dp[i-1] - 1 >= 0 && s[i - dp[i-1] - 1] == '('{\n                dp[i] = dp[i - 1] + 2\n                if(i - dp[i-1] - 2 >= 0){\n                    dp[i] += dp[i - dp[i-1] - 2]\n                }\n            }\n        }\n        res = Max(res, dp[i])\n    }\n    return res\n}\n\nfunc Max(a, b int) int{\n    if a > b{\n        return a\n    }\n    return b\n}\n```\n\n> 其实还有两种方法，一种利用纯利用栈的，还有一种很神奇的方法，没什么通用性，很难直接想出来，就不做记录了，纯栈的解法后面再来补充\n\n**解法三**\n\n~~纯利用栈的解法以后再来补充~~ 算了，直接写了吧\n\n```java\npublic int longestValidParentheses(String s) {\n    if (s==null || s.length()<=0) {\n        return  0;\n    }\n    Deque<Integer> stack=new ArrayDeque<>();\n    stack.push(-1); //临界点\n    int res=0;\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)=='('){\n            stack.push(i);\n        }else{\n            stack.pop();\n            if(stack.isEmpty()){ \n                //栈为空,说明当前的')'肯定是不合法的\n                //其实相当于一个分界点,这个位置之前的字符不可能再构成合法的序列了\n                //后面的栈空的时候就不能再根据-1来算长度了,需要一个新的临界点\n                stack.push(i);\n            }else{\n                res=Math.max(res,i-stack.peek());\n            }\n        }\n    }\n    return res;\n}\n```\n关键的地方就在于将**非法的右括号**入栈，作为一个分界点便于后面计算，初始的-1也很关键\n\n**解法四**\n\nUPDATE: 2020.7.4，把之前所谓的“神奇”的方法也记录下，其实也没啥神奇的，看一下就懂了，这种方法还是很优秀的，空间复杂度为`O(1)`\n```golang\n//实时统计左右括号的个数，当匹配的时候统计长度，记得左右都要扫一遍\nfunc longestValidParentheses(s string) int {\n    var left, right = 0, 0\n    var res = 0\n    for i := 0; i < len(s); i++ {\n        if s[i] == '(' {\n            left++\n        } else {\n            right++\n        }\n        if right > left {\n            right, left = 0, 0\n        }else if right == left {\n            res = Max(res, left*2)\n        }\n    }\n    right, left = 0, 0\n    for i := len(s) - 1; i >= 0; i-- {\n        if s[i] == '(' {\n            left++\n        } else {\n            right++\n        }\n        if right < left {\n            right, left = 0, 0\n        } else if right == left {\n            res = Max(res, left*2)\n        }\n    }\n    return res\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n\n## [面试题 17.13. 恢复空格](https://leetcode-cn.com/problems/re-space-lcci/)\n\nDifficulty: **中等**\n\n哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子`\"I reset the computer. It still didn’t boot!\"`已经变成了`\"iresetthecomputeritstilldidntboot\"`。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典`dictionary`，不过，有些词没在词典里。假设文章用`sentence`表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n\n**注意:** 本题相对原题稍作改动，只需返回未识别的字符数\n\n**示例：**\n\n```go\n输入：\ndictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\nsentence = \"jesslookedjustliketimherbrother\"\n输出： 7\n解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。\n```\n\n**提示：**\n\n*   `0 <= len(sentence) <= 1000`\n*   `dictionary`中总字符数不超过 150000。\n*   你可以认为`dictionary`和`sentence`中只包含小写字母。\n\n\n\n**解法一**\n\n同样的解法，用Java写就是922ms，我觉得主要就是substring拖慢了速度，Java里面substring是O(N)的操作，而golang中取切片值仅仅只是修改几个切片的熟悉罢了，时间复杂度是O(1)的，所以会很快，时间复杂度可以近似的看作O(N^2)\n```golang\n//正向dp，60ms\nfunc respace(dictionary []string, sentence string) int {\n    var dict = make(map[string]bool)\n    for i := 0; i < len(dictionary); i++ {\n        dict[dictionary[i]] = true\n    }\n    var n = len(sentence)\n    //前i个字符的最少未识别字符\n    var dp = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        dp[i] = dp[i-1] + 1 //初始值\n        for j := 0; j < i; j++ {\n            if dict[sentence[j:i]] {\n                dp[i] = Min(dp[j], dp[i])\n            }\n        }\n    }\n    return dp[n]\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n> 查询了网上的一些资料，发现Java的substring其实在1.7之前时间复杂度是O(1)的，后面为了避免内存泄漏就改成O(N)了 [参考](https://www.iteye.com/blog/lvdccyb-1947937)\n\n**解法二**\n\n记忆化递归，其实一开始就被题目的tag给迷惑了，我一看记忆化，就直接往记忆化的方向去写了，加上前天刚写了 单词拆分2的记忆化，唉，看来以后不能直接看tag了，一开始写了个贼垃圾的dfs，就是下面注释的部分，时间复杂度爆炸，两层for循环\n```golang\n//记忆化dfs tle了 可能思路有点问题\n//确实是思路出了问题，下面补充了正确的记忆化写法 248ms\nfunc respace(dictionary []string, sentence string) int {\n    var dict = make(map[string]bool)\n    for i := 0; i < len(dictionary); i++ {\n        dict[dictionary[i]] = true\n    }\n    var cache = make(map[string]int)\n    return dfs(sentence, dict, cache)\n}\n\n// func dfs(s string, dict map[string]bool, cache map[string]int) int {\n//     if _, ok := cache[s]; ok {\n//         return cache[s]\n//     }\n//     var res = len(s)\n//     for i := 0; i <= len(s); i++ {\n//         temp := len(s)\n//         for j := i + 1; j <= len(s); j++ {\n//             if dict[s[i:j]] {\n//                 temp = Min(temp, dfs(s[j:], dict, cache))\n//             }\n//         }\n//         res = Min(res, temp+i)\n//     }\n//     cache[s] = res\n//     return res\n// }\n\nfunc dfs(s string, dict map[string]bool, cache map[string]int) int {\n    if _, ok := cache[s]; ok {\n        return cache[s]\n    }\n    var res = len(s)\n    for i := 1; i <= len(s); i++ {\n        if dict[s[:i]] {\n            res = Min(res, dfs(s[i:], dict, cache))\n        }else{\n            res = Min(res, dfs(s[i:], dict, cache) + i)\n        }\n    }\n    cache[s] = res\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n**解法三**\n\n上面的解法从某种角度上来说都还是是属于暴力解法，即使是golang的O(N^2)的方法，哈希表的常数也是很大的，而且因为是存的字符串，所以字符串本身Hash的时间也是不能忽略的，因此我们可以引入**前缀树**，不了解相关知识的可以看我[之前的文章](http://imlgw.top/2019/12/17/zi-dian-shu/)\n\n这里我用golang也写了一版，但是提升不明显，所以用Java重写了一版，时间复杂度有了质的飞跃\n```java\n//Trie+dp 14ms,很强\npublic int respace(String[] dictionary, String s) {\n    Node root = new Node();\n    for (String word : dictionary ) {\n        root.insert(word);\n    }\n    int n = s.length();\n    int[] dp = new int[n+1];\n    for (int i = 1; i <=n ; i++) {\n        dp[i] = dp[i-1] + 1;\n        Node cur = root;\n        for (int j = i-1; j >=0 ; j--) {\n            int c = s.charAt(j)-'a';\n            //很大的优化点，c不存在，那么以c为后缀的其他字符肯定也不会存在，直接break\n            if(cur.next[c] == null){\n                break;\n            }\n            if(cur.next[c].isWord){\n                dp[i] = Math.min(dp[i], dp[j]);\n            }\n            if(dp[i] == 0){\n                break;\n            }\n            cur = cur.next[c];\n        }\n    }\n    return dp[n];\n}\n\n//这里Trie不用写搜索，直接手动的搜索，这样可以做一些剪枝\nclass Node{\n    Node[] next = new Node[26];\n    \n    boolean isWord;\n\n    //反向插入\n    public void insert(String s){\n        Node cur = this;\n        for (int i = s.length()-1; i >= 0; i--) {\n            int c = s.charAt(i)-'a';\n            if(cur.next[c] == null){\n                cur.next[c] = new Node();\n            }\n            cur = cur.next[c];\n        }\n        cur.isWord = true;\n    }\n}\n```\n**解法四**\n\n没错，这题解法很多，也都很值得学习，解法四其实就是之前学过的字符串哈希的方法，所以这个解法右转--->[Rabin-Karp算法](http://imlgw.top/2020/07/01/rabinkarp-suan-fa/#%E9%9D%A2%E8%AF%95%E9%A2%98-17-13-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC)\n\n## [174. 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)\n\nDifficulty: **困难**\n\n\n一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。\n\n骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。\n\n有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。\n\n为了尽快到达公主，骑士决定每次只向右或向下移动一步。\n\n**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**\n\n例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。\n\n<table class=\"dungeon\" style=\"display: table;\">\n\n<tbody style=\"display: table-row-group;\">\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-2 (K)</td>\n\n<td style=\"display: table-cell;\">-3</td>\n\n<td style=\"display: table-cell;\">3</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">-5</td>\n\n<td style=\"display: table-cell;\">-10</td>\n\n<td style=\"display: table-cell;\">1</td>\n\n</tr>\n\n<tr style=\"display: table-row;\">\n\n<td style=\"display: table-cell;\">10</td>\n\n<td style=\"display: table-cell;\">30</td>\n\n<td style=\"display: table-cell;\">-5 (P)</td>\n\n</tr>\n\n</tbody>\n\n</table>\n\n**说明:**\n\n*   骑士的健康点数没有上限。\n\n*   任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。\n\n\n**解法一**\n\n以后每日一题没写出来之前绝壁不看群了，看了一眼群，看见群友讨论了这题，说了二分和dp，然后我就直接向二分的方向去想了，如果独立的想的话，应该也是可以得出二分的解法的，毕竟题目的描述很明显就是二分答案，**最低的健康血量**，大于这个血量的肯定可以救出来，小于这个血量的肯定救不出来，所以check就是判断在某个血量下，能否拯救到公主（DP）\n\n时间复杂度O(N^2logN)（其实我认为也可以当作N^2毕竟上下界都确定了，logN也就30左右），这种解法也挺不错的，融合了二分和dp\n\n```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int left = 0;\n    int right = Integer.MAX_VALUE;\n    int res = 0;\n    while(left <= right){\n        int mid = left + (right-left)/2;\n        if(check(dungeon, mid)){\n            res = mid;\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return res;\n}\n\npublic boolean check(int[][] dungeon, int live){\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MIN_VALUE;\n    //live的血量从左上到dungeon[i][j]的剩余最多血量\n    int[][] dp = new int[m+1][n+1];\n    //地牢外围加上INF的围墙，简化逻辑\n    Arrays.fill(dp[0], INF);\n    dp[0][1] = live;\n    for(int i = 1; i <= m; i++){\n        dp[i][0] = INF;\n        for(int j = 1; j <= n; j++){\n            if(dp[i-1][j] <= 0 && dp[i][j-1] <=0 ){\n                dp[i][j] = INF; //无法到达这里\n            }else{\n                dp[i][j] = dungeon[i-1][j-1] + Math.max(dp[i][j-1], dp[i-1][j]);\n            }\n        }\n    }\n    return dp[m][n] > 0;\n}\n```\n当然这题也有纯dp的做法，很可惜，我压根没往上面想，我只想着二分dp，写完了AC之后就去看评论区了，结果发现大家都是直接dp的。。。然后还看到了一个关键词：逆向dp，然后赶紧关了评论区回来写了下面的dp解法\n\n**解法二**\n```java\n/*\n    -2  -3  3\n    -5 -10  1\n    10  30 -5 1\n            \n    7   5   2\n    6  11   5\n    1   1   6\n*/\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length;\n    int n = dungeon[0].length;\n    int INF = Integer.MAX_VALUE;\n    //从dungeon[i-1][j-1]到右下角至少要多少血量\n    int[][] dp = new int[m+1][n+1];\n    Arrays.fill(dp[m], INF);//末行\n    dp[m][n-1] = 1; //初始血量\n    for (int i = m-1; i >= 0; i--) {\n        dp[i][n] = INF; //首列和尾列\n        for (int j = n-1; j >= 0; j--) {\n            dp[i][j] = Math.max(Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1);\n        }\n    }\n    return dp[0][0];\n}\n```\n这题为啥不能正向dp呢，设`dp[i][j]`为从左上角到i,j所需要的最低血量? 其实这个很明显就是有问题的，没办法转移，`dp[i][j]`和`dp[i-1][j]`没有任何关系，都不一定是同一条路径\n\n## [97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/)\n\nDifficulty: **困难**\n\n\n给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。\n\n**示例 1:**\n\n```go\n输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n输出: true\n```\n\n**示例 2:**\n\n```go\n输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n输出: false\n```\n\n**解法一**\n![Ugzon0.png](https://s1.ax1x.com/2020/07/18/Ugzon0.png)\n```java\npublic boolean isInterleave(String s1, String s2, String s3) {\n    int ns1 = s1.length(), ns2 = s2.length(), ns3 = s3.length();\n    if(ns1+ns2!=ns3) return false;\n    boolean[][] dp = new boolean[ns1+1][ns2+1];\n    for(int i = 1; i <= ns1 && s1.charAt(i-1)==s3.charAt(i-1); i++){\n        dp[i][0] = true;\n    }\n    for(int i = 1; i <= ns2 && s2.charAt(i-1)==s3.charAt(i-1); i++){\n        dp[0][i] = true;\n    }\n    dp[0][0] = true;\n    for(int i = 1; i <= ns1; i++){\n        for(int j = 1; j <= ns2; j++){\n            char sc = s3.charAt(i+j-1);\n            dp[i][j] = (sc == s1.charAt(i-1) && dp[i-1][j]) \n                || sc == s2.charAt(j-1) && dp[i][j-1];\n        }\n    }\n    return dp[ns1][ns2];\n}\n```\n\n## [857. 最小的窗口子序列（LintCode）](https://www.lintcode.com/problem/minimum-window-subsequence/description)\n\n\n给定字符串S和T，在字符串S中找到最小(连续的)子字符串W（窗口），使得T是W的子序列。\n如果S中没有包含T中的所有字符的窗口，则返回空字符串\"\"。如果有多个这样的最小长度窗口，则返回一个起点编号最小的。\n1. 输入中的所有字符串只包含小写字母。\n2. S的长度范围在[1, 20000]。\n3. T的长度范围在[1, 100]。\n\n**样例 1:**\n```go\n输入：S=\"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\"，T=\"u\"\n输出：\"\"\n解释： 无法匹配\n```\n**样例 2:**\n```go\n输入：S = \"abcdebdde\"， T = \"bde\"\n输出：\"bcde\"\n解释：\"bcde\"是答案，\"deb\"不是一个较小的窗口，因为窗口中的T元素必须按顺序发生。\n```\n**解法一**\n\nLeetCode上是会员题，所以在LintCode上写的，一开始以为是滑窗，想了半天，也只有暴力的思路，看了下讨论区，发现大家都是dp做的。。。\n\n```java\npublic String minWindow(String S, String T) {\n    int m = S.length(), n = T.length();\n    //S前i个字符包含T前j个字符的最小窗口子序列起始位置\n    int[][] dp = new int[m+1][n+1];\n    for (int i = 0; i <= m; i++){\n        //虽然T串为空，但是注意这里不是0，因为需要最短，所以起点越靠后越短\n        //最后的长度就是通过 i-dp[i][j]来计算的\n        Arrays.fill(dp[i], -1);\n        dp[i][0] = i;\n    }\n    int start = -1, end = m;\n    for (int i = 1; i <= m; i++) {\n        //注意T的长度小于S的长度(不考虑也可以，只是会多遍历很多次)\n        for (int j = 1; j <= Math.min(n, i); j++){\n            if (S.charAt(i-1) == T.charAt(j-1)) {\n                dp[i][j] = dp[i-1][j-1];\n            }else{\n                //dbd\n                //  b   dbd和db包含b的最小窗口起始位置一样\n                dp[i][j] = dp[i-1][j];\n            }\n            \n        }\n        if (dp[i][n]!=-1 && i-dp[i][n] < end-start+1) {\n            start = dp[i][n];\n            end = i-1;\n        }\n    }\n    return start==-1 ? \"\" : S.substring(start,end+1);\n}\n```\n这题和滑动窗口专题中的 [最小覆盖子串](http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)\n算是一道姊妹题，但是解法确完全不一样，当然这题也可以滑窗但是并不是很通用（主要是我没看懂）貌似会比dp要好\n>双序列型DP，后面有时间会把类似的题单独抽取出来\n\n## [1553. 吃掉 N 个橘子的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges/)\n\nDifficulty: **困难**\n\n厨房里总共有 `n` 个橘子，你决定每一天选择如下方式之一吃这些橘子：\n\n*   吃掉一个橘子。\n*   如果剩余橘子数 `n` 能被 2 整除，那么你可以吃掉 `n/2` 个橘子。\n*   如果剩余橘子数 `n` 能被 3 整除，那么你可以吃掉 `2*(n/3)` 个橘子。\n\n每天你只能从以上 3 种方案中选择一种方案。\n\n请你返回吃掉所有 `n` 个橘子的最少天数。\n\n**示例 1：**\n\n```golang\n输入：n = 10\n输出：4\n解释：你总共有 10 个橘子。\n第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。\n第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）\n第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。\n第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。\n你需要至少 4 天吃掉 10 个橘子。\n```\n\n**示例 2：**\n\n```golang\n输入：n = 6\n输出：3\n解释：你总共有 6 个橘子。\n第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）\n第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）\n第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。\n你至少需要 3 天吃掉 6 个橘子。\n```\n\n**示例 3：**\n\n```golang\n输入：n = 1\n输出：1\n```\n\n**示例 4：**\n\n```golang\n输入：n = 56\n输出：6\n```\n\n**提示：**\n\n*   `1 <= n <= 2*10^9`\n\n**解法一**\n\n题目很简单，暴力的方法非常容易想到，但是问题是这题的数据范围比较大`2*1e9`，直接暴搜肯定会T，所以需要优化下，这里我们可以直接将`minDays(n-1)`优化掉，将这种只吃一个的情况和其他情况和并，比如我现在n=5，那么我们就可以直接求`Min(minDays(2)+1, minDays(1)+2)`，5没法被2或者3整除，所以我们将5吃掉几个，变成可以被2和3整除的，吃掉的个数就是n%2和n%3，也就是在这之前额外需要的天数\n```golang\nvar dp = make(map[int]int)\n​\nfunc minDays(n int) int {\n    if n == 1 || n == 0 {\n        return n\n    }\n    if v, ok := dp[n]; ok {\n        return v\n    }\n    res := 1+Min(minDays(n/2)+n%2, minDays(n/3)+n%3)\n    dp[n] = res\n    return res\n}\n​\nfunc Min (a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n---\n\n## [NC549.变向](https://www.nowcoder.com/practice/85efab854e60499daa524ca943b72d35)\n\n牛牛准备在一个3行n列的跑道上跑步。一开始牛牛可以自己选择位于(1,1)还是(2,1)还是(3,1)。\n\n跑道的每一格都有一些金币，当牛牛跑到一个格子，他会获得这个格子的所有金币。\n\n当牛牛位于第i行第j列时，他可以的下一步最多可能有三种选择：\n\n1. 不花费金币跑到第i行第j+1列\n2. 花费`m[j]`的金币跑到第i-1行第j+1列（如果i=1则不可以这么跑）。\n3. 花费`m[j]`的金币跑到第i+1行第j+1列（如果i=3则不可以这么跑）。\n（牛牛是一个富豪，本身带了很多的金币，所以你不用担心他钱不够用）\n现在告诉你所有格子的金币数量和每一列的金币花费，牛牛想知道他跑到第n列最多可以赚得多少金币（赚得金币=获得金币-消耗金币）\n\n**示例1**\n```go\n输入：3,[1,9,3],[6,4,6],[1,1,5],[3,2,1]\n输出: 16\n说明: 一开始牛牛选择位于第2行第1列，拿到6个金币。然后牛牛花3金币到第1行的2列拿到9个金币，最后牛牛花费2金币到第2行第3列。总共获得21金币，消耗5金币。赚得16金币。\n```\n**备注:**\n\n- 2 <= n <= 1e5\n\n- 第1个参数n代表跑道的列数\n第2，3，4个参数vector<int> a1,a2,a3各有n个元素，代表第1，2，3行每一列的金币个数\n第5个参数vector<int> m有n个元素代表每一列进行换行的时候需要的金币花费\n\n**解法一**\n\n题目意思搞清楚就行了\n```java\n//很直白的dp\npublic int solve (int n, int[] a1, int[] a2, int[] a3, int[] m) {\n    // write code here\n    int[][] dp = new int[3][n];\n    dp[0][0] = a1[0];\n    dp[1][0] = a2[0];\n    dp[2][0] = a3[0];\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = a1[j] + Math.max(dp[0][j-1], dp[1][j-1]-m[j-1]);\n        dp[1][j] = a2[j] + Math.max(dp[1][j-1], Math.max(dp[0][j-1]-m[j-1], dp[2][j-1]-m[j-1]));\n        dp[2][j] = a3[j] + Math.max(dp[2][j-1], dp[1][j-1]-m[j-1]);\n    }\n    return Math.max(dp[0][n-1],Math.max(dp[1][n-1], dp[2][n-1]));\n}\n```\n## [NC554 简单变向](https://www.nowcoder.com/practice/11f7c6cb54524c3693119e4088533305)\n牛牛准备在一个3行n列的跑道上跑步。一开始牛牛位于(1,1)。\n\n当牛牛位于第i行第j列时，他可以的下一步最多可能有三种选择：\n\n1. 跑到第i行第j+1列\n2. 跑到第i-1行第j+1列（如果i=1则不可以这么跑）。\n3. 跑到第i+1行第j+1列（如果i=3则不可以这么跑）。\n\n跑道上有一些格子设置了路障(一个格子可能有多个路障)，牛牛不能跑到路障上。现在牛牛想知道，从(1,1)到(3,n)有多少条不同的路径？\n\n为了防止答案过大，答案对1e9+7取模。\n\n比较简单就不贴case了\n\n**解法一**\n\n注意溢出就行了\n```java\npublic int solve (int n, int m, int[] x, int[] y) {\n    long[][] dp = new long[3][n+1];\n    int MOD = (int)1e9+7;\n    boolean[][] v = new boolean[3][n];\n    for(int i = 0; i < m; i++){\n        v[x[i]-1][y[i]-1] = true;\n    }\n    dp[0][0] = 1;\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = v[0][j] ? 0 : (dp[0][j-1] + dp[1][j-1])%MOD;\n        dp[1][j] = v[1][j] ? 0 : (dp[1][j-1] + dp[0][j-1]+dp[2][j-1])%MOD;\n        dp[2][j] = v[2][j] ? 0 : (dp[2][j-1] + dp[1][j-1])%MOD;\n    }\n    return  (int)(dp[2][n-1]%MOD);\n}\n```\n## [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)\n\nDifficulty: **中等**\n\n\n有 `n` 个城市通过 `m` 个航班连接。每个航班都从城市 `u` 开始，以价格 `w` 抵达 `v`。\n\n现在给定所有的城市和航班，以及出发城市 `src` 和目的地 `dst`，你的任务是找到从 `src` 到 `dst` 最多经过 `k` 站中转的最便宜的价格。 如果没有这样的路线，则输出 `-1`。\n\n**示例 1：**\n\n```go\n输入: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\n输出: 200\n解释: \n城市航班图如下\n\n从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。\n```\n\n**示例 2：**\n\n```go\n输入: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 0\n输出: 500\n解释: \n城市航班图如下\n\n从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。\n```\n\n**提示：**\n\n*   `n` 范围是 `[1, 100]`，城市标签从 `0` 到 `n` `- 1`.\n*   航班数量范围是 `[0, n * (n - 1) / 2]`.\n*   每个航班的格式 `(src,` `dst``, price)`.\n*   每个航班的价格范围是 `[1, 10000]`.\n*   `k` 范围是 `[0, n - 1]`.\n*   航班没有重复，且不存在环路\n\n\n**解法一**\n\n范围很小只有100，一开始以为是Floyd，但是有K的限制不好处理\n```golang\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\n    //dp[i][k]：从src到i节点中转k次最短距离\n    var Min = func(a, b int) int {if a<b {return a};return b}\n    var INF = 0x3f3f3f3f\n    var dp = make([][]int, n)\n    for i := 0; i < n; i++ {\n        //K+2是为了方便初始化，不用单独处理K==0的情况\n        dp[i] = make([]int, K+2)\n        for j := 0; j <= K+1; j++ {\n            dp[i][j] = INF   \n        }\n    }\n    for k := 0; k <= K+1; k++ {\n        dp[src][k] = 0\n    }\n    for k := 1; k <= K+1; k++ {\n        for _,flt := range flights {\n            //src到flt[1]通过flt[0]中转\n            dp[flt[1]][k] = Min(dp[flt[1]][k], dp[flt[0]][k-1]+flt[2])\n        }\n    }\n    if dp[dst][K+1] == INF {\n        return -1\n    }\n    return dp[dst][K+1]\n}\n```\n> 这题也可以`Dijkstra`但是我不会\n\n## [NC557.好多牛牛](https://www.nowcoder.com/practice/edced5e80f3e46efa9c965e7f634c58c)\n\n给出一个字符串S，牛牛想知道这个字符串有多少个子序列等于\"niuniu\"子序列可以通过在原串上删除任意个字符(包括0个字符和全部字符)得到。为了防止答案过大，答案对1e9+7取模\n\n**示例1**\n```go\n输入: \"niuniniu\"\n输出: 3\n说明:\n删除第4，5个字符可以得到\"niuniu\"\n删除第5，6个字符可以得到\"niuniu\"\n删除第6，7个字符可以得到\"niuniu\"\n```\n**备注:**\n10 <= len(s) <= 1e5\n\n**解法一**\n\n菜啊，没想出来，真的菜\n```java\n//UPDATE: 2020.9.27，之前的解法过了OJ，但是其实是有问题的\n//二维DP（不方便优化成一维的）\npublic int solve1 (String s) {\n    // write code here \n    String p = \"niuniu\";\n    int m = p.length();\n    int n = s.length();\n    int MOD = (int)1e9+7;\n    //dp[i][j]代表s[0,j]中有多少个p[0,j]\n    long[][] dp = new long[7][n+1];\n    Arrays.fill(dp[0], 1);\n    for (int i = 1; i <= m; i++){\n        for (int j = 1; j <= n; j++){\n            if (s.charAt(j-1) == p.charAt(i-1)) {\n                //dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n                //上面的是错的，之所以正确是因为题目的niuniu没有连续的相同字符\n                //考虑如下case:  p = \"aa\" , s = \"abaa\" wa = 6, ac = 3\n                dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % MOD;\n            } else {\n                dp[i][j] = dp[i][j-1];\n            }\n        }\n    }\n    return (int)dp[m][n];\n}\n```\n实际上这个解法最好把内外循环交换下，这样更好降维\n```java\n//二维DP，交换内外循环\npublic int solve2 (String s) {\n    // write code here \n    String p = \"niuniu\";\n    int n = s.length();\n    int m = p.length();\n    int MOD = (int)1e9+7;\n    //dp[i][j]代表s[0,i]中有多少个p[0,j]\n    long[][] dp = new long[n+1][m+1];\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        dp[i][0] = 1;\n        for (int j = 1; j <= m; j++){\n            if (s.charAt(i-1) == p.charAt(j-1)) {\n                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;\n            } else {\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return (int)dp[n][m];\n}\n```\n**解法二**\n\n按照上面交换内外循环后的解法再降维\n```java\n//UPDATE: 2020.9.27，之前的解法过了OJ，但是其实是有问题的\n//按上面的来降维舒服多了\npublic int solve3 (String s) {\n    String p = \"niuniu\";\n    int n = s.length();\n    int m = p.length();\n    int MOD = (int)1e9+7;\n    //dp[j]代表s[0,i]中有多少个p[0,i]\n    long[] dp = new long[m+1];\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++){\n        //for (int j = 1; j <= m; j++){\n        //内层应该反过来递推，保证dp[j]和dp[j-1]是上一次的\n        for (int j = m; j >= 1; j--){\n            if (s.charAt(i-1) == p.charAt(j-1)) {\n                dp[j] = (dp[j] + dp[j-1]) % MOD;\n            }\n        }\n    }\n    return (int)dp[m];\n}\n```\n\n## [926. 将字符串翻转到单调递增](https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/)\n\nDifficulty: **中等**\n\n\n如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是_单调递增_的。\n\n我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 `S`，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。\n\n返回使 `S` 单调递增的最小翻转次数。\n\n**示例 1：**\n\n```go\n输入：\"00110\"\n输出：1\n解释：我们翻转最后一位得到 00111.\n```\n\n**示例 2：**\n\n```go\n输入：\"010110\"\n输出：2\n解释：我们翻转得到 011111，或者是 000111。\n```\n\n**示例 3：**\n\n```go\n输入：\"00011000\"\n输出：2\n解释：我们翻转得到 00000000。\n```\n\n**提示：**\n\n1.  `1 <= S.length <= 20000`\n2.  `S` 中只包含字符 `'0'` 和 `'1'`\n\n**解法一**\n\n动态规划的解法\n\n```golang\nfunc minFlipsMonoIncr(S string) int {\n    var n = len(S)\n    //dp[i][0]: [0~i] s[i]==0 需要最小额翻转次数\n    //dp[i][1]: [0~i] s[i]==1 需要最小额翻转次数\n    var dp = make([][2]int, n)\n    var Min = func(a, b int) int {if a < b {return a}; return b}\n    var preSum = make([]int, n+1)\n    for i := 1; i <= n; i++ { \n        preSum[i] = preSum[i-1] + int(S[i-1]-48)\n    }\n    if S[0] == '1' {\n        dp[0][0] = 1\n    }else {\n        dp[0][1] = 1\n    }\n    for i := 1; i < n; i++ {\n        if S[i] == '1' {\n            dp[i][1] = Min(dp[i-1][1], dp[i-1][0])\n            dp[i][0] = preSum[i+1] //包含i\n        } else {\n            dp[i][0] = preSum[i] //不包含i\n            dp[i][1] = Min(dp[i-1][0], dp[i-1][1]) + 1\n        }\n    }\n    return Min(dp[n-1][1], dp[n-1][0])\n}\n```\n\n**解法二**\n\n寻找分割点，使得分割点左边的1和右边的0相加的和最少\n\n```golang\n//Trick，寻找分割点，使得分割点左边的1和右边的0相加的和最少\nfunc minFlipsMonoIncr(S string) int {\n    var count0 = 0 //分割点右边的0\n    var count1 = 0 //分割点左边的1\n    var Min = func(a, b int) int {if a < b {return a}; return b}\n    for i := 0; i < len(S); i++ {\n        if S[i] == '0' {\n            count0++\n        }\n    }\n    var res = count0\n    for i := 0; i < len(S); i++ {\n        if S[i] == '1' {\n            count1++\n        } else {\n            count0--\n        }\n        res = Min(res, count1+count0)\n    }\n    return res\n}\n```\n\n## [LCP 19. 秋叶收藏集](https://leetcode-cn.com/problems/UlBDOe/)\n\n小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。\n出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。\n\n**示例 1：**\n```go\n输入：leaves = \"rrryyyrryyyrr\"\n输出：2\n解释：调整两次，将中间的两片红叶替换成黄叶，得到 \"rrryyyyyyyyrr\"\n```\n**示例 2：**\n```go\n输入：leaves = \"ryr\"\n输出：0\n解释：已符合要求，不需要额外操作\n提示：\n3 <= leaves.length <= 10^5\nleaves 中只包含字符 'r' 和字符 'y'\n```\n\n**解法一**\n\n和上一题[926. 将字符串翻转到单调递增](#926-将字符串翻转到单调递增)一样，不过很明显这里有三个状态，一个是前面的r结尾，一个是中间的y结尾，一个是末尾的r结尾，最后求出以最后的r结尾的最短次数就ok了\n```java\npublic int minimumOperations(String s) {\n    int n = s.length();\n    int[][] dp = new int[n+1][3];\n    //0，1，2分别代表 前面的r 中间的y 结尾的r\n    dp[0][0] = s.charAt(0) == 'r' ? 0 : 1;\n    dp[0][1] = dp[0][2] = dp[1][2] = 0x3f3f3f3f;\n    //简单的递推\n    for (int i = 1; i < n; i++) {\n        if (s.charAt(i) == 'r') {\n            dp[i][0] = dp[i-1][0];\n            dp[i][1] = Math.min(dp[i-1][1]+1, dp[i-1][0]+1);\n            dp[i][2] = Math.min(dp[i-1][2], dp[i-1][1]);\n        } else {\n            dp[i][0] = dp[i-1][0]+1;\n            dp[i][1] = Math.min(dp[i-1][0], dp[i-1][1]);\n            dp[i][2] = Math.min(dp[i-1][2]+1, dp[i-1][1]+1);\n        }\n    }\n    return dp[n-1][2];\n}\n```\n> 空间还可以优化，代码也还可以更简洁，不过我懒得改了\n\n## [845. 数组中的最长山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/)\n\nDifficulty: **中等**\n\n我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “_山脉”_：\n\n*   `B.length >= 3`\n*   存在 `0 < i < B.length - 1` 使得 `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\n\n（注意：B 可以是 A 的任意子数组，包括整个数组 A。）\n\n给出一个整数数组 `A`，返回最长 _“山脉”_ 的长度。\n\n如果不含有 “_山脉” _则返回 `0`。\n\n**示例 1：**\n\n```go\n输入：[2,1,4,7,3,2,5]\n输出：5\n解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。\n```\n\n**示例 2：**\n\n```go\n输入：[2,2,2]\n输出：0\n解释：不含 “山脉”。\n```\n\n**提示：**\n\n1.  `0 <= A.length <= 10000`\n2.  `0 <= A[i] <= 10000`\n\n示例 1：\n\n```go\n输入：[2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉是 [1,4,7,3,2]，长度为 5。\n```\n\n**示例 2：**\n\n```go\n输入：[2,2,2]\n输出：0\n解释：不含山脉\n```\n\n**解法一**\n\n遍历的过程中记录上升和下降的长度，然后注意重置的时机，当且仅当up和down都大于0的时候为合法，统计一个最大值就可以了\n```java\npublic int longestMountain(int[] A) {\n    int res = 0;\n    int up = 0, down = 0;\n    //[2,1,4,7,3,2,5]\n    for (int i = 1; i < A.length; i++) {\n        //前面是下降，这里开始增加或者和前一个元素相同，需要重置\n        if ((down > 0 && A[i] > A[i-1]) || A[i] == A[i-1]) {\n            up = down = 0;\n        }\n        up += A[i] > A[i-1] ? 1 : 0;\n        down += A[i] < A[i-1] ? 1 : 0;\n        if (up > 0 && down > 0) {\n            res = Math.max(res, up+down+1);   \n        }\n    }\n    return res;\n}\n```\n## _区间DP_\n\n后面有时间会单独将这些题目分类整理成文章，目前暂时先这样\n\n\n\n## [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)\n\n有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\n\n现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。\n\n求所能获得硬币的最大数量。\n\n**说明:**\n\n- 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。\n- 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\n\n**示例:**\n\n```java\n输入: [3,1,5,8]\n输出: 167 \n解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n```\n\n**解法一**\n\n暴力回溯，其实就是尝试所有的组合，这样时间复杂度`O(N!)` ，数据超过十几就不行了\n\n```java\npublic int maxCoinsTLE(int[] nums) {\n    LinkedList<Integer> list=new LinkedList<>();\n    for (int n:nums) list.add(n);\n    dfs(list,0);\n    return max;\n}\n\nprivate int max=0;\n\npublic void dfs(LinkedList<Integer> list,int sum) {\n    if (list.size()==0) {\n        max=Math.max(sum,max);\n        return;\n    }\n    for (int i=0;i<list.size();i++) {\n        int temp=list.get(i);\n        //这个值要先算\n        int cur=(i-1<0?1:list.get(i-1))*(i+1>=list.size()?1:list.get(i+1))*temp;\n        list.remove(i);\n        dfs(list,sum+cur);\n        list.add(i,temp);\n    }\n}\n```\n\n**解法二**\n\n区间型动态规划，也是我第一次听说这个名词，但是之前其实已经做了不少的区间型的dp了\n\n```java\npublic int maxCoins(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int[] A=new int[nums.length+2];\n    A[0]=1;A[A.length-1]=1;\n    for (int i=0;i<nums.length;i++) {\n        A[i+1]=nums[i]; //copy一个新数组\n    }\n    //区间DP\n    int n=A.length;\n    int[][] dp=new int[n][n]; //dp[i][j]代表的是不包含边界i,j的最大得分\n    for (int len=2;len<=n;len++) { //枚举区间长度\n        for (int i=0;i<=n-len;i++) { //枚举起点\n            int j=i+len-1; //区间终点\n            for (int k=i+1;k<j;k++) { //枚举分割点\n                dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+A[k]*A[i]*A[j]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n\n这里为了处理边界将数组头尾插入了1，copy了一个新的数组，下面的区间型dp也是在看了题解，然后对着板子写的，当然这题的关键不是这里，关键是如何规划，这里搬运 [题解区大佬](https://leetcode-cn.com/problems/burst-balloons/solution/dong-tai-gui-hua-qiu-jie-by-feng-ji-wei-wang/) 的解释\n\n我们来分析一下按照上面的那个递归的思路状态转移方程能写吗？如果按照上面的递归的思路，我们定义dp[i][j]表示对于i-j的气球的最大的收益，那状态转移方程就是\n\n`dp[i][j]=max(coins[k]* coins[k-1] * coins[k+1]+dp[i][k-1]+dp[k+1][j]) k∈[i,j]`,\n\n就按上面的那个例子，[3,1,5,8],来写一下过程\n\n```java\n扎爆3 剩下[]和[1,5,8]\n扎爆1 剩下[3]和[5,8]\n扎爆5 剩下[3,1]和[8]\n扎爆8 剩下[3,1,5]和[]\n```\n\n然后在这些里面找到一个最大值返回，这其中对于扎爆1和8的最大的收益这样定义是没有问题的，因为两者都在边界，但是对于扎爆1和5就有问题了，就拿先扎爆1来说，扎爆1，剩下的最大的收益变为了[3]和[5,8]这两个区间的最大的收益的和，这个肯定不对，因为剩下的[3,5,8]区间的最大的收益的和不会是[3]的最大收益和与[5,8]的最大收益和的总和构成的，所以这个状态转移方程是不对的\n\n那应该怎么定义状态转移方程呢，这也就是这道题巧妙的地方，它使用逆向思维，也就是上面的状态转移方程是由某个气球先爆得出来的，那么这里我们让指定的气球最后爆，这样的话状态转移方程为\n\n`dp[i][j]=max(coins[k]*coins[i-1]*coins[j+1]+dp[i][k-1]+dp[k+1][j]) k∈[i,j]` \n\n再来看上面的例子，就对了，也就是对于[i,j]的气球，我们让某个位置的气球最后再爆，求出它左区间的最大的收益和右区间的最大的收益，加上这个气球最后爆掉所获得的收益，一 一比较，返回一个最大值就好了，这里要注意的是，要按区间的长度来进行状态的转移，也就是先求长度为1的，然后2的依次类推，因为这里状态转移方程涉及到了当前位置的后面的区间的最大的收益，但是后面的区间的长度是小于当前区间的长度的，故应该按长度来进行状态的转移，这也是典型的区间型动态规划的套路\n\n**解法三**\n\n在解法二的基础上简化了代码，`dp[i][j]`代表`i`和`j`之间，包含`i`和`j`位置，戳爆所有气球的最大得分\n\n```java\npublic int maxCoins(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return 0;\n    }\n    int n=nums.length;\n    //dp[i][j]代表的是包含边界i,j的最大得分\n    int[][] dp=new int[n][n]; \n    for (int len=1;len<=n;len++) { //枚举区间长度\n        for (int i=0;i<=n-len;i++) { //枚举起点\n            int j=i+len-1; //区间终点\n            for (int k=i;k<=j;k++) { //枚举分割点\n                dp[i][j]=Math.max(dp[i][j],(k-1>=0?dp[i][k-1]:0)+(k+1<n?dp[k+1][j]:0)+nums[k]*(i-1>=0?nums[i-1]:1)*(j+1<n?nums[j+1]:1));\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n\n**UPDATE:2020.7.19**\n打卡题，重新写一遍，稍微好一点的写法，上面一堆三目不太好\n\n```golang\nfunc maxCoins(nums []int) int {\n    if len(nums) <= 0{\n        return 0\n    }\n    nums = append(nums, 1)\n    nums = append([]int{1}, nums...)\n    var n = len(nums)\n    var dp = make([][]int, n)\n    for i := 0; i < n; i++{\n        dp[i] = make([]int, n)\n    }\n    for tlen := 1; tlen <= n-2; tlen++{ //枚举区间长度\n        for left := 1; left+tlen-1 < n-1; left++{ //枚举左端点\n            right := left+tlen-1 //右端点\n            for k := left; k <= right; k++{ //枚举分割点\n                dp[left][right] = Max(dp[left][right], dp[left][k-1]+dp[k+1][right]+nums[k]*nums[left-1]*nums[right+1])\n            }\n        }\n    }\n    return dp[1][n-2]\n}\n\nfunc Max(a, b int)int{\n    if a > b{\n        return a\n    }\n    return b\n}\n```\n\n\n## [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子**排成一行**，每堆都有正整数颗石子 `piles[i]` 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 `true` ，当李赢得比赛时返回 `false` 。\n\n**示例：**\n\n```java\n输入：[5,3,4,5]\n输出：true\n解释：\n亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。\n如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。\n```\n\n**提示：**\n\n1. `2 <= piles.length <= 500`\n2. `piles.length` 是偶数。\n3. `1 <= piles[i] <= 500`\n4. `sum(piles)` 是奇数。\n\n**解法一**\n\n博弈型dp，先采用区间dp的解法试试（区间dp是真的妙啊！！！)\n\n```java\n//通用的区间DP\npublic boolean stoneGame(int[] piles) {\n    //[5,3,4,5]\n    int N=piles.length;\n    //(i~j) 先手(0),后手(1)的最大收益\n    int[][][] dp=new int[N][N][2];\n    //base init len=1的情况\n    for(int i=0;i<N;i++){\n        dp[i][i][0]=piles[i];\n        dp[i][i][1]=0;\n    }\n    for (int len=2;len<=N;len++) { //枚举区间长度\n        for (int left=0;left<=N-len;left++) { //枚举所有区间\n            //left+len-1<N\n            int right=left+len-1;\n            //先手拿left或者right的最大收益\n            //我先手拿了left或者right之后，剩下[left+1,right]或[left,right-1]区间\n            //我在剩下的区间中继续选其实就成为了后手，所以我们加上剩下区间的后手最大值\n            int firLeft=piles[left]+dp[left+1][right][1];\n            int firRight=piles[right]+dp[left][right-1][1];\n            if(firLeft>firRight){\n                dp[left][right][0]=firLeft;\n                //先手选left那么就相当于让另一个人（后手）从[left+1,right]中先手取最大值\n                dp[left][right][1]=dp[left+1][right][0];\n            }else{\n                dp[left][right][0]=firRight;\n                //同上\n                dp[left][right][1]=dp[left][right-1][0];\n            }\n        }\n    }\n    return dp[0][N-1][0]-dp[0][N-1][1]>0;\n}\n```\n**解法二**\n\n数学推理的方法，具体的证明给不出来，但是很容易理解它的正确性\n\n```java\n//数学\npublic boolean stoneGame(int[] piles) {\n    return true;\n}\n```\n首先题目有两个特殊的条件（这两个条件我解法一没用到）`piles.length` 是偶数，`sum(piles)` 是奇数，这其实说明了不会有平局，因为是偶数，我们把所有的柱子用奇偶来划分，那么奇数柱子和偶数**石头堆的数量**一定是相同的，而且**两者总的石头数一定有一个数量的差异**，不可能相等，我先手拿的话我就可以只考虑拿较大的那一类石头堆，那我能保证我拿到的一定是奇数或偶数的堆吗？其实随便举一个例子就知道了，比如4堆石头，先手的人总是能控制自己一定拿到1，3或者2，4所以先手的一定是可以赢得，推广到N堆石头也同样适用\n\n## [1039. 多边形三角剖分的最低得分](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/)\n\n给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 `A[0], A[i], ..., A[N-1]`。\n\n假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。\n\n返回多边形进行三角剖分后可以得到的最低分。\n\n**示例 1：**\n\n```java\n输入：[1,2,3]\n输出：6\n解释：多边形已经三角化，唯一三角形的分数为 6。\n```\n\n**实例2：**\n\n![J8IK8U.png](https://s1.ax1x.com/2020/04/21/J8IK8U.png)\n\n```java\n输入：[3,7,4,5]\n输出：144\n解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。\n```\n\n**解法一**\n\n区间DP套路，枚举所有的区间和区间内的点，`区间内的点`和`区间左右端点`将整个区间又划分为两个`已知的子区间`，典型的区间dp\n\n```java\n//环形的结构\npublic int minScoreTriangulation(int[] A) {\n    if(A==null || A.length<=0) return 0;\n    int N=A.length;\n    //从 0 ~ N-1 形成一个环\n    //    1-3 \n    //   /    \\\n    //  5      1\n    //   \\    /\n    //    1—4\n    // dp[left][right] 代表left~right区间形成的环的最小得分值\n    int[][] dp=new int[N][N];\n    for (int len=3;len<=N;len++) { //枚举长度,从3开始\n        for (int left=0;left<=N-len;left++) { //枚举左端点\n            //left+len-1<N\n            int right=left+len-1;\n            //init初始化区间值\n            dp[left][right]=Integer.MAX_VALUE;\n            for (int i=left+1;i<right;i++) { //枚举区间内的所有的点(不包括端点)),将环分割成左右两部分\n                dp[left][right]=Math.min(dp[left][right],dp[left][i]+dp[i][right]+A[i]*A[left]*A[right]);\n            }\n        }\n    }\n    return dp[0][N-1];\n}\n```\n\n## [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)\n\n给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。\n\n**示例 1:**\n\n```java\n输入:\n\n\"bbbab\"\n输出:\n\n4\n一个可能的最长回文子序列为 \"bbbb\"。\n```\n\n**示例 2:**\n\n```java\n输入:\n\n\"cbbd\"\n输出:\n\n2\n一个可能的最长回文子序列为 \"bb\"。\n```\n\n**解法一**\n\n动态规划，`dp[i][j]` 代表i~j的最长回文串\n\n```java\npublic int longestPalindromeSubseq(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int[][] dp=new int[n][n]; //dp[i][j] 代表i~j的最长回文子串\n    for (int i=0;i<n;i++) {\n        dp[i][i]=1;\n    }\n    //bbbab\n    for (int i=n-1;i>=0;i--) {\n        for (int j=i+1;j<n;j++) { \n            if (s.charAt(i)==s.charAt(j)) {\n                dp[i][j]=dp[i+1][j-1]+2;\n            }else{\n                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n\n核心的dp公式：\n\n1. `s[i]==p[j]`，`dp[i][j]=dp[i+1][j-1]+2` \n2. `s[i]!=p[j]` ，`dp[i][j]=max(dp[i+1][j],dp[i][j-1])`\n\n是不是有的眼熟？没错，和LCS的dp思路很相似\n\n这里其实还有个需要注意的地方，就是两次循环的方向，我们要保证每次计算dp值的时候右值都是已经计算过的，所以需要调整循环的执行方向让 `i`从右往左，让`j`从`i`向右，这样i+1和j-1的dp就都是计算过的了\n\n**UPDATE**\n\n```java\n//update: 2020.4.19\n//区间dp写法,更加套路化，其实思路是一样的\npublic int longestPalindromeSubseq(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int N=s.length();\n    int[][] dp=new int[N][N];\n    //base len=1\n    for(int i=0;i<N;i++){\n        dp[i][i]=1;\n    }\n    for(int len=2;len<=N;len++){\n        for(int i=0;i<=N-len;i++){\n            //j=i+len-1<N\n            int j=i+len-1;\n            if(s.charAt(i)==s.charAt(j)){\n                dp[i][j]=dp[i+1][j-1]+2;\n            }else{\n                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][N-1];\n}\n```\n\n**解法二**\n\n对比一下递归解法是真的简洁，没有那么多边界考虑\n\n```java\n//递归解法,自底向上\nprivate Integer[][] cache=null;\n\npublic int longestPalindromeSubseq(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    cache=new Integer[n][n];\n    return helper(s,0,n-1);\n}\n\npublic int helper(String s,int left,int right){\n    if (left>right) {\n        return 0;\n    }\n    if (left==right) {\n        return 1;\n    }\n    if (cache[left][right]!=null) {\n        return cache[left][right];\n    }\n    if (s.charAt(left) == s.charAt(right)) {\n        return cache[left][right]=helper(s,left+1,right-1)+2; //由外向内缩进\n    }\n    return cache[left][right]=Math.max(helper(s,left+1,right),helper(s,left,right-1));\n}\n```\n**解法三**\n\n将问题转换为LCS的问题\n\n```java\n//LCS的解法\npublic int longestPalindromeSubseq(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int[][] dp=new int[n+1][n+1]; //dp[i][j] 代表s[0,i]~rs[0,j]的最长子序列\n    String rs=new StringBuilder(s).reverse().toString();\n    for (int i=1;i<=s.length();i++) {\n        for (int j=1;j<=rs.length();j++) {\n            if (s.charAt(i-1)==rs.charAt(j-1)) {\n                dp[i][j]=dp[i-1][j-1]+1;\n            }else{\n                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[n][n];\n}\n```\n最长的回文序列其实就是求这个字符串和它翻转后的字符串的最长公共子序列！很妙的解法\n\n## [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)\n\n给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。\n\n请你返回让 s 成为回文串的 **最少操作次数** 。\n\n「回文串」是正读和反读都相同的字符串。\n\n**示例 1：**\n\n```java\n输入：s = \"zzazz\"\n输出：0\n解释：字符串 \"zzazz\" 已经是回文串了，所以不需要做任何插入操作。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"mbadm\"\n输出：2\n解释：字符串可变为 \"mbdadbm\" 或者 \"mdbabdm\" 。\n```\n\n\n**示例 3：**\n\n```java\n输入：s = \"leetcode\"\n输出：5\n解释：插入 5 个字符后字符串变为 \"leetcodocteel\" 。\n```\n\n**示例 4：**\n\n```java\n输入：s = \"g\"\n输出：0\n```\n\n\n**示例 5：**\n\n```java\n输入：s = \"no\"\n输出：1\n```\n\n**提示：**\n\n- 1 <= s.length <= 500\n- s 中所有字符都是小写字母。 \n\n**解法一**\n\n170周赛的压轴题，其实和前面的[516. 最长回文子序列](#516-最长回文子序列)是一样的。。。没啥好说的\n\n```java\npublic int minInsertions(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int[][] dp=new int[n][n];\n    for (int i=n-1;i>=0;i--) {\n        for (int j=i+1;j<n;j++) {\n            if (s.charAt(i) == s.charAt(j)) {\n                dp[i][j]=dp[i+1][j-1];   \n            }else{\n                //不相等就可以在头部插入s[j]或者尾部插入s[i]\n                //头部插入s[j]则子区间就是dp[i][j-1]\n                //尾部插入s[i]则子区间就是dp[i+1][j]\n                dp[i][j]=1+Math.min(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n**解法二**\n\nUPDATE：2020.5.18，区间dp的写法\n\n```java\npublic int minInsertions(String s) {\n    int[][] dp=new int[s.length()][s.length()];\n    for(int len=2;len<=s.length();len++){\n        for(int left=0;left+len-1<s.length();left++){\n            int right=left+len-1;\n            if(s.charAt(left)==s.charAt(right)){\n                dp[left][right]=dp[left+1][right-1];\n            }else{\n                dp[left][right]=Math.min(dp[left][right-1],dp[left+1][right])+1;\n            }\n        }\n    }\n    return dp[0][s.length()-1];\n}\n```\n\n这题也可以用LCS的解法解，`n-lcs[n][n]`就是最少的插入次数 \n\n## [664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/)\n\n有台奇怪的打印机有以下两个特殊要求：\n\n打印机每次只能打印同一个字符序列。\n每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。\n给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。\n\n**示例 1:**\n\n```java\n输入: \"aaabbb\"\n输出: 2\n解释: 首先打印 \"aaa\" 然后打印 \"bbb\"。\n```\n\n**示例 2:**\n\n```java\n输入: \"aba\"\n输出: 2\n解释: 首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。\n```\n\n**提示:** 输入字符串的长度不会超过 100。\n\n**解法一**\n\n前一天看了大致的思路，隔了一天独立的写了一下，将前天思路的很多细节都想明白了\n\n```java\npublic int strangePrinter(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int N=s.length();\n    int[][] dp=new int[N][N];\n    for (int i=0;i<N;i++) {\n        dp[i][i]=1;\n    }\n    //aa        1\n    //aab       2\n    //aaba      2\n    //aabab     3\n    //aababa    4\n    for (int len=2;len<=N;len++) {\n        for (int left=0;left+len-1<N;left++) { //左端点\n            int right=left+len-1; //右端点\n            //和前一个区间[left,right-1]的第一个字符相等,可以直接顺带打印出来\n            if(s.charAt(right)==s.charAt(left)){ \n                //至少是dp[left][right-1]\n                dp[left][right]=dp[left][right-1];\n                continue;\n            }\n            //最多是前一个区间+1(直接打印right位置的字符)\n            dp[left][right]=dp[left][right-1]+1; \n            //枚举[left,right)中的所有字符,如果有和right相等的就考虑从这个位置分割整个字符\n            //比如 abc b 这个最后的b就可以连同前面的bc一起顺带打印出来\n            //所以当前区间的值就是可以是dp[a][a]+dp[b][c],我们从所有的这种情况中取最小值就ok了\n            for (int i=left;i<right;i++) { \n                if(s.charAt(right)==s.charAt(i)){\n                    dp[left][right]=Math.min(dp[left][i-1]+dp[i][right-1],dp[left][right]);\n                }\n            }\n        }\n    }\n    return dp[0][N-1];\n}\n```\n`dp[left][right]`代表left到right的最少打印次数，然后我们要理解一点：`dp[left][right]` 其实只可能有两个取值，`dp[left][right-1]`或者`dp[left][right-1]+1`，我们求最小打印次数其实就是希望增加一个字符后打印次数不变\n\n> **eg:**  abc b 这个最后的b就可以连同前面的bc一起顺带打印出来，打印次数不变\n\n枚举所有的区间`[left,right]`，然后枚举区间`[left,right-1]`内的字符，如果区间`[left,right-1]`内的某个字符`i`和`right`相等，那么`right`就可以跟随`[i,right-1]`一起顺带打印出来，这样该区间的dp值为\n\n`dp[left][right]=dp[left][i-1]+dp[i][right-1]`\n这样就有可能让打印次数不变，我们求一下所有情况的最小值就可以了\n\n> 这题的代码还可以更简洁，不过我懒得改了，感觉上面的代码已经很清晰了\n>\n> ps:  这几天做了不少有点难度的DP题，发现确实自己对边界的处理，递推公式的理解有了一点提升，加油💪\n\n## [1547. 切棍子的最小成本](https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/)\n\nDifficulty: **困难**\n\n\n有一根长度为 `n` 个单位的木棍，棍上从 `0` 到 `n` 标记了若干位置。例如，长度为 **6** 的棍子可以标记如下：\n\n![UTOOLS1597929649437.png](https://upload.cc/i1/2020/08/20/5m7x61.png)\n\n给你一个整数数组 `cuts` ，其中 `cuts[i]` 表示你需要将棍子切开的位置。\n\n你可以按顺序完成切割，也可以根据需要更改切割的顺序。\n\n每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。\n\n返回切棍子的 **最小总成本** 。\n\n**示例 1：**\n\n![UTOOLS1597929677739.png](https://upload.cc/i1/2020/08/20/QGugd1.png)\n\n```go\n输入：n = 7, cuts = [1,3,4,5]\n输出：16\n解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示：\n\n第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。\n而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。\n```\n\n**示例 2：**\n\n```go\n输入：n = 9, cuts = [5,6,1,4,2]\n输出：22\n解释：如果按给定的顺序切割，则总成本为 25 。总成本 <= 25 的切割顺序很多，例如，[4，6，5，2，1] 的总成本 = 22，是所有可能方案中成本最小的。\n```\n\n**提示：**\n\n*   `2 <= n <= 10^6`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   `cuts` 数组中的所有整数都 **互不相同**\n\n**解法一**\n\n201th周赛的t4，感觉还是挺简单的，今天补的时候花了10分钟搞清楚思路，一遍看视频一边写，最后不出意外的的T了~😂一开始没想清楚细节，想到了以区间开始和结尾做dp，然后就直接开了个n*n的数组，虽然是对的，但是在初始化的时候就t了，这里实际上只需要开一个len(cuts)^2的空间就行了\n```golang\nfunc minCost(n int, cut []int) int {\n    sort.Ints(cut)\n    //在前后加上0和n\n    cut = append(cut, n)\n    cut = append([]int{0}, cut...)\n    var Min = func(a,b int) int {if a<b {return a};return b}\n    var m = len(cut)\n    //dp[i][j]切割i,j的成本\n    var dp = make([][]int, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]int, m)\n        if i < m-1 {\n            dp[i][i+1] = 0   \n        }\n    }\n    for tlen := 2; tlen <= m; tlen++ {\n        for left := 0; left+tlen < m; left++ {\n            right := left+tlen //注意这里不加1\n            dp[left][right] = math.MaxInt32\n            for k := left+1; k < right; k++ {\n                dp[left][right] = Min(dp[left][right], dp[left][k]+dp[k][right]+cut[right]-cut[left])\n            }\n        }\n    }\n    return dp[0][m-1]\n}\n```\n一开始tle的**错误**代码\n```golang\nfunc minCost(n int, cut []int) int {\n    sort.Ints(cut)\n    //0,1,3,4,5,6\n    cut = append(cut, n)\n    cut = append([]int{0}, cut...)\n    var Min = func(a,b int) int {if a<b {return a};return b}\n    var m = len(cut)\n    var dp = make([][]int, n+1)\n    for i := 0; i <= n; i++ {\n        dp[i] = make([]int, n+1) //这里就t了\n        // for j := 0; j <= n; j++ {\n        //     dp[i][j] = math.MaxInt32\n        // }\n    }\n    for i := 0; i < m-1; i++ {\n        for j := i+1; j < m; j++ {\n            dp[cut[i]][cut[j]] = 0x3f3f3f3f\n        }\n        dp[cut[i]][cut[i+1]] = 0\n    }\n    for tlen := 2; tlen <= m; tlen++ {\n        for left := 0; left+tlen-1 < m; left++ {\n            right := left+tlen-1\n            for k := left+1; k < right; k++ {\n                dp[cut[left]][cut[right]] = Min(dp[cut[left]][cut[right]], dp[cut[left]][cut[k]] + dp[cut[k]][cut[right]] + cut[right]-cut[left])\n            }\n        }\n    }\n    return dp[0][n]\n}\n```\n\n## _数位DP_\n\n## [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)\n\n给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。\n\n**示例:**\n\n```java\n输入: 13\n输出: 6 \n解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。\n```\n\n**解法一**\n\n这个题其实困扰了我很长时间，之前看了好几次都放弃了，感觉有些找规律的数学解法太难想到了，所以这里直接采用**数位DP**，相对于其他的解法，这种解法会更加套路模板化\n```java\n//dp[pos][sumOne]代表枚举到pos位置，前面1出现的个数为sumOne的时候，pos到最低位出现的数字1的个数\nint [][] dp=null;\n\npublic int countDigitOne(int n) {\n    int len=0;\n    int[] num=new int[64]; //64位肯定够了\n    while(n!=0){\n        num[len++]=n%10;\n        n/=10;\n    }\n    dp=new int[len+1][len+1];\n    //从高位向低位枚举\n    return dfs(num,len-1,0,true,true);\n}\n\npublic int dfs(int[] num,int pos,int sumOne,boolean leadZero,boolean limit){\n    //枚举完所有的数位，直接返回sumOne(这个数有多少个1)\n    if(pos==-1) return sumOne;\n    //状态重叠，状态要完全一致\n    if(!leadZero && !limit && dp[pos][sumOne]!=0) return dp[pos][sumOne];\n    int res=0;\n    int up=limit?num[pos]:9;\n    for (int i=0;i<=up;i++) {\n        res+=dfs(num,pos-1,sumOne+(i==1?1:0),leadZero&&i==0,i==up&&limit);\n    }\n    if(!leadZero && !limit) dp[pos][sumOne]=res;\n    return res;\n}\n```\n\n优化下代码，前导0对状态存取没有影响，这里考虑的是数字的组成\n\n```java\n//简化下代码，前导0其实没有影响\n//dp[pos][sumOne]代表从高位枚举到pos位置，前面1的个数sumOne时\nint [][] dp=null;\n\npublic int countDigitOne(int n) {\n    int len=0;\n    int[] num=new int[64]; //64位肯定够了\n    while(n!=0){\n        num[len++]=n%10;\n        n/=10;\n    }\n    dp=new int[len+1][len+1];\n    //从高位向低位枚举\n    return dfs(num,len-1,0,true);\n}\n\npublic int dfs(int[] num,int pos,int sumOne,boolean limit){\n    //枚举完所有的数位，直接返回sumOne\n    if(pos==-1) return sumOne;\n    //状态重叠，状态要完全一致\n    if(!limit && dp[pos][sumOne]!=0) return dp[pos][sumOne];\n    int res=0;\n    int up=limit?num[pos]:9;\n    for (int i=0;i<=up;i++) {\n        res+=dfs(num,pos-1,sumOne+(i==1?1:0),i==up&&limit);\n    }\n    if(!limit) dp[pos][sumOne]=res;\n    return res;\n}\n```\n**Update: 2020.6.24**\n\n用go重写了下，同时发现之前对这个状态的理解是错的。\n\n```golang\nfunc countDigitOne(n int) int {\n    var nums []int\n    for n > 0 {\n        nums = append(nums, n%10)\n        n /= 10\n    }\n    dp := make([][]int, len(nums))\n    for i := 0; i < len(dp); i++ {\n        dp[i] = make([]int, len(nums))\n    }\n    return dfs(len(nums)-1, 0, true, nums, dp)\n}\n\nfunc dfs(pos int, cnt int, limit bool, nums []int, dp [][]int) int {\n    if pos == -1 {\n        return cnt\n    }\n    if !limit && dp[pos][cnt] != 0 {\n        return dp[pos][cnt]\n    }\n    var up = 9\n    if limit {\n        up = nums[pos]\n    }\n    var res = 0\n    for i := 0; i <= up; i++ {\n        if i == 1 {\n            res += dfs(pos-1, cnt+1, i == up && limit, nums, dp)\n        } else {\n            res += dfs(pos-1, cnt, i == up && limit, nums, dp)\n        }\n    }\n    if !limit {\n        dp[pos][cnt] = res\n    }\n    return res\n}\n```\n这里`cnt`指的其实是`[最高位 ~ pos位]`的1出现的个数，当pos为-1的时候其实就是到达了某一个具体的数字，比如`1231`这个时候就会返回`cnt=2`，与此同时，cnt也是状态的一部分，比如`n=1200 , pos=1 , cnt=1`表示枚举到了第1位出现了1个1，就说明高两位`1`出现了1次，也就是`10`或者`01`，这个时候当我们先求出了`01xx(0100 ~ 0199)`中的1的个数的时候，我们保存这个状态，当前我们下次再遇到这个状态的时候，也就是`10xx`的时候，我们就可以直接将前面`01xx`的dp值返回，因为`01xx`和`10xx`包含的1的数量肯定是一样的，无需重复计算\n\n> **数位DP**的概念和模板其实我也是下午在网上查的，然后找到了两个写的比较好的文章 [数位dp总结 之 从入门到模板](https://blog.csdn.net/wust_zzwh/article/details/52100392)，[数字组成的奥妙——数位dp](https://www.luogu.com.cn/blog/virus2017/shuweidp) 以后遇到类似的题又多了一种解法（数学的解法至今仍没学会🤣）只有这一题想搞懂**数位DP**还是不太够，这题还是比较简单的，还是要多做题，多总结才能慢慢体会，lc上好像数位dp好像并不多，过两天都做一下试试\n\n## [1420. 生成数组](https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/) \n\n给你三个整数 `n`、`m` 和 `k` 。下图描述的算法用于找出正整数数组中最大的元素。\n\n![JdU4w8.png](https://s1.ax1x.com/2020/04/23/JdU4w8.png)\n\n请你生成一个具有下述属性的数组 arr ：\n\n- arr 中有 n 个整数。\n- 1 <= arr[i] <= m 其中 (0 <= i < n) 。\n- 将上面提到的算法应用于 arr ，search_cost 的值等于 k 。\n\n返回上述条件下生成数组 arr 的 方法数 ，由于答案可能会很大，所以 必须 对 10^9 + 7 取余。\n\n**示例 1：**\n\n```java\n输入：n = 2, m = 3, k = 1\n输出：6\n解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n```\n\n\n**示例 2：**\n\n```java\n输入：n = 5, m = 2, k = 3\n输出：0\n解释：没有数组可以满足上述条件\n```\n\n\n**示例 3：**\n\n```java\n输入：n = 9, m = 1, k = 1\n输出：1\n解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]\n```\n\n\n**示例 4：**\n\n```java\n输入：n = 50, m = 100, k = 25\n输出：34549172\n解释：不要忘了对 1000000007 取余\n```\n\n\n**示例 5：**\n\n```java\n输入：n = 37, m = 17, k = 7\n输出：418930126\n```\n\n**提示：**\n\n- 1 <= n <= 50\n- 1 <= m <= 100\n- 0 <= k <= n \n\n**解法一**\n\n185周赛T4，类似于数位DP，记忆化递归的方式很好理解\n\n```java\nint mod=(int)1e9+7;\n\nInteger [][][] dp=null;\n\npublic int numOfArrays(int n, int m, int k) {\n    dp=new Integer[n+1][m+1][k+1];\n    return dfs(n,0,m,k);\n}\n\npublic int dfs(int pos,int preMax,int m,int k){\n    if(k==0 && pos==0) return dp[pos][preMax][k]=1;\n    //k=0但是pos不为0并没有结束,还可以继续找比preMax小的元素\n    //if(pos==0 || k==0) return 0; \n    if(pos==0 || k<0) return 0;\n    if(dp[pos][preMax][k]!=null){\n        return dp[pos][preMax][k];\n    }\n    long res=0;\n    for (int i=1;i<=m;i++) {\n        if(i>preMax){ //大于preMax,代价-1,更新最大值\n            res=(res+dfs(pos-1,i,m,k-1))%mod;\n        }else{ //小于preMax,代价不变,最大值不变\n            res=(res+dfs(pos-1,preMax,m,k))%mod;\n        }\n    }\n    return dp[pos][preMax][k]=(int)(res%mod);\n}\n```\n一开始没注意给dp数组赋初始值，直接按照0判断的，结果T了半天，我都懵了了，后来才意识到，很多状态的结果就是0，你直接按照0判断，很多相同的dp值为0的状态都没有被取出来用\n\n**优化**\n\n```java\nint mod=(int)1e9+7;\n\nLong [][][] dp=null;\n\npublic int numOfArrays(int n, int m, int k) {\n    dp=new Long[n+1][m+1][k+1];\n    return (int)dfs(n,0,m,k);\n}\n\npublic long dfs(int pos,int preMax,int m,int k){\n    if(k==0 && pos==0) return dp[pos][preMax][k]=1L;\n    //k=0但是pos不为0并没有结束,还可以继续找比preMax小的元素\n    //if(pos==0 || k==0) return 0; \n    if(pos==0 || k<0) return 0L;\n    if(dp[pos][preMax][k]!=null){\n        return dp[pos][preMax][k];\n    }\n    long res=0;\n    //小于等于preMax的部分可以通过dfs(pos-1,preMax,m,k)算出来,减少递归次数\n    res=(res+(preMax*dfs(pos-1,preMax,m,k))%mod)%mod;\n    for (int i=preMax+1;i<=m;i++) {\n        res=(res+dfs(pos-1,i,m,k-1))%mod;\n    }\n    return dp[pos][preMax][k]=res%mod;\n}\n```\n**解法二**\n\n递推的方式，其实思想是一样的，但是个人感觉并不是特别容易直接想出来\n\n```java\npublic int numOfArrays(int n, int m, int k) {\n    int mod=1000_000_007;\n\n    long[][][] dp=new long[n+1][m+1][k+1];\n    for(int i=1;i<=m;i++){\n        dp[1][i][1]=1;\n    }\n    for(int i=2;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            for(int cost=1;cost<=k;cost++){\n                //新增加的元素小于等于j也就是原数组的最大值,对应上面递归的i<=preMax\n                //所以新增加的元素在新数组的末尾有1~j种选择\n                dp[i][j][cost]=(j*dp[i-1][j][cost])%mod;\n                for(int nm=1;nm<j;nm++){\n                    //新增加的元素大于原数组的最大值j,对应上面递归的i>preMax\n                    dp[i][j][cost]=(dp[i][j][cost]+dp[i-1][nm][cost-1])%mod;\n                }\n            }\n        }\n    }\n    long res=0;\n    for(int i=1;i<=m;i++){\n        res+=dp[n][i][k];\n        res%=mod;\n    }\n    return (int)(res%mod);\n}\n```\n\n## [902. 最大为 N 的数字组合](https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/)\n\nDifficulty: **困难**\n\n\n我们有一组**排序的**数字 `D`，它是  `{'1','2','3','4','5','6','7','8','9'}` 的非空子集。（请注意，`'0'` 不包括在内。）\n\n现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如 `D = {'1','3','5'}`，我们可以写出像 `'13', '551', '1351315'` 这样的数字。\n\n返回可以用 `D` 中的数字写出的小于或等于 `N` 的正整数的数目。\n\n**示例 1：**\n\n```\n输入：D = [\"1\",\"3\",\"5\",\"7\"], N = 100\n输出：20\n解释：\n可写出的 20 个数字是：\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n```\n\n**示例 2：**\n\n```\n输入：D = [\"1\",\"4\",\"9\"], N = 1000000000\n输出：29523\n解释：\n我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，\n81 个四位数字，243 个五位数字，729 个六位数字，\n2187 个七位数字，6561 个八位数字和 19683 个九位数字。\n总共，可以使用D中的数字写出 29523 个整数。\n```\n\n**提示：**\n\n1.  `D` 是按排序顺序的数字 `'1'-'9'` 的子集。\n2.  `1 <= N <= 10^9`\n\n**解法一**\n\nlc上写的第3道数位DP，套模板，理解的还不够深刻，等以后做多了再单独开专题讲解\n```java\nboolean[] dict;\n\nint[] nums;\n\nInteger[] dp;\n\npublic int atMostNGivenDigitSet(String[] D, int N) {\n    int pos = -1;\n    nums = new int[64];\n    while (N > 0) {\n        nums[++pos] = N % 10;\n        N /= 10;\n    }\n    dict = new boolean[10];\n    dp = new Integer[pos + 1];\n    for (int i = 0; i < D.length; i++) {\n        dict[Integer.valueOf(D[i])] = true;\n    }\n    return dfs(pos, true, true);\n}\n\n//从pos~0有多少个合法的数\npublic int dfs(int pos, boolean leadZero, boolean limit) {\n    if (pos == -1) {\n        //枚举完所有的数位，没有前导0说明找到了一个合法的数\n        return leadZero ? 0 : 1;\n    }\n    if (!leadZero && !limit && (dp[pos] != null)) {\n        return dp[pos];\n    }\n    int res = 0;\n    int up = limit ? nums[pos] : 9;\n    for (int i = 0; i <= up; i++) {\n        //前面全是0 || 当前位在dict中\n        if ((leadZero && (i == 0)) || dict[i]) {\n            res += dfs(pos - 1, leadZero && (i == 0), limit && (i == up));\n        }\n    }\n    if (!leadZero && !limit) {\n        dp[pos] = res;\n    }\n    return res;\n}\n```\n\n## _状压DP_\n\n## [464. 我能赢吗](https://leetcode-cn.com/problems/can-i-win/)\n\n在 \"100 game\" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。\n\n如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？\n\n例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。\n\n给定一个整数 `maxChoosableInteger` （整数池中可选择的最大数）和另一个整数 `desiredTotal`（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？\n\n你可以假设 `maxChoosableInteger` 不会大于 20， `desiredTotal` 不会大于 300。\n\n**示例：**\n\n```java\n输入：\nmaxChoosableInteger = 10\ndesiredTotal = 11\n\n输出：\nfalse\n\n解释：\n无论第一个玩家选择哪个整数，他都会失败。\n第一个玩家可以选择从 1 到 10 的整数。\n如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。\n第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.\n同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。\n```\n\n**解法一**\n\n从 [力扣上的 DP 问题分类汇总](https://leetcode-cn.com/circle/article/NfHhXD/) 过来的，所以首先知道这个是状压DP，但是菜鸡的我并不知道状压DP是啥🤣，所以先写了个暴力的搜索，然后不出意料的t了\n\n```java\n//TLE case 20 210 41/45\npublic boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n    if(desiredTotal<=maxChoosableInteger) return true;\n    if((1+maxChoosableInteger)*(maxChoosableInteger)/2<desiredTotal) return false;\n    boolean[] visit=new boolean[maxChoosableInteger+1];\n    return dfs(maxChoosableInteger,desiredTotal,visit);\n}\n\npublic boolean dfs(int max,int total,boolean[] visit){\n    if(total<=0) return false; //前人已经拿完了\n    for (int i=1;i<=max;i++) {\n        if(!visit[i]){\n            visit[i]=true;\n            boolean temp=dfs(max,total-i,visit);\n            visit[i]=false;\n            if(!temp){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n注意这个写法的返回时机，有些语句是不能合并的，比如下面这样就是错的（别问我为啥知道的🤣）\n\n```java\npublic boolean dfs(int max,int total,boolean[] visit){\n    if(total<=0) return false;\n    for (int i=1;i<=max;i++) {\n        if(!visit[i]){\n            visit[i]=true;\n            if(!dfs(max,total-i,visit)){\n                return true;\n            }\n            visit[i]=false;\n        }\n    }\n    return false;\n}\n```\n\n像上面这样写乍一看好像没问题，对比一下两种写法，其实就是回溯`visit`的时机不同，第一个是另一个人`dfs` 不管成功与否都会回溯状态，而第二种是另一个人`dfs` 成功后才会回溯状态，失败后就不会回溯状态了，但是在这题中不管另一个人失败与否都需要回溯状态，首先另一个人成功后我肯定是要回溯，另一个人成功意味着我失败了，我还要继续尝试找必胜的选取方法，但是另一个人失败后还是需要回溯状态，仔细想想，下一层dfs(另一个人)失败是因为下下一层dfs(我)成功了，我在那一次成功后并没有回溯`visit`，这样下一层（另一个人）就用不了被下下层占用的数字，就无法枚举所有情况，自然就错了\n\n> 各位大佬见谅，表达能力有限，上面的都是我胡言乱语，大佬们跳过就行了\n\n**解法二**\n\n根据昨天写的一个数位DP，加上自己的yy，写了个状压DP出来了🤣，上面的解法明显会有很多的重复解，而确定是否重复的关键其实就是数字的选取情况，上面我们是用的一个`visit`数组来记录这选取的情况，要直接通过这个`visit`来判断状态是否相同是很耗时耗力的，所以就引入了状态压缩，我们可以用二进制的第`i`位的0或者1来表示`i`这个数字的选取与否，这样所有数字的选取状态就可以用一个数来很方便的表示，题目说了不超过20位，所以这里就可以用一个`int`来表示状态`state`，通过`state`来判断状态是否一致，进而进行记忆化的存取\n\n```java\nBoolean[] dp=null; //用Boolean比较方便判断是否记忆化\n\npublic boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n    //小于最大值先手可以直接拿\n    if(desiredTotal<=maxChoosableInteger) return true;\n    //前N项和还不够desiredTotal\n    if((1+maxChoosableInteger)*(maxChoosableInteger)/2<desiredTotal) return false;\n    //20位二进制 1<<21\n    dp=new Boolean[1<<21];\n    return dfs(maxChoosableInteger,desiredTotal,0);\n}\n\npublic boolean dfs(int max,int total,int state){\n    if(total<=0) return false; //前人已经拿完了\n    if(dp[state]!=null){\n        return dp[state];\n    }\n    for (int i=max;i>=1;i--) {\n        //参数传递的，就不用回溯了，代码变的简洁多了\n        if((state>>i&1)==0 && !dfs(max,total-i,state|(1<<i))){\n            return dp[state]=true;\n        }\n    }\n    return dp[state]=false;\n}\n```\n其实一开始开了个二维的 `new Boolean[desiredTotal] [1<<21]`，然后就直接MLE了😅 太菜了hahaha，然后看了下，发现`state`一样的话，`total`肯定是一样的（反过来就不一定了），所以只需要一维的就可以了\n\n其实也可以用`int[]`做状压\n\n```java\n//int做状压，似乎性能没有提升\nint[] dp=null; //0:未初始化 1:true 2:false\n\npublic boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n    //小于最大值先手可以直接拿\n    if(desiredTotal<=maxChoosableInteger) return true;\n    //前N项和还不够desiredTotal\n    if((1+maxChoosableInteger)*(maxChoosableInteger)/2<desiredTotal) return false;\n    //20位二进制 1<<21\n    dp=new int[1<<21];\n    return dfs(maxChoosableInteger,desiredTotal,0);\n}\n\npublic boolean dfs(int max,int total,int state){\n    if(dp[state]!=0){\n        return dp[state]==1;\n    }\n    for (int i=max;i>=1;i--) {\n        //参数传递的，就不用回溯了，代码变的简洁多了\n        if((state>>i&1)==0 && (i>=total || !dfs(max,total-i,state|(1<<i)))){\n            dp[state]=1;\n            return true;\n        }\n    }\n    dp[state]=2;\n    return false;\n}\n```\n\n## _博弈DP_\n\n## [292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)\n\n你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。\n\n你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。\n\n**示例:**\n\n```java\n输入: 4\n输出: false \n解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；\n     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。\n```\n\n**解法一**\n\n博弈型动态规划入门题\n\n```java\npublic boolean canWinNim(int n) {\n    boolean[] dp=new boolean[n];\n    dp[0]=true;\n    dp[1]=true;\n    dp[2]=true;\n    //t t t f t t t f .....\n    //每个状态取决于前3个状态\n    for (int i=3;i<n;i++) {\n        //分别拿1,2,3个看对面能不能赢\n        dp[i]=!dp[i-1] || !dp[i-2] || !dp[i-3];\n    }\n    return dp[n-1];\n}\n```\n这个解法在数据过大的时候还是会TLE\n\n**解法二**\n\n规律\n\n```java\npublic boolean canWinNim(int n) {\n    return n%4!=0;\n}\n```\n\n## [1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/)\n\nDifficulty: **简单**\n\n\n爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。\n\n最初，黑板上有一个数字 `N` 。在每个玩家的回合，玩家需要执行以下操作：\n\n*   选出任一 `x`，满足 `0 < x < N` 且 `N % x == 0` 。\n*   用 `N - x` 替换黑板上的数字 `N` 。\n\n如果玩家无法执行这些操作，就会输掉游戏。\n\n只有在爱丽丝在游戏中取得胜利时才返回 `True`，否则返回 `false`。假设两个玩家都以最佳状态参与游戏。\n\n**示例 1：**\n\n```go\n输入：2\n输出：true\n解释：爱丽丝选择 1，鲍勃无法进行操作。\n```\n\n**示例 2：**\n\n```go\n输入：3\n输出：false\n解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。\n```\n\n**提示：**\n\n1.  `1 <= N <= 1000`\n\n**解法一**\n\n博弈DP，和上面的类似，尝试所有情况\n```golang\nfunc divisorGame(N int) bool {\n    //N=i时，先手的人能否赢\n    var dp = make([]bool, N+1)\n    dp[1] = false\n    for i := 2; i <= N; i++ {\n        //尝试所有可行的选择\n        //从i中先手拿j，看对方在i-j中先手能不能赢\n        for j := 1; j < i; j++ {\n            if i%j == 0 && !dp[i-j] {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[N]\n}\n```\n\n**解法二**\n\n很明显，这题也有一个数学的解法😂，利用奇数和偶数的性质，N为偶数的时候，先手的人是必赢的\n```golang\n//规律，偶数必赢，奇数必输\n//最后在N=2的时候结束比赛，所以谁先到2谁就赢\n//奇数的因子只有奇数，奇数-奇数 = 偶数，当我拿到偶数时候可以直接拿走1，变为奇数，如此往来\n//最终我必定能先到2\nfunc divisorGame(N int) bool {\n    return N%2 == 0\n}\n```\n\n## [1140. 石子游戏 II](https://leetcode-cn.com/problems/stone-game-ii/)\n\nDifficulty: **中等**\n\n\n亚历克斯和李继续他们的石子游戏。许多堆石子 **排成一行**，每堆都有正整数颗石子 `piles[i]`。游戏以谁手中的石子最多来决出胜负。\n\n亚历克斯和李轮流进行，亚历克斯先开始。最初，`M = 1`。\n\n在每个玩家的回合中，该玩家可以拿走剩下的 **前** `X` 堆的所有石子，其中 `1 <= X <= 2M`。然后，令 `M = max(M, X)`。\n\n游戏一直持续到所有石子都被拿走。\n\n假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。\n\n**示例：**\n\n```\n输入：piles = [2,7,9,4,4]\n输出：10\n解释：\n如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 \n如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。\n所以我们返回更大的 10。 \n```\n\n**提示：**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 10 ^ 4`\n\n**解法一**\n\n瞎写的记忆化，懒得改dp了\n```java\nint n = 0;\n\nInteger[][] cache;\n\npublic int stoneGameII(int[] piles) {\n    n = piles.length;\n    //这里用后缀和会简单一点，懒得改了\n    int[] preSum = new int[n+1];\n    cache = new Integer[n+1][n+1];\n    preSum[0] = 0;\n    for(int i = 1; i <=n; i++){\n        preSum[i] = preSum[i-1] + piles[i-1];\n    }\n    return dfs(preSum, 0, 1);\n}\n\npublic int dfs(int[] preSum, int start, int M){\n    if(cache[start][M]!=null){\n        return cache[start][M];\n    }\n    int res = 0;\n    for(int len = 1; start + len - 1 < n && len <= 2*M; len++){\n        //start=0 len=2 (0,1)\n        int temp = preSum[n] - preSum[start] - dfs(preSum, start + len, Math.max(M, len));\n        res = Math.max(res, temp);\n    }\n    return cache[start][M] = res;\n}\n```\n## [1406. 石子游戏 III](https://leetcode-cn.com/problems/stone-game-iii/)\n\nDifficulty: **困难**\n\n\nAlice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 `stoneValue` 给出。\n\nAlice 和 Bob 轮流取石子，**Alice** 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 **1、2 或 3 堆石子** 。比赛一直持续到所有石头都被拿走。\n\n每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 **0** 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。\n\n假设 Alice 和 Bob 都采取 **最优策略** 。如果 Alice 赢了就返回 _\"Alice\"_ _，_Bob 赢了就返回 _\"Bob\"，_平局（分数相同）返回 _\"Tie\"_ 。\n\n**示例 1：**\n\n```go\n输入：values = [1,2,3,7]\n输出：\"Bob\"\n解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。\n```\n\n**示例 2：**\n\n```go\n输入：values = [1,2,3,-9]\n输出：\"Alice\"\n解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。\n如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。\n如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。\n注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。\n```\n\n**示例 3：**\n\n```go\n输入：values = [1,2,3,6]\n输出：\"Tie\"\n解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。\n```\n\n**示例 4：**\n\n```go\n输入：values = [1,2,3,-1,-2,-3,7]\n输出：\"Alice\"\n```\n\n**示例 5：**\n\n```go\n输入：values = [-1,-2,-3]\n输出：\"Tie\"\n```\n\n**提示：**\n\n*   `1 <= values.length <= 50000`\n*   `-1000 <= values[i] <= 1000`\n\n\n**解法一**\n\n某次双周赛的T4，没参加，感觉这题还是挺简单的，比2还要简单，下面的做法直接套用2的做法，改成了后缀和数组\n```java\n//后缀数组\nint[] sufSum = null;\n\nInteger[] dp = null;\n\npublic String stoneGameIII(int[] stoneValue) {\n    int n = stoneValue.length;\n    sufSum = new int[n+1];\n    dp = new Integer[n+1];\n    for (int i = n-1; i >= 0; i--){\n        sufSum[i] = sufSum[i+1] + stoneValue[i];\n    }\n    int alice = dfs(stoneValue, 0);\n    int bob = sufSum[0]-alice;\n    if (alice == bob) {\n        return \"Tie\";\n    }\n    return alice > bob ? \"Alice\" : \"Bob\";\n}\n\npublic int dfs(int[] sv, int start){\n    if (start > sv.length) {\n        return 0;\n    }\n    if (dp[start]!=null) {\n        return dp[start];\n    }\n    int sum = sufSum[start];\n    return dp[start] = Math.max(sum-dfs(sv, start+1), Math.max(sum-dfs(sv, start+2), sum-dfs(sv, start+3)));\n}\n```\n这题还有更好的做法，先挖个坑，后面有时间再写\n\n\n## [1510. 石子游戏 IV](https://leetcode-cn.com/problems/stone-game-iv/)\n\nDifficulty: **困难**\n\n\nAlice 和 Bob 两个人轮流玩一个游戏，Alice 先手。\n\n一开始，有 `n` 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 **任意** 非零 **平方数** 个石子。\n\n如果石子堆里没有石子了，则无法操作的玩家输掉游戏。\n\n给你正整数 `n` ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 `True` ，否则返回 `False` 。\n\n**示例 1：**\n\n```go\n输入：n = 1\n输出：true\n解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。\n```\n\n**示例 2：**\n\n```go\n输入：n = 2\n输出：false\n解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。\n```\n\n**示例 3：**\n\n```go\n输入：n = 4\n输出：true\n解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。\n```\n\n**示例 4：**\n\n```go\n输入：n = 7\n输出：false\n解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。\n如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 3 -> 2 -> 1 -> 0）。\n如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 6 -> 2 -> 1 -> 0）。\n```\n\n**示例 5：**\n\n```go\n输入：n = 17\n输出：false\n解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。\n```\n\n**提示：**\n\n*   `1 <= n <= 10^5`\n\n\n**解法一**\n\n前几次双周赛的T4，太水了，大水题，顶多算mid\n```golang\nfunc winnerSquareGame(n int) bool {\n    var dp = make([]bool, 100001)\n    dp[0] = false\n    for i := 1; i <= n; i++ {\n        for j := 1; j*j <= i; j++ {\n            if !dp[i-j*j] {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[n]\n}\n```\n**解法二**\n\n玩了一手花哨的记忆化手法😂\n```golang\n//记忆化\nfunc winnerSquareGame(n int) bool {\n    var T, F = true, false\n    var dfs func(int) bool\n    var dp = make([]*bool, 100001)\n    //先手拿x^2个石头\n    dfs = func (n int) bool {\n        if dp[n] != nil {\n            return *dp[n]\n        }\n        if n == 0 {\n            return F\n        }\n        for i := 1; i*i <= n; i++{\n            if !dfs(n-i*i) {\n                dp[n] = &T\n                return T\n            }\n        }\n        dp[n] = &F\n        return F\n    }\n    return dfs(n)\n}\n```\n\n## [486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)\n\nDifficulty: **中等**\n\n\n给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。\n\n给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。\n\n**示例 1：**\n\n```go\n输入：[1, 5, 2]\n输出：False\n解释：一开始，玩家1可以从1和2中进行选择。\n如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。\n所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。\n因此，玩家 1 永远不会成为赢家，返回 False 。\n```\n\n**示例 2：**\n\n```go\n输入：[1, 5, 233, 7]\n输出：True\n解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。\n     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。\n```\n\n**提示：**\n\n*   1 <= 给定的数组长度 <= 20.\n*   数组里所有分数都为非负数且不会大于 10000000 。\n*   如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。\n\n\n**解法一**\n\n记忆化，这种博弈的题目记忆化写起来会比较自然\n```golang\nfunc PredictTheWinner(nums []int) bool {\n    var Max = func(a, b int) int {if a > b {return a};return b}\n    var n = len(nums)\n    var preSum = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        preSum[i] = preSum[i-1] + nums[i-1]\n    }\n    //记忆化\n    var dp = make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        for j := 0; j < n; j++ {\n            dp[i][j] = -1\n        }\n    }\n    var dfs func(i int, j int) int\n    dfs = func(i int, j int) int {\n        if dp[i][j] != -1 {\n            return dp[i][j]\n        }\n        if i == j {\n            return nums[i]\n        }\n        //区间和\n        sum := preSum[j+1] - preSum[i]\n        dp[i][j] = Max(sum-dfs(i+1, j), sum-dfs(i, j-1))\n        return dp[i][j]\n    }\n    A := dfs(0, n-1)\n    return A >= preSum[n]-A\n}\n```\n**解法二**\n\n区间DP的写法当然也可以，思路一样\n```golang\nfunc PredictTheWinner(nums []int) bool {\n    var n = len(nums)\n    var dp = make([][]int, n)\n    var Max = func(a,b int) int {if a>b {return a};return b}\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n        dp[i][i] = nums[i]\n    }\n    var preSum = make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        preSum[i] = preSum[i-1] + nums[i-1]\n    }\n    for tlen := 2; tlen <= n; tlen++ {\n        for left := 0; left+tlen-1 < n; left++ {\n            right := left+tlen-1\n            sum := preSum[right+1]-preSum[left]\n            dp[left][right] = Max(sum-dp[left][right-1], sum-dp[left+1][right])\n        }\n    }\n    return dp[0][n-1] >= preSum[n]-dp[0][n-1]\n}\n```\n\n## _图论_\n\n暂时先放在这里，等后面学了dij，spfa那些后一起单独总结一下\n\n## [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)\n\n有 `N` 个网络节点，标记为 `1` 到 `N`。\n\n给定一个列表 `times`，表示信号经过**有向**边的传递时间。 `times[i] = (u, v, w)`，其中 `u` 是源节点，`v` 是目标节点， `w` 是一个信号从源节点传递到目标节点的时间。\n\n现在，我们从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1`。\n\n**示例：**\n\n![tfoiPf.png](https://s1.ax1x.com/2020/06/08/tfoiPf.png)\n\n```java\n输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2\n输出：2\n```\n\n**注意:**\n\n1. `N` 的范围在 `[1, 100]` 之间。\n2. `K` 的范围在 `[1, N]` 之间。\n3. `times` 的长度在 `[1, 6000]` 之间。\n4. 所有的边 `times[i] = (u, v, w)` 都有 `1 <= u, v <= N` 且 `0 <= w <= 100`。\n\n**解法一**\n\n临时起意学了下Floyd，然后在lc上搜了一下找到了这一题，思路也很直接\n\n```java\n//Floyd\npublic int networkDelayTime(int[][] times, int N, int K) {\n    int[][] dis=new int[N][N];\n    int INF = 0x3f3f3f3f;\n    for(int i=0;i<N;i++) Arrays.fill(dis[i],INF);\n    for(int i=0;i<N;i++) dis[i][i]=0;\n    for(int[] t:times) dis[t[0]-1][t[1]-1]=t[2];\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                dis[i][j]=Math.min(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n    int res=0;\n    K-=1; //从0开始！从1开始的都是邪教\n    for(int i=0;i<N;i++){\n        if(dis[K][i]==INF) return -1;\n        res=Math.max(dis[K][i],res);\n    }\n    return res;\n}\n```\n\n大概说一下，其实Floyd就是动态规划的思想，`dp[k][i][j]`代表从`i~j`允许经过前`k`个节点中转时的最短路径，那么其实很容易推导出，`dp[k][i][j]=min(dp[k-1][i][k]+dp[k-1][k][j],dp[k][i][j])`其实也就是尝试以每个点为中转点，看能否缩短两点之间的距离，和区间DP有点像，关于`k`为什么要放外面其实仔细想一下就知道了，我们需要保证在求`dp[k][i][j]`的时候需要保证`dp[k-1][i][j]`以及`dp[k-1][i][k]` 和`dp[k-1][k][j]`都是已经计算完毕的，想一想，如果k放在里面能保证么？很明显不行，可以类比上面的 [576. 出界的路径数](#576-出界的路径数)，一样的道理。然后我们再观察整个递推方程，发现`dp[k]`只依赖于`dp[k-1]`所以就可以直接滚动数组优化掉k维度的空间，也就是上面的解法\n\n## [1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)\n\nDifficulty: **中等**\n\n\n给你一个`points` 数组，表示 2D 平面上的一些点，其中 points[i] = [x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>] 。\n\n连接点 [x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>] 和点 [x<sub style=\"display: inline;\">j</sub>, y<sub style=\"display: inline;\">j</sub>]` 的费用为它们之间的 **曼哈顿距离** ：x<sub style=\"display: inline;\">i</sub> - x<sub style=\"display: inline;\">j</sub>| + |y<sub style=\"display: inline;\">i</sub> - y<sub style=\"display: inline;\">j</sub>| ，其中 |val| 表示 val 的绝对值。\n\n请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。\n\n**示例 1：**\n![wDmhAf.png](https://s1.ax1x.com/2020/09/14/wDmhAf.png)\n\n```\n输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n输出：20\n解释：\n\n我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\n注意到任意两个点之间只有唯一一条路径互相到达。\n```\n\n**示例 2：**\n\n```\n输入：points = [[3,12],[-2,5],[-4,1]]\n输出：18\n```\n\n**示例 3：**\n\n```\n输入：points = [[0,0],[1,1],[1,0],[-1,1]]\n输出：4\n```\n\n**示例 4：**\n\n```\n输入：points = [[-1000000,-1000000],[1000000,1000000]]\n输出：4000000\n```\n\n**示例 5：**\n\n```\n输入：points = [[0,0]]\n输出：0\n```\n\n**提示：**\n\n*   1 <= points.length <= 1000\n*   -10<sup>6</sup> <= x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub> <= 10<sup>6</sup>\n*   所有点 (x<sub style=\"display: inline;\">i</sub>, y<sub style=\"display: inline;\">i</sub>) 两两不同。\n\n\n**解法一**\n\nPrim O(V^2)最小生成树，206th周赛t3，裸的mst，但是彩笔的我并不会，事后补了一波 [OI Wiki](https://oi-wiki.org/graph/mst/#prim)，（这个是原始的暴力Prim，应对这个题够了）  \n```java\n//Prim O(V^2) 任取一个节作为起点，dis[i]记录mst点集到点i的最短距离\n//每次取出mst点集外dis[i]最小的点，也就是离mst点集最近的点，并标记为mst节点\n//然后利用该点更新其他的mst点集外的点的dis距离，直到将所有的点都加进去，适合稠密图（边数远大于点数）\n//可以使用一些数据结构来优化时间复杂度，暂时不深究\npublic int minCostConnectPoints(int[][] points) {\n    int INF = 0x3f3f3f3f;\n    int n = points.length;\n    //dis表示mst点集到该点的最小距离\n    int[] dis = new int[n];\n    Arrays.fill(dis, INF);\n    dis[0] = 0;\n    boolean[] vis = new boolean[n];\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        int minCost = INF;\n        int k = -1; //最小的新节点\n        for (int j = 0; j < n; j++) {\n            if (!vis[j] && dis[j] < minCost) {\n                minCost = dis[j];\n                k = j;\n            }\n        }\n        vis[k] = true;\n        res += minCost;\n        for (int j = 0; j < n; j++) {\n            //更新所有mst点集外的点的dis\n            if (vis[j]) continue;\n            int mhd = Math.abs(points[k][0]-points[j][0])+Math.abs(points[k][1]-points[j][1]);\n            dis[j] = Math.min(dis[j], mhd);\n        }\n    }\n    return res;\n}\n```\n这个题明显是稠密图，用邻接矩阵表示的，Prim用邻接矩阵时机复杂度就是O(V^2)，V为点数\n> 数据结构中对于稀疏图的定义为：有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图（dense graph）。\n\n**解法二**\n\nKruskal + 并查集，比较适合稀疏图，这里时机复杂度是O(ElogE)，E为边数\n```java\n//Kruskal+UnionFind\n//以边为中心，首先构造出所有的边，然后排序，从最短的边开始，合并该边的两个端点，这里需要用到并查集\n//合并n-1次后就得到mst（n为节点数），适合稀疏图\nint[] parent;\nint[] rank;\n//路径压缩\npublic int find(int a){\n    if (parent[a] == a) {\n        return a;\n    }\n    return parent[a] = find(parent[a]);\n}\n\npublic boolean union(int a, int b) {\n    int pa = find(a);\n    int pb = find(b);\n    if (pa == pb) {\n        return false;\n    }\n    //随便合并 553ms\n    //parent[pa] = pb;\n    //按秩合并 564ms 似乎没有什么变化。。。\n    if (rank[pa] > rank[pb]) {\n        parent[pb] = pa;\n    }else if (rank[pb] > rank[pa]) {\n        parent[pa] = pb;\n    }else{\n        parent[pa] = pb;\n        rank[pb]++;\n    }\n    return true;\n}\n\npublic int minCostConnectPoints(int[][] points) {\n    int n = points.length;\n    parent = new int[n];\n    rank = new int[n];\n    //n-1 + n-2 + n-3 +...+ 1 = (n-1) + (n-1)*(n-2)/2 = n(n-1)/2\n    //5 : 4+3+2+1 = 4*\n    //0,1: 端点，2: 边权值\n    int[][] edge = new int[n*(n-1)/2][3];\n    int idx = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            int dis = Math.abs(points[i][0]-points[j][0])+Math.abs(points[i][1]-points[j][1]);\n            edge[idx++] = new int[]{i, j, dis};\n        }\n        parent[i] = i;\n        rank[i] = 1;\n    }\n    //按照边的权值排序\n    Arrays.sort(edge, (e1, e2)->e1[2]-e2[2]);\n    int res = 0;\n    int count = 0;\n    for (int i = 0; i < edge.length; i++) {\n        if (union(edge[i][0], edge[i][1])) {\n            res += edge[i][2];\n            count++;\n        }\n        if (count == n-1) {\n            break;\n        }\n    }\n    return res;\n}\n```","tags":["LeetCode","动态规划"],"categories":["算法"]},{"title":"深入理解Java虚拟机（二）","url":"/2019/08/17/shen-ru-li-jie-java-xu-ni-ji-er/","content":"\n> 这一篇主要讲JVM的类加载机制，本来很久之前就写了，但是这几天又重新学习了一遍，纠正了之前很多错误的观点，然后又补充了很多东西\n\n## 类加载的过程\n\n**前言：**\n\n在Java语言中，类型的加载，连接和初始化过程都是在**运行期间**完成的，这与那些在**编译期间**需要进行链接工作的语言（C/C++）不同，这样毫无疑问会增加类加载的性能开销，但是会为Java提供高度的灵活性，Java天生可以动态扩展的就是依赖于运行时期**动态加载和动态链接**这个特点实现的，比如一个接口，完全可以在运行时期动态的指定其具体的实现类。又或者用户可以通过类加载器让一个本地的引用运行时从其他地方（网络等）加载一个二进制的流作为程序代码的一部分。\n\n![mark](http://static.imlgw.top///20190418/em4YNNmXXmho.png?imageslim)\n\n### ①加载\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流。\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n- 在内存中生成一个代表这个类的 `java.lang.Class` 对象\n\n#### 类加载的最终产物\n\n> 类加载的最终产物是位于堆中的`Class`对象\n\n《深入理解Java虚拟机》里面介绍的JVM内存结构(p39)\n\n![JVM内存结构](http://static.imlgw.top///20190417/yk2bzxILsCpL.png?imageslim)\n\n\n\n**堆（Heap）**：最大的一块区域，线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。\n\n> The Java Virtual Machine has a *heap* that is `shared` among `all` Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.\n>\n> The heap is created on virtual machine `start-up`. Heap storage for objects is reclaimed by an automatic storage management system (known as a *garbage collector(GC)*); \n>\n> 摘自  [官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3)\n\n**方法区（Method Area）**：又称为`非堆`，线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。\n\n> The Java Virtual Machine has a *method area* that is `shared` among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the \"text\" segment in an operating system process. It stores per-class structures such as the **run-time constant pool**, **field** and **method data**, and the code for methods and constructors, including the special methods ([§2.9](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9)) used in class and instance initialization and interface initialization.\n\n**运行时常量池(run-time constant pool)**：\n\n是方法区的一部分，用于存放编译期生成的各种字面量\"123\"，\"LGW\" 等字符串常量池，和符号引用。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，运行期间也能将新的常量放入池中。如String.intern()方法。\n\n**方法栈（JVM Stack）**：\n\n线程私有。存储局部变量表、操作栈、动态链接、方法出口，`对象指针`。\n\n**本地方法栈（Native Method Stack）**：\n\n线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。\n\n**程序计数器（Program Counter Register）**：\n\n线程私有，它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。\n\n#### 加载类的方式\n\n- 本地磁盘 classpath\n- 内存中加载 ，动态代理？RPC?\n- 通过网络加载.class\n- 从zip，jar中加载\n- 数据库中提取.class\n- 动态编译\n\n### ②连接:  \n\n#### 验证 \n\n**文件格式验证**\n\n- 是否以魔数`0xCAFEBABE`（咖啡宝贝）开头\n\n- 主、次版本号是否在当前虚拟机处理范围之内\n\n- 常量池中的常量中是否有不被支持的常量类型（检查常量tag标志）\n\n- .....\n\n**元数据验证**\n\n第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求\n\n**字节码验证**\n\n主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的\n\n由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在 JDK 1.6 之后的 Javac 编译器和 Java 虚拟机中进行了一项优化，给方法体的 Code 属性的属性表中增加了一项名为\" StackMapTable\" 的属性, 只需要检查StackMapTable属性中的记录是否合法皆可以了\n\n**符号引用验证**\n\n符号引用的校验发生在虚拟机将`符号引用`转化为`直接引用`的时候，这个转化动作将在连接的第三阶段—-**解析**阶段中发生，通常需要校验以下内容：\n\n- 符号引用中通过字符串描述的全限定名是否能找到对应的类\n- 在指定类中是否存在符合方法的字段描述以及简单名称说描述的方法和字段。\n- 符号引用中的类，字段，方法的访问性是否可以被当前类访问\n- .......\n\n如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间\n\n#### 准备\n\n为类的**静态变量**分配内存，并初始化为默认值\n\n| 数据类型  | 默认值   |\n| --------- | -------- |\n| boolean   | false    |\n| char      | '/u0000' |\n| byte      | (byte)0  |\n| short     | (short)0 |\n| int       | 0        |\n| long      | 0L       |\n| double    | 0.0d     |\n| float     | 0.0f     |\n| reference | null     |\n\n🎯 当然并不是所有情况下都会初始化为零值，如果字段表的属性中有`ConstantValue` ，准备阶段就会直接初始化为这个这个`ConstantValue`属性的值\n\n#### 解析\n\n解析阶段是虚拟机将**常量池**内的**符号引用**替换为**直接引用**的过程。\n\n- **符号引用：** 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候能无歧义的定位到目标中就行。\n- **直接引用：** 直接引用可以是直接指向目标的指针，相对偏移量或者一个能间接定位到目标的句柄。\n\n除 `invokedynamic`(动态语言支持) 指令以外，虚拟机实现可以对第一次解析的结果进行缓存。\n\n解析动作主要针对类或接口、字段解析、类方法解析、接口方法解析、方法类型解析、方法句柄解析和调用点限定符 7 类符号引用进行。\n\n关于这个也可以看看R大的回答 [JVM符号引用转换直接引用的过程 ](https://www.zhihu.com/question/30300585/answer/51335493)( 吹爆我R大 😁\n\n### ③初始化：\n\n初始化阶段就是执行`类构造器<clinit>`方法的过程\n\n#### 类构造器&lt;client&gt;\n\n💡`<clinit>`方法是由编译器自动收集类中的所有**类变量的赋值**动作和**静态语句块**（static块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中**出现的顺序决定的**，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块**可以赋值**，但是**不能访问**（比如print）\n\n💡 和**实例构造器**`<init>` 不同，不需要显式的去调用父类的构造器，虚拟机会保证子类的`<clinit>`方法执行之前，父类的`<clinit>`方法已经执行完毕，因此虚拟机中第一个被执行的`<clinit>` 一定是Object类\n\n💡` <clinit>` 方法对于类或者接口来说并不是必须的，如果类中没有静态语句块也没有静态变量的**赋值**操作，那么编译器可以不为这个类生成`<clinit>` 方法\n\n💡 对于接口，不能使用static块，但是可以有静态变量的赋值操作。子类接口的`<clinit>`方法调用并不保证父接口的`<clinit>`方法被先调用，只有用到父接口的静态变量的时候，父接口`<clinit>`方法才会被调用。接口的实现类在初始化时也一样不会执行接口的`<clinit>`方法。\n\n💡 虚拟机会保证一个类的`<clinit>`方法在多线程环境中被正确地加锁、同步。如果一个线程的`<clinit>`方法调用时间过长，就可能造成多个线程阻塞。Demo如下\n\n```java\npublic class ClinitThreadTest {\n    public static void main(String[] args) {\n        new Thread(()->new SimpleObj()).start();\n        new Thread(()->new SimpleObj()).start();\n        new Thread(()->new SimpleObj()).start();\n    }\n\n    static class SimpleObj{\n        private static AtomicBoolean init=new AtomicBoolean(true);\n\n        static {\n            System.out.println(Thread.currentThread().getName()+\" i will be init\");\n            while (init.get()){\n\n            }\n            System.out.println(\"i am finished\");\n       }\n    }\n}\n```\n\n#### 为类的静态变量赋予正确的初始值\n\n下面这个Demo很经典，可以帮助我们理解类加载的过程\n\n```java\npublic class SingleTon {\n    private static SingleTon ins=new SingleTon();\n\n    public static  int x=0;\n\n    public static int y;\n\n    private SingleTon(){\n        x++;y++;\n    }\n\n    public static SingleTon getIns(){\n        return ins;\n    }\n\n    public static void main(String[] args) {\n        SingleTon singleTon=getIns();\n        System.out.println(singleTon.x);\n        System.out.println(singleTon.y);\n    }\n}\n```\n\n如果不熟悉类加载的过程可能一眼就觉得应该是（1，1），其实不然，结合上面的加载过程分析\n\n🔺 首先加载连接，然后执行准备工作，在执行完**准备阶段**工作后三个静态变量都有了**默认的初始值**，然后进入初始化阶段\n\n🔺 `<clinit>`初始化阶段会按顺序**从上往下**依次赋予正确的初始值，所以**先执行**了`new Singleton()`给`ins`赋初始值，会调用它的构造器，然后x，y都++变为1，**再然后**就会给x，y赋予正确的初始值，x初始值为0，而y没有初始值所以就是（0，1）\n\n### Class对象在哪里？\n\n先说结论，Class对象和其他普通的Java对象一样都是存放在堆中的。\n\n存放在方法区的是类的元数据(InstanceKlass，包括类的常量池( constant pool)  ，域(Field)信息  ，方法(Method)信息 ，除了常量外的所有静态(static)变量 等)，`java.lang.Class实例`并不负责记录真正的类元数据，而只是对VM内部的`InstanceKlass`对象的一个包装供Java的反射访问用，在《深入理解Java虚拟机》一书里面说的存放在方法区中应该是有问题的。\n\n**类(静态)变量存放在哪里**\n\n从JDK 1.3到JDK 6的HotSpot VM，静态变量保存在类的元数据（InstanceKlass）的末尾(永久代)。而从JDK 7开始的HotSpot VM，静态变量则是保存在类的Java镜像（java.lang.Class实例）的末尾，也就是堆中\n\n参考 R大 [知乎回答](https://www.zhihu.com/question/50258991) \n\n## Java程序对类的使用方式\n\n所有的java虚拟机实现必须在每个类或接口被java程序**首次主动使用**时才**初始化**它们\n\n### 主动使用\n\n- 创建类的实例（new）\n- 对某个类或接口的静态变量进行读写（getstatic，putstatic）\n- 调用类的静态方法（invokestatic）\n- 反射某个类 （Class.forName()也可以设置不初始化类）\n- 初始化子类时会先初始化父类\n- 启动类 java HelloWorld  包含main函数的类\n- Jdk1.7的动态语言支持\n\n### 被动使用\n\n除了上面 7 个之外，其它的都是被动使用，**不会初始化类**，下面的Demo有几个很容易出错的的例子\n\n```java\npackage classloader_study.misc;\npublic class ClassActiveUse {\n    static {\n        System.out.println(\"main is init\");\n    }\n    public static void main(String[] args) throws ClassNotFoundException {\n        //System.out.println(Obj.t);\n        //Obj.getObj();\n        //Class.forName(\"classloader_study.Obj\");\n        //System.out.println(ObjChild.age);\n        \n        //父类会被初始化 通过子类调用父类的静态变量，子类不会初始化但是会被加载 \n        //1. System.out.println(ObjChild.n);\n        //不会初始化 定义应用数组也不会初始化类，但是会加载类\n        //2. Obj [] arrays=new Obj[10]; \n        //不会初始化 常量会在编译期间放到常量池中不会初始化类也不会加载，子类加载也一样\n        //3. System.out.println(Obj.t); \n        //Obj会被初始化   final修饰的复杂化类型再编译期间无法计算得到，会初始化类\n        //4. System.out.println(Obj.x); \n        // 类加载器去加载\n        //5. ClassLoader.loadClass();\n    }\n}\n\nclass Obj{\n\n    public static  final int t=10;  //编译期间就已经确定了就是10\n\t\n    public static int n=111;\n    \n    public static final int x=new Random().nextInt(100); //值不是常量，运行期间才会确定\n    static { \n        System.out.println(\"Obj is init\");\n    }\n\n    public static void getObj(){\n        System.out.println(\"NULL\");\n    }\n}\n\nclass ObjChild extends Obj{\n    public static int age=12;\n\n    static {\n        System.out.println(\"Child is init\");\n    }\n}\ninterface I{\n    final static int a=0;\n}\n```\n\n⚡new 一个Obj数组的时候，**会加载**Obj类，**不会初始化**Obj对象，但是会导致另一个类的初始化: `Lclassloader_study.misc.Obj`  这个类就代表了一个元素类型为Obj的一维数组，数组中应有的属性length和方法clone()都是在这个类实现的，这个类是由JVM在运行期间动态的为我们生成的，这个动作由`anewarray` 指令触发，而基本类型的数组由 `newarray` 指令触发。\n\n⚡ final修饰的常量会在**编译期间**就放到调用这个变量的方法的类的常量池中，既不会加载也不会初始化，这一点可以通过反编译`ClassActiveUse` 看的到，两个类不存在任何关系了，甚至可以在编译完成后`将Obj的class文件删掉`仍然可以执行，但是后面的另一个final常量很明显在**编译期间无法确定值**，只有在运行期间才能回去到值，所以会加载并初始化类\n\n⚡ 对接口的初始化和对类的初始化有一点不同，接口也有初始化过程，接口和类真正有区别是在上面主动使用的第5点，在**子接口被加载的时候并不要求其父接口全部完成了初始化**，只有在真正使用到父接口的时候才会初始化，这一点可以参考前文的 [类构造器部分](#③初始化：)\n\n> `-XX:+TraceClassLoading` 可以用来追踪类的加载信息并且打印出来\n\n###  对象的访问定位\n\n**如果直接使用句柄访问**，java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象数据与类型数据各自的具体地址信息，如下图所示。\n\n![mark](http://static.imlgw.top///20190418/FRA9GB31iiXH.png?imageslim)\n\n**如果使用直接指针访问**，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如下图所示，每个对象都有一个自己Class对象的引用(`getClass`)\n\n![mark](http://static.imlgw.top///20190418/1OtoI6wkivdz.png?imageslim)\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。\n\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。HotSpot虚拟机使用的是直接指针访问的方式。句柄来访问的情况也十分常见。\n\n## JVM类加载器\n\n### 概述\n\n> 虚拟机设计团队把加载阶段中的 `“通过一个类的全限定名来获取描述此类的二进制字节流”` 这个动作被放到Java虚拟机外部去实现，以便于让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为 `“类加载器”`\n\n 类加载器并不需要等到某个类被 \"首次使用\" 时才加载它，这一点从前面讲解的 [被动使用的例子](#被动使用) 哪里就看得出来\n\nJVM规范允许类加载器在预料某个类将要被使用的时候就预先加载它，如果在预先加载的过程中遇到了class文件缺失或者存在错误，类加载器必须在程序**首次主动使用**该类时才报告错误（LinkageError错误）\n\n 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误\n\n![JVM类加载器](http://static.imlgw.top///20190419/pKeI6Bx6lbcX.png?imageslim)\n\n\n\n**根（Bootstrap）类加载器**\n\n该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承 java.lang.ClassLoader类(c/c++实现的)。\n\n```java\nSystem.out.println(System.getProperty(\"sun.boot.class.path\"));\nD:\\java\\jre\\lib\\resources.jar;D:\\java\\jre\\lib\\rt.jar;D:\\java\\jre\\lib\\sunrsasign.jar;D:\\java\\jre\\lib\\jsse.jar;D:\\java\\jre\\lib\\jce.jar;D:\\java\\jre\\lib\\charsets.jar;D:\\java\\jre\\lib\\jfr.jar;D:\\java\\jre\\classes\n```\n\n**扩展（Extension）类加载器**\n\n它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre.lib.ext子目录（扩展目录）下加载类库，如果把用户创建的**JAR**文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是 java.lang.ClassLoader类的子类。\n\n```java\nSystem.out.println(System.getProperty(\"java.ext.dirs\")); //java.ext.dirs属性\nD:\\java\\jre\\lib\\ext;C:\\WINDOWS\\Sun\\Java\\lib\\ext\n```\n\n**系统（System）类加载器**\n\n也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，它是用户自定义的类加载器的`默认父加载器`。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。\n\n```java\nSystem.out.println(System.getProperty(\"java.class.path\"));\nD:\\java\\jre\\lib\\charsets.jar;D:\\java\\jre\\lib\\deploy.jar;\nD:\\java\\jre\\lib\\ext\\access-bridge-64.jar;\nD:\\java\\jre\\lib\\ext\\cldrdata.jar;\nD:\\java\\jre\\lib\\ext\\dnsns.jar;\nD:\\java\\jre\\lib\\ext\\jaccess.jar;\nD:\\java\\jre\\lib\\ext\\jfxrt.jar;\nD:\\java\\jre\\lib\\ext\\localedata.jar;\nD:\\java\\jre\\lib\\ext\\nashorn.jar;\nD:\\java\\jre\\lib\\ext\\sunec.jar;\nD:\\java\\jre\\lib\\ext\\sunjce_provider.jar;\nD:\\java\\jre\\lib\\ext\\sunmscapi.jar;\nD:\\java\\jre\\lib\\ext\\sunpkcs11.jar;\nD:\\java\\jre\\lib\\ext\\zipfs.jar;\nD:\\java\\jre\\lib\\javaws.jar;\nD:\\java\\jre\\lib\\jce.jar;\nD:\\java\\jre\\lib\\jfr.jar;\nD:\\java\\jre\\lib\\jfxswt.jar;\nD:\\java\\jre\\lib\\jsse.jar;\nD:\\java\\jre\\lib\\management-agent.jar;\nD:\\java\\jre\\lib\\plugin.jar;\nD:\\java\\jre\\lib\\resources.jar;\nD:\\java\\jre\\lib\\rt.jar;\nC:\\WorkSpace\\concurrent_package\\out\\production\\concurrent_package;\nC:\\JetBrains\\IntelliJ IDEA 2018.1.4\\lib\\idea_rt.jar\n```\n\n> 其实所谓的父子加载器并不是继承的父子关系，而是包含的关系，子加载器中包含一个父加载器的引用\n\n### 自定义类加载器\n\n**先看下JDK的ClassLoader(1.8)源码**\n\n```java\n protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        //没有父加载器就交给根加载器\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    //需要子类去实现\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n这是ClassLoader类加载类的方法，可以看到中间有一段 \n\n```java\nif(parent!=null){  c = parent.loadClass(name, false);}\n```\n\n这就是**双亲委派机制**的实现，委托父类，让父类去加载，父类(根加载器)没有就会再层层下降如果有一个加载成功就会成功返回，除此之外还调用了一个没有实现的`findClass`\n\n```java\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n    throw new ClassNotFoundException(name);\n}\n```\n\n也就是说想自定义类加载器的话就得重写`findClass`方法，实际上这个`findClass`才是类加载的核心，真正加载Class文件转换为CLass实例的就是`findClass`方法， `loadClass()`只是实现加载的逻辑，比如**双亲委派机制**\n\n**实现一个简易的ClassLoader**\n\n```java\npublic class MyClassLoader extends ClassLoader {\n    //将字节码放到这个路径下\n    private static final String DEFAULT_DIR = \"D:\\\\ClassLoaderTest\";\n\n    private String dir = DEFAULT_DIR;\n\n    private String classLoaderName;\n\n    public MyClassLoader() {\n        \n    }\n\n    public MyClassLoader(String classLoaderName) {\n        this.classLoaderName = classLoaderName;\n    }\n\n    public MyClassLoader(ClassLoader parent, String classLoaderName) {\n        super(parent);\n        this.classLoaderName = classLoaderName;\n    }\n\n    public String getDir() {\n        return dir;\n    }\n\n    public void setDir(String dir) {\n        this.dir = dir;\n    }\n\n    public String getClassLoaderName() {\n        return classLoaderName;\n    }\n\n    /**\n     * xx.xx.xx.xx.xx.AAA\n     * xx/xx/xx/xx/xx/.AAA.class\n     *\n     * @param name\n     * @return\n     * @throws ClassNotFoundException\n     */\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        String classPath = name.replace(\".\", \"/\");\n        File classFile = new File(dir, classPath + \".class\");\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(\"The class \" + name + \" not found under \" + dir);\n        }\n\t\t//字节码文件的字节流\n        byte[] classBytes = loadClassBytes(classFile);\n        if (null == classBytes || classBytes.length == 0)\n            throw new ClassNotFoundException(\"load the class \" + name + \" failed\");\n\t\t//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class\n        return this.defineClass(name, classBytes, 0, classBytes.length);\n    }\n\t\n    //将文件流转换为字节流\n    private byte[] loadClassBytes(File classFile) {\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n             FileInputStream fis = new FileInputStream(classFile)) {\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = fis.read(buffer)) != -1) {\n                baos.write(buffer, 0, len);\n            }\n            baos.flush();\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```\n\n> defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class，前提是Class文件是合法的。\n\n```java\n//自定义的需要加载的类\npublic class MyObject {\n    static {\n        System.out.println(\"MyObject static is init\");\n    }\n\n    public void Hello(){\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n**测试自定义的ClassLoader**\n\n```java\npublic class ClassLoaderTest {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n        MyClassLoader loader=new MyClassLoader(\"Resolmi\");\n        //Class<?> aClass = loader.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        Class<?> aClass = Class.forName(\"classloader_study.myClassLoader.MyObject\", true, loader);\n        System.out.println(aClass);\n        System.out.println(aClass.getClassLoader());\n\n        Object obj=aClass.newInstance();\n        Method hello = aClass.getMethod(\"Hello\", null);\n        hello.invoke(obj, new Object[]{});\n    }\n}\n```\n\n这里直接`loadClass`或者`Class.forName()`都可以，通常我们的forName()都是默认用的**AppClassLoader**也就是系统加载器，但是我们也可以把我们的自定义加载器传递进去。\n\n> tip: loadClass 不会初始化类，不属于上面提到的6种主动使用的方式，属于被动使用，Class.forName 第二个参数就是控制是否初始化\n\n```java\nMyObject static is init\nclass classloader_study.myClassLoader.MyObject\nclassloader_study.myClassLoader.MyClassLoader@74a14482\nHello World\n```\n\n如果使用了`ide`的话，这里很有可能编译器帮你自动编译了，也就是在你的classpath里面已经有字节码文件了，所以就直交给AppClassLoader加载了，所以需要将classpath里面的删掉，将字节码拷贝到你自定义的classLoader指定的目录里面。\n\n### 双亲委派模式\n\n即在类加载的时候，系统会判断当前类是否已经被加载，如果被加载，就会直接返回可用的类，否则就会尝试加载，在尝试加载时，会先请求双亲处理，如果双亲请求失败，则会自己加载\n\n这里光看几个内置的ClassLoader可能还不太清晰这里用我们自定义的Loader来试试\n\n```java\npublic class MyClassLoaderTest2 {\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n        //loader1的加载目录是D:\\\\ClassLoaderTest（默认的）\n        MyClassLoader loader1=new MyClassLoader(\"Resolmi-father\");\n        //设置loader1为loader2的父加载器\n        MyClassLoader loader2=new MyClassLoader(loader1,\"Resolmi2-son\");\n        //这个类存放在 D:\\\\ClassLoaderTest\\\\classloader_study\\\\myClassLoader 下面\n        Class<?> aClass = loader2.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        //设置Loader2的加载目录，这是个空目录，下面什么都没有\n        loader2.setDir(\"D:\\\\ClassLoaderTest2\");\n        System.out.println(aClass);\n        System.out.println(aClass.getClassLoader());\n        System.out.println(((MyClassLoader)aClass.getClassLoader()).getClassLoaderName());\n     }\n}\n```\n\n控制台打印如下\n\n```java\nclass classloader_study.myClassLoader.MyObject\nclassloader_study.myClassLoader.MyClassLoader@74a14482\nResolmi-father\n```\n\n我们用`Loader2`去加载类，但是这个类的加载目录是空的，然后我们指定`Loader2` 的父加载器为`Loader1`而`loader1` 得加载路径就是要加载得类的路径，可以看到这个这个类最终还是被加载出来了，而且是被 `loader1`加载出来的，也就是`loader2`把加载任务委托给了父加载器`loader1`,然后层层委托再回到`loader1`，由它加载。\n\n到这里可能会有疑问，为什么要用双亲委派模式？这样走一圈多慢啊，其实这样做主要有两个方面的原因\n\n💡 提高系统安全性，使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。对于一些系统核心类，用户自定义的不起作用了，因为都会交给`BootStrapLoader`去加载，比如自定义了一个java.lang.String的类，然后在加载的时候经过层层委派最后会交给 `BootStrapLoader`去加载然后返回，所以你自定义的String根本没有加载的机会，这样就避免了用户篡改Java核心的类\n\n💡 避免重复加载，父Loader已经加载过的类，子Loader就不用再加载了，比如`Object类`这个类在`rt.jar`下，所以无论是在哪种环境下，最终都会交给`BootStrapClassLoader`去加载这个类，加载得到的都是同一个`Object类`，如果不采用双亲委派机制，让各个Loader自己加载那么可能加载出来的就会有很多个Object类（不是同一个Object类，下面会说到）\n\n```java\nException in thread \"main\" java.lang.SecurityException: Prohibited package name: java.lang\n```\n\n### 加密解密类加载器\n\n本质上和上面的没什么区别，就是多了解密的功能，这里首先用加密工具类加密class\n\n```java\npublic final class EncryptUtil {\n\t//相当于密钥\n    public static final byte ENCRYPT_FACTOR = (byte) 0xff;\n\n    private EncryptUtil() {\n\n    }\n\n    public static void encrypt(String source, String target) throws FileNotFoundException {\n        try (FileInputStream in= new FileInputStream(source); FileOutputStream out = new FileOutputStream(target)) {\n            int data;\n            while ((data=in.read())!=-1){\n                out.write(data^ENCRYPT_FACTOR);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        encrypt(\"D:\\\\ClassLoaderTest\\\\classloader_study\\\\myClassLoader\\\\MyObject.class\",\"D:\\\\ClassLoaderTest\\\\classloader_study\\\\myClassLoader\\\\MyObject2.class\");\n    }\n}\n```\n\n然后用加密解密类加载器加载这个类\n\n```java\npublic class DecryptClassLoader extends ClassLoader {\n\n    private final String DEFAULT_DIR = \"D:\\\\ClassLoaderTest\";\n\n    private String dir = DEFAULT_DIR;\n\n    public DecryptClassLoader() {\n        super();\n    }\n\n    public DecryptClassLoader(ClassLoader parent) {\n        super(parent);\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        String classPath = name.replace(\".\", \"/\");\n        File classFile = new File(dir, classPath + \".class\");\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(\"没找到对应的类文件 ：\" + dir);\n        }\n        byte[] classBytes = loadClassByte(classFile);\n        if (null == classBytes || classBytes.length == 0) {\n            throw new ClassNotFoundException(\"加载失败\");\n        }\n        return this.defineClass(name, classBytes, 0, classBytes.length);\n    }\n\n    private byte[] loadClassByte(File classFile) {\n        try (FileInputStream in = new FileInputStream(classFile); ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n            int data;\n            while ((data=in.read())!=-1){\n                //主要就是这里发生了变化，异或了0xff\n                baos.write(data^0xff);\n            }\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void setDir(String dir) {\n        this.dir = dir;\n    }\n}\n```\n\n当然结果是加载成功啦😋，这里如果用其他的类加载器加载，或者把0xff那里去掉，就会报如下错误\n\n```java\nException in thread \"main\" java.lang.ClassFormatError: Incompatible magic value 889275713 in class file classloader_study/myClassLoader/MyObject\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:642)\n\tat classloader_study.myClassLoader.MyClassLoader.findClass(MyClassLoader.java:64)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat classloader_study.encryption_study.ClassLoaderTest.main(ClassLoaderTest.java:15)\n```\n\n这个异常是链接阶段验证的错误，是上面提到的`defineClass()`抛出来的，因为你加了密，JVM在加载这个二进制流的时候就无法识别了自然就无法加载。\n\n### 打破双亲委派机制\n\n**覆盖loadClass()**\n\n要打破双亲委派机制主要就是要覆盖`loadClass()`方法，自己定义加载类的方式。\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException {\n    Class<?> clazz = null;\n\n    //让父加载器加载java核心的包，因为有些类是继承的Java内部的核心类比如Object类\n    if (name.startsWith(\"java.\")) {\n        try {\n            ClassLoader system = ClassLoader.getSystemClassLoader();\n            //这里仍然是委托上级\n            clazz = system.loadClass(name);\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return clazz;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    try {\n        //自己先找\n        clazz = findClass(name);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\t//找不到就交给父加载器\n    if (clazz == null && getParent() != null) {\n        getParent().loadClass(name);\n    }\n\n    return clazz;\n}\n```\n\n其实就是自己先找，找不到才会交给父加载器，然后一个需要注意的就是你想加载的这个类可能继承了Java内部核心的类像`Object`类，然后要加载子类就要先加载它的父类，而你的这个包里面肯定是加载不到这些Java内部的核心类的，所以这些还是得交给上层的加载器去加载。\n\n**测试效果**\n\n```java\npublic class SimpleClassLoaderTest {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        SimpleClassLoader simpleClassLoader = new SimpleClassLoader();\n        Class<?> aClass = simpleClassLoader.loadClass(\"classloader_study.break_parent.SimpleObject\");\n        System.out.println(aClass.getClassLoader());\n    }\n}\n```\n\n注意这里在`classpath`里面是有这个类的字节码文件的，按照双亲委托机制应该由AppClassLoader去加载\n\n![mark](http://static.imlgw.top///20190420/5Nc0S6OoIa2D.png?imageslim)\n\n但是仍然是由我们的SimpleClassLoader加载的，说明我们成功了打破了双亲委派机制（貌似Tomcat也是这种加载机制，有时间看看Tomcat的类加载器）\n\n**面试题**\n\n❓ **能不能自己写个类比如`java.lang.String`去覆盖Java的`String`？如果不覆盖`loadClass()`方法使用双亲委托肯定是不行，但是既然上面已经打破了双亲委托那是不是就可以了呢？**\n\n`Talk is cheap，show me the code` 试试就知道了\n\n先准备一个String类\n\n```java\npackage java.lang;\n/**\n * @author imlgw.top\n * @date 2019/4/18 12:01\n */\npublic class String {\n    static {\n        System.out.println(\"i am init\");\n    }\n    public int getVal(){\n        return  250;\n    }\n}\n```\n\n编译好之后放到我们自定义的`ClassLoader`的目录下，然后将我们`loadClass()`方法加载核心包的地方注释掉（不然还是会交给父加载器去加载）然后为了表示是我们自定义的`ClassLoader`加载的我们把classpath里面的字节码文件也删掉。\n\n```java\n public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        SimpleClassLoader simpleClassLoader = new SimpleClassLoader();\n        Class<?> aClass = simpleClassLoader.loadClass(\"java.lang.String\");\n        System.out.println(aClass.getClassLoader());\n    }\n```\n\n然后就会看到如下的`SecurityException`\n\n```java\njava.lang.SecurityException: Prohibited package name: java.lang\n\tat java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:761)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:642)\n\tat classloader_study.break_parent.SimpleClassLoader.findClass(SimpleClassLoader.java:52)\n\tat classloader_study.break_parent.SimpleClassLoader.loadClass(SimpleClassLoader.java:77)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:7)\n```\n\n其实Java为了安全，自定义类取名不能取`java.*`等核心包名开头，在`preDefineClass`里面做了检查，所以即使你打破了双亲委托机制你依然不能去覆盖Java的核心类（肯定不行啊😄）。\n\n其实这里后来了解了`Unsafe`后也尝试用`Unsafe` 去加载这个类\n\n```java\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n        Unsafe unsafe=UnsafeTest.getUnsafe();\n        String classPath = name.replace(\".\", \"/\");\n        File classFile = new File(dir, classPath + \".class\");\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(\"The class \" + name + \" found under \" + dir);\n        }\n\n        byte[] classBytes = loadClassBytes(classFile);\n        if (null == classBytes || classBytes.length == 0)\n            throw new ClassNotFoundException(\"load the class \" + name + \" failed\");\n\n        return unsafe.defineClass(null,classBytes,0,classBytes.length,SimpleClassLoader.this,null);\n}\n```\n\n`loadClass` 同上，尝试加载你会发现 会提示找不到`Object` 类，嗯？已经在加载父类了，难不成还真可以？这里其实已经和上面的方法不同了，上面的方法是不会进入到加载父类的环节的，直接在加载前就被检测了包名然后GG了，随后我在`loadClass` 中让系统加载器去加载Object类，再次尝试加载\n\n```java\njava.lang.SecurityException: Prohibited package name: java.lang\n\tat sun.misc.Unsafe.defineClass(Native Method)\n\tat classloader_study.break_parent.SimpleClassLoader.findClass(SimpleClassLoader.java:57)\n\tat classloader_study.break_parent.SimpleClassLoader.loadClass(SimpleClassLoader.java:83)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:7)\nException in thread \"main\" java.lang.NullPointerException\n\tat classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:8)\n```\n\n还是熟悉的味道😂 `defineClass`虚拟机本地方法抛了异常\n\n### 类加载器细节深入\n\n**定义加载器&初始加载器**\n\n⚡真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正`完成类的加载`工作是通过调用 `defineClass(findClass)`来实现的；而`启动`类的加载过程是通过调用 `loadClass`来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：**一个类的定义加载器是它引用的其它类的初始加载器**。如类 `com.example.Outer`引用了类 `com.example.Inner`，则由类 `com.example.Outer`的**定义加载器**负责启动类 `com.example.Inner`的加载过程。\n\n**命名空间&运行时包**\n\n> 每个类都有自己的命名空间，命名空间由`该加载器及所有父加载器所加载的类`组成，`子加载器的命名空间包含所有父加载器的命名空间`，因此子加载器可以加载的类可以看就按父加载器加载的类，例如系统类加载器可以看见根加载器加载的类。由父加载器加载的类看不见子加载器加载的类，如果两个类之间没有直接或者间接的父子关系，那么他们各自加载的类相互不可见\n\n⚡数组类的Class不是由类加载器加载的，是由JVM在运行期间动态生成的，但是通过`getClassLoader`返回的类加载器和数组的元素的类加载器是一样的，原生的类型比如`int` 之类的没有类加载器返回的是null\n\n⚡每个类加载器都有其自己的命名空间，命名空间由该加载器和其所有父类加载器所加载的类组成，同一份字节码两个不同的类加载器加载出来的不是同一个类。\n\n```java\npublic class MyClassLoaderTest2 {\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n        //注意这里的ClassLoader要么利用前面的打破了双亲委托机制的，要么把classpath里面字节码的删掉。\n        MyClassLoader loader1=new MyClassLoader(\"Resolmi1\");\n        MyClassLoader loader2=new MyClassLoader(\"Resolmi2\");\n        Class<?> aClass2 = loader2.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        Class<?> aClass1 = loader1.loadClass(\"classloader_study.myClassLoader.MyObject\");\n        //两个不同的加载器（没有父子关系）加载同一个类加载出来的不是同一个\n        System.out.println(aClass1.hashCode()); //2133927002\n        System.out.println(aClass2.hashCode()); //1836019240\n     }\n}\n```\n\n⚡**父类加载器**无法访问**子类加载器**加载的类，而**子加载器**可以访问到**父加载器**所加载的类\n\n```java\npublic class ClassLoaderTest {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n        //使用上面自定义的ClassLoader\n        MyClassLoader loader=new MyClassLoader(\"Resolmi\");\n        Class<?> aClass = loader.loadClass(\"classloader_study.myClassLoader.Parent\");\n        //创建实例\n        aClass.newInstance();\n    }\n}\n```\n\n**Parent类**\n\n```java\npublic class Parent {\n    public Parent() {\n        System.out.println(\"Parent is load by\" + this.getClass().getClassLoader());\n        Hello();\n    }\n\n    public void Hello() {\n        //父加载器访问子加载器加载的类\n        System.out.println(\"Parent can see the \" + Sub.class);\n    }\n}\n```\n\n**Sub类**\n\n```java\npublic class Sub {\n    public Sub(){\n        System.out.println(\"Sub is load by\"+this.getClass().getClassLoader());\n        new Parent(); //构造Parent类\n    }\n}\n```\n\n做完了这些工作之后，编译代码，然后将classpath中的`Parent.class`拷贝到自定义的ClassLoader路径下面，然后删掉classpath中的`Parent.class` ，然后运行\n\n```java\nSub is load byclassloader_study.myClassLoader.MyClassLoader@74a14482\nParent is load bysun.misc.Launcher$AppClassLoader@18b4aac2\nException in thread \"main\" java.lang.NoClassDefFoundError: classloader_study/myClassLoader/Sub\n\tat classloader_study.myClassLoader.Parent.Hello(Parent.java:15)\n\tat classloader_study.myClassLoader.Parent.<init>(Parent.java:10)\n\tat classloader_study.myClassLoader.Sub.<init>(Sub.java:10)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat classloader_study.myClassLoader.ClassLoaderTest.main(ClassLoaderTest.java:14)\nCaused by: java.lang.ClassNotFoundException: classloader_study.myClassLoader.Sub\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 9 more\n```\n\n可以看到，我们的`Sub` 是由我们自定义的`MyClassLoader` 加载的，因为我们删掉了Classpath中的字节码，而在自定义的路径中有所以最后还是由我们的 `MyClassLoader` 加载了，所以我们的`Parent`类首先也会由我们的`自定义类加载器MyClassLoader`去作为**初始加载器**加载，由于我们的Classpath中还有字节码文件，所以在双亲委派机制下`Sub类` 最终由`AppClassLoader`加载 ，两个类由不同的类加载器加载，然后我们在`Parent` 类中试图访问`Sub` 类，结果抛出了`ClassNotFoundException`  和`NoClassDefFoundError` 异常\n\n❓ **那我们反过来在`Sub`类中访问 `Parent` 类会发生什么，改造一下Parent和Sub**\n\n**Parent类**\n\n```java\npublic class Parent {\n    public Parent() {\n        System.out.println(\"Parent is load by\" + this.getClass().getClassLoader());\n        //Hello();\n    }\n\n    public void Hello() {\n        //父加载器访问子加载器加载的类\n        System.out.println(\"Parent can see the \" + Sub.class);\n    }\n}\n```\n\n**Sub类**\n\n```java\npublic class Sub {\n    public Sub(){\n        System.out.println(\"Sub is load by\"+this.getClass().getClassLoader());\n        new Parent(); //构造Sub类\n        //访问父加载器加载的类\n        System.out.println(\"Sub can see \"+Parent.class);\n    }\n}\n```\n\n和上面一样删掉Classpath中Sub类的class文件没然后运行\n\n```java\nfindclass is invoke MyClassLoader is loadclassloader_study.myClassLoader.Sub\nSub is load byclassloader_study.myClassLoader.MyClassLoader@74a14482\nParent is load bysun.misc.Launcher$AppClassLoader@18b4aac2\nSub can see class classloader_study.myClassLoader.Parent\n\nProcess finished with exit code 0\n```\n\n没有任何问题，由此就可以证明我们上面的结论是正确的。\n\n❓ **面试题：如何让一个类的static代码块执行两次**\n\n用不同的类加载器去加载这个类，至于为什么应该不用我多说了吧。\n\n**类的卸载和ClassLoader的卸载**\n\n>  由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中**始终不会被卸载**，Java虚拟机本身会引用这些类加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象始终是可达的。\n\n⚡JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）\n\n- 该类所有的实例都已经被GC。\n- 加载该类的ClassLoader实例已经被GC。(Class对象里面有对ClassLoader的引用)\n- 该类的java.lang.Class对象没有在任何地方被引用。\n\nGC的时机我们是不可控的，那么同样的我们对于Class的卸载也是不可控的，使用`-XX:+TraceClassUnloading` 或者jvisualvm可以看到类的卸载\n\n## 线程上下文加载器(**TCCL**)\n\n​\t在说TCCL之前不得不说一下另一个话题，SPI（Service Provider Interface，SPI）服务提供接口，由第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 **Java 核心库**来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进**类路径**（classpath）里。SPI接口中的代码经常需要加载具体的实现类。\n\n> 为什么要使用SPI?  SPI是JDK内置的一种**服务提供发现机制**。这样做的好处主要是为了解耦，实现动态替换，减少硬编码（比如jdk1.6之前的Class.forName(\"XXXX\") ）面向接口编程，在很多开源框架中都有体现，比如Dubbo，Spring等\n\n那么问题来了，`SPI的接口`是Java核心库的一部分位于`rt.jar`中，是由**根加载器**(Bootstrap Classloader)来加载的，而`SPI的实现类`是一般是第三方的提供的，位于`classpath`目录中，而**根加载器**很明显是无法直接加载到这个目录下的SPI 的实现类的 (双亲委派)，那`SPI`是如何自动加载到实现类的呢？\n\n为了解决这个问题，虚拟机提供了**线程上下文加载器（TCCL）**配合`ServiceLoader`来帮助上层加载器加载类，`TCCL`破坏了“双亲委派模型”，可以在执行过程中切换为`TCCL` 来加载第三方的SPI实现类，抛弃双亲委派机制，使程序可以逆向使用类加载器。**TCCL**默认是系统类加载器，也可以通过`setContextClassLoader`去设置\n\n### JDBC源码案例分析\n\n翻到了最开始学JDBC的时候写的代码😄\n\n![JDBC](http://static.imlgw.top///20190420/K4uQf6h5czDb.png?imageslim)\n\n**贾琏欲执事**，可以看到第一步还是加载并且初始化驱动，前面已经提到这一步其实没有必要了，jdk1.6之后因为ServiceLoader，SPI机制的出现，就不用再显示的加载驱动，但是正如上面所说`Driver`只是个接口存放于`rt.jar` 中，由根加载器所加载，那SPI是怎么自动的加载到`mysql`的`Driver`实例的呢？😕\n\n我们一步步的来看，首先`DriverManager.getConnection()`这里，`getConnection`是个静态方法，调用它就会先执行`DriverManager`类的静态代码块，而静态代码块里面主要执行的就是`loadInitialDrivers()`\n\n### loadInitialDrivers()源码\n\n```java\nprivate static void loadInitialDrivers() {\n    String drivers;\n    try {\n        drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            public String run() {\n                return System.getProperty(\"jdbc.drivers\");\n            }\n        });\n    } catch (Exception ex) {\n        drivers = null;\n    }\n    // If the driver is packaged as a Service Provider, load it.\n    // Get all the drivers through the classloader\n    // exposed as a java.sql.Driver.class service.\n    // ServiceLoader.load() replaces the sun.misc.Providers()\n\t// 如果驱动正确打包为jar就会用ServiceLoader去加载它\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n            /****************************************************/\n\t\t\t/*ServiceLoad工具类，注意这个ServiceLoad的加载器，默认就是TCCL*/\n            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n            /****************************************************/\n            /*在这里会获取到一个Drivers的迭代器，但是其实还没有开始加载类*/\n            Iterator<Driver> driversIterator = loadedDrivers.iterator();\n\n            /* Load these drivers, so that they can be instantiated.\n             * It may be the case that the driver class may not be there\n             * i.e. there may be a packaged driver with the service class\n             * as implementation of java.sql.Driver but the actual class\n             * may be missing. In that case a java.util.ServiceConfigurationError\n             * will be thrown at runtime by the VM trying to locate\n             * and load the service.\n             *\n             * Adding a try catch block to catch those runtime errors\n             * if driver not available in classpath but it's\n             * packaged as service and that service is there in classpath.\n             */\n            try{\n                while(driversIterator.hasNext()) {\n                    //迭代的过程中通过next反射加载并初始化这个驱动字节码\n                    //没有接收返回的数据库驱动实例\n                    driversIterator.next();\n                }\n            } catch(Throwable t) {\n            // Do nothing\n            }\n            return null;\n        }\n    });\n\n    println(\"DriverManager.initialize: jdbc.drivers = \" + drivers);\n\t//加载Jdk中的驱动实例（虽然我并不知道是什么）总之我们第三方的驱动已经加载好了\n    if (drivers == null || drivers.equals(\"\")) {\n        return;\n    }\n    String[] driversList = drivers.split(\":\");\n    println(\"number of Drivers:\" + driversList.length);\n    for (String aDriver : driversList) {\n        try {\n            println(\"DriverManager.Initialize: loading \" + aDriver);\n            Class.forName(aDriver, true,\n                    ClassLoader.getSystemClassLoader());\n        } catch (Exception ex) {\n            println(\"DriverManager.Initialize: load failed: \" + ex);\n        }\n    }\n}\n```\n\n可以看到中间有一行很关键的代码\n\n `ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);`\n\n这就是我上面所提到的 `ServiceLoader` \n\n> 对于SPI机制，JDK提供了`java.util.ServiceLoader`工具类，在使用某个服务接口时，它可以帮助我们查找该服务接口的实现类，加载和初始化，前提条件是基于它的约定：当服务的提供者提供了服务接口的一种实现之后，在`jar`包的`META-INF/services/`目录里同时创建一个以`服务接口命名的文件`。该文件里就是实现该服务接口的具体实现类（去解压看看那些jar包就可以看见这些信息o(*￣▽￣*)ブ）\n\n### ServiceLoader类源码\n\n为了节约篇幅删掉了一些注释，发现其实整个类也没多少行大概2，3百行的样子，需要注意这个类并不是线程安全的，所以使用的时候需要注意\n\n```java\npublic final class ServiceLoader<S> implements Iterable<S> {\n\t//目录前缀就是从这里来的\n    private static final String PREFIX = \"META-INF/services/\";\n\n    //实现类Service\n    private final Class<S> service;\n\n    // The class loader used to locate, load, and instantiate providers\n    private final ClassLoader loader;\n\n    // The access control context taken when the ServiceLoader is created\n    private final AccessControlContext acc;\n\n    // Cached providers, in instantiation order\n    // 按照实例的顺序，来缓存服务提供者避免重复的加载，具体可以看下面的iterator方法\n    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();\n\n    // The current lazy-lookup iterator\n    private LazyIterator lookupIterator;\n\n    public void reload() {\n        providers.clear();\n        //初始化懒加载迭代器\n        lookupIterator = new LazyIterator(service, loader);\n    }\n\t\n    //构造器\n    private ServiceLoader(Class<S> svc, ClassLoader cl) {\n        service = Objects.requireNonNull(svc, \"Service interface cannot be null\");\n        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;\n        acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;\n        reload();\n    }\n\n    private static void fail(Class<?> service, String msg, Throwable cause)\n        throws ServiceConfigurationError\n    {\n        throw new ServiceConfigurationError(service.getName() + \": \" + msg,\n                                            cause);\n    }\n\n    private static void fail(Class<?> service, String msg)\n        throws ServiceConfigurationError\n    {\n        throw new ServiceConfigurationError(service.getName() + \": \" + msg);\n    }\n\n    private static void fail(Class<?> service, URL u, int line, String msg)\n        throws ServiceConfigurationError\n    {\n        fail(service, u + \":\" + line + \": \" + msg);\n    }\n\n    // Parse a single line from the given configuration file, adding the name\n    // on the line to the names list.\n    //\n    private int parseLine(Class<?> service, URL u, BufferedReader r, int lc,\n                          List<String> names)\n        throws IOException, ServiceConfigurationError\n    {\n        String ln = r.readLine();\n        if (ln == null) {\n            return -1;\n        }\n        int ci = ln.indexOf('#');\n        if (ci >= 0) ln = ln.substring(0, ci);\n        ln = ln.trim();\n        int n = ln.length();\n        if (n != 0) {\n            if ((ln.indexOf(' ') >= 0) || (ln.indexOf('\\t') >= 0))\n                fail(service, u, lc, \"Illegal configuration-file syntax\");\n            int cp = ln.codePointAt(0);\n            if (!Character.isJavaIdentifierStart(cp))\n                fail(service, u, lc, \"Illegal provider-class name: \" + ln);\n            for (int i = Character.charCount(cp); i < n; i += Character.charCount(cp)) {\n                cp = ln.codePointAt(i);\n                if (!Character.isJavaIdentifierPart(cp) && (cp != '.'))\n                    fail(service, u, lc, \"Illegal provider-class name: \" + ln);\n            }\n            if (!providers.containsKey(ln) && !names.contains(ln))\n                names.add(ln);\n        }\n        return lc + 1;\n    }\n\n    private Iterator<String> parse(Class<?> service, URL u)\n        throws ServiceConfigurationError\n    {\n        InputStream in = null;\n        BufferedReader r = null;\n        ArrayList<String> names = new ArrayList<>();\n        try {\n            in = u.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n            int lc = 1;\n            while ((lc = parseLine(service, u, r, lc, names)) >= 0);\n        } catch (IOException x) {\n            fail(service, \"Error reading configuration file\", x);\n        } finally {\n            try {\n                if (r != null) r.close();\n                if (in != null) in.close();\n            } catch (IOException y) {\n                fail(service, \"Error closing configuration file\", y);\n            }\n        }\n        return names.iterator();\n    }\n\n    // Private inner class implementing fully-lazy provider lookup\n    // 看名字就知道了，懒迭代器，在迭代的时候才真正的加载\n    private class LazyIterator\n        implements Iterator<S>\n    {\n\n        Class<S> service;\n        ClassLoader loader;\n        Enumeration<URL> configs = null;\n        Iterator<String> pending = null;\n        String nextName = null;\n\n        private LazyIterator(Class<S> service, ClassLoader loader) {\n            this.service = service;\n            this.loader = loader;\n        }\n\n        private boolean hasNextService() {\n            if (nextName != null) {\n                return true;\n            }\n            if (configs == null) {\n                try {\n                    String fullName = PREFIX + service.getName();\n                    if (loader == null)\n                        configs = ClassLoader.getSystemResources(fullName);\n                    else\n                        configs = loader.getResources(fullName);\n                } catch (IOException x) {\n                    fail(service, \"Error locating configuration files\", x);\n                }\n            }\n            while ((pending == null) || !pending.hasNext()) {\n                if (!configs.hasMoreElements()) {\n                    return false;\n                }\n                pending = parse(service, configs.nextElement());\n            }\n            nextName = pending.next();\n            return true;\n        }\n        \n\t\t//迭代器的next\n        private S nextService() {\n            if (!hasNextService())\n                throw new NoSuchElementException();\n            String cn = nextName;\n            nextName = null;\n            Class<?> c = null;\n            try {\n                //利用TCCL加载实现类，但是不初始化\n                c = Class.forName(cn, false, loader);\n            } catch (ClassNotFoundException x) {\n                fail(service,\n                     \"Provider \" + cn + \" not found\");\n            }\n            if (!service.isAssignableFrom(c)) {\n                fail(service,\n                     \"Provider \" + cn  + \" not a subtype\");\n            }\n            try {\n                //newInstance()初始化了对应的实现类\n                S p = service.cast(c.newInstance());\n                //放到providers中\n                providers.put(cn, p);\n                return p;\n            } catch (Throwable x) {\n                fail(service,\n                     \"Provider \" + cn + \" could not be instantiated\",\n                     x);\n            }\n            throw new Error();          // This cannot happen\n        }\n\n        public boolean hasNext() {\n            if (acc == null) {\n                return hasNextService();\n            } else {\n                PrivilegedAction<Boolean> action = new PrivilegedAction<Boolean>() {\n                    public Boolean run() { return hasNextService(); }\n                };\n                return AccessController.doPrivileged(action, acc);\n            }\n        }\n\n        public S next() {\n            if (acc == null) {\n                return nextService();\n            } else {\n                PrivilegedAction<S> action = new PrivilegedAction<S>() {\n                    public S run() { return nextService(); }\n                };\n                return AccessController.doPrivileged(action, acc);\n            }\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    /**\n     * Lazily loads the available providers of this loader's service.\n     * @return  An iterator that lazily loads providers for this loader's\n     *          service\n     */\n    public Iterator<S> iterator() {\n        return new Iterator<S>() {\n\n            Iterator<Map.Entry<String,S>> knownProviders\n                = providers.entrySet().iterator();\n\n            public boolean hasNext() {\n                if (knownProviders.hasNext())\n                    return true;\n                return lookupIterator.hasNext();\n            }\n\n            public S next() {\n                if (knownProviders.hasNext())\n                    return knownProviders.next().getValue();\n                return lookupIterator.next();\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n\n        };\n    }\n\n    /* 重载的ServiceLoad */\n    public static <S> ServiceLoader<S> load(Class<S> service,\n                                            ClassLoader loader)\n    {\n        return new ServiceLoader<>(service, loader);\n    }\n\n\t//DriverManage里面就是调用的这个方法\n    public static <S> ServiceLoader<S> load(Class<S> service) {\n        //拿到了TCCL\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        //调用上面重载的ServiceLoad方法\n        return ServiceLoader.load(service, cl);\n    }\n\n\n    public static <S> ServiceLoader<S> loadInstalled(Class<S> service) {\n        ClassLoader cl = ClassLoader.getSystemClassLoader();\n        ClassLoader prev = null;\n        while (cl != null) {\n            prev = cl;\n            cl = cl.getParent();\n        }\n        return ServiceLoader.load(service, prev);\n    }\n\n    public String toString() {\n        return \"java.util.ServiceLoader[\" + service.getName() + \"]\";\n    }\n\n}\n```\n\n> 首先我们要明白一点，`Driver接口`，`DriverManage类`，以及`ServiceLoader`都是由**根加载器**去加载的(如果不相信的话可以用TraceClassLoading去查看)，所以在`ServiceLoader`中也是无法直接加载具体得实现类的\n\n前面`loadInitialDriver()`调用的就是这里的`ServiceLoader.load(Class< S> service)` 方法，这个方法中悄悄的拿到了`TCCL` ，而TCCL在`Launcher` 类（系统加载器和扩展加载器都是在Launcher中实现的）中默认设置成了系统加载器，具体可以去看一下源码这里我就不展开了，然后调用另一个重载的构造方法将`TCCL` 传递进去，最终调用了 `reload()`方法\n\n```java\npublic void reload() {\n    providers.clear();\n    //初始化懒加载迭代器\n    lookupIterator = new LazyIterator(service, loader);\n}\n```\n\n 在这个方法中首先清空服务提供者(providers)缓存，然后初始化了一个`LazyIterator` 看名字就知道是啥意思了，其实到这里仍然没有任何具体的加载动作，因为这里采用的是按需加载，也就是懒加载，在迭代的时候才会去加载类\n\n```java\nprivate class LazyIterator implements Iterator<S>{\n\tClass<S> service;\n    ClassLoader loader;\n    Enumeration<URL> configs = null;\n    Iterator<String> pending = null;\n    String nextName = null;\n\n    private LazyIterator(Class<S> service, ClassLoader loader) {\n        this.service = service;\n        this.loader = loader;\n    }\n\n    private boolean hasNextService() {\n        if (nextName != null) {\n            return true;\n        }\n        if (configs == null) {\n            try {\n                //拿到接口全名\n                String fullName = PREFIX + service.getName();\n                if (loader == null)\n                    configs = ClassLoader.getSystemResources(fullName);\n                else\n                    configs = loader.getResources(fullName);\n            } catch (IOException x) {\n                fail(service, \"Error locating configuration files\", x);\n            }\n        }\n        while ((pending == null) || !pending.hasNext()) {\n            if (!configs.hasMoreElements()) {\n                return false;\n            }\n            //解析\n            pending = parse(service, configs.nextElement());\n        }\n        nextName = pending.next();\n        return true;\n    }\n    \n\t//迭代器的next\n    private S nextService() {\n        if (!hasNextService())\n            throw new NoSuchElementException();\n        String cn = nextName;\n        nextName = null;\n        Class<?> c = null;\n        try {\n            //具体加载类的地方就是在这里\n            //利用前面传进来的TCCL加载实现类，但是不初始化类\n            c = Class.forName(cn, false, loader);\n        } catch (ClassNotFoundException x) {\n            fail(service,\n                 \"Provider \" + cn + \" not found\");\n        }\n        if (!service.isAssignableFrom(c)) {\n            fail(service,\n                 \"Provider \" + cn  + \" not a subtype\");\n        }\n        try {\n            //newInstance()实例化对应的实现类\n            S p = service.cast(c.newInstance());\n            //put到providers中\n            providers.put(cn, p);\n            return p;\n        } catch (Throwable x) {\n            fail(service,\n                 \"Provider \" + cn + \" could not be instantiated\",\n                 x);\n        }\n        throw new Error();          // This cannot happen\n    }\n\n    public boolean hasNext() {\n        if (acc == null) {\n            return hasNextService();\n        } else {\n            PrivilegedAction<Boolean> action = new PrivilegedAction<Boolean>() {\n                public Boolean run() { return hasNextService(); }\n            };\n            return AccessController.doPrivileged(action, acc);\n        }\n    }\n\n    public S next() {\n        if (acc == null) {\n            return nextService();\n        } else {\n            PrivilegedAction<S> action = new PrivilegedAction<S>() {\n                public S run() { return nextService(); }\n            };\n            return AccessController.doPrivileged(action, acc);\n        }\n    }\n\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n}\n```\n🔸 可以看到在迭代器的`nextService()` 中才开始利用的`Class.forName()` 加载的具体实现类，而这个加载器正器正是前面`reload`传递过来的 `TCCL` 也就是默认的系统类加载器\n\n🔸 随后在紧跟的try语句中通过 `newInstance()` 实例化了具体的实现类(MySql的驱动) ，然后put进providers队列并且返回实例化的实现类，但是在`loadInitialDrivers`中并没有接收这个返回，那他这里实例化是什么用意呢？\n\n我们回到`getConnection()` 方法\n\n### getConnection()源码\n\n前面的静态方法调用完毕驱动已经加载，下面就是获取数据库连接了.\n\n```java\npublic static Connection getConnection(String url,\n    String user, String password) throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n\n    if (user != null) {\n        info.put(\"user\", user);\n    }\n    if (password != null) {\n        info.put(\"password\", password);\n    }\n\t// Reflection.getCallerClass()调用者的Class对象\n    return (getConnection(url, info, Reflection.getCallerClass()));\n}\n```\n\n一般获取连接都是调用的上面这个方法，这个方法最终会调用另一个重载的方法，同时传入一个调用者的Class对象\n\n```java\nprivate static Connection getConnection(\n    String url, java.util.Properties info, Class<?> caller) throws SQLException {\n    /*\n     * When callerCl is null, we should check the application's\n     * (which is invoking this class indirectly)\n     * classloader, so that the JDBC driver class outside rt.jar\n     * can be loaded from here.\n     */\n    //Caller就是调用者的CLass也就是我们的应用代码类\n    //获取到我们应用类的类加载器\n    ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;\n    synchronized(DriverManager.class) {\n        // synchronize loading of the correct classloader.\n        if (callerCL == null) {\n            //如果为空就，获取线程线下文加载器\n            callerCL = Thread.currentThread().getContextClassLoader();\n        }\n    }\n\n    if(url == null) {\n        throw new SQLException(\"The url cannot be null\", \"08001\");\n    }\n\n    println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\");\n\n    // Walk through the loaded registeredDrivers attempting to make a connection.\n    // Remember the first exception that gets raised so we can reraise it.\n    SQLException reason = null;\n\t\n    //遍历这个registeredDrivers里面都是DriverInfo\n    for(DriverInfo aDriver : registeredDrivers) {\n        // If the caller does not have permission to load the driver then\n        // skip it.\n        //检查加载驱动的加载器是不是调用者的类加载器\n        if(isDriverAllowed(aDriver.driver, callerCL)) {\n            try {\n                println(\"    trying \" + aDriver.driver.getClass().getName());\n                //获取连接\n                Connection con = aDriver.driver.connect(url, info);\n                if (con != null) {\n                    // Success!\n                    println(\"getConnection returning \" + aDriver.driver.getClass().getName());\n                    return (con);\n                }\n            } catch (SQLException ex) {\n                if (reason == null) {\n                    reason = ex;\n                }\n            }\n\n        } else {\n            println(\"    skipping: \" + aDriver.getClass().getName());\n        }\n\n    }\n\n    // if we got here nobody could connect.\n    if (reason != null)    {\n        println(\"getConnection failed: \" + reason);\n        throw reason;\n    }\n\n    println(\"getConnection: no suitable driver found for \"+ url);\n    throw new SQLException(\"No suitable driver found for \"+ url, \"08001\");\n}\n```\n\n🔸 可以看到中间有一个foreach循环，遍历`registeredDrivers`，这是个`CopyOnWriteArrayList` 这个类看名字就知道存放的是已经注册的`Drivers` 实现类，那这些实现类是什么时候注册进来的呢？回到我们之前抛出的一个问题，在`ServiceLoader`的迭代器中加载了具体的类之后进行了实例化，但是`DriverManager` 中并没有接收这个实例，我们来看一下具体的驱动实现类\n\n```java\npackage com.mysql.cj.jdbc;\n\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n    public Driver() throws SQLException {\n    }\n\n    static {\n        try {\n            //注册到DriverManager中去\n            DriverManager.registerDriver(new Driver());\n        } catch (SQLException var1) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n}\n```\n\n🔸 相信看到这里大家就明白了，前面初始化这个类的作用就是为了能触发这个**静态代码块**，进而执行registerDriver()方法进行注册，真是妙啊👏一环套一环\n\n🔸 还有一个需要注意的地方就是这里注册的虽然是个空的Driver类，但是别忘了它还有个父类NonRegisteringDriver\n\n这个类才是真正的实现类具体的`connect()` 等方法都是在这个里面实现的，而Driver继承了它的方法\n\n🔸 在遍历`registeredDrivers` 的时候还调用了一个`isDriverAllowed(aDriver.driver, callerCL)` 方法这个方法第一个参数就是驱动的实现类，第二个参数就是前面获取到的**调用者的类加载器** ，作用就是通过利用传进来的加载器尝试加载这个类，然后判断是不是同一个类，（众所周知不同的加载器因为命名空间的存在，即使加载同一份字节码文件得到的也不是一个类） 如果是就允许加载，否则不允许，为啥要这样做呢？其实还是因为命名空间的问题，因为有了SPI的机制，你**加载初始化这个实现类的加载器**(TCCL)和最终去**调用实现类的方法的类的加载器**有可能不是同一个，因为程序员可以很容易的将TCCL修改成其他的类加载器，如果不保证一致的话后面就会出现`ClassCastException`等异常 \n\n```java\nprivate static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) {\n    boolean result = false;\n    if(driver != null) {\n        Class<?> aClass = null;\n        try {\n            aClass =  Class.forName(driver.getClass().getName(), true, classLoader);\n        } catch (Exception ex) {\n            result = false;\n        }\n\n         result = ( aClass == driver.getClass() ) ? true : false;\n    }\n\n    return result;\n}\n```\n\n### **总结**\n\n当高层提供了统一接口让低层去实现（面向接口编程，解耦），同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。\n\n## Jar Hell\n\nJar包地狱，[参考](https://www.hidennis.tech/2016/05/30/what-is-jar-hell/)\n\n这个问题其实可以通过`OSGI`等组件化框架来解决，使用OSGI可以完美解决这个问题，OSGI是基于模块（Bundle）驱动的，每个模块都有属于自己的classpath和类加载器，模块之间通过包暴露和引入进行关联，每个模块有着自己独立的生命周期，我们可以动态地对模块进行加载、卸载、更新。如此看来，OSGI可以用一句话描述，就是一个为Java提供的动态模块化的系统。但是OSGI太过复杂，实用性并不强\n\n[阿里架构师对OSGI的评价](http://hellojava.info/?p=152)\n\n这里我主要想说的是怎么在代码中利用类加载器来检测Jar Hell\n\n```java\npublic class JarHell {  \n    public static void main(String[] args) {  \n        try {  \n            Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(\"org/apache/log4j/Logger.class\");  \n            while(urls.hasMoreElements()) {  \n                URL url = urls.nextElement();  \n                System.out.println(url);  \n            }  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n       \n    }  \n}  \n```\n\n这样就可以找到classpath中冲突的jar包，当然通过idea的工具会更方便 😂\n\n## 参考\n\n《深入理解Java虚拟机》\n\n[深入探讨 Java 类加载器](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code4)\n\n","tags":["JVM","ClassLoader"],"categories":["JVM"]},{"title":"深入理解Java虚拟机（一）","url":"/2019/08/11/shen-ru-li-jie-java-xu-ni-ji-yi/","content":"\n本文在 [CyC大佬](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=minor-gc-%e5%92%8c-full-gc) 的博客基础之上做了一些扩充改编（ 改编不是乱编，戏说不是胡说，今年下半年.......🐵\n\n## Java内存区域\n\n![mark](http://static.imlgw.top/blog/20190817/rTyjnrafmg3Q.png?imageslim)\n\n### 程序计数器\n\n- 程序计数器是一块较小的内存空间，它可以看成当前线程执行的字节码的行号指示器\n\n- 程序计数器位于线程独占去\n- 如果线程执行的是Java方法，这个计数齐记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是native方法，这个计数器的值为undefined\n- 此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 \n\n### Java虚拟机栈\n\n每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png)\n\n可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：\n\n```java\njava -Xss2M HackTheJavaCopy to clipboardErrorCopied\n```\n\n该区域可能抛出以下异常：\n\n- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；\n- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。\n\n### 堆\n\n所有对象实例以及数组都在这里分配内存，是垃圾收集的主要区域（\"GC 堆\"）。\n\n现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆大致分成两块：\n\n- 新生代（Young Generation）\n- 老年代（Old Generation）\n\n堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。\n\n可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。\n\n### 方法区\n\nJava虚拟机规范中将其描述为堆的一个逻辑部分，但是它还有一个别名就叫做`非堆`，而在HotSpot中则称之为`永久代（Permanent Generation）`。\n\n这一块主要用于存放**已被加载的类信息（类的版本，字段，方法，接口）**、**运行时常量池**、**静态变量**、即时编译器(JIT)编译后的代码等数据。\n\n和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。\n\n对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。\n\n`HotSpot` 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。\n\n方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，**静态变量和字符串常量池等被放入堆中**。\n\n### 运行时常量池\n\n运行时常量池是方法区的一部分，**Class 文件中的常量池**（编译器生成的**字面量**和**符号引用**）会在**类加载后**被放入这个区域\n\n除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()\n\n> When the intern method is invoked, if the pool already contains a string equal to this {@code String} object as determined by the {@link #equals(Object)} method, then the string from the pool is returned. Otherwise, this {@code String} object is added to the pool and a reference to this {@code String} object is returned.\n\n```java\npublic class StringIntern {\n    public static void main(String[] args) {\n        //s1 s2存放在局部变量表中\n        // abc 存放在常量池中（字节码常量）\n        String s1=\"abc\";\n        String s2=\"abc\";\n\n        System.out.println(s1==s2); //true\n        //new出来的一定是在堆内存中\n        String s3=new String(\"abc\");\n        System.out.println(s1==s3); //false\n        //运行时常量,intern将字符串添加到常量池中并且返回一个引用\n        System.out.println(s1==s3.intern()); //true\n        //颠覆认知的\n        //实际上这里创建了两个字符串对象，一个在堆中，一个在常量池中\n        System.out.println(s3==s3.intern()); //false\n    }\n}\n```\n\n关于String常量池 参考可以这篇 [文章](https://blog.csdn.net/qq_34115899/article/details/86583262)\n\n或这一篇[美团技术团队](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)\n\n### 直接内存\n\n在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。\n\n## 对象创建\n\n![mark](http://static.imlgw.top/blog/20190811/JcRnzxY4HN5q.png?imageslim)\n\n假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为`“指针碰撞”`（Bump the Pointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为`“空闲列表”`（Free List）。选择哪种分配方式由`Java堆是否规整`决定，而Java堆是否规整又由所采用的`垃圾收集器是否带有压缩整理功能决定`。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。\n\n### 线程安全问题\n\n创建对象的时候需要修指针指向的位置，在并发情况下这并不是线程安全的，虚拟机可以采用CAS加上失败重试（自旋）的方式保证更新操作的原子性，但是这样会影响性能，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为`本地线程分配缓冲`（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的FLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。\n\n###  **对象结构**\n\n#### Object Header\n\n对象头包括两部分\n\n**自身运行时数据（Mark Word）**比如 对象哈希值，对象分带年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，另一部分就是**类型指针**\n\n#### InstanceData\n\n实例数据，是对象真正存储的有效信息，也是在程序中定义的各个类型字段的内容，无论是从父类继承下来的还是在之类种定义的，都需要记录下来。\n\n#### **Padding**\n\n这一部分并不是必须的，其实就是用于内存对齐的，HotSpot自动内存管理系统要求对象起始地址必须是8个字节的整数倍，也就是对象大小必须是8的整数倍，如果不够则需要填充这部分就是Padding\n\n### HotSpot源码\n\n找到了openJdk的Java8对应的创建对象的[源码](http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/6a0ead6dc6db/src/share/vm/interpreter/bytecodeInterpreter.cpp)，大概1966行左右\n\n## 堆的划分\n\n### 堆结构分代\n\nJava虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念（JDK1.8之后为metaspace替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，而且HotSpot也有取消永久代的趋势，在JDK 1.7中HotSpot已经开始了“去永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。\n\n**新生代（Young Generation）**\n\n新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。\n\n**老年代（Old Generationn）**\n\n在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。\n\n**永久代（Permanent Generationn）**\n\n永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。\n\n### 堆结构分代的意义\n\n　　Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（`对HotSpot虚拟机而言`），这就是JVM的内存分代策略。\n　　堆内存是虚拟机管理的内存中最大的一块，也是`垃圾回收最频繁`的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率。\n　　有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在`老年代`中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。\n\n## 垃圾收集\n\n垃圾收集主要是针对`堆和方法区`进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。\n\n### 判断一个对象是否可以被回收\n\n在堆中存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收的时候，第一件事情就是要确定这些对象之中那些还“活着”，那些已经“死去”（不会再被使用）\n\n#### **引用计数法**\n\n给对象加上一个引用计数器，每当有一个地方引用它的时候，计数器值就加1，引用失效的时候就减一，计数器为0的对象就是不可能再被使用的。\n\n但是在主流的Java虚拟机中都没有使用引用计数器来进行内存管理，主要的原因就是它很难解决循环引用的问题。\n\n```java\npublic class Test {\n    public Object instance = null;\n    public static void main(String[] args) {\n        Test a = new Test();\n        Test b = new Test();\n        a.instance = b;\n        b.instance = a;\n        a = null;\n        b = null;\n        doSomething();\n    }\n}\n```\n\n上面的代码中 `Test a`  和`Test b` 互相引用，在后续将两个对象引用赋为null后两个对象的引用计数器仍然不为0，导致无法回收这两个对象。\n\n#### **可达性分析法**\n\n以 `GC Roots` 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收，Java 虚拟机使用该算法来判断对象是否可被回收。\n\nJava语言中可以作为GC Root的对象包括下面几种\n\n- 虚拟机栈中局部变量表中引用的对象\n- 本地方法栈中 JNI 中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中的常量引用的对象\n\n#### OopMap，安全点，安全区\n\n采用可达性分析法首先就找找到那些是`GC Root`，目前主要有两种查找 GC Roots 的方法：\n\n💡**保守式 GC**：遍历方法区和栈区查找，无法使用复制算法，除非采用`句柄访问对象的方式`但效率不高，无法准确区分是不是引用（指针）类型的变量\n\n💡**准确式 GC**：与保守式GC相对的就是准确式GC，就是我们准确的知道，某个位置上面是否是指针，对于java来说，就是知道对于某个位置上的数据是什么类型的，这样就可以判断出所有的位置上的数据是不是指向GC堆的引用，包括栈和寄存器里的数据。HotSpot则是通过 `OopMap` 数据结构来记录在对象内的什么偏移量上是什么类型的数据\n\n很明显，保守式 GC 的成本太高。准确式 GC 的优点就是能够让虚拟机快速定位到 GC Roots。\n\n对应 `OopMap` 的位置即可作为一个`Safe Point`（安全点）。\n\n**什么是安全点？**\n\nOopMap的作用是为了在GC的时候，快速进行可达性分析，所以OopMap并不需要一发生改变就去更新这个映射表。只要这个`更新在GC发生之前`就可以了。所以OopMap只需要在预先选定的一些位置上记录变化的OopMap就行了。这些特定的点就是`SafePoint`（安全点）。由此也可以知道，程序并不是在所有的位置上都可以进行GC的，只有在达到这样的安全点才能暂停下来进行GC。\n\n**安全点的选取**\n\n在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的`\"Stop-The-World\"`，因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。\n\n安全点意味着在这个点时，所有`工作线程的状态是确定`的，JVM 就可以安全地执行 GC 。\n\n安全点的选取一般在以下几个位置，避免程序过长时间执行。\n\n- 循环的末尾\n\n- 方法临返回前\n\n- 调用方法之后\n\n- 抛异常的位置\n\n**安全区**\n\n​\t安全点的使用似乎解决了OopMap计算的效率的问题，但是这里还有一个问题。安全点需要程序自己跑过去，那么对于那些已经停在路边休息或者看风景的程序（比如那些处在Sleep或者Blocked状态的线程），他们可能并不会在很短的时间内跑到安全点去。所以这里为了解决这个问题，又引入了安全区域的概念。\n\n​\t安全区域很好理解，就是在程序的一段代码片段中并`不会导致引用关系发生变化`，也就不用去更新OopMap表了，那么在这段代码区域内任何地方进行GC都是没有问题的。这段区域就称之为安全区域。线程执行的过程中，如果进入到安全区域内，就会标志自己已经进行到安全区域了。那么虚拟机要进行GC的时候，发现该线程已经运行到安全区域，就不会管该线程的死活了。所以，该线程在脱离安全区域的时候，要`自己检查`系统是否已经完成了GC或者根节点枚举（这个跟GC的算法有关系），如果完成了就继续执行，如果未完成，它就必须等待收到可以安全离开安全区域的Safe Region的信号为止。\n\n**中断方式**\n\n在程序需要GC的时候怎么让所有线程到达安全点中断然后进行GC ?\n\n- 抢断式中断：抢断式中断就是在GC的时候，让所有的线程都中断，如果这些线程中发现中断地方不在安全点上的，就恢复线程，让他们重新跑起来，直到跑到安全点上。（现在几乎没有虚拟机采用这种方式）\n\n- 主动式中断：主动式中断在GC的时候，不会主动去中断线程，仅仅是设置一个标志，当程序运行到安全点时就去轮训该位置，发现该位置被设置为真时就自己中断挂起。所以轮训标志的地方是和安全点重合的，另外创建对象需要分配内存的地方也需要轮询该位置。\n\n#### 方法区的回收\n\n方法区（HotSpot中的永久代），在Java规范中并没有要求虚拟机对该区域进行垃圾回收，这个区域的垃圾回收效率要远低于在`堆中` \n\n回收的主要对象：\n\n- 废弃常量\n- 无用的类(Class对象)\n\n判断一个常量是否是废弃常量，只要没有任何对象引用常量池中的常量，该常量就可以回收。\n\n判断一个类是不是无用的类条件则比较苛刻。\n\n- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。\n- 加载该类的 ClassLoader 已经被回收。\n- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。\n\n满足了上述条件虚拟机才**可以** 对其进行回收，但是这也并不是必然的。\n\n#### Finalize()\n\n这个方法忘了就好😁\n\n当一个对象可被回收时，如果重写该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。\n\n### 引用类型\n\n无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。\n\nJava 提供了四种强度不同的引用类型。\n\n#### 强引用\n\n被强引用关联的对象不会被回收。\n\n使用 new 一个新对象的方式来创建强引用。\n\n```java\nObject obj = new Object();Copy to clipboardErrorCopied\n```\n\n#### 软引用\n\n被软引用关联的对象只有在内存不够的情况下才会被回收。\n\n使用 SoftReference 类来创建软引用。\n\n```java\nObject obj = new Object();\nSoftReference<Object> sf = new SoftReference<Object>(obj);\nobj = null;  // 使对象只被软引用关联Copy to clipboardErrorCopied\n```\n\n#### 弱引用\n\n被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。\n\n使用 WeakReference 类来创建弱引用。\n\n```java\nObject obj = new Object();\nWeakReference<Object> wf = new WeakReference<Object>(obj);\nobj = null;Copy to clipboardErrorCopied\n```\n\n####  虚引用\n\n又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。\n\n为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。\n\n使用 PhantomReference 来创建虚引用。\n\n```java\nObject obj = new Object();\nPhantomReference<Object> pf = new PhantomReference<Object>(obj, null);\nobj = null;\n```\n\n### 垃圾收集算法\n\n#### 标记 - 清除算法\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png)\n\n\n\n在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。\n\n在清除阶段，会遍历整个堆进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 `“空闲链表”` 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。\n\n在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。\n\n详细可以参考 [垃圾回收的算法与实现](http://www.ituring.com.cn/book/tupubarticle/10955)\n\n#### 复制算法\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png)\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n\n主要不足是`只使用了内存的一半`。\n\n现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块`较大的 Eden` 空间和`两块较小的 Survivor 空间`，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，`最后清理 Eden 和使用过的那一块 Survivor。`\n\nHotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要`依赖于老年代进行空间分配担保`，也就是借用老年代的空间存储放不下的对象。\n\n#### 标记 - 整理\n\n复制算法在对象存活率较高的时候就要进行很多的复制操作，效率将会变低，老年代也没有额外的空间做担保，所以老年代一般不能直接使用这种算法。\n\n![CyC](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png)\n\n让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n- 不会产生内存碎片\n\n- 需要移动大量对象，处理效率比较低。\n\n#### 分代收集\n\n分代收集顾名思义就是分代来收集，针对不同的代执行不同的收集算法。\n\n一般将堆分为新生代和老年代。\n\n- 新生代使用：少量存活对象，采用复制算法只需要付出少量的复制成本就可以完成收集。\n- 老年代使用：存活率高没有担保，采用标记 - 清除 或者 标记 - 整理 算法，\n\n### 垃圾收集器\n\n![mark](http://static.imlgw.top/blog/20190813/3f2uQGV4SjI4.png?imageslim)\n\n以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。\n\n#### Serial收集器\n\n**Serial（串行）**收集器是最基本、发展历史最悠久的收集器，它是采用`复制算法`的`新生代收集器`，曾经（JDK 1.3.1之前）是虚拟机`新生代`收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是**它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）**。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。\n\n下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：\n\n![mark](http://static.imlgw.top/blog/20190813/03PTqvGk6jdy.png?imageslim)\n\n为了消除或减少工作线程因内存回收而导致的停顿，HotSpot虚拟机开发团队在JDK 1.3之后的Java发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着Serial收集器已经“老而无用”，实际上到现在为止，它依然是**HotSpot虚拟机运行在Client模式下的默认的新生代收集器**。它也有着优于其他收集器的地方：**简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。**\n\n在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。\n\n#### ParNew 收集器\n\n`ParNew`收集器就是Serial收集器的多线程版本，它也是一个`新生代收集器`。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。\n\nParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：\n\n![mark](http://static.imlgw.top/blog/20190813/NDuVa0QjwwYM.png?imageslim)\n\nParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，`除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作`，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。\n\nParNew 收集器在`单CPU的环境`中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在多CPU环境下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用`-XX:ParallerGCThreads`参数设置。\n\n#### Parallel Scavenge 收集器\n\n`Parallel Scavenge`收集器也是一个并行的多线程`新生代收集器`，它也使用`复制算法`。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。\n\n> **吞吐量**：CPU用于运行用户代码的时间和CPU消耗的总时间（CPU执行时间+垃圾收集时间）的比值\n>\n> **单线程与多线程**：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；\n>\n> **并行（Parallel）**：指多条垃圾收集线程同时执行，但是此时用户线程仍然处于等待状态，也就是说和用户线程是串行的。\n>\n> **并发（Concurrent）**：并发指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以并行的方式执行。\n\n`停顿时间越短就越适合需要与用户交互的程序`，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在`后台运算而不需要太多交互的任务`。\n\n`Parallel Scavenge`  提供了两个参数用于较精确控制吞吐量\n\n- `-XX:MaxGCPauseMills` 控制最大垃圾收集停顿时间\n\n- `-XX:GCTimeRatio` 直接设置吞吐量大小\n\n缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n\nParallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数`-XX:+UseAdaptiveSizePolicy`，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为`GC自适应的调节策略（GC Ergonomics）`。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别\n\n另外值得注意的一点是，Parallel Scavenge收集器`无法与CMS收集器配合使用`，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。\n\n#### Serial Old收集器\n\nSerial收集器的老年代版本，同样是单线程，使用标记整理算法\n\n![mark](http://static.imlgw.top/blog/20190813/y1H9NyikWogV.png?imageslim)\n\n这个收集器的主要意义是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：\n\n- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。\n- 作为 CMS 收集器的后备预案，在并发收集发生 `Concurrent Mode Failure` 时使用（下面会介绍）。\n\n#### Parallel Old收集器\n\n是 Parallel Scavenge 收集器的老年代版本。\n\n![mark](http://static.imlgw.top/blog/20190813/itz21ThRoKAD.png?imageslim)\n\n在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器\n\n#### CMS收集器（Concurrent Mark Sweep）\n\n并发的老年代收集器，Mark Sweep 指的是标记 - 清除算法，它的运作相对前面几种来说要更加复杂一些，整体分为4哥步骤\n\n- **初始标记**：仅仅是标记一下GC Root能直接关联到的对象，速度很快，需要停顿\n- **并发标记**：进行GC Root Tracing的过程，它在整个回收过程中耗时最长，不需要停顿，\n- **重新标记**：为了`修正`并发标记阶段程序继续运行导致标记变化的那一部分对象的标记记录，需要停顿\n- **并发清除**：不需要停顿\n\n在整个过程中耗时最长的`并发标记`和`并发清除`过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\n![mark](http://static.imlgw.top/blog/20190813/zJiEhyXRjfTO.png?imageslim)\n\n**缺点**\n\n- 对CPU资源非常敏感 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受，后面出现了`i-CMS`让GC线程和用户线程交替运行，但是表现很一般已被弃用。\n\n- 无法处理`浮动垃圾`，可能出现 `Concurrent Mode Failure`。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存给用户线程使用，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够用户线程运行，就会出现 `Concurrent Mode Failure`，jdk1.6之后虚拟机会临时启用 Serial Old 来替代 CMS。\n\n- 标记-清除算法导致的空间碎片 CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发`Full GC`\n\n#### G1收集器\n\nG1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n\n堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。\n\n![mark](http://static.imlgw.top/blog/20190814/o8sxTPY30GnJ.png?imageslim)\n\nG1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。\n\n![mark](http://static.imlgw.top/blog/20190814/3olH4WWVEysA.png?imageslim)\n\n通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个`优先列表`，每次根据允许的收集时间，优先回收价值最大的 Region。\n\n但是即使是这样分了Region垃圾回收器就一定会以Region为单位分配么？显然是不可能的，Region不可能完全独立，一个对象分配在Region中并不是只能被当前Region部分引用，而是可以与整个Java堆的任意对象发生引用关系，这样在做可达性分析的时候岂不是仍然需要遍历整个堆? 这个问题并不是只在G1中存在，其他收集器也会存在，只是G1这样划分之后问题更加突出了，在`G1收集器`中每个 Region 都有一个 Remembered Set，用来记录该 Region 对象`的引用对象`所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。\n\n如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：\n\n- **初始标记（Initial Marking）** 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。\n- **并发标记（Concurrent Marking）** 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。\n- **最终标记（Final Marking）** 为了修正在`并发标记期间`因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要`停顿线程`，但是可并行执行。\n- **筛选回收（Live Data Counting and Evacuation）** 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，`但是因为只回收一部分Region，时间是用户可控制的`，而且停顿用户线程将大幅度提高收集效率。\n\n**特点**\n\n- **并行与并发** G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。\n- **分代收集** 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。\n- **空间整合** G1从整体来看是基于`“标记-整理”`算法实现的收集器，从局部（两个Region之间）上来看是基于**“复制”**算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。\n- **可预测的停顿** 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。\n\n#### 理解GC日志\n\nGC(Garbage Collection)是Java虚拟机中一个很重要的组成部分，在很多情况下我们都需要查看它的日志，下面内容就是介绍如何查看GC日志。\n\n可选参数\n\n```java\n-XX:+PrintGC 输出GC日志\n-XX:+PrintGCDetails 输出GC的详细日志\n-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）\n-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）\n-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息\n-Xloggc:../logs/gc.log 日志文件的输出路径\n```\n\n**测试类**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/8/15 17:16\n */\npublic class GCTest {\n    \n    /**\n     * vm参数 ：-XX:+PrintGCDetails 输出GC的详细日志\n     */\n    private byte[] data =new byte[1024*1024*10]; //10M\n\n    public static void main(String[] args) {\n        GCTest gcTest = new GCTest();\n        gcTest=null; //for gc\n        System.gc();\n        System.out.println(\"GC Test\");\n    }\n}\n```\n\n**控制台打印结果**\n\n```java\n[GC (System.gc()) [PSYoungGen: 12902K->712K(38400K)] 12902K->720K(125952K), 0.3622244 secs] [Times: user=0.00 sys=0.00, real=0.36 secs] \n[Full GC (System.gc()) [PSYoungGen: 712K->0K(38400K)] [ParOldGen: 8K->638K(87552K)] 720K->638K(125952K), [Metaspace: 3438K->3438K(1056768K)], 0.0103044 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] \nGC Test\nHeap\n PSYoungGen      total 38400K, used 998K [0x00000000d5e00000, 0x00000000d8880000, 0x0000000100000000)\n  eden space 33280K, 3% used [0x00000000d5e00000,0x00000000d5ef9b20,0x00000000d7e80000)\n  from space 5120K, 0% used [0x00000000d7e80000,0x00000000d7e80000,0x00000000d8380000)\n  to   space 5120K, 0% used [0x00000000d8380000,0x00000000d8380000,0x00000000d8880000)\n ParOldGen       total 87552K, used 638K [0x0000000081a00000, 0x0000000086f80000, 0x00000000d5e00000)\n  object space 87552K, 0% used [0x0000000081a00000,0x0000000081a9fb68,0x0000000086f80000)\n Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n  \nProcess finished with exit code 0\n```\n\n`PSYoungGen` 看见这个其实就猜的到了，Parallel Scavenge收集器收集的新生代，代表GC的区域和收集器。下面的`ParOldGen`对应的就是Parallel Old的老年代 ，PSYoungGen后面紧跟的 `12902K->712K(38400K)` 则代表 `GC前该区域已经使用的容量 -> GC后该区域已使用的容量（该区域总容量）`  ，而方括号外面的部分则代表 `GC前Java堆已使用量 -> GC后Java堆已使用量（Java堆中容量）` 。\n\n### 内存分配与回收策略\n\n- **Minor GC**：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。\n- **Full GC**：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多，出现Full GC通常会伴随着Minor GC，但是并不一定有时候也会直接进行Full GC。\n\n对象的内存分配，往大的方向讲就是在堆上分配内存（也有可能被JIT拆散并间接的在栈上分配），对象主要分配在新生代的`Eden` 区上，如果启动了`本地线程分配缓冲`（TLAB） 会优先在TLAB上分配，少数情况也会直接分配在老年代中，分配的规则不是确定的，取决于垃圾收集器的组合以及虚拟机相关的参数的设置。\n\n> -Xms  初始Heap大小\n>\n> -Xmx  java heap最大值 \n>\n> -Xmn  Young generation的heap大小\n\n#### 对象优先分配在Eden上\n\n大多数情况，对象会直接在新生代Eden上分配。当Eden区没有足够的区域进行分配的时候，虚拟机将会发起一次`Minor GC` 。\n\n下面我们通过代码来感受一下这个过程\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/8/15 17:16\n */\npublic class GCTest {\n    private static int _1M= 1024*1024; //1m\n\n    /*\n        -XX:+PrintGCDetails\n        -verbose:gc\n        -Xms20M 限制Java堆大小20M不可扩展\n        -Xmx20M\n        -Xmn10M 10M分配给新生代\n        -XX:SurvivorRatio=8\n    */\n    public static void main(String[] args) throws InterruptedException {\n        byte[] alloc1,alloc2,alloc3,alloc4;\n        alloc1=new byte[2*_1M];\n        alloc2=new byte[2*_1M];\n        alloc3=new byte[2*_1M];\n        System.out.println(\"GC Test\"); //发生GC\n        alloc4=new byte[3*_1M];\n    }\n}\n\n```\n\n**控制台打印**\n\n```java\nGC Test\n[GC (Allocation Failure) [PSYoungGen: 8002K->696K(9216K)] 8002K->6840K(19456K), 0.0028974 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 696K->0K(9216K)] [ParOldGen: 6144K->6783K(10240K)] 6840K->6783K(19456K), [Metaspace: 3439K->3439K(1056768K)], 0.0042088 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 9216K, used 3154K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n  eden space 8192K, 38% used [0x00000000ff600000,0x00000000ff914930,0x00000000ffe00000)\n  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)\n  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)\n ParOldGen       total 10240K, used 6783K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  object space 10240K, 66% used [0x00000000fec00000,0x00000000ff29fc88,0x00000000ff600000)\n Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n\nProcess finished with exit code 0\n\n```\n\n在`alloc4`的时候 发现空间已经不足以装下了，所以进行了一次Minor GC，随后GC掉了YoungGen大概6M的空间，但是这些对象大于`from` 和`to` 两块`Survivor` 区域无法直接存入所以通过分配担保进入老年代中，可以看到后面老年代66%的占用存放的就是这几个对象。GC结束后，`alloc4` 也顺利的进入的`Eden` \n\n#### 大对象直接进入老年代\n\n所谓的大对象其实就是需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串以及数组，比如我上面代码中的byte数组，经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”这些大对象，所以应该避免产生“朝生夕死”的短命大对象。\n\n虚拟机提供了一个  `-XX: PretenureSizeThreshold`参数，令大于这个设置值的对象直接在老年代分配（只对Serial和ParNew两款收集器有效，Parallel一般不用设置）。\n\n```java\npublic class GCTest {\n    private static int _1M= 1024*1024; //1m\n\n    /*\n        -XX:+PrintGCDetails\n        -verbose:gc\n        -Xms20M 限制Java堆大小20M不可扩展\n        -Xmx20M\n        -Xmn10M 10M分配给新生代\n        -XX:SurvivorRatio=8\n    */\n    public static void main(String[] args) throws InterruptedException {\n        byte[] alloc1,alloc2,alloc3,alloc4;\n        alloc1=new byte[9*_1M];\n        System.out.println(\"GC Test\");\n    }\n}\n```\n\n**控制台打印**\n\n```java\nGC Test\nHeap\n PSYoungGen      total 9216K, used 2022K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n  eden space 8192K, 24% used [0x00000000ff600000,0x00000000ff7f9990,0x00000000ffe00000)\n  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)\n  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)\n ParOldGen       total 10240K, used 9216K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  object space 10240K, 90% used [0x00000000fec00000,0x00000000ff500010,0x00000000ff600000)\n Metaspace       used 3447K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n\nProcess finished with exit code 0\n\n```\n\n可以看到这个对象几乎全部被放到了老年代里面，老年代占用率 90%\n\n#### 长期存活的对象将进入老年代\n\n虚拟机为对象定义年龄计数器 Age，对象在 Eden 出生并经过 Minor GC 依然存活并且能被Survivor容纳的话，将移动到 Survivor 中，年龄就增加 1 岁，对象在Survivor区域每熬过一次 Minor GC年龄就增加一岁，当他的年龄增加到一定程度（默认为15岁），就会将它移动到老年代中（很形象有没有 😁）\n`-XX:MaxTenuringThreshold` 用来定义年龄的阈值。\n\n#### 动态年龄判定\n\n虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 `Survivor` 中`相同年龄`所有对象大小的总和大于 `Survivor 空间的一半`，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄\n\n#### 空间分配担保\n\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的`连续空间`是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代\n最大可用的连续空间是否`大于`历次晋升到老年代对象的`平均大小`，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC，如果出现了担保失败，那就只好发起一次`Full GC`  ，绕的圈子是最大的，但是一般情况下这个开关还是默认打开的，避免产生太多的Full GC，JDK1.6之后这个参数就被废掉了，`只要老年代的连续空间大于新生代总空间或者每次晋升的平均大小就进行Minor GC否则进行Full GC`\n\n#### Full GC触发条件\n\n对于 Minor GC，其触发条件非常简单，当 Eden 空间快满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下情况：\n\n**_调用 System.gc()_**\n只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n\n**_老年代空间不足_**\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。\n为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数\n调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对\n象进入老年代的年龄，让对象在新生代多存活一段时间。\n\n**_空间分配担保失败_**\n使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。\n\n**_JDK 1.7 及以前的永久代空间不足_**\n在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据\n当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也\n会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。\n为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。\n\n**_Concurrent Mode Failure_**\n执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n## 参考\n\n**周志明《深入理解Java虚拟机》**\n\n[CYC大佬的博客🙏](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=minor-gc-%e5%92%8c-full-gc)","tags":["JVM"],"categories":["JVM"]},{"title":"自旋锁，CLH锁，MCS锁","url":"/2019/08/10/zi-xuan-suo-clh-suo-mcs-suo/","content":"\n- [自旋锁](#自旋锁)\n  - [简单自旋锁](#简单自旋锁)\n  - [Ticket Lock](#ticket-lock)\n- [CLH锁](#clh锁)\n- [MCS锁](#mcs锁)\n- [总结](#总结)\n- [参考](#参考)\n\n## 自旋锁\n\n自旋锁(spin lock)是一个典型的对临界资源的互斥手段，自旋锁是基于CAS原语的，所以它是轻量级的同步操作，它的名称来源于它的特性。自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。由于自旋锁只不进行线程状态的改变（挂起线程），所以当线程竞争不激烈时，它的响应速度极快（因为`避免了线程调度的上下文切换`）。自旋锁适用于锁保护的临界区很小的情况，线程竞争不激烈的场景下。如果线程之间竞争激烈或者临界区的操作特别耗时，那么线程的自旋操作就会耗费大量的cpu资源，所以这种情况下性能就会下降明显。\n\n###  简单自旋锁\n\n```java\npublic class SimpleSpinLock {\n    private AtomicReference<Thread> owner = new AtomicReference<Thread>();\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        // 后面解锁的就只能是当前线程\n        while (!owner.compareAndSet(null, currentThread)) {\n        }\n    }\n\n    public void unlock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁\n        owner.compareAndSet(currentThread, null);\n    }\n}\n```\n\n**缺点**\n\n- CAS操作需要硬件的配合（现代处理器大多都支持）\n\n- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重（这是由于Atomic的volatile变量导致的，同时这也是必须的）\n\n- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。\n\n### Ticket Lock\n\n```java\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); // 服务号\n    private AtomicInteger ticketNum = new AtomicInteger(); // 排队号\n\n    public int lock() {\n        // 首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        // 只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n        }\n        return myTicketNum;\n    }\n\n    public void unlock(int myTicket) {\n        // 解锁后只有拥有该线程的下一个排队号线程才能加锁,保证了公平性,不会有插队的情况\n        int next = myTicket + 1;\n        // 只有当前线程拥有者才能释放锁\n        serviceNum.compareAndSet(myTicket, next);\n    }\n}\n```\n\n**缺点**\n\nTicket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n## CLH锁\n\nCLH的发明人是：Craig，Landin and Hagersten，三个人的名字合称\n\nCLH锁是一种基于隐式链表（节点里面没有next指针）的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。\n\n```java\npublic class CLHLock {\n    public static class CLHNode {\n        private volatile boolean isLocked = true; // 默认是在等待锁\n    }\n\n    private volatile CLHNode tail ;\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER = AtomicReferenceFieldUpdater\n            . newUpdater(CLHLock.class, CLHNode .class , \"tail\" );\n\n    public void lock(CLHNode currentThreadNode) {\n        //获取之前的尾结点, 然后将自己设置为尾节点\n        CLHNode preNode = UPDATER.getAndSet( this, currentThreadNode);\n        if(preNode != null) {//已有线程占用了锁，进入自旋\n            while(preNode.isLocked ) {\n            }\n        }\n    }\n\n    public void unlock(CLHNode currentThreadNode) {\n        // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。\n        // 尝试设置尾节点为自己, 传入的期望值是自己,成功就代表队列中只有它一个\n        if (!UPDATER.compareAndSet(this, currentThreadNode, null)) {\n            // 还有后续线程\n            currentThreadNode.isLocked = false ;// 改变状态，让后续线程结束自旋\n        }\n    }\n}\n```\n\n这里用到了`原子字段更新器`，让tail变量可以具有CAS的功能，具体可以参考之前的文章[CAS与原子变量](http://imlgw.top/2019/04/22/cas-yu-yuan-zi-bian-liang/#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8)\n\n**缺点**\n\n先说一下`NUMA`和`SMP`两种处理器结构\nSMP(Symmetric Multi-Processor)，即对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。SMP的优点是`能够保证内存一致性`，缺点是这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。常用的PC机就属于这种。\n\nNUMA(Non-Uniform Memory Access)非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，`访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度`，这也是非一致存储访问NUMA的由来。NUMA优点是可以较好地解决原来SMP系统的扩展问题，缺点是由于访问远地内存的延时远远超过本地内存，因此当CPU数量增加时，系统性能无法线性增加。\n\n**CLH锁的缺点是在NUMA系统结构下性能很差，在这种系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，在SMP架构下能够保证内存一致性所以自旋判断较快**\n\n## MCS锁\n\nMCS Spinlock是一种基于显式链表（节点里面拥有next指针）的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，由直接前驱负责通知其结束自旋（与CLH自旋锁不同的地方，不在轮询前驱的状态，而是由前驱主动通知），从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。而MCS是在自己的结点的locked域上自旋等待。正因为如此，它解决了CLH在NUMA系统架构中获取locked域状态内存过远的问题。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/8/10 21:49\n */\npublic class MCSLock {\n    public static class MCSNode {\n        //持有后继者的引用\n        volatile MCSNode next;\n        // 默认是在等待锁\n        volatile boolean block = true;\n    }\n\n    volatile MCSNode tail;// 指向最后一个申请锁的MCSNode\n\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER = AtomicReferenceFieldUpdater\n            .newUpdater(MCSLock.class, MCSNode.class, \"tail\");\n\n    public void lock(MCSNode currentThreadMcsNode) {\n        //更新tail为最新加入的线程节点，并取出之前的节点（也就是当前节点的前驱）\n        MCSNode predecessor = UPDATER.getAndSet(this, currentThreadMcsNode);\n        if (predecessor != null) {\n            //连接在tail的尾部\n            predecessor.next = currentThreadMcsNode;\n            //轮询自己的isLocked属性\n            while (currentThreadMcsNode.block) {\n\n            }\n        } else {\n            //前驱节点为空直接获取锁,自己是第一个\n            currentThreadMcsNode.block = false;\n        }\n    }\n\n    public void unlock(MCSNode currentThreadMcsNode) {\n        if (currentThreadMcsNode.block) {\n            return;\n        }\n        //判断是不是只有一个线程\n        if (currentThreadMcsNode.next == null) {\n            //CAS 将tail设置为空\n            if (UPDATER.compareAndSet(this, currentThreadMcsNode, null)) {\n                // 设置成功返回，没有其他线程等待锁\n                return;\n            } else {\n                //CAS更新tail失败,有线程抢先一步执行lock更新了tail\n                //但是可能还没有连接在 之前的tail(当前节点)后\n                while (currentThreadMcsNode.next == null) {\n                    //等待 predecessor.next = currentThreadMcsNode执行\n                    //否则后面会报NPE\n                }\n            }\n        }\n        //修改后继者的isLocked,通知后继者结束自旋\n        currentThreadMcsNode.next.block = false;\n        currentThreadMcsNode.next = null;// for GC\n    }\n}\n```\n\n## 总结\n\n传统的`Spin lock` 和 `Ticket Lock`都在同一个共享变量上竞争（例如SimpleSpinLock中的owner、Ticket Lock中的serviceNum），这样对给CPU保证缓存一致性带来的压力比较大，每次读写都需要同步到所有的线程，而MCS和CLH最大的优化点在于把上述同一个点上的竞争分散到队列的每个节点中去了。\n\n## 参考\n\n[自旋锁、排队自旋锁、MCS锁、CLH锁](https://coderbee.net/index.php/concurrent/20131115/577)","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"阻塞队列","url":"/2019/08/07/zu-sai-dui-lie/","content":"\n## 阻塞队列\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\n**非阻塞队列中的几个主要方法：**\n\n- `add(E e)`:将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常\n\n-  `remove()`:移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常\n\n- `offer(E e)`：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false\n\n- `poll()`：移除并获取队首元素，若成功，则返回队首元素；否则返回null\n\n- `peek()`：获取队首元素，若成功，则返回队首元素；否则返回null\n\n对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。\n\n**阻塞队列中的几个主要方法：**\n\n阻塞队列包括了非阻塞队列中的大部分方法，上面列举的5个方法在阻塞队列中都存在，但是要注意这5个方法在阻塞队列中都进行了**同步措施**。除此之外，阻塞队列提供了另外4个非常有用的方法：\n\n- `put(E e)`方法用来向队尾存入元素，如果队列满，则等待\n\n- `take()`方法用来从队首取元素，如果队列为空，则等待\n\n- `offer(E e,long timeout, TimeUnit unit)`方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true\n\n- `poll(long timeout, TimeUnit unit)`方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果没取到，则返回null；否则返回取得的元素\n\n###  Java里的阻塞队列\n\n- **ArrayBlockingQueue** ：一个由数组结构组成的有界阻塞队列。\n- **LinkedBlockingQueue** ：一个由链表结构组成的有界阻塞队列。\n- **PriorityBlockingQueue** ：一个支持优先级排序的无界阻塞队列。\n- **DelayQueue**：一个使用优先级队列实现的无界阻塞队列。\n- **SynchronousQueue**：一个不存储元素的阻塞队列。\n- **LinkedTransferQueue**：一个由链表结构组成的无界阻塞队列。\n- **LinkedBlockingDeque**：一个由链表结构组成的双向阻塞队列。\n\n> 除了这几个外还有一个 `ScheduledThreadPoolExecutor.DelayedWorkQueue`这个其实是DelayQueue的优化\n\n### ArrayBlockingQueue\n\nArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：\n\n`ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);`\n\n访问者的公平性是使用可重入锁实现的\n\n### LinkedBlockingQueue\n\nLinkedBlockingQueue是一个用链表实现的**有界**阻塞队列。此队列按照先进先出的原则对元素进行排序。\n\n容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被\n设置为 Integer.MAX_VALUE ，成为了无界队列。\n\n### PriorityBlockingQueue\n\nPriorityBlockingQueue是一个支持优先级的无界队列。底层采用数组实现了二叉堆，相比PriorityQueue其实就是将默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。\n\n### DelayQueue\n\n这个队列还是挺有意思的，DelayQueue是一个支持延时获取元素的无界阻塞队列。内部使用PriorityQueue来存储元素。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中**取出**元素。我们可以将DelayQueue运用在以下应用场景：\n\n- 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取(删除)元素时，表示缓存有效期到了。\n- 定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。\n\n队列中的Delayed必须实现compareTo来指定元素的顺序。比如让延时时间最长的放在队列的末尾。实现代码如下：\n\n**如何实现Delayed接口**\n\n我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类。这个类实现了Delayed接口。\n\n然后使用getDelay可以查询当前元素还需要延时多久，代码如下：\n\n```java\npublic long getDelay(TimeUnit unit) {\n    return unit.convert(time - now(), TimeUnit.NANOSECONDS);\n}\n```\n\n通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为getDelay时可以指定任意单位，一旦以纳秒作为单位，而延时的时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。\n\n**如何实现延时队列**\n\n延时队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。\n\n```java\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.TimeUnit;\n\npublic class DelayedEle implements Delayed {\n\n    private final long delayTime; //延迟时间\n    private final long expire;  //到期时间\n    private String data;   //数据\n\n    public DelayedEle(long delay, String data) {\n        delayTime = delay;\n        this.data = data;\n        expire = System.currentTimeMillis() + delay;\n    }\n\n    /**\n     * 剩余时间=到期时间-当前时间\n     */\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return unit.convert(this.expire - System.currentTimeMillis() , TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * 优先队列里面优先级规则\n     */\n    @Override\n    public int compareTo(Delayed o) {\n        //根据delay时间\n        return (int) (this.getDelay(TimeUnit.MILLISECONDS) -o.getDelay(TimeUnit.MILLISECONDS));\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"DelayedElement{\");\n        sb.append(\"delay=\").append(delayTime);\n        sb.append(\", expire=\").append(expire);\n        sb.append(\", data='\").append(data).append('\\'');\n        sb.append('}');\n        return sb.toString();\n    }\n}\n```\n\n**测试**\n\n```java\nimport java.util.concurrent.DelayQueue;\n\n/**\n * @author imlgw.top\n * @date 2019/8/7 17:55\n */\npublic class DelayedQueueTest {\n    public static void main(String[] args) throws InterruptedException {\n        DelayQueue<DelayedEle> delayQueue = new DelayQueue<DelayedEle>();\n\n        DelayedEle element1 = new DelayedEle(3000,\"lgw\");\n        DelayedEle element2 = new DelayedEle(3000,\"top\");\n\n        delayQueue.offer(element1);\n        delayQueue.offer(element2);\n        long l = System.currentTimeMillis();\n\n        System.out.println(l);\n        element1 =  delayQueue.take();\n        System.out.println(System.currentTimeMillis()-l);\n\n        System.out.println(element1);\n    }\n}\n\n/** 测试结果\n *  1565176036796\n *  3016\n *  DelayedElement{delay=3000, expire=1565176039796, data='lgw'}\n */\n \n```\n\n### SynchronousQueue\n\nSynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue 和 ArrayBlockingQueue。\n\n> 线程池工厂方法 **newCachedThreadPool** 底层就是用的Synchronized\n\n### LinkedTransferQueue\n\nTransferQueue相比SynchronousQueue用处更广、更好用，因为你可以决定是使用BlockingQueue的方法（译者注：例如put方法）还是确保一次传递完成（译者注：即transfer方法）。在队列中已有元素的情况下，调用transfer方法，可以确保队列中被传递元素之前的所有元素都能被处理。[Doug Lea说](http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html)从功能角度来讲，LinkedTransferQueue实际上是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。\n\nLinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列LinkedTransferQueue多了tryTransfer和transfer方法。\n\nLinkedTransferQueue与SynchronousQueue中公平模式的实现TransferQueue是一样的，队列中存放的不是数据，而是操作（取出数据的操作take和放入数据的操作put）队列中既可以存放take操作也可以存放put操作，但是队列中不能同时存在两种不同的操作，因为不同的操作会触发队列进行配对（操作出队）。\n\n**transfer方法**。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下：\n\n```java\nprivate E xfer(E e, boolean haveData, int how, long nanos) {\n    if (haveData && (e == null))\n        throw new NullPointerException();\n    Node s = null;                        // the node to append, if needed\n\n    retry:\n    for (;;) {                            // restart on append race\n\n        for (Node h = head, p = h; p != null;) { // find & match first node\n            boolean isData = p.isData;\n            Object item = p.item;\n            if (item != p && (item != null) == isData) { // unmatched\n                if (isData == haveData)   // can't match\n                    break;\n                if (p.casItem(item, e)) { // match\n                    for (Node q = p; q != h;) {\n                        Node n = q.next;  // update by 2 unless singleton\n                        if (head == h && casHead(h, n == null ? q : n)) {\n                            h.forgetNext();\n                            break;\n                        }                 // advance and retry\n                        if ((h = head)   == null ||\n                            (q = h.next) == null || !q.isMatched())\n                            break;        // unless slack < 2\n                    }\n                    LockSupport.unpark(p.waiter);\n                    return LinkedTransferQueue.<E>cast(item);\n                }\n            }\n            Node n = p.next;\n            p = (p != n) ? n : (h = head); // Use head if p offlist\n        }\n\n        if (how != NOW) {                 // No matches available\n            if (s == null)\n                s = new Node(e, haveData);\n            //（1）尝试添加到链表尾部\n            Node pred = tryAppend(s, haveData);\n            if (pred == null)\n                continue retry;           // lost race vs opposite mode\n            if (how != ASYNC)\n            //（2）等待消费者消费\n                return awaitMatch(s, pred, e, (how == TIMED), nanos);\n        }\n        return e; // not waiting\n    }\n}\n```\n\n（1）代码是试图把存放当前元素的s节点作为tail节点。（2）代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。\n\n**tryTransfer方法**。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。\n\n对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。\n\n**实例**\n\n```java\npackage juc_study.collection.blocking;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedTransferQueue;\n\npublic class LinkedTransferQueueDemo {\n    static LinkedTransferQueue<String> lnkTransQueue = new LinkedTransferQueue<String>();\n    public static void main(String[] args) {\n        ExecutorService exService = Executors.newFixedThreadPool(2);\n        Producer producer = new LinkedTransferQueueDemo().new Producer();\n        Consumer consumer = new LinkedTransferQueueDemo().new Consumer();\n        exService.execute(producer);\n        exService.execute(consumer);\n        exService.shutdown();\n    }\n    class Producer implements Runnable{\n        @Override\n        public void run() {\n            for(int i=0;i<3;i++){\n                try {\n                    System.out.println(\"Producer is waiting to transfer...\");\n                    lnkTransQueue.transfer(\"A\"+i);\n                    System.out.println(\"producer transfered element: A\"+i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable{\n        @Override\n        public void run() {\n            for(int i=0;i<3;i++){\n                try {\n                    System.out.println(\"Consumer is waiting to take element...\");\n                    String s= lnkTransQueue.take();\n                    System.out.println(\"Consumer received Element: \"+s);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n### LinkedBlockingDeque\n\nLinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是Jdk的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以初始化队列的容量，用来防止其再扩容时过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。\n\n## 参考\n\n[并发容器学习—LinkedTransferQueue](https://my.oschina.net/bzhangpoorman/blog/3044802)\n\n[阻塞队列之LinkedTransferQueue](https://blog.csdn.net/YJian2008/article/details/16951811)\n\n[并发队列-无界阻塞延迟队列DelayQueue原理探究](https://www.jianshu.com/p/2659eb72134b)\n\n[并发编程网](http://ifeve.com/blocking-queues/)\n\n[Java 7中的TransferQueue](http://ifeve.com/java-transfer-queue/)","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"ThreadPoolExecutor源码解析","url":"/2019/07/30/threadpoolexecutor-yuan-ma-jie-xi/","content":"\n## 深入ThreadPoolExecutor源码\n\n### 类结构\n\n![mark](http://static.imlgw.top/blog/20190802/wTkHh1NbyM8K.png?imageslim)\n\n这里主要要说的是 `ThreadPoolExecutor`类\n\n### 线程池状态\n\n打开源码映入眼帘的就是这几个字段和方法，对应的就是线程池的一些运行状态和相关方法\n\n```java\n//控制线程池中数量和状态的字段,用AtomicInteger保存\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n//count bit顾名思义就是 workerCount的位数，这里是29\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n//1<<29 -1 == 1111....1111(29个1) 线程数(workerCount)上限 大约5亿\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\n//高三位存放状态，相应的低29位就是workerCount\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\n// 拆解ctl获取状态和数量\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\n// 拼接状态和数量得到ctl\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n#### 状态转换过程\n\n![mark](http://static.imlgw.top/blog/20190802/EWlphYbCMVjv.png?imageslim)\n\n💡 **RUNNING** ：能接受新提交的任务，并且也能处理阻塞队列中的任务；\n\n💡 **SHUTDOWN**：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 `RUNNING` 状态时，调用 `shutdown()`方法会使线程池进入到该状态。（`finalize()` 方法在执行过程中也会调用shutdown()方法进入该状态）\n\n💡 **STOP**：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 `RUNNING` 或 `SHUTDOWN` 状态时，调用 `shutdownNow()` 方法会使线程池进入到该状态\n\n💡 **TIDYING**：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态\n\n💡 **TERMINATED**：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。\n\n进入`TERMINATED`的条件如下：\n\n- 线程池不是RUNNING状态；\n- 线程池状态不是TIDYING状态或TERMINATED状态；\n- 如果线程池状态是SHUTDOWN并且workerQueue为空；\n- workerCount为0；\n- 设置TIDYING状态成功。\n\n### 成员变量\n\n再往下，就会看见一些很重要的成员变量\n\n```java\n//任务缓存队列，存放待执行的任务\nprivate final BlockingQueue<Runnable> workQueue; \n//可重入锁，线程池主要的锁\nprivate final ReentrantLock mainLock = new ReentrantLock();\n//线程集合(线程池的workers集合)\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n//对应的条件变量\nprivate final Condition termination = mainLock.newCondition(); \n//用来记录线程池中曾经出现过的最大线程数，和线程池容量没有关系\nprivate int largestPoolSize;\n//用来记录已经执行完毕的任务个数\nprivate long completedTaskCount; \n//工厂方法，用来创建线程\nprivate volatile ThreadFactory threadFactory; \n//拒绝策略\nprivate volatile RejectedExecutionHandler handler; \n//线程闲置时候的最大存活时间\nprivate volatile long keepAliveTime; \n//是否允许核心线程闲置的时候超时\nprivate volatile boolean allowCoreThreadTimeOut; \n//核心线程数\nprivate volatile int corePoolSize; \n//最大线程数\nprivate volatile int maximumPoolSize; \n//默认的拒绝策略：AbortPolicy直接拒绝并抛异常\nprivate static final RejectedExecutionHandler defaultHandler = new AbortPolicy();\n```\n\n### execute()\n\n **源码分析**\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n\n    //获取线程池的状态和线程数量\n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) { //workerCount小于核心线程数量\n        //将任务添加到workers中，第二个参数代表是否根据corePoolSize来添加线程，false则根据maxPoolSize\n        if (addWorker(command, true))\n            return;\n        //添加失败，重新获取ctl\n        c = ctl.get();\n    }\n    \n    //上面添加到workers中失败，有可能是核心线程不够用了或者线程池不是运行状态\n    //如果线程池是Running状态 尝试添加任务到阻塞队列中\n    if (isRunning(c) && workQueue.offer(command)) {\n        //添加到等待队列成功，重新获取ctl\n        int recheck = ctl.get();\n        //如果线程池不是Running状态就从等待队列中remove这个任务\n        if (! isRunning(recheck) && remove(command))\n            reject(command); //采用拒绝策略拒绝该任务\n        else if (workerCountOf(recheck) == 0)\n            //线程池Running但是没有线程\n            //创建一个线程但是不传入Runnable(已经在阻塞队列中了)\n            addWorker(null, false);\n    }\n    //两种情况\n    //1. 线程池不是Running状态并且command不为null，addWorker会直接false然后拒绝这个任务\n    //2. 添加到workQueue(阻塞队列)失败，也就是 queue满了，可能是需要扩容了\n    //   所以后面的参数是false，添加失败也会直接拒绝\n    else if (!addWorker(command, false))\n        reject(command);\n}\n```\n\n这里要理解addWorker的第二个参数，true则代表当前线程池的**上界**仍然是corePoolSize，后面的addWorker会根据上界来判断是否增加线程，false则代表**上界**是maximumPoolSize，这一点在后面的分析中会看到。\n\n**Executor大致执行流程**\n\n![mark](http://static.imlgw.top/blog/20190803/j3xQrmOkc3Kl.png?imageslim)\n\n### addWorker()\n\n`addWorker()` 的作用就是创建线程(Worker)并且添加到Workers集合中，然后启动线程\n\n**源码分析**\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // rs>=SHUTDOWN说明不是RUNNING状态\n        if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null &&!workQueue.isEmpty()))\n            return false;\n        \n        for (;;) {\n            int wc = workerCountOf(c);\n            //如果大于可允许的最大线程数，或者大于当前的线程池的上界，直接false\n            //上面传入的第二个参数的作用体现出来了，为true上界则是corePoolSize\n            if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            //利用CAS自增 增大workCount线程数，成功后就跳出循环\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            //CAS失败，重新获取ctl\n            c = ctl.get();  // Re-read ctl\n            //判断还是不是Running状态(能到这里说明rs==Running状态)，不是的话就跳出去重新来过\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n            // CAS失败并且还是Running状态，继续自旋尝试自增\n        }\n    }\n    //线程是否启动，以及线程是否添加\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        //创建一个Worker(对线程的封装)\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\t\t\t\t//是RUNNING状态 或者 是SHUTDOWN状态且没有提交任务(SHUTDOWN状态还可以执行阻塞队列的任务)\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    //添加到工作集中\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s; //记录最大值\n                    workerAdded = true; //添加成功\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                //启动线程，执行Worker的run方法\n                t.start(); \n                workerStarted = true; //启动成功\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            //启动失败，回滚workers并尝试关闭线程池\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n🔸 首先判断当前线程池的状态是否适合继续addWorker，分析这里的if条件，RUNNING不会false ，STOP，TIDYING，TERMINATED直接false，SHUTDOWN状态如果firstTask为空 阻塞队列中还有任务的时候不会false，其他情况都false。\n\n🔸 获取当前的workerCount判断是否超过了当前的上界，这里就用到了第二个参数\n\n🔸 然后利用CAS自旋增加workerCount\n\n🔸 创建Worker对象，获取mainLock并加锁，因为workers是HashSet并不是线程安全的\n\n🔸 再次获取线程池转台并判断是否合法，合法就添加到workers中，然后在finally块中释放锁\n\n🔸 根据前面的workerAdded 判断是否启动线程\n\n🔸 在最终的finally块中根据是否启动成功来决定是否回滚\n\n### addWorkerFailed()\n\n启动失败，回滚之前的添加操作\n\n```java\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    //获取锁\n    mainLock.lock();\n    try {\n        if (w != null)\n            //从workers中移除\n            workers.remove(w);\n        //减少workerCount\n        decrementWorkerCount();\n        //尝试关闭线程池\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n### Worker类\n\n封装了线程对象，线程池维护的就是这些worker\n\n```java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable\n{\n    /**\n     * This class will never be serialized, but we provide a\n     * serialVersionUID to suppress a javac warning.\n     */\n    private static final long serialVersionUID = 6138294804551838833L;\n\n    /** Thread this worker is running in.  Null if factory fails. */\n    final Thread thread;\n    /** Initial task to run.  Possibly null. */\n    Runnable firstTask; //传入的任务\n    /** Per-thread task counter */\n    volatile long completedTasks;\n\n    /**\n     * Creates with given first task and thread from ThreadFactory.\n     * @param firstTask the first task (null if none)\n     */\n    Worker(Runnable firstTask) {\n        setState(-1); // 设置状态为 -1\n        this.firstTask = firstTask;\n        //根据工厂方法创建线程\n        //将Worker传递进去，作为Thread的参数\n        //new Thread(Worker worker);\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    /** Delegates main run loop to outer runWorker  */\n    public void run() {\n        runWorker(this);\n    }\n\n    // Lock methods\n    //\n    // The value 0 represents the unlocked state.\n    // The value 1 represents the locked state.\n    // 是否获取到了锁\n    protected boolean isHeldExclusively() {\n        return getState() != 0; \n    }\n\n    protected boolean tryAcquire(int unused) {\n        //利用CAS设置state\n        //很明显这里是个不可重入的独占锁，具体可以对比ReentrantLock的实现方法\n        if (compareAndSetState(0, 1)) {\n            //继承自AbstractOwnableSynchronizer\n            //保存当前的持有锁的线程\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n    \n    //释放锁设置state=0\n    protected boolean tryRelease(int unused) {\n        //设置独占锁线程为空\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); } //最终会调用tryAcquire(1);\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); } //最终会调用tryRelease(1);\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    //打断已经启动的线程\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n```\n\n这里可以看到Worker继承了AQS并且实现了Runnable接口，然后借助AQS实现了一个`独占的不可重入的锁`，其实这也是很巧妙的一点（这里我和博客上的理解有点出入）。\n\n到这里大家肯定会有疑问，为什么这里要实现AQS然后实现一个锁？既然要又为什么要实现一个不可重入的，而不直接使用`ReentrantLock` 那不是更加方便么？？除此之外还有一个小细节就是构造器里面为什么`setState(-1)`  这样不就获取不到锁了么？？\n\n其实这是为了后面`shutdown`的时候`interruptIdleWorkers`能判断出线程是否在工作，从而打断那些空闲的线程。如果使用可重入锁的话就无法通过`tryLock()` 来判断线程是否在工作。而`setState(-1)` 则是为了防止在任务没有开始前被打断\n\n### runWorker()\n\n在上面`AddWorker()`最后添加成功后会启动Worker线程，而在worker线程中run方法又会调用一个`runWorker()`方法，这里就是具体执行任务的地方\n\n```java\nfinal void runWorker(Worker w) {\n    //当前执行线程\n    Thread wt = Thread.currentThread();\n    //拿到任务\n    Runnable task = w.firstTask; \n    w.firstTask = null;\n    //前面构造worker的时候设置了state=-1\n    //设置state为0，tryRelease(1)\n    //其实这样是为了在这之前不会被打断（还没有开始执行任务）\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true; //是否因为异常而退出？\n    try {\n        //task为空就从阻塞队列中拿任务\n        while (task != null || (task = getTask()) != null) {\n            //加锁，但是这个锁不会和其他的Worker互斥，这个锁只是用来判断worker是否在工作\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                //打断当前执行线程wt\n                wt.interrupt();\n            try {\n                //空方法交给子类去实现\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run(); //执行任务\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    //空方法交给子类去实现\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++; //完成任务数++\n                w.unlock();\n            }\n        }\n        completedAbruptly = false; //下面的收尾工作会根据这个判断是否调整线程数\n    } finally {\n        processWorkerExit(w, completedAbruptly); //收尾工作\n    }\n}\n```\n\n🔸 首先获取了参数传递进来的worker携带的任务\n\n🔸 然后执行了w.unlock()，实际上这里就对应了上面Worker类构造器中的setState(-1)，正因为前面设置了state为 -1 所以在unlock()之前，获得锁的CAS操作肯定都会失败，当然这也是为了在任务启动前不会被打断，所以在这里unlock()就又将state设置为了0 也就表示可以通过CAS获得锁了，也可以被shutdown打断了。\n\n🔸 然后这个线程就会执行worker中的任务，如果worker中任务为空就会从阻塞队列中获取任务\n\n🔸 获取到任务后进入循环先进行 lock() 操作，这就代表已经开始执行任务了，这个时候shutdown就无法发送中断信号中断这个线程执行 (注意这个lock并不会和其他的worker互斥，因为每个Worker都是新new出来的，完全不相关的，他们的state状态都是独立的)\n\n🔸 `runStateAtLeast(ctl.get(), STOP)` 返回`ctl.get() >= STOP`  ，判断线程池是否正在关闭如果是就打断该线程，如果不是需要确保线程不是Interrupt状态\n\n`If pool is stopping, ensure thread is interrupted;  if not, ensure thread is not interrupted.`\n\n🔸`beforeExecute()` 和`afterExecute()` 都是空方法交给子类去实现的。\n\n🔸 到finally块里面就代表这个工作线程已经快要结束了，`processWorkerExit()`  就是处理一些\"后事\"的\n\n### getTask()\n\n这个方法就是用来从阻塞队列中获取任务的，如果 `getTask()` 返回null，在`runWorker()` 里面接收到`null` 后就会**跳出循环**进而执行`finally` 块里面的`processWorkerExit()` 。而这也就意味着这个线程`执行结束`了，不会在执行任务了，剩下的就是等待JVM回收这个线程。\n\n```java\nprivate Runnable getTask() {\n    //是否超时？和keepAliveTime相关\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 如果线程池状态为SHUTDOWN并且任务队列没任务 或者 线程状态>=STOP\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        // 是否允许线程超时 允许核心线程超时(主动超时)？ 或者wc大于了核心线程数(被动超时)\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\t\t//此时需要回收多余的线程\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c)) //cas减少线程数\n                return null; //返回null\n            continue; //cas失败 继续循环\n        }\n\n        try {\n            //根据timed判断是限时获取还是直接获取\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take(); //阻塞的获取\n            if (r != null)\n                return r;\n            //没获取到，超时了\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n🔸 获取线程池状态，如果线程池状态为SHUTDOWN并且任务队列没任务 或者 线程状态>=STOP 就通过CAS自旋减少线程数，然后返回null\n\n🔸 判断是否允许当前线程获取任务超时，如果允许核心线程超时就代表所有线程都会超时限制，又或者是当前线程数超过了核心线程数，也就是经过了扩容，所以核心线程之外的线程都是有超时限制的。\n\n🔸 如果 ① wc超过最大线程数  ②没超过最大线程数，但是超时了并且此时wc>1(留一个处理任务)③没超过最大线程数，但是超时了并且阻塞队列为空，此时需要回收多余的线程\n\n🔸 根据timed选取从阻塞队列中获取任务的方式，要么是限时获取的poll或者一直阻塞的take，获取到了之后返回\n\n### processWorkerExit()\n\n看名字就知道是一个收尾的方法，执行线程结束后的一些必要收尾工作。\n\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        //如果是因为异常而退出则 getTask() 没有机会去调整线程数所以需要在这里调整\n        decrementWorkerCount();  // wc--\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //完成任务总数+=该worker完成的任务数\n        completedTaskCount += w.completedTasks;\n        //移除出线程集workers\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n    \n    //尝试结束线程池\n    tryTerminate();\n    \n    //获取ctl\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        //非异常结束\n        if (!completedAbruptly) {\n            //最小值根据是否允许核心线程超时来判断\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1; //如果最小为0并且任务队列不为空则保证线程池中至少有一个线程执行这些任务\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        //1.异常结束，新增加一个线程到线程池,相当于替换了异常的线程\n        //2.非异常结束，工作线程小于核心线程，增加线程，确保在不允许核心线程超时的情况下线程数不小于corePoolSize\n        addWorker(null, false);\n    }\n}\n```\n\n`runStateLessThan`  c < STOP 返回true就说明是`SHUTDOWN` 或者`RUNNING` ，到这里该工作线程（Worker）的生命周期就结束了。\n\n### 工作线程的生命周期\n\n![mark](http://static.imlgw.top/blog/20190803/NbjiMxDqJlu4.png?imageslim)\n\n### tryTerminate()\n\n在上面的处理收尾工作的`processWorkerExit()` 的时候中间调用了一个 `tryTerminate()` 方法\n\n```java\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        //如果是在RUNNING状态 直接return\n        //如果已经是TIDYING或者TERMINATED状态 直接return\n        //如果是SHUTDOWN状态并且阻塞队列中还有任务 直接return\n        //return就说明线程池还不到关闭的时候\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))\n            return;\n        //到这里就说明要么是STOP状态，要么是SHUTDOWN状态阻塞队列也没任务了\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            //中断一个空闲的worker线程\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\t\t\n        //wc==0 没有线程存活了\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            //CAS自旋 修改线程池状态为TIDYING\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    terminated(); //空方法,交给子类去实现的\n                } finally {\n                    //设置状态为 TERMINATED\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    //唤醒termination上awiat的线程\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        // else retry on failed CAS\n    }\n}\n```\n\n这里最后的`termination.signalAll()` 实际上是唤醒的`awaitTermination()` 方法阻塞的线程\n\n```java\npublic boolean awaitTermination(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (;;) {\n            if (runStateAtLeast(ctl.get(), TERMINATED))\n                return true;\n            if (nanos <= 0)\n                return false;\n            //限时等待\n            nanos = termination.awaitNanos(nanos);\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n### shutdown()\n\n```java\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        //CAS自旋设置线程池状态为 SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        //打断idle(空闲)的worker\n        interruptIdleWorkers(); \n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n```\n\n这里关键的就是这个打断空闲线程的操作。\n\n### interruptIdleWorkers()\n\n打断空闲的worker，这里的空闲线程其实指的就是在阻塞队列上获取不到任务而阻塞的线程\n\n经过上面的分析我们知道Worker会不断的从阻塞队列中去拿任务也就是 `getTask()` 方法，如果阻塞队列为空就会阻塞住 直到有任务提交到阻塞队列中，或者执行线程被中断。\n\n这里我们是要SHUTDOWN那阻塞队列中肯定是不会再有任务提交，所以`take()` 会阻塞住，所以我们就只能通过打断执行线程的方式来打断`take()` 操作，否则会一直阻塞，线程池无法关闭。\n\n```java\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock(); //加锁，因为Wokers是HashSet是线程不安全的\n    try {\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            //没有被打断并且没有在工作(空闲)\n            if (!t.isInterrupted() && w.tryLock()) {\n                try {\n                    //打断Worker里面的线程\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            //只打断一个就直接break\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n🔸首先获取了mainLock保证了workers的线程安全避免产生并发修改异常。\n\n🔸然后遍历workers，打断那些没有被打断并且没有工作的线程，那这里怎么知道线程是不是在工作呢？\n\n别忘了前面提到的Worker类借助AQS实现了一个`不可重入`的`lock` 方法，而在worker执行任务的时候会执行 `lock` 加锁，所以在这里`tryLock()` 如果返回`true`则说明 并没有在工作可以打断，反之如果正在工作`tryLock()` 不可重入，无法获取到自己持有的锁返回false，所以线程肯定是在工作状态所以不应该打断，这些线程会在执行完任务后自行了断，因为线程池状态已经设置为`SHUTDOWN` 当然前提是这些任务是**可终止的**\n\n🔸打断后释放`tryLock()`获取到的锁\n\n🔸如果只打断一个就直接break，否则就继续下一轮循环\n\n🔸释放mianLock\n\n> 瞎猜: 这里可以通过getState判断线程状态但是有可能在执行任务的过中阻塞\n\n### shutdownNow()\n\n和上面的shutdown()一样都是用来关闭线程池的但是看方法名就知道这个比较粗暴，shutdownNow立刻马上关闭，一点情面都不给😂，虽然说是打断所有的线程但是毕竟使用的是`Interrupt` ，也许别人正在执行的线程根本就不会理你😂，所以在提交任务的时候要对任务进行正确的interrupt响应，或者确保线程不会一直阻塞否则线程池就无法正常关闭\n\n```java\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        //CAS自旋设置状态为STOP\n        advanceRunState(STOP);\n        //打断所有的线程包括正在工作的线程\n        interruptWorkers();\n        //排干阻塞队列，因为已经STOP了不会再执行队列里面的任务了\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    //尝试关闭线程池\n    tryTerminate();\n    return tasks;\n}\n```\n\n### interruptWorkers()\n\n```java\nprivate void interruptWorkers() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers)\n            //打断所有启动的线程\n            w.interruptIfStarted();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n打断了所有的启动的线程，即使他们可能不会响应这个Interrupted信号，但是由于线程池状态已经变为了STOP，所以他们也活不长了(当然前提是执行的任务是可以结束的)，在下一次获取任务的时候就会直接return 。\n\n## 细节是魔鬼\n\n在群里面看见的问题，为什么线程池要用 线程不安全的 `HashSet` 然后设置了一个 `mainLock` 控制并发，而不是直接使用线程安全的并发集合？\n\n这一点其实在源码的注释中已经说的很清楚了，之前一直没有注意到\n\n```java\n    /**\n     * Lock held on access to workers set and related bookkeeping.\n     * While we could use a concurrent set of some sort, it turns out\n     * to be generally preferable to use a lock. Among the reasons is\n     * that this serializes interruptIdleWorkers, which avoids\n     * unnecessary interrupt storms, especially during shutdown.\n     * Otherwise exiting threads would concurrently interrupt those\n     * that have not yet interrupted. It also simplifies some of the\n     * associated statistics bookkeeping of largestPoolSize etc. We\n     * also hold mainLock on shutdown and shutdownNow, for the sake of\n     * ensuring workers set is stable while separately checking\n     * permission to interrupt and actually interrupting.\n     */\n    private final ReentrantLock mainLock = new ReentrantLock();\n\n```\n\n一开始还挺抗拒的，感觉有的地方有的看不懂（英语渣渣留下眼泪）然后去stackoverflower上看了一下找到了一个答案  [Using ReentrantLock in ThreadPoolExecutor to ensure thread-safe workers](https://stackoverflow.com/questions/31942117/using-reentrantlock-in-threadpoolexecutor-to-ensure-thread-safe-workers) \n\n大概总结一下就是两点\n\n1. 避免 “中断风暴” ，如果是用的显式锁那么如果有10个线程同时去执行shutdown方法，那么10个线程会排队去执行`interruptIdleWorkers` ，如果使用并发安全的队列的话，在10个线程同时去执行shutdown方法，那么肯定会同时去 `interruptIdleWorkers` 也就是所谓的中断风暴\n\n   > [中断风暴(维基百科)](https://en.wikipedia.org/wiki/Interrupt_storm) 中文几乎搜不到相关资料，其实就是字面意思，而太多的中断请求会的影响系统的整体性能，不得不说大师就是大师，细节之处则更能体现水平，我等也只能膜拜了\n\n2. 另一点就是为了方便统计线程池的一些信息比如 `largestPoolSize` 等，这点也好理解，使用并发的Set只能保这个set的并发安全，而对于其他的一些线程池的相关的信息统计起来就比较麻烦，可能又需要另外的加锁，所以索性就直接搞一个全局的锁，一举两得\n\n## ThreadPoolExecutor使用\n\n### 构造方法\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n\n其实从中也可以看出对各个参数的一些限制。\n\n**corePoolSize：**核心池的大小，这个参数与后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了`prestartAllCoreThreads()`或者`prestartCoreThread()`方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。`默认情况下`，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中\n\n**maximumPoolSize：**线程池最大线程数，它表示在线程池中最多允许创建多少个线程\n\n**keepAliveTime**：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当`线程池中的线程数大于corePoolSize时`，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize：即当线程池中的线程数大于`corePoolSize`时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize，但是如果调用了`allowCoreThreadTimeOut(boolean)`方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0，这些内容其实在上面的深入源码中都有过分析。\n\n**unit：**参数keepAliveTime的时间单位\n\n**workQueue**：一个阻塞队列，用来存储等待执行的任务，这个参数的选择会对线程池的运行过程产生重大影响\n\n**threadFactory**：线程工厂，主要用来创建线程(根据传进来的Runnable/Callable)\n\n**handler**：表示当拒绝处理任务时的策略，有以下四种取值\n\n- **ThreadPoolExecutor.AbortPolicy** 丢弃任务并抛出RejectedExecutionException异常。 \n- **ThreadPoolExecutor.DiscardPolicy** 也是丢弃任务，但是不抛出异常。 \n- **ThreadPoolExecutor.DiscardOldestPolicy** 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n- **ThreadPoolExecutor.CallerRunsPolicy**  由调用线程处理该任务 \n\n### 线程池的关闭\n\n`shutdown()`  `shutdownNow()` ，上面已经分析过了，就不再过多介绍了。\n\n### 工厂方法\n\n上面的构造器中一共有7个参数，可见要构造一个线程池并非那么容易，所以jdk 在`Executors` 类中为我们提供了一些工厂方法，可以直接构造一些特定的线程池。\n\n**newCachedThreadPool()**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n可以看到`core`为0，最大值为`Integer.MAX_VALUE`，任务队列使用的`SynchronousQueue` ，这个队列是一个很奇葩的阻塞队列，实际上它不是一个真正的队列，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作，只有两个都准备好的时候才不会阻塞，所以它内部不会为队列元素维护空间，也就是说并不会缓存任务，一旦提交了(put)任务，要么就由空闲线程去执行(take)，要么创建一条新线程去执行(take)。\n\n**newFixedThreadPool()**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n可以看到，最大值和core都是 `nThread` ，也就是最多`nThread`个线程，阻塞队列采用 `LinkedBlockQueue` \n\n**newSingleThreadExecutor()**\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n等价于`newFixedThreadPool(1)` ，但是这里的返回值经过了一层包装 返回的不再是`ThreadPoolExecutor` 也就是不会再有那些扩展的monitor方法\n\n> A wrapper class that exposes only the ExecutorService methods  of an ExecutorService implementation.\n>\n\n类似的方法其实还有一些，像`newWorkStealingPool` 等，感兴趣可以自己去查一查。\n\n其实这里阿里巴巴Java开发规范并不建议使用工厂方法创建线程\n\n![mark](http://static.imlgw.top/blog/20190806/lMVPdlPqEPNO.png?imageslim)\n\n所以建议还是通过构造器的方式去创建线程，这样也更加灵活更加可控。","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"JUC并发工具包","url":"/2019/07/24/bing-fa-gong-ju-bao/","content":"\n## CountDownLatch\n\n结合前面的知识，我们知道`Thread.join()`可以实现一个线程等待另一个线程`结束`再执行，但是有时候我们可能并不需要等到另一个线程结束，只需要等待特定的操作结束后就可以，可能有人会说可以通过`wait/notify`模型来实现，但是其实我们可以采用更加方便的工具类也就是 `java.util.concurrent.CountDownLatch`。\n\n| Constructor and Description                                  |\n| ------------------------------------------------------------ |\n| `CountDownLatch(int count)`   构造一个以给定计数 `CountDownLatch` CountDownLatch。 |\n\n**案例**\n\n```java\npublic class CountDownLatchTest {\n\n    private static Random random=new Random(System.currentTimeMillis());\n\n    private static ExecutorService executor=Executors.newFixedThreadPool(2);\n\n    private static  CountDownLatch latch;\n\n\n    public static void main(String[] args) throws InterruptedException {\n        int  []data=query();\n        //构造器的参数代表需要执行的先决条件的数量\n        latch=new CountDownLatch(data.length);\n        for (int i = 0; i <data.length ; i++) {\n            executor.execute(new SimpleRunnable(data,i,latch));\n        }\n        latch.await();\n        //异步关闭\n        executor.shutdown();\n        System.out.println(\"all of works done \");\n\n    }\n\n    static class SimpleRunnable implements Runnable{\n        private final int []data;\n        private final int index;\n        private final CountDownLatch latch;\n\n\n        public SimpleRunnable(int[] data, int index, CountDownLatch latch) {\n            this.data = data;\n            this.index = index;\n            this.latch=latch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(random.nextInt(2000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            int value=data[index];\n            if (value%2==0) {\n                data[index]=2*value;\n            }else{\n                data[index]=10*value;\n            }\n            System.out.println(Thread.currentThread().getName()+\" finished\");\n            latch.countDown();\n        }\n    }\n    \n    private static int[] query(){\n        return new int[]{1,2,3,4,5,6,7,8,9,10};\n    }\n}\n```\n\n`CountDownLatch`内部维护了一个未执行操作的计数器 `count`这个count需要通过构造器传入，CountDownLatch 实例的countdown方法每执行一次`count` 就会减一 ，在`count` 减为0之前`await` 方法的执行线程会被暂停，\n\n直到`count`减为0的时候才会被唤醒继续执行。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/24 15:09\n */\npublic class CountDownLatchTest2 {\n    private static int data;\n\n    public static void main(String[] args) throws InterruptedException {\n        final CountDownLatch latch=new CountDownLatch(4);\n\n        new Thread(() -> {\n            for (int i = 1; i <10; i++) {\n                data=i;\n                latch.countDown();\n                try {\n                    Thread.sleep(new Random().nextInt(1000));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        latch.await();\n        System.out.println(\"data:\"+data);\n    }\n}\n```\n\nCountDownLatch传入的count为4，循环执行了10次，结果是多少？当然是4了，当减为0的时候await调用就会返回不会再等待，后面即使count已经减为0再减也没有什么意义。\n\n### API\n\n| Modifier and Type | Method and Description                                       |\n| ----------------- | ------------------------------------------------------------ |\n| `void`            | `await()`   导致当前线程等到锁存器计数到零，除非线程是 interrupted 。 |\n| `boolean`         | `await(long timeout,  TimeUnit unit)`  使当前线程等待直到锁存器计数到零为止，除非线程为 interrupted或指定的等待时间过去。 |\n| `void`            | `countDown()`   减少锁存器的计数，如果计数达到零，释放所有等待的线程。 |\n| `long`            | `getCount()`   返回当前计数。                                |\n| `String`          | `toString()`   返回一个标识此锁存器的字符串及其状态。        |\n\n## CyclicBarrier\n\n有时候多个线程可能需要相互等待对方执行到某一步然后再执行下一步。生活中就有很多这样的情形？比如相约爬山：大家约定好集合的地点然后等所有人到达指定的集合地点后再一起去，先到达的人需要等待后到达的人，只有所有人到齐后才会出发去爬山。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/24 15:54\n */\npublic class CyclicbarrierTest1 {\n    public static void main(String[] args){\n        CyclicBarrier cyclicBarrier=new CyclicBarrier(2);\n        new Thread(()->{\n            try {\n                //do something\n                Thread.sleep(2000);\n                System.out.println(\"t1 finished\");\n                cyclicBarrier.await();\n                System.out.println(\"other thread is done too\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(()->{\n            try {\n                //do something\n                Thread.sleep(6000);\n                System.out.println(\"t2 finished\");\n                cyclicBarrier.await();\n                System.out.println(\"other thread is done too\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n上面的代码就体现了这种情况，两个线程开始先分别做各自的事情，然后到达一个点之后，需要相互等待，先到达的等待后到达的，上面的例子中很显然 `t1` 先到达它需要等待`t2` 到达后才能继续运行。\n\n同时，如果外界是想要知道这个CyclicBarrier的任务执行情况可以在构造函数中加入一个回调的`Runnable`\n\n```java\nCyclicBarrier cyclicBarrier=new CyclicBarrier(2,()->{\n    System.out.println(\"t1,t2 both arrived\");\n});\n```\n\n这样的方式还是很优雅的。\n\n如果细心的话其实你还会发现相比上面的CountDown多了一个BrokenBarrierException，我们来看看doc\n\n如果有线程正在waiting而 Barrier已经被reset了\n\n> If the barrier is {@link #reset} while any thread is waiting\n>\n> or if the barrier {@linkplain #isBroken is broken} when\n>\n> {@code await} is invoked, or while any thread is waiting, then\n>\n> {@link BrokenBarrierException} is thrown.\n\n如果某一个线程在waiting的时候被打断了，那么其他的waiting线程将会抛出这个异常\n\n>If any thread is {@linkplain Thread#interrupt interrupted} while waiting\n>\n>then all other waiting threads will throw\n>\n>{@link BrokenBarrierException} and the barrier is placed in the broken\n>\n>state.\n\n**源码解析**\n\n`CyclicBarrier`并没有借助AQS而是利用`Condition`条件变量来实现的，关于`Condition`后面会介绍。\n\n**doAwait()**\n\n```java\nprivate int dowait(boolean timed, long nanos)\n    throws InterruptedException, BrokenBarrierException,\n           TimeoutException {\n    final ReentrantLock lock = this.lock;\n    lock.lock(); //加锁\n    try {\n        final Generation g = generation;\n\n        if (g.broken)\n            throw new BrokenBarrierException();\n\n        if (Thread.interrupted()) {\n            breakBarrier();\n            throw new InterruptedException();\n        }\n\n        int index = --count; //和countDownLatch类似\n        if (index == 0) {  // tripped 所有线程都抵达了\n            boolean ranAction = false;\n            try {\n                final Runnable command = barrierCommand; \n                if (command != null)\n                    command.run(); //执行构造器中传入的CallBack\n                ranAction = true;\n                nextGeneration(); //下一个轮回\n                return 0;\n            } finally {\n                if (!ranAction)\n                    breakBarrier();\n            }\n        }\n\n        // loop until tripped, broken, interrupted, or timed out\n        for (;;) {\n            try {\n                if (!timed)\n                    trip.await();\n                else if (nanos > 0L)\n                    nanos = trip.awaitNanos(nanos);\n            } catch (InterruptedException ie) {\n                if (g == generation && ! g.broken) {\n                    breakBarrier();\n                    throw ie;\n                } else {\n                    // We're about to finish waiting even if we had not\n                    // been interrupted, so this interrupt is deemed to\n                    // \"belong\" to subsequent execution.\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            if (g != generation)\n                return index;\n\n            if (timed && nanos <= 0L) {\n                breakBarrier();\n                throw new TimeoutException();\n            }\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n **nextGeneration()** \n\n```java\nprivate void nextGeneration() {\n    // signal completion of last generation\n    trip.signalAll(); //唤醒这个barrier上所有的等待线程，trip是一个condition\n    // set up next generation\n    count = parties; //count复位\n    generation = new Generation();\n}\n```\n\n其实也可以用CountDownLatch实现和CyclicBarrier类似的功能，这里就不再演示。\n\n### API\n\n| Modifier and Type | Method and Description                                       |\n| ----------------- | ------------------------------------------------------------ |\n| `int`             | `await()`   等待所有 parties到达屏障，并且在这个障碍上调用`await` 。 |\n| `int`             | `await(long timeout,  TimeUnit unit)`  等待所有 parties已经在此屏障上调用  `await` ，或指定的等待时间过去。 |\n| `int`             | `getNumberWaiting()`   返回目前正在等待的线程的数量。        |\n| `int`             | `getParties()`   返回parties                                 |\n| `boolean`         | `isBroken()`   查询这个障碍是否处于Broken                    |\n| `void`            | `reset()`   将屏障重置为初始状态。                           |\n\n### 区别\n\n- `CountDownLatch`不能`reset`（递减到0后不能复原），`CyclicBarrier`正如其名是可以循环使用的。\n\n- `CountDownLatch`工作线程之间互不关心，`CyclicBarrier`所有线程必须到达一个共同的点才会继续执行\n\n## Exchanger\n\nJDK1.5引入的，看名字就猜得到大概是干嘛的，主要就是用于`两个线程` 之间的数据交换，其实也就相当于只有两个参与方的`CyclicBarrier` 当两个线程都达到`exchanger point` (集合点) 就会进行数据的交换，`一手交钱，一手交货` 所以在使用的时候也要注意两个线程能否正确的到达`exchanger point` 如果有一方无法到达则另一方就会陷入等待，当然你可以加上timeout。另外这个只适用与两个线程，如果有2个以上的线程参与将会造成数据传输混乱，无法控制。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 13:54\n */\npublic class ExchangerTest1 {\n    public static void main(String[] args) {\n        final Exchanger<String> exchanger=new Exchanger<>();\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+\" start\");\n            try {\n                String res = exchanger.exchange(\"i am  A\",10,TimeUnit.SECONDS);\n                System.out.println(\"back msg=\" +res);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (TimeoutException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\"done\");\n        }).start();\n\n\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+\" start\");\n            try {\n                String res = exchanger.exchange(\"i am  B\");\n                System.out.println(\"back msg=\" +res);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\"done\");\n        });\n    }\n}\n```\n\n### 线程安全问题\n\n确实Exchanger如果使用不当会造成很多问题，所以在使用的时候一定要谨慎，首先它只适用与两个线程之间传输数据，其次这里传输的对象是`同一个` ，也就是说发送端和接收端的对象内存地址是一样的是一个对象。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 15:14\n */\npublic class ExchangerTest2 {\n    public static void main(String[] args) {\n        final Exchanger<Simple> exchanger=new Exchanger<>();\n        new Thread(()->{\n            Simple simple = new Simple(1);\n            System.out.println(Thread.currentThread().getName()+\" start. send to B\"+simple);\n            try {\n                Simple res = exchanger.exchange(simple);\n                //休眠10s\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(\"A receive from B obj:\"+res +\" data:\"+res.a);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\" done\");\n        },\"A\").start();\n\n        new Thread(()->{\n            Simple simple = new Simple(2);\n            System.out.println(Thread.currentThread().getName()+\" start. send to A:\"+simple);\n            try {\n                Simple res = exchanger.exchange(simple);\n                //修改发送出去的obj\n                simple.setA(100000);\n                System.out.println(\"B receive from A obj:\"+res +\" data:\"+res.a);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\" done\");\n        },\"B\").start();\n    }\n\n    static class Simple{\n        private int a;\n\n        public Simple(int a) {\n            this.a = a;\n        }\n\n        public int getA() {\n            return a;\n        }\n\n        public void setA(int a) {\n            this.a = a;\n        }\n    }\n}\n```\n\n**结果**\n\n```java\nA start. send to Bjuc_study.tools.Exchanger.ExchangerTest2$Simple@72d6db17\nB start. send to A:juc_study.tools.Exchanger.ExchangerTest2$Simple@4295c176\nB receive from A obj:juc_study.tools.Exchanger.ExchangerTest2$Simple@72d6db17 data:1\nB done\nA receive from B obj:juc_study.tools.Exchanger.ExchangerTest2$Simple@4295c176 data:100000\nA done\n```\n\n两个线程拿到的是同一个对象并不是拷贝，两个线程同时的去操作这个对象这其实是很危险的很有可能就会产生一些线程安全问题，使用的时候一定要注意\n\n## Semaphore\n\n信号量，相信学过操作系统的同学肯定对这个很熟悉了，熟悉PV操作的话这个一看就懂了。\n\n| Constructor and Description                                  |\n| ------------------------------------------------------------ |\n| `Semaphore(int permits)`   创建一个 `Semaphore`与给定数量的许可证，默认非公平锁 |\n| `Semaphore(int permits,  boolean fair)`  创建一个 `Semaphore`与给定数量的许可证和是否公平 |\n\n### Semaphore实现一个显示锁\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 15:48\n */\npublic class SemaphoreTest1 {\n    public static void main(String[] args) {\n        final SemaphoreLock semaphoreLock=new SemaphoreLock();\n\n        new Thread(()->{\n            try {\n                semaphoreLock.lock();\n                System.out.println(Thread.currentThread().getName()+\" get the lock\");\n                TimeUnit.SECONDS.sleep(4);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                semaphoreLock.unlock();\n                System.out.println(Thread.currentThread().getName()+\"release the lock\");\n            }\n\n        }).start();\n\n        new Thread(()->{\n            try {\n                semaphoreLock.lock();\n                System.out.println(Thread.currentThread().getName()+\" get the lock\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                semaphoreLock.unlock();\n                System.out.println(Thread.currentThread().getName()+\"release the lock\");\n            }\n\n        }).start();\n    }\n\n    static class SemaphoreLock{\n        private final  Semaphore semaphore =new Semaphore(1);\n\n        private void lock() throws InterruptedException {\n            semaphore.acquire();\n        }\n\n        public void unlock(){\n            semaphore.release();\n        }\n    }\n}\n```\n\n### 实现生产者消费者模型\n\n生产者消费者模型其实也挺重要的，有时候面试会让你手写一个生产者消费者模型，在之前的文章中其实有实现过一个但是那个其实还是很简单的一个，那个是没有Buffer的，下面这个用信号量实现的就是有Buffer的，后面会单独整理出所有的生产者消费者模型的实现方法。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 16:43\n */\npublic class ProduceConsumerV4 {\n    public static void main(String[] args) {\n        ProduceConsumerV4 pc = new ProduceConsumerV4();\n        Stream.of(\"Produce1\", \"Produce2\", \"Produce3\", \"Produce4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\", \"Consumer2\", \"Consumer3\", \"Consumer4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n\t\n    //buffer载体\n    private LinkedList<Object> buffer=new LinkedList<>();\n\n    private final Semaphore full = new Semaphore(0);\n\t\n    //buffer最大值\n    private final Semaphore empty = new Semaphore(3);\n\n    //互斥锁\n    private final Semaphore mutex= new Semaphore(1);\n\n    public void produce() {\n        //已经生产了\n        try {\n            empty.acquire();\n            //不能和上面的信号量交换\n            mutex.acquire();\n            buffer.add(new Object());\n            System.out.println(Thread.currentThread().getName() + \" produce a obj , current list size:\" +buffer.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            mutex.release();\n            full.release();\n        }\n    }\n\n    public void consumer() {\n        try {\n            full.acquire();\n            mutex.acquire();\n            //移除最后一个\n            buffer.removeLast();\n            System.out.println(Thread.currentThread().getName() + \" consumer a obj, current size: \" + buffer.size());//consumer\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            mutex.release();\n            empty.release();\n        }\n    }\n}\n```\n\n### API\n\n| Modifier and Type              | Method and Description                                       |\n| ------------------------------ | ------------------------------------------------------------ |\n| `void`                         | `acquire()`   从该信号量获取许可证，阻塞直到获取到，可以被interrupt |\n| `void`                         | `acquire(int permits)`   从该信号量获取给定数量的许可证，阻塞直到获取到可以被interrupt |\n| `void`                         | `acquireUninterruptibly()`  从该信号量获取许可证，阻塞直到获取到，无视interrupt，不会被interrupt |\n| `void`                         | `acquireUninterruptibly(int permits)`   从该信号量获取给定数量的许可证，阻止直到获取到，不可被interrupt。 |\n| `int`                          | `availablePermits()`   返回此信号量中当前可用的许可数。      |\n| `int`                          | `drainPermits()`   获取并返回所有可立即获得的许可证。        |\n| `protected Collection<Thread>` | `getQueuedThreads()`   返回一个包含`可能`正在等待获取的线程的集合。 |\n| `int`                          | `getQueueLength()`   返回等待获取的线程数的估计值。          |\n| `boolean`                      | `hasQueuedThreads()`   查询是否有线程等待获取。              |\n| `boolean`                      | `isFair()`   是不是公平锁                                    |\n| `protected void`               | `reducePermits(int reduction)`   缩小可用许可证的数量。      |\n| `void`                         | `release()`   释放许可证，将其返回到信号量。(0的时候也可以release) |\n| `void`                         | `release(int permits)`   释放给定数量的许可证，将其返回到信号量。 |\n| `String`                       | `toString()`   返回一个标识此信号量的字符串及其状态。        |\n| `boolean`                      | `tryAcquire()`   从这个信号量获得许可证，立即返回，不会阻塞。 |\n| `boolean`                      | `tryAcquire(int permits)`   从这个信号量获取给定数量的许可证，不会阻塞 |\n| `boolean`                      | `tryAcquire(int permits,  long timeout, TimeUnit unit)`  从该信号量获取给定数量的许可证，如果在给定的等待时间获取到，就返回true，可以被打断 |\n| `boolean`                      | `tryAcquire(long timeout,  TimeUnit unit)`  从该信号量获取许可证，如果在给定的等待时间获取到，就返回true，可以被打断 |\n\n## Lock\n\n通常被称为显式锁，与之对应的`synchroized` 则被称为内部锁，显式锁是jdk1.5引入的锁，他的作用与内部锁相同，但是它的功能比内部锁更加强大，但是并不是内部锁的替代品，其实在之前的 [Java多线程基础](http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/#LOCK%E6%8E%A5%E5%8F%A3)  一文中就手写过一个带有`限时等待`的锁 ，那个其实就是模仿的`Lock` 接口\n\n### ReentrantLock\n\nReentrantLock是Lock接口的一个实现类也是用的最多的一个实现类，`Reentrant` 本意就是 可重入的，可再入的， 表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，`synchnorized`也是可重入的。\n\n| Constructor and Description                                  |\n| ------------------------------------------------------------ |\n| `ReentrantLock()`   创建一个 `ReentrantLock`的实例。         |\n| `ReentrantLock(boolean fair)`   根据给定的公平策略创建一个 `ReentrantLock`的实例。 |\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/25 20:07\n */\npublic class ReentrantLockTest1 {\n\n    private static final ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread0 = new Thread(() -> needLock() );\n        Thread thread1 = new Thread(() -> needLock() );\n        thread0.start();\n        thread1.start();\n        TimeUnit.SECONDS.sleep(3);\n        thread1.interrupt();\n    }\n\n    public static void needLock() {\n        try {\n            //可打断的获取锁\n            lock.lockInterruptibly();\n            System.out.println(Thread.currentThread().getName()+\" is get the lock\");\n            while (true){\n\t\t\t\t//空转\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock(); //确保锁的释放\n        }\n    }\n}\n```\n\n**测试结果**\n\n```java\nThread-0 is get the lock\njava.lang.InterruptedException\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)\n\tat java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)\n\tat juc_study.tools.Lock.ReentrantLockTest1.needLock(ReentrantLockTest1.java:26)\n\tat juc_study.tools.Lock.ReentrantLockTest1.lambda$main$1(ReentrantLockTest1.java:16)\n\tat java.lang.Thread.run(Thread.java:748)\nException in thread \"Thread-1\" java.lang.IllegalMonitorStateException\n\tat java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)\n\tat java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)\n\tat juc_study.tools.Lock.ReentrantLockTest1.needLock(ReentrantLockTest1.java:34)\n\tat juc_study.tools.Lock.ReentrantLockTest1.lambda$main$1(ReentrantLockTest1.java:16)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n#### API\n\n| Modifier and Type              | Method and Description                                       |\n| ------------------------------ | ------------------------------------------------------------ |\n| `int`                          | `getHoldCount()`  当前线程调用lock()的次数 (重入的次数)      |\n| `protected Thread`             | `getOwner()`   返回当前拥有此锁的线程，如果没有，返回 `null` 。 |\n| `protected Collection<Thread>` | `getQueuedThreads()`   返回包含可能正在等待获取此锁的线程的集合。 |\n| `int`                          | `getQueueLength()`   返回等待获取此锁的线程数的估计值。      |\n| `protected Collection<Thread>` | `getWaitingThreads(Condition condition)`   返回包含可能在与此锁相关联的给定条件下等待的线程的集合。 |\n| `int`                          | `getWaitQueueLength(Condition condition)`   返回与此锁相关联的给定条件等待的线程数的估计。 |\n| `boolean`                      | `hasQueuedThread(Thread thread)`  查询给定线程是否等待获取此锁。 |\n| `boolean`                      | `hasQueuedThreads()`   查询是否有线程正在等待获取此锁。      |\n| `boolean`                      | `hasWaiters(Condition condition)`   查询任何线程是否等待与此锁相关联的给定条件。 |\n| `boolean`                      | `isFair()`   如果此锁的公平设置为true，则返回 `true` 。      |\n| `boolean`                      | `isHeldByCurrentThread()`   查询此锁是否由当前线程持有。     |\n| `boolean`                      | `isLocked()`   查询此锁是否由任何线程持有。                  |\n| `void`                         | `lock()`   获得锁，不能被打断                                |\n| `void`                         | `lockInterruptibly()`   获得锁，可以被打断                   |\n| `Condition`                    | `newCondition()`   返回`Condition`用于这种用途实例`Lock`实例。 |\n| `String`                       | `toString()`   返回一个标识此锁的字符串以及其锁定状态。      |\n| `boolean`                      | `tryLock()`   尝试获取该锁，不会阻塞，直接返回，             |\n| `boolean`                      | `tryLock(long timeout,  TimeUnit unit)`  尝试在给定时间内获取锁，可以被打断 |\n| `void`                         | `unlock()`   释放锁。                                        |\n\n### ReadWriteLock\n\n看名字就知道是干啥的了，之前我们在 [多线程设计模式](http://imlgw.top/2019/04/09/java-duo-xian-cheng-li-mian-de-she-ji-mo-shi/#%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F) 中也提到了读写锁，并且实现了一个简易的读写锁。\n\n**读写锁案例**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/26 12:15\n */\npublic class ReadWriteLockTest1 {\n\n    private final static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock(false);\n\n    private final static Lock readLock=readWriteLock.readLock();\n\n    private final static Lock writeLock=readWriteLock.writeLock();\n\n    private  static final List<Long> data=new ArrayList<>();\n\n    public static void main(String[] args) {\n        Thread thread0 = new Thread(() -> write());\n        thread0.start();\n\n        Thread thread1 = new Thread(() -> read());\n        thread1.start();\n\n        Thread thread2 = new Thread(() -> read());\n        thread2.start();\n    }\n\n    public static void write(){\n        try {\n            writeLock.lock();\n            data.add(System.currentTimeMillis());\n            TimeUnit.SECONDS.sleep(5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    public static void read(){\n        try {\n            readLock.lock();\n            data.forEach(System.out::println);\n            TimeUnit.SECONDS.sleep(5);\n            System.out.println(Thread.currentThread().getName()+\" ====\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            readLock.unlock();\n        }\n    }\n}\n```\n\n### 显式锁对比内部锁\n\n显式锁和内部锁都各有优缺点，谁也不能替代谁（这里的显式锁主要指`ReentrantLock`）。\n\n**特性上**\n\n- 显式锁支持公平锁（显式锁，内部锁默认都是非公平的）\n- 显式锁可以`tryLock()`无需等待，内部锁只能一直等待锁释放\n\n- 显式锁有带超时的`tryLock(long timeout,  TimeUnit unit)`。\n- 显式锁可以响应中断请求 `lockInterruptibly()`\n- 显式锁提供了一系列的方法对锁的相关信息监控，内部锁则没有\n- .........\n\n**性能上**\n\n其实很多人会认为`synchronized`性能很差，不如显式锁\n\n- jdk1.5中，在高争用的情况下，确实显式锁要优于内部锁\n- jdk1.5之后， 对内部锁进行了一些优化，包括 **锁消除**，**锁粗化**，**偏向锁**，和**适应性锁** (这些优化后面的文章会再做解释) 。这些优化使得内部锁的性能提升了很多，甚至在低争用情况下性能还要优于 显式锁。\n\n**使用上**\n\n- Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问。\n\n- Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用，而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。\n\n其实很明显内部锁相比显式锁使用起来要简单易用，所以保守一点默认优先使用内部锁，在需要显式锁的特性的时候再选用显式锁。\n\n## Condition\n\nCondition对应的其实就是显式锁的通信方法，`Lock.newCondition()` 返回的就是一个Condition实例 \n\n`Condition`接口的`await()/signal()`  其实就对应了 `synchronize` 的 `wait()/notify()` ，但是相对于 `wait()/notify()`  Condition接口解决了 **过早唤醒**  问题以及 `Object.wait(time)` 无法区分是否是由于等待超时还是被唤醒的问题。\n\n`Object.wait()/notify()`要求执行线程持有所属对象的内部锁，同样`Condition.await()/notify()`也需要线程持有**创建**该Condition的显式锁，`每个Condition`实例内部都维护了一个等待队列，不同的Condition之间不会相互影响，这样一来就解决了过早唤醒的问题，对于生产者消费者问题我们可以分别给消费者和生产者创建一个Condition，生产者通知消费者时候只会唤醒消费者，消费者通知生产者的时候也只会通知生产者。\n\n### 解决过早唤醒\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/26 15:09\n */\npublic class ConditionTest1 {\n\n    private static final ReentrantLock LOCK = new ReentrantLock();\n\n    private static final Condition pCondition = LOCK.newCondition();\n\n    private static final Condition cCondition = LOCK.newCondition();\n\n    private static LinkedList<Long> buffer = new LinkedList<>();\n\n    private static final Integer MAX_BUFFER = 5;\n\n    public static void main(String[] args) {\n        ConditionTest1 conditionTest1 = new ConditionTest1();\n        Stream.of(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\", \"p8\", \"p9\", \"p10\", \"p11\").forEach(name -> {\n            new Thread(() -> conditionTest1.produce(), name).start();\n        });\n\n        Stream.of(\"c1\", \"c2\", \"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"c10\", \"c11\").forEach(name -> {\n            new Thread(() -> conditionTest1.consumer(), name).start();\n        });\n    }\n\n    public void produce() {\n        try {\n            LOCK.lock();\n            while (buffer.size() >= MAX_BUFFER) {\n                pCondition.await();\n            }\n            long l = System.currentTimeMillis();\n            buffer.add(l);\n            System.out.println(Thread.currentThread().getName() + \" produced \" + l + \" ,current buffer size \" + buffer.size());\n            //通知消费者\n            cCondition.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            LOCK.unlock();\n        }\n    }\n\n    public void consumer() {\n        try {\n            LOCK.lock();\n            while (buffer.size() == 0) {\n                cCondition.await();\n            }\n            Long aLong = buffer.removeLast();\n            System.out.println(Thread.currentThread().getName() + \" consumer \" + aLong + \" ,current buffer size \" + buffer.size());\n            //通知生产者\n            pCondition.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            LOCK.unlock();\n        }\n    }\n}\n```\n\n### 解决Object.wait()无法区分其返回原因\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/26 17:48\n */\npublic class ConditionTest2 {\n    private static final Object obj = new Object();\n\n    private static final ReentrantLock LOCK = new ReentrantLock();\n\n    private static final Condition condition = LOCK.newCondition();\n\n    private static boolean isReady = false;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        new Thread(() -> {\n            //3s+\n            Date date = new Date(System.currentTimeMillis() + 3000);\n            try {\n                LOCK.lock();\n                while (!isReady) {\n                    boolean b = condition.awaitUntil(date);\n                    if (!b) {\n                        System.out.println(\"Fucking t0!!!!!, i am timeout\");\n                        return;\n                    }\n                    System.out.println(\"oh i get the lock!!!\");\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                LOCK.unlock();\n            }\n        }, \"t1\").start();\n\n        TimeUnit.SECONDS.sleep(5);\n        \n        new Thread(() -> {\n            try {\n                LOCK.lock();\n                isReady = true;\n                condition.signal();\n            } finally {\n                LOCK.unlock();\n            }\n        }, \"t0\").start();\n    }\n}\n```\n\n可见**awaitUntil()** 是有一个返回值的，返回true则表示在等待时间内获取到了锁，反之则是因为超时.\n\n> 写这个Demo的时候是拿之前的改的，然后有一个地方的notify忘了改成signal，然后一直抛异常。。。因为condition里面也有wait/notify方法所以使用的时候一定要注意不要调错了。\n\n### API\n\n| Modifier and Type | Method and Description                                       |\n| ----------------- | ------------------------------------------------------------ |\n| `void`            | `await()`   使当前线程等待直到发出信号或中断                 |\n| `boolean`         | `await(long time,  TimeUnit unit)`  使当前线程等待直到发出信号或中断，或指定的等待时间过去。 |\n| `long`            | `awaitNanos(long nanosTimeout)`   使当前线程等待直到发出信号或中断，或指定的等待时间过去。 |\n| `void`            | `awaitUninterruptibly()`   使当前线程等待直到发出信号。      |\n| `boolean`         | `awaitUntil(Date deadline)`  使当前线程等待直到发出信号或中断，或者指定的最后期限到达。 |\n| `void`            | `signal()`   唤醒一个等待线程。                              |\n| `void`            | `signalAll()`   唤醒所有等待线程。                           |\n\n## StampedLock\n\n`StampedLock`是`Java8`引入的一种新的锁机制，是对读写锁`ReentrantReadWriteLock`的增强，读写锁虽然分离了读和写的功能，使得读与读之间不互斥，但是读和写之间依然是互斥的，本质上仍然是悲观锁，如果有大量的读线程就会引起写线程的饥饿，而`StampedLock`则提供了一种乐观的读策略,这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会写线程\n\n### 悲观锁策略\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/28 13:47\n */\npublic class StampedLockTest1 {\n    \n    private static final StampedLock stampedLock = new StampedLock();\n\n    private final static List<Long> shareData = new ArrayList<>();\n\n    public static void main(String[] args) {\n        final ExecutorService executorService = Executors.newFixedThreadPool(10);\n        Runnable readRunnable = () -> {\n            while (true) {\n                read();\n            }\n        };\n\n        Runnable writeRunnable = () -> {\n            while (true) {\n                write();\n            }\n        };\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n        executorService.submit(readRunnable);\n\n        executorService.submit(writeRunnable);\n\n    }\n\n    private static void read() {\n        long stamped = -1;\n        try {\n            stamped = stampedLock.readLock();\n            System.out.println(Thread.currentThread().getName() + \" read \" + shareData);\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            stampedLock.unlockRead(stamped);\n        }\n    }\n\n    private static void write() {\n        long stamp = -1;\n        try {\n            stamp = stampedLock.writeLock();\n            shareData.add(System.currentTimeMillis());\n            System.out.println(Thread.currentThread().getName() + \" Write \");\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n    }\n}\n```\n\n其实这种方式就和`ReadWriteLock` 是等价的了。\n\n### 乐观读策略\n\n相对上面的方式，其实就是改变了读的策略\n\n```java\n    private static void read() {\n        long stamp = stampedLock.tryOptimisticRead(); //非阻塞\n        //暂存res\n        String res=Thread.currentThread().getName() + \" read \" + shareData;\n        if (!stampedLock.validate(stamp)) {\n            try {\n                //验证失败,说明有线程进行了写操作,可能造成数据不一致\n                //进行锁升级,获取共享读锁\n                stamp = stampedLock.readLock();\n                //覆盖res\n                res=Thread.currentThread().getName() + \" read \" + shareData;\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        System.out.println(res);\n    }\n```\n\n先尝试获取乐观读锁（非阻塞）返回一个戳，然后进行读操作，缓存读的结果，然后根据前面返回的戳验证在此过程中是否有写线程被占用过，如果被占用过就表示数据可能不一致了，就需要转换成普通的`共享读锁` ，再次读取数据刷新结果，保证数据的一致性，最后释放锁。\n\n这里一开始被视频里面讲的搞懵了他写的是这样的\n\n```java\n    private static void read() {\n        long stamp = stampedLock.tryOptimisticRead(); //非阻塞\n        if (stampedLock.validate(stamp)) {\n            try {\n                stamp = stampedLock.readLock();\n                System.out.println(Thread.currentThread().getName() + \" read \" + shareData);\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n    }\n```\n\n然后就说这样比ReadWriteLock效率高很多，我越看越觉得不对劲，然后自己查了下，看了下官方的Demo发现他写的确实是错的。。。\n\nAPI什么的就不多说了，这里如果想了解更多可以看看[这篇文章](https://segmentfault.com/a/1190000015808032#articleHeader20)\n\n另外如果想看看性能对比的可以看看 [这篇文章](http://ifeve.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/)\n\n> 这里还要存个疑，最后的释放读锁之后到最后一步的时候不是也有可能有写线程进入么，那样不是也会造成数据不一致的情况么？ 因为源码上注释的Demo也是这样写的所以这里还是有点疑问的。\n\n### 需要注意的地方\n\n- 所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；\n- 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；\n\n-  StampedLock是不可重入的 (如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)，所以这就要我们开发人员不要去修改返回的戳或者让它逃逸出去\n-  StampedLock 不支持Condition\n\n## ForkJoin\n\nForkJoin是Java7提供的原生多线程并行处理框架，其基本思想是将大任务分割成小任务，最后将小任务聚合起来得到结果。fork是分解的意思, join是收集的意思. 它非常类似于HADOOP提供的MapReduce框架，只是MapReduce的任务可以针对集群内的所有计算节点，可以充分利用集群的能力完成计算任务。ForkJoin更加类似于单机版的MapReduce。\n\n### RecursiveTask\n\n**计算sum和**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/30 11:58\n */\npublic class RecursiveTest1 {\n\t\n    //这个值代表一个线程可以处理的最大数据，不能太小也不能太大\n    private final static int MAX_THRESHOLD=3;\n\n    public static void main(String[] args) {\n        final ForkJoinPool forkJoinPool=new ForkJoinPool();\n        ForkJoinTask<Integer> submit = forkJoinPool.submit(new CaculateRecursiveTask(0, 100));\n        try {\n            Integer integer = submit.get();\n            System.out.println(integer);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class CaculateRecursiveTask extends RecursiveTask<Integer>{\n\n        private final int start;\n        private final int end;\n\n        private CaculateRecursiveTask(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        protected Integer compute() {\n            if(end-start<=MAX_THRESHOLD){\n                return IntStream.rangeClosed(start,end).sum();\n            }else{\n                int mid=(start+end)/2;\n                CaculateRecursiveTask leftTask=new CaculateRecursiveTask(start,mid);\n                CaculateRecursiveTask rightTask=new CaculateRecursiveTask(mid+1,end);\n                //阻塞\n                leftTask.fork();\n                rightTask.fork();\n                //返回结果\n                return leftTask.join()+rightTask.join();\n            }\n        }\n    }\n}\n```\n\n### RecursiveAction\n\n**计算sum和**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/30 13:08\n */\npublic class RecursiveActionTest1 {\n\n    private final static int MAX_THRESHOLD=3;\n\n    private static AtomicInteger SUM=new AtomicInteger(0);\n\n    public static void main(String[] args) throws InterruptedException {\n        final ForkJoinPool forkJoinPool=new ForkJoinPool();\n        forkJoinPool.submit(new CalculateRecursiveAction(0, 100));\n        TimeUnit.SECONDS.sleep(3);\n        System.out.println(SUM.get());\n    }\n\n    private static class CalculateRecursiveAction extends RecursiveAction{\n\n        private final int start;\n        private final int end;\n\n        private CalculateRecursiveAction(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        protected void compute() {\n\n            if(end-start<=MAX_THRESHOLD){\n                SUM.addAndGet(IntStream.rangeClosed(start,end).sum());\n            }else{\n                int mid=(start+end)/2;\n                CalculateRecursiveAction leftTask=new CalculateRecursiveAction(start,mid);\n                CalculateRecursiveAction rightTask=new CalculateRecursiveAction(mid+1,end);\n                //阻塞\n                leftTask.fork();\n                rightTask.fork();\n            }\n        }\n    }\n}\n```\n\n## Phaser\n\nCountDownLatch和CyclicBarrier都是JDK 1.5引入的，而Phaser是JDK 1.7引入的。Phaser的功能与CountDownLatch和CyclicBarrier有部分重叠，同时也提供了更丰富的语义和更灵活的用法。\n\nPhaser顾名思义，与阶段相关。Phaser比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个CyclicBarrier来实现，每个CyclicBarrier负责等待一个阶段的任务全部完成。但是使用CyclicBarrier的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而Phaser可同时解决这两个问题。\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/30 13:44\n */\npublic class PhaserTest1 {\n    public static void main(String[] args) {\n        final Phaser phaser = new Phaser();\n\n        Stream.of(\"t1\", \"t2\", \"t3\", \"t4\", \"t5\").forEach(name -> new Thread(new Task(phaser), name).start());\n        //注册main线程\n        phaser.register();\n        phaser.arriveAndAwaitAdvance();\n        System.out.println(\"all of work finished\");\n    }\n\n    static class Task implements Runnable {\n        private final Phaser phaser;\n\n        Task(Phaser phaser) {\n            this.phaser = phaser;\n            //动态增加\n            this.phaser.register();\n        }\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" is working\");\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //\n            phaser.arriveAndAwaitAdvance();\n        }\n    }\n}\n```\n\n### API\n\n| Modifier and Type   | Method and Description                                       |\n| ------------------- | ------------------------------------------------------------ |\n| `int`               | `arrive()`   抵达这个移相器，而不用等待别人到达。            |\n| `int`               | `arriveAndAwaitAdvance()`   到达这个移相器，等待其他人。     |\n| `int`               | `arriveAndDeregister()`   到达这个移相器并从其中注销，而无需等待别人到达。 |\n| `int`               | `awaitAdvance(int phase)`   等待该相位器的相位从给定相位值前进，如果当前相位不等于给定相位值，则立即返回，或者该相位器被终止。 |\n| `int`               | `awaitAdvanceInterruptibly(int phase)`   等待该移相器的阶段从给定的相位值推进，如果在等待时 `InterruptedException`则抛出  `InterruptedException` ，或者如果当前相位不等于给定的相位值或者该相位器被终止，则立即返回。 |\n| `int`               | `awaitAdvanceInterruptibly(int phase,  long timeout, TimeUnit unit)`  等待该移相器的阶段从给定的相位值或给定的超时时间  `InterruptedException`到等待时抛出 `InterruptedException`  ，如果当前相位不等于给定的相位值，则立即返回，或者该相位器被终止。 |\n| `int`               | `bulkRegister(int parties)`   增加给定数量的新的有争议的派对到这个移相器。 |\n| `void`              | `forceTermination()`   强制此移相器进入终止状态。            |\n| `int`               | `getArrivedParties()`   返回在此移相器的当前阶段到达的已注册方的数量。 |\n| `Phaser`            | `getParent()`   返回此移相器的父级，如果没有，则返回 `null` 。 |\n| `int`               | `getPhase()`   返回当前相位数。                              |\n| `int`               | `getRegisteredParties()`   返回在此移动设备上注册的各方数量。 |\n| `Phaser`            | `getRoot()`   返回此移相器的根祖先，如果它没有父代，则与该移相器相同。 |\n| `int`               | `getUnarrivedParties()`   返回尚未到达此移相器当前阶段的已注册方的数量。 |\n| `boolean`           | `isTerminated()`   返回 `true`如果移相器已被终止。           |\n| `protected boolean` | `onAdvance(int phase,  int registeredParties)`  在即将进行的相位提前执行动作的可覆盖方法，并控制终止。 |\n| `int`               | `register()`   添加一个新的unririved party到这个移相器。     |\n| `String`            | `toString()`   返回一个标识此移相器的字符串及其状态。        |\n\n## 总结\n\n大致归纳了一些常见的并发工具，当然只是浅显的记录了一下怎样使用，原理部分还没有深入的了解，后续肯定会去研究底层实现源码包括`AQS`和`LockSupport`等等，其实越往后学就越想知道到底层是怎样个过程，到底是如何加锁如何解锁？CAS又起到了什么作用？Synchnorized底层又是如何实现？...学无止境啊. JUC除了这些并发工具外还有**线程池** ，**阻塞队列** 还没介绍，后面会继续介绍。","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"LeetCode滑动窗口","url":"/2019/07/20/leetcode-hua-dong-chuang-kou/","content":"\n## LeetCode 滑动窗口\n\n滑动问题包含一个滑动窗口，它是一个运行在一个大数组上的子列表，该数组是一个底层元素集合。假设有数组 [a b c d e f g h ]，一个大小为 3 的 **滑动窗口** 在其上滑动，则有：\n\n```java\n[a b c]\n  [b c d]\n    [c d e]\n      [d e f]\n        [e f g]\n          [f g h]\n```\n\n一般情况下就是使用这个窗口在数组的 **合法区间** 内进行滑动，同时 **动态地**记录一些有用的数据，很多情况下，能够极大地提高算法地效率。\n\n## [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n给定一个数组 *nums*，有一个大小为 *k* 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 *k* 内的数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口最大值。\n\n**示例:**\n\n```java\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7] \n解释: \n\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**注意：**\n\n你可以假设 *k* 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。\n\n**进阶：**\n\n你能在线性时间复杂度内解决此题吗？\n\n**解法一**\n\n```java\npublic static int[] maxSlidingWindow2(int[] nums, int k) {\n    //题目上说的不为空，还是给我来了个空。。。。\n    if(nums.length==0){\n        return new int[]{};\n    }\n    if(k==1) return nums;\n    LinkedList<Integer> list=new LinkedList<Integer>();\n    int []res=new int[nums.length-k+1];\n    int index=0;\n    list.add(0);\n    for (int i=1;i<nums.length;i++) {\n        while(!list.isEmpty() && nums[list.getLast()]<nums[i]){\n            //小于nums[i]的元素,从右边(尾)出队列 ,控制最左边(头)最大\n            list.removeLast();\n        }\n        //然后将它加到队列中，从右边(尾)\n        list.addLast(i);\n        //如果队列溢出了就从右边移除一个（头）\n        if(i-list.getFirst()==k){\n            list.removeFirst();\n        }\n        if(i>=k-1){\n            res[index++]=nums[list.getFirst()];\n        }\n    }\n    return res;\n}\n```\n\n> 2020.2.9 回头看了下，这不是单调队列么😂（用堆也可以啦，不过既然要在头尾都操作，直接用队列会更方便）\n\n其实开始我也不会做，看了提示后搞了半天才弄出来，23ms，70%左右，思路就是利用一个双端队列(头尾都可以进出)，队列中存**数组下标**，然后遍历数组，在进入队列时从右向左遍历队尾，将**小于当前元素**的队尾元素去除(因为已经没用了，后面的最大值不可能是它们)，举个例子\n\n> [2，1，-1，3，......]  k=3 ，当读到**3**这个元素的时候，窗口再向右移动最大值肯定不会是右边的元素了，所以直接剔除他们，在纸上画一画就明白了\n\n然后很关键的一步就是什么时候移除最左边的元素，其实按照人的思路来想就是最左边的元素不在窗口内的时候，比如上面的例子，读到**3**的时候，**2**其实就应该剔除了因为它已经不在窗口内了。用代码来描述就是\n\n`i-list.getFirst()==k`，i代表**当前元素下标**，上面的例子**3**对应的**i**就是**3**，**list.getFirst()=0**，刚好差为k，就代表**2**已经超出窗口了应该移除了。\n\n其实这里我开始不是这样做的，我在队列里面存的不是元素索引，我存的是元素，然后在判断什么时候移除的时候发现判断不了，**index**也只是结果元素的下标，并不能代表队列最左元素的下标，对于数组存下标优先于存元素，多一个已知量有时候还是很方便的\n\n**解法二**\n\n属于对暴力法的优化吧，最坏情况下时间复杂度`O(NK)`，比如完全逆序的情况（2020.2.9回顾fix）\n\n```java\npublic static int[] maxSlidingWindow3(int[] nums, int k) {\n    //题目上说的不为空，还是给我来了个空。。。。\n    int len = nums.length;\n    if (len == 0) return new int[]{};\n    if (len == 1) return new int[]{nums[0]};\n    int localMax = Integer.MIN_VALUE;\n    int[] result = new int[len - k + 1];\n    for (int i = 0; i < k; i++) {\n        //找到第一个窗口的最大值\n        localMax = max(nums[i], localMax);\n    }\n    result[0] = localMax;\n    for (int i = 1; i < len - k + 1; i++) {\n        //窗口的下一个元素 k=3 , i=1 下一个元素下标为 3\n        if (nums[i + k - 1] > localMax) {\n            //判断当前窗口最大值和下一个元素的大小\n            //如果比当前窗口的最大值还要大 就不用找了 就是它了\n            localMax = nums[i + k - 1];\n        } else if (nums[i - 1] == localMax) {\n            //下一个元素比当前窗口最大值小 而且很不巧\n            //当前最大值刚好是当前窗口的最左边的元素，也就是马上要超过窗口的元素\n            localMax = nums[i];\n            //所以就要重新找最大值\n            for (int x = i; x < i + k; x++) {\n                localMax = max(nums[x], localMax);\n            }\n        }\n        //剩下的请况就是 比当前最大值小，并且最大值不是最左边的元素(还没有出界)，最大值不变\n        //copy到结果中\n        result[i] = localMax;\n    }\n    return result;\n}\n\n//其实可以用Math.max()\npublic static int max(int a,int b){\n    if(a>=b)return a;\n    return b;\n}\n```\n\n2ms，99%  提交记录这种做法是最快的😂，时间复杂度最坏应该是`O(NK)`\n\n## [5312. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/) \n\n给你一个整数数组 `arr` 和两个整数 `k` 和 `threshold` 。\n\n请你返回长度为 `k` 且平均值大于等于 `threshold` 的子数组数目。\n\n **示例 1：**\n\n```java\n输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n输出：3\n解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。\n```\n\n\n**示例 2：**\n\n```java\n输入：arr = [1,1,1,1,1], k = 1, threshold = 0\n输出：5\n```\n\n\n**示例 3：**\n\n```java\n输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n输出：6\n解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n```\n\n\n**示例 4：**\n\n```java\n输入：arr = [7,7,7,7,7,7,7], k = 7, threshold = 7\n输出：1\n```\n\n\n**示例 5：**\n\n```java\n输入：arr = [4,4,4,4], k = 4, threshold = 1\n输出：1\n```\n\n**提示：**\n\n- `1 <= arr.length <= 10^5`\n- `1 <= arr[i] <= 10^4`\n- `1 <= k <= arr.length`\n- `0 <= threshold <= 10^4`\n\n**解法一**\n\n19双周赛的第2题，很简单的滑动窗口，枚举所有窗口计数就行了\n\n```java\npublic int numOfSubarrays(int[] arr, int k, int threshold) {\n    threshold*=k;\n    int sum=0;\n    int count=0;\n    for (int i=0;i<k;i++) {\n        sum+=arr[i];\n    }\n    for (int i=k;i<arr.length;i++) {\n        if (sum>=threshold) {\n            count++;\n        }\n        //0 1 2 3\n        sum+=arr[i];\n        sum-=arr[i-k];\n    }\n    return count;\n}\n```\n\n## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例 1:**\n\n```java\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```java\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```java\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**解法一**\n\n这题其实很久以前(半年前)做过一次，当时用的方法很low😂\n\n![mark](http://static.imlgw.top///20190503/zQ9MBrOhQm4S.png?imageslim)\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n    char [] chars = s.toCharArray();\n    if (chars.length == 0) {\n        return 0;\n    }\n    int length = 1;\n    String temp=new String();\n    for (int i = 0; i <s.length()-1; i++) {\n        if(chars[i] != chars[i+1]) {\n            temp=s.substring(i, i+2);\n        } else continue;\n        for (int j = i+2; j < s.length(); j++) {\n            if (!temp.contains(chars[j]+\"\")) {\n                temp = s.substring(i, j+1);\n            } else break;\n        }\n        //Break出来后判断是否是最长的k\n        length=temp.length()>length?temp.length():length;\n    }\n    return length;\n}\n```\n\n我这种完全就是利用api暴力法，居然还跑过了，时间复杂度应该是O(N3)，这题的ac率还是挺低的只有 29.3%\n\n**解法二**\n\n下面的是我下午重新做的\n\n```java\npublic static int lengthOfLongestSubstring4(String s) {\n    //边界问题永远不能忽略\n    //LinkedList<Integer> list=new LinkedList<>();\n    int length=s.length();\n    if(length==0) return 0;\n    int head=0,tail=0;\n    int max=1;\n    for (int i=1;i<length;i++) {\n        int index=i-1; //当前元素前一个元素下标\n        while(index>=head){\n            if(s.charAt(i)!=s.charAt(index)){\n                index--;\n            }else{\n                //按思路应该是把相等前所有元素移除，但是那样效率好低，所以这里我决定用数组模拟队列\n                head=index+1;\n                tail++;\n                break;\n            }\n            //从尾遍历到头仍然没有相等，可以添加到队列中\n            if(index==head-1){\n                tail++;\n                break;\n            }\n        }\n        //每次结束循环后 尾index-头index\n        max=tail-head+1 > max?tail-head+1:max;\n        //System.out.println(max);\n    }\n    return max;\n}\n```\n\n20ms左右80%左右，思路也比较清晰，遍历字符串，然后从后往前遍历字符串，判断当前字符串在前面有没有，有的话就将前面相等那个元素(index)前的元素都移除（窗口右移）\n\neg: `[head...index....tail] i`  向右移动`....index [head ... i]`\n\n把当前元素添加进来，时间复杂度是O(N^2)，比上面单纯的暴力法要快多了，但是并不是最优解\n\n**解法三**\n\n上面的算法，其实还可以优化，每次判断前面有没有重复元素的时候可以直接用一个大小256的扩展ASCII码表数组来判断（前提是这些字符都在标准的ASCII字符中），`freq[s.charAt(i)]` 代表的就是s.charAt(i)这个字符在窗口内出现过没有，出现过就为1，否则就是0，这里如果ASCII不够其实也可以用HashMap，查找效率也很高接近O(1)\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n    int length=s.length();\n    if(length==0) return 0;\n    int[] freq=new int[256]; //ASCII码表\n    freq[s.charAt(0)]=1;\n    int head=0,tail=0;\n    int max=1;\n    while(head<length){\n        if(tail+1<length&&freq[s.charAt(tail+1)]==0){\n            //没有重复，右边界右移\n            tail++;\n            freq[s.charAt(tail)]++;\n        }else{\n            //逐渐缩减左边界，直到不再有重复元素\n            freq[s.charAt(head)]--;\n            head++;\n        }\n        max=max<tail-head+1?tail-head+1:max;\n    }\n    return max;\n}\n```\n这种做法最坏情况（没有重复的字符）下其实会遍历两遍数组tail先移动到尾部head随后有移动到尾部，但是比较好理解，解法四实际上就是对这里的优化，head每次移动都是直接移动到上一个重复元素的位置，而不是一个一个的向右移\n\n**解法四**\n\n提交记录上最快的方法，理解起来有点费劲，现在回头看又看不懂了。。。\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n    int n = s.length(), ans = 0;\n    //索引为元素值，这里因为元素都是字符转过来就是askll码，所以可以直接这样\n    int[] index = new int[128];\n    for (int j = 0, i = 0; j < n; j++) {\n        //如果字符 char 在没有出现过，index[char]为0，出现则index[char]是遍历出现的最后的char的位置\n        // index[s.charAt(j)] 是当前字符上一次出现的位置(从1开始)\n        i = Math.max(i,index[s.charAt(j)]);\n        //j - i + 1 就是舍弃s.charAt(j)重复出现之前字符的长度  如abca,当s.charAt(j) == a时，j - i + 1就是bca的长度\n        //求最大值常规操作\n        ans = Math.max(ans, j - i + 1);\n        index[s.charAt(j)] = j + 1;\n        // 从1开始\n    }\n    return ans;\n}\n```\n\n这里最主要就是这个**i**的理解\n\n![mark](http://static.imlgw.top///20190503/Qcj2l3E0v5sN.png?imageslim)\n\n这个i不一定是当前元素上一次出现的位置，也有可能是离**当前**元素从右向左**最近**的**重复字符**的_位置_。而index中存的就是这个元素的索引位置+1，为什么要加1？\n\n![mark](http://static.imlgw.top///20190503/N4GzYaft0suh.png?imageslim)\n\n主要是因为i的默认值是0而数组默认值也是0，如果以0开始就会出现上面的情况。\n\n其实这两种算法也比较类似，只是后面判断字符是否出现过的方式不同，前者是直接遍历这个子串，后者是利用字符为索引，其值就是上一次出现的位置(+1)，借此来计算长度。\n\n**回首掏**\n\n19/9/14，在网页上又写了一种不同的解法，属于解法4的变体（做的时候并没有想到解法4），`freq[]` 数组索引是字符串，但是值是该字符在s中对应的索引，不会遍历两遍数组，left可以通过索引直接跳到上一次出现的位置\n\n```java\npublic static int lengthOfLongestSubstring6(String s) {\n    if(s==null||s.length()<1) return 0;\n    if(s.length()==1) return 1;\n    int[] freq=new int[256];\n    int left=0,right=0,res=0;\n    Arrays.fill(freq,-1);\n    while(right<s.length()){\n        char sr=s.charAt(right);\n        //已经存在,并且在窗口内\n        if(freq[sr]!=-1 && freq[sr]>=left){\n            //System.out.println(left+\",\"+right+\",\"+freq[sr]);\n            res=Math.max(res,right-left);\n            left=freq[sr]+1;\n            freq[sr]=right;\n        }else{\n            res=Math.max(res,right-left+1);\n            freq[sr]=right;\n        }\n        right++;\n    }\n    return res;\n}\n```\n**回首掏2**\n\n```java\npublic static int lengthOfLongestSubstring7(String s) {\n    if(s==null||s.length()<1) return 0;\n    if(s.length()==1) return 1;\n    int[] freq=new int[256];\n    int left=0,right=0,res=0;\n    //Arrays.fill(freq,-1);\n    while(right<s.length()){\n        char sr=s.charAt(right);\n        //已经存在(出现过),并且上一次出现在窗口内\n        if(freq[sr]!=0 && freq[sr]>=left){\n            //这里不包含right,所以不用加1\n            res=Math.max(res,right-left);\n            //left移动到重复位置元素的下一个\n            //因为freq的值是存的索引+1所以这里不用+1\n            left=freq[sr];\n        }else{\n            //这里包含right所以需要加1\n            res=Math.max(res,right-left+1);\n        }\n        //加1是为了区别s的第一个字符\n        freq[sr]=right+1;\n        right++;\n    }\n    return res;\n}\n```\n感觉对这题有很深的执念😅，对上面右优化了一下，但是其实还是上面的解法三比较简单，说到解法三，我又抽风改了一个boolean数组版本的\n\n```java\n//update: 2020.4.13 重写了一遍，代码更简洁了\npublic int lengthOfLongestSubstring(String s) {\n    if(s==null ||s.length()<=0) return 0;\n    boolean[] freq=new boolean[128];\n    int left=0,right=0;\n    int max=0;\n    while(left<=right && right<s.length()){\n        if(!freq[s.charAt(right)]){\n            max=Math.max(max,right-left+1);\n            freq[s.charAt(right++)]=true;\n        }else{\n            freq[s.charAt(left++)]=false;\n        }\n    }\n    return max;\n}\n```\n**_以上解法全部作废_**\n\n统一使用`for-while`结构，能用`for-if`的一定可以用`for-while`，反过来就不行\n\n```java\n//2020.5.5根据自己总结的滑窗模板重写\npublic int lengthOfLongestSubstring(String s) {\n    if(s==null || s.length()<=0) {\n        return 0;\n    }\n    int n=s.length();\n    int left=0;\n    int res=1;\n    boolean[] freq=new boolean[128];\n    for(int right=0;right<n;right++){\n        while(freq[s.charAt(right)]){\n            freq[s.charAt(left++)]=false; //left不用限制\n        }\n        freq[s.charAt(right)]=true;\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n**最优解**\n\nmap记录元素最后出现的位置，当重复的时候更新起点，只用遍历一遍\n```go\nfunc lengthOfLongestSubstring(s string) int {\n    if len(s)==0{\n        return 0\n    }\n    m:=make(map[rune]int)\n    start:=0\n    res:=0\n    for i,ch:=range s{\n        if idx,ok:=m[ch];ok && idx+1>start{\n            start=idx+1\n        }\n        m[ch]=i\n        res=Max(res,i-start+1)\n    }\n    return res\n}\n\nfunc Max(a,b int) int{\n    if a>b{\n        return a\n    }\n    return b\n}\n```\n\n## [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)\n\n给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的绝对值最大(不超过)为 *k*。\n\n**示例 1:**\n\n```java\n输入: nums = [1,2,3,1], k = 3\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入: nums = [1,0,1,1], k = 1\n输出: true\n```\n\n**示例 3:**\n\n```java\n输入: nums = [1,2,3,1,2,3], k = 2\n输出: false\n```\n\n**解法一**\n\n这题建议区看看原版的英文题，这里翻译过来有点误导人，应该是不超过k，写个最大搞得我有点懵\n\n```java\npublic static Boolean containsNearbyDuplicate2(int[] nums, int k) {\n    int len=nums.length;\n    //if(k==35000) return false; 哈哈哈哈\n    if(len==0||k==0)return false;\n    for (int i=1;i<len;i++) {\n        int index=i-1;\n        while(i-index<=k){\n            //k步之内\n            if(index<0){\n                break;\n            }\n            if(nums[i]==nums[index--]){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n暴力法，惨不忍睹，600ms，15%beats 。这题最好的做法还是借助hash表\n\n**解法二**\n\n```java\npublic static Boolean containsNearbyDuplicate3(int[] nums, int k) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    int len=nums.length;\n    if(len==0||k==0) return false;\n    for (int i=0;i<len;i++) {\n        if(map.containsKey(nums[i])){\n            int index=map.get(nums[i]);\n            if(i-index<=k) {\n                return true;\n            } else {\n                //大于k了那前面那个没用了\n                map.replace(nums[i],i);\n            }\n        } else {\n            map.put(nums[i],i);\n        }\n    }\n    return false;\n}\n```\n\n12ms，90%，其实效率的差距就在查找子串里有没有这个字符上，HashMap的containsKey的效率比我们遍历的不知道高到那里去了，底层源码暂时还看不太懂，以后看的时候再专门来讲\n\n19.9.14又做了一遍，直接在网页上写的，本来应该是bugfree的，结果减反了。。。\n\n```java\npublic static boolean containsNearbyDuplicate4(int[] nums, int k) {\n\tHashMap<Integer,Integer> hashMap=new HashMap<>();\n\tint left=0,right=0;\n\twhile(right<nums.length){\n\t\tif(hashMap.containsKey(nums[right])){\n\t\t\t//md,重新做的时候这里减反了真是个zz\n\t\t\tif(right-hashMap.get(nums[right])<=k){\n\t\t\t\treturn true;\n\t\t\t} else{\n\t\t\t\thashMap.put(nums[right],right);\n\t\t\t}\n\t\t}else{\n\t\t\thashMap.put(nums[right],right);\n\t\t}\n\t\tright++;\n\t}\n\treturn false;\n}\n```\n19.9.15又做了一遍，这次代码写的很简洁，思路也不同了，直接利用set集合，维护一个大小为k的连续set(窗口)\n\n```java\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashSet<Integer> set=new HashSet<>();\n    for (int i=0;i<nums.length;i++) {\n        if (!set.add(nums[i])) {\n            return true;\n        }\n        if (set.size()>k) {\n            set.remove(nums[i-k]);\n        }\n    }\n    return false;\n}\n```\n\n## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)\n\n给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0。\n\n**示例:** \n\n```java\n输入: s = 7, nums = [2,3,1,2,4,3]\n输出: 2\n解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。\n```\n\n**进阶:**\n\n如果你已经完成了*O*(*n*) 时间复杂度的解法, 请尝试 *O*(*n* log *n*) 时间复杂度的解法。\n\n**解法一**\n\n老规矩先上个慢的\n\n```java\npublic static int minSubArrayLen(int s, int[] nums) {\n    int len=nums.length;\n    if(len==0)return 0;\n    int minLen=Integer.MAX_VALUE;\n    for (int i=1;i<len;i++){\n        if(nums[i-1]>=s) return 1;\n        int index=i-1;\n        int sum=nums[i];\n        //累加前面的元素，直到大于s或者index<0\n        while(sum<s&&index>=0){\n            sum+=nums[index--];\n        }\n        if(sum>=s){\n            minLen=minLen>i-index?i-index:minLen;\n        } else if(i==len-1){\n            return 0;\n        }\n    }\n    return minLen;\n}\n```\n\n这个是最开始想到了思路比较清晰，遍历数组然后逆序求和直到大于S，要注意边界，比较慢，主要就是那个循环累加前面的元素会很耗费时间，111ms，14% beats🤣\n\n**解法二**\n\n```java\npublic static int minSubArrayLen2(int s, int[] nums) {\n    int len =nums.length;\n    if(len==0)return 0;\n    //窗口左右边界\n    int head=0,tail=-1;\n    int minLen=Integer.MAX_VALUE;\n    int sum=0;\n    // 2,3,1,2,4,3 | 7\n    while (tail<len) {\n        if(sum>=s){\n            minLen=minLen>tail-head+1?tail-head+1:minLen;\n            //System.out.println(minLen);\n            //删除头节点（左边界左移）\n            sum-=nums[head++];\n        } else{\n            //尾指针到达边界了\n            if(tail==len-1) break;\n            //尾节点++，(右边界右移)\n            sum+=nums[++tail];\n            //如果有元素大于s直接返回，节约时间\n            if(nums[tail]>=s){\n                return 1;\n            }\n        }\n    }\n    return minLen==Integer.MAX_VALUE?0:minLen;\n}\n```\n\n2ms ，99%beats，一对比差距就出来了，上面这种做法就是利用了滑动窗口的思想，很巧妙的利用了上一次计算的值，不用重复的计算累加和，上面的那种方法每次都会重新计算累加和，但是很多都是重复的计算，所以浪费了很多时间，要注意边界条件\n\n`2 3 1 2 4 3  s=7`\n\n![mark](http://static.imlgw.top///20190504/U9BTOJMRVhDO.jpg?imageslim)\n\n自己在纸上画一下就懂了\n\n**解法三**\n\n~~找到一个模板，统一一下写法~~\n\n```java\npublic static int minSubArrayLen3(int s, int[] nums) {\n    int len =nums.length-1;\n    if(len==0)return 0;\n    int head=0,tail=-1;\n    int minLen=Integer.MAX_VALUE;\n    int sum=0;\n    // 2,3,1,2,4,3 | 7\n    while (head<=len) {\n        if(tail+1<=len && sum<s){\n            sum+=nums[++tail];\n        }else{\n            sum-=nums[head++];\n        }\n        if(sum>=s){\n            minLen=minLen>tail-head+1?tail-head+1:minLen;\n        }\n    }\n    return minLen==Integer.MAX_VALUE?0:minLen;\n}\n```\n\n**Update(2020.5.4)**\n\n上面的这也配叫模板？下面的是重做的时候统一的写法\n\n```go\nvar INF = 1 << 31\n\nfunc minSubArrayLen(s int, nums []int) int {\n    left := 0\n    sum := 0\n    res := INF\n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        for sum >= s {\n            res = Min(res, right-left+1)\n            sum -= nums[left]\n            left++\n        }\n    }\n    if res == INF {\n        return 0\n    }\n    return res\n}\n\nfunc Min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\n## [面试题57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) \n\n输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n**示例 1：**\n\n```java\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n```\n\n\n**示例 2：**\n\n```java\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n```\n\n**限制：**\n\n- `1 <= target <= 10^5`\n\n**解法一**\n\n滑动窗口，根据等差数列前n项和求sum，然后逐步的缩圈，右移\n\n```java\npublic int[][] findContinuousSequence(int target) {\n    List<int[]> res=new ArrayList<>();\n    int left=1,right=2;\n    int sum=0;\n    //9 right最多到5\n    while(left<=right && right<=(target+1)/2){\n        //等差数列前n项和\n        int n=right-left+1;\n        sum=left*n+n*(n-1)/2;\n        if(sum>target){\n            left++; //剔除一个小的\n        }else if(sum<target){\n            right++; //添加一个大的\n        }else{ //build结果集\n            res.add(build(left,right));\n            left++;//窗口左移,剔除一个小的\n            right++; //回头重写发现这里还可以优化,右边界也可以扩大\n        }\n    }\n    return res.toArray(new int[0][0]);\n}\n\npublic int[] build(int left,int right){\n    int[] res=new int[right-left+1];\n    for(int i=left;i<=right;i++){\n        res[i-left]=i;\n    }\n    return res;\n}\n```\n这里其实并不是最优解，还有更好的数学解法，直接根据求和公式，枚举所有的长度，逆向求出所有的首项，这里后面有时间再来实现\n\n## [480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)\n\n中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。\n\n例如：\n\n```java\n[2,3,4]，中位数是 3\n[2,3]，中位数是 (2 + 3) / 2 = 2.5\n```\n\n给出一个数组 nums，有一个大小为 *k* 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。\n\n例如：\n\n给出 *nums* = `[1,3,-1,-3,5,3,6,7]`，以及 *k* = 3。\n\n```java\n窗口位置                      中位数\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n```\n\n 因此，返回该滑动窗口的中位数数组 `[1,-1,-1,3,5,6]`。\n\n**提示：**\n假设`k`是合法的，即：`k` 始终小于输入的非空数组的元素个数.\n\nhead题，理清楚思路后也不难。\n\n```java\npublic static double[] medianSlidingWindow(int[] nums, int k) {\n    //看了一圈评论区，大概知道思路了，还是要排序\n    //List<Integer> list=new ArrayList<>(); 用链表还是不方便啊\n    int [] queue=new int[k];\n    int head=0,tail=k-1;\n    //头尾\n    double [] res=new double[nums.length-k+1];\n    for (int i=0;i<k;i++) {\n        queue[i]=nums[i];\n    }\n    Arrays.sort(queue);\n    printArray(queue);\n    if (k%2==0) {\n        res[0]=queue[(k-1)/2]/2.0+queue[(k-1)/2+1]/2.0;\n        //注意除小数 .。。。。这里的测试用例Integer最大值，直接相加/2会越界\n    } else {\n        res[0]=queue[k/2];\n    }\n    for (int i=k;i<nums.length;i++) {\n        //插入之前要移除上一次的头元素，这里用数组不好搞啊啊\n        //System.out.println(nums[i-k]);\n        deleHead(queue,nums[i-k]);\n        tail--;\n        //printArray(queue);\n        //二分找插入点\n        int index=binarySearch(queue,0,tail,nums[i]);\n        System.out.println(index);\n        tail++;\n        //插入元素，tail++;\n        for (int j=tail;j>index;j--) {\n            //后一个等于前一个，给插入的元素腾出位置\n            queue[j]=queue[j-1];\n        }\n        queue[index]=nums[i];\n        //求中点\n        if (k%2==0) {\n            res[i-k+1]=queue[head+(tail-head)/2]/2.0+queue[head+(tail-head)/2+1]/2.0;\n        } else {\n            res[i-k+1]=queue[head+(tail-head)/2];\n        }\n    }\n    return res;\n}\n\npublic static void deleHead(int []nums,int target){\n    for (int j=0,i=0;j<nums.length;j++,i++) {\n        if(nums[j]==target){\n            if (i==nums.length-1) {\n                return;\n            }\n            while(i<nums.length-1){\n                nums[i]=nums[i+1];\n                i++;\n            }\n            return;\n        }\n    }\n}\n\npublic  static int binarySearch(int []nums,int lo,int hi,int target){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(nums[mid]<target){\n            lo=mid+1;\n        } else if(nums[mid]>target){\n            hi=mid-1;\n        } else{\n            return mid;\n        }\n    }\n    return lo;\n}\n```\n\n根据评论区提供的思路，用数组实现了一遍，当时就感觉有问题，确实，最后 164ms ，27%，很慢了，我觉得主要问题就是那个删除头的操作，但是毕竟数组，没办法，随即改用链表\n\n```java\npublic static double[] medianSlidingWindow2(int[] nums, int k) {\n    //看了一圈评论区，大概知道思路了，还是要排序\n    List<Integer> list=new ArrayList<>();\n    int head=0,tail=k-1;\n    //头尾\n    double [] res=new double[nums.length-k+1];\n    //Arrays.sort(nums,0,k);\n    int []temp=new int[k];\n    for (int i=0;i<k;i++) {\n        temp[i]=nums[i];\n    }\n    Arrays.sort(temp);\n    for (int i=0;i<k;i++) {\n        list.add(temp[i]);\n    }\n    if (k%2==0) {\n        res[0]=list.get((k-1)/2)/2.0+list.get((k-1)/2+1)/2.0;\n    } else {\n        res[0]=list.get(k/2);\n    }\n    for (int i=k;i<nums.length;i++) {\n        //插入之前要移除上一次的头元素，这里用数组不好搞啊啊\n        //list.remove((Object)nums[i-k]); 直接删太慢了\n        int dele=binarySearch(list,0,k-1,nums[i-k]);\n        list.remove(dele);\n        //System.out.println(list);\n        //二分找插入点，找的区间为 [i-k+1, i-1]\n        //int head=i-k+1,tail=i-1;\n        int index=binarySearch(list,0,k-2,nums[i]);\n        System.out.println(index);\n        list.add(-1);\n        for (int j=k-1;j>index;j--) {\n            //后一个等于前一个，给插入的元素腾出位置\n            list.set(j,list.get(j-1));\n        }\n        list.set(index,nums[i]);\n        System.out.println(list);\n        //求中点\n        if (k%2==0) {\n            res[i-k+1]=list.get((k-1)/2) / 2.0 + list.get((k-1)/2+1)/2.0;\n        } else {\n            res[i-k+1]=list.get(k/2);\n        }\n    }\n    return res;\n}\npublic  static int binarySearch(List<Integer> list,int lo,int hi,int target){\n    while(lo<=hi){\n        int mid=lo+(hi-lo)/2;\n        if(list.get(mid)<target){\n            lo=mid+1;\n        } else if(list.get(mid)>target){\n            hi=mid-1;\n        } else{\n            return mid;\n        }\n    }\n    return lo;\n}\n```\n\n47ms，70%左右，删除的时候利用二分删除，如果直接根据元素去删就跟数组效率差不多了。\n\n## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n\n给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。\n\n**示例：**\n\n```java\n输入: S = \"ADOBECODEBANC\", T = \"ABC\"\n输出: \"BANC\"\n```\n\n**说明：**\n\n- 如果 S 中不存这样的子串，则返回空字符串 \"\"。\n- 如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\n**解法一**\n\n```java\npublic static String minWindow(String s, String t) {\n    int slen=s.length();\n    int tlen=t.length();\n    int l=0,r=0; //初始都为0\n    int[] target=new int[256]; //A:1 B:1 C:1\n    int[] window=new int[256];\n    int count=0; //不同字符的数量\n    for (int i=0;i<tlen;i++) {\n        target[t.charAt(i)]++;\n    }\n    for (int a:target) {\n        if (a!=0) {\n            count++; //统计不同字符出现的次数\n        }\n    }\n    int match=0; //match代表已经匹配的字符\n    int[] res=new int[]{0,Integer.MAX_VALUE};\n    while(r<slen){\n        char c=s.charAt(r); \n        if(target[c]!=0){ //在目标子串中存在\n            window[c]++; //window对应的char++\n            if(window[c]==target[c]){ //到达了目标串中该char所需的数量\n                match++;\n            }\n        }\n        r++;\n        while(l<r&&count==match) { //满足目标串，注意别越界\n            char d=s.charAt(l);\n            if (r-l<res[1]-res[0]) { //统计最小值\n                res[0]=l;\n                res[1]=r;\n            }\n            l++;\n            if (target[d]!=0) {\n                window[d]--;\n                if (window[d]<target[d]) {//左边界左移后不再满足目标串\n                    match--;\n                }\n            }\n        }\n    }\n    return res[1]==Integer.MAX_VALUE?\"\":s.substring(res[0],res[1]);\n}\n```\n10ms 86%，Hard题，其实大致的思路还是有的，主要是不知道怎么去和目标串对比，没想到用一个`window`数组去对比，一致想的是在目标串的数组上做手脚，但是越想越复杂。。。太蠢了😅，这题其实也可以用一个HashMap来做，但是我看了下提交记录上的普遍都是7,80ms，相对都比较慢，实际上题目没有明确的说明有特殊字符的话都是可以用一个**ASCII**数组来充当HashMap的，当然我这里用数组的时候相比HashMap要多了一步，需要统计不同字符出现的次数，不过这个操作也是常数级别的操作，并不耗时，整体时间复杂度O(N+M)，NM分别代表目标子串`t` 和源字符串 `p`的长度，首先遍历了`t` 然后滑动窗口，后面的滑动窗口左右边界最多移动2M次\n\n**Update**\n\n2020.4.15，在瞄了一眼之前做的之后按照之前的思路重写了一遍，感觉还行，有一个地方WA了一次\n\n```java\n//update: 2020.4.15\npublic String minWindow(String s, String t) {\n    if(s==null || t==null) return \"\";\n    int[] needMap=new int[128]; //需要的字符map\n    int[] curMap=new int[128];  //已经匹配的字符map\n    int needCount=0; //需要匹配的字符个数\n    for(int i=0;i<t.length();i++){\n        if(needMap[t.charAt(i)]==0){\n            needCount++;\n        }\n        needMap[t.charAt(i)]++;\n    }\n    int matchCount=0; //已经匹配的个数\n    int left=0,right=0;\n    int minLeft=0,maxRight=Integer.MAX_VALUE;\n    while(left<=right && right<s.length()){\n        char c=s.charAt(right);\n        if(needMap[c]!=0){\n            curMap[c]++;\n            if(curMap[c]==needMap[c]){\n                matchCount++;\n            }\n        }\n        while(left<=right && right<s.length() && matchCount==needCount){\n            if(right-left<maxRight-minLeft){\n                maxRight=right;\n                minLeft=left;\n            }\n            char cl=s.charAt(left);\n            if(curMap[cl]!=0){\n                curMap[cl]--;\n                //这里注意，WA点，开始写的=0\n                if(curMap[cl]<needMap[cl]){\n                    matchCount--;\n                }\n            }\n            left++;\n        }\n        right++;\n    }\n    return Integer.MAX_VALUE==maxRight?\"\":s.substring(minLeft,maxRight+1);\n}\n```\n> 刷题的时候发现有一道很类似的题，[最小窗口子序列](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#857-%E6%9C%80%E5%B0%8F%E7%9A%84%E7%AA%97%E5%8F%A3%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LintCode%EF%BC%89)唯一的区别就是这道题要求有序（子序列）\n\n## [632. 最小区间](https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/)\n\nDifficulty: **困难**\n\n\n你有 `k` 个升序排列的整数数组。找到一个**最小**区间，使得 `k` 个列表中的每个列表至少有一个数包含在其中。\n\n我们定义如果 `b-a < d-c` 或者在 `b-a == d-c` 时 `a < c`，则区间 [a,b] 比 [c,d] 小。\n\n**示例 1:**\n\n```java\n输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n输出: [20,24]\n解释: \n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n```\n\n**注意:**\n\n1.  给定的列表可能包含重复元素，所以在这里升序表示 >= 。\n2.  1 <= `k` <= 3500\n3.  -10<sup>5</sup> <= `元素的值` <= 10<sup>5</sup>\n\n\n**解法一**\n\n```golang\nfunc smallestRange(nums [][]int) []int {\n    var n = len(nums)\n    //列表中所有元素k,存在于那些数组中\n    var m = make(map[int][]int)\n    var Max = func (a, b int) int {if a > b {return a}; return b}\n    var Min = func (a, b int) int {if a < b {return a}; return b}\n    //记录最大最小值，然后在区间内滑窗，也可以直接将所有数组归并排一下，然后滑窗，比较麻烦，懒得写了\n    //所以下面的做法实际上是和循序无关的，没有用到有序这个条件\n    var maxV = math.MinInt32\n    var minV = math.MaxInt32\n    for i :=0; i < n; i++ {\n        for j := 0; j < len(nums[i]); j++ {\n            m[nums[i][j]] = append(m[nums[i][j]], i)\n            maxV = Max(maxV, nums[i][j])\n            minV = Min(minV, nums[i][j])\n        }\n    }\n    //同 76.最小覆盖子串，这题可能思维的转换比较重要\n    var count = 0\n    var freq = make([]int, n+1)\n    var res =[]int{minV, maxV}\n    var left = minV\n    for right := minV; right <= maxV; right++ {\n        if lis, ok := m[right]; ok {\n            for _, numIdx := range lis {\n                freq[numIdx]++\n                if freq[numIdx] == 1{\n                    count++\n                }\n            }\n        }\n        for count == n && left <= right {\n            if right-left < res[1]-res[0] {\n                res[0] = left\n                res[1] = right\n            }\n            if lis, ok := m[left]; ok{\n                for _, numIdx := range lis {\n                    freq[numIdx]--\n                    if freq[numIdx] < 1 {\n                        count--\n                    }\n                }\n            }\n            left++\n        }\n    }\n    return res\n}\n```\n**解法二**\n\n上面的解法并不是最好的解法，没有用到有序的条件，比较好的解法应该是小根堆（本来打算用Go撸一个的，写一半感觉太麻烦了，不过整体小根堆的逻辑实现是对的，就是没有泛型要改很多东西，不太方便）\n![](https://i.loli.net/2020/11/30/Q5KsxNi3MquZtWE.png)\n维护两个最值，一个是找到一个能覆盖当前所有列表的最小的右端点（max），一个是当前列表最小的那个元素（最左的端点），然后不断缩减左端点求最小区间\n```java\nclass Node {\n    int i, j;\n    public Node (int i, int j) {\n        this.i = i;\n        this.j = j;\n    }\n}\n\n//k组链表，平均m个元素，时间复杂度 O(kmlog(k))\npublic int[] smallestRange(List<List<Integer>> nums) {\n    PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> nums.get(a.i).get(a.j)-nums.get(b.i).get(b.j));\n    int INF = (int) 1e5+1;\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.size(); i++) {\n        pq.add(new Node(i, 0));\n        max = Math.max(max, nums.get(i).get(0));\n    }\n    int [] res = {-INF, INF};\n    while (true) {\n        Node cur = pq.poll();\n        //应该把val也存进去的，懒得改了\n        if (max-nums.get(cur.i).get(cur.j) < res[1]-res[0]) {\n            res[0] = nums.get(cur.i).get(cur.j);\n            res[1] = max;\n        }\n        if (cur.j+1 >= nums.get(cur.i).size()) {\n            break;\n        }\n        pq.add(new Node(cur.i, cur.j+1));\n        max = Math.max(max, nums.get(cur.i).get(cur.j+1));\n    }\n    return res;\n}\n```\n\n## [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)\n\n给定一个字符串 **s** 和一个非空字符串 **p**，找到 **s** 中所有是 **p** 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 **s** 和 **p** 的长度都不超过 20100。\n\n**说明：**\n\n- 字母异位词指字母相同，但排列不同的字符串。\n- 不考虑答案输出的顺序。\n\n**示例 1:**\n\n```java\n输入:\ns: \"cbaebabacd\" p: \"abc\"\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。\n```\n\n **示例 2:**\n\n```java\n输入:\ns: \"abab\" p: \"ab\"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n```\n\n**解法一**\n\n这题和上面一题其实一样，只是这里要求是连续的，在上面一题的基础上在添加结果的时候判断下长度就OK\n\n```java\npublic List<Integer> findAnagrams(String s, String p) {\n    int[] target=new int[256];\n    int[] window=new int[256];\n    int l=0,r=0;\n    int plen=p.length();\n    int slen=s.length();\n    int count=0,match=0;\n    List<Integer> res=new ArraysList<>();\n    for (int i=0;i<plen;i++) {\n        target[p.charAt(i)]++;\n    }\n    for (int a:target) {\n        if(a!=0){\n            count++;\n        }\n    }\n\n    while(r<slen){\n        char right=s.charAt(r);\n        if (target[right]!=0) {\n            window[right]++;\n            if (window[right]==target[right]) {\n                match++;\n            }\n        }\n        r++;\n        while(l<r && count==match){\n            char left=s.charAt(l);\n            if (r-l==res) {\n                res.add(l);\n            }\n            l++;\n            if (target[left]!=0) {\n                window[left]--;\n                //不满足了\n                if (window[left]<target[left]) {\n                    match--;\n                }\n            }\n        }\n    }\n    return res;\n}\n```\n**UPDATE:2020.7.23**\n\n用模板重写了下\n```golang\nfunc findAnagrams(s string, p string) []int {\n    var target = make([]int, 128)\n    var window = make([]int, 128)\n    var match = 0\n    for _, sp := range p {\n        if target[sp] == 0 {\n            match++\n        }\n        target[sp]++\n    }\n    var left = 0\n    var count = 0\n    var res []int\n    for right := 0; right < len(s); right++ {\n        if target[s[right]] > 0 {\n            window[s[right]]++\n            if window[s[right]] == target[s[right]] {\n                count++\n            }\n        }\n        for count == match && left <= right {\n            if right-left+1 == len(p) {\n                res = append(res, left)\n            }\n            if window[s[left]] > 0 {\n                window[s[left]]--\n                if window[s[left]] < target[s[left]] {\n                    count--\n                }\n            }\n            left++\n        }\n    }\n    return res\n}\n```\n15ms，86%时间复杂度`O(M+N)`，其实是完全套的之前最小覆盖子串的模板，不如肯定不好写这么长\n\n**解法二**\n\n正常的做法，实际上上面的解法一直在避免直接比较target和window，但是实际上比较这两个数组的成本是很低的，两个数组长度固定，比较时间复杂度O(1)，具体情况具体分析，不过套模板几乎是通用的\n```golang\nfunc findAnagrams(s string, p string) []int {\n    var left = 0\n    //-'a'看起来太丑了，直接128\n    var target [128]int //注意用数组，可以直接比较\n    var window [128]int\n    for _, sp := range p {\n        target[sp]++\n    }\n    var res []int\n    for right := 0; right < len(s); right++ {\n        if target[s[right]] > 0 {\n            window[s[right]]++\n        }\n        for right-left+1 > len(p) {\n            if window[s[left]] > 0 {\n                window[s[left]]--\n            }\n            left++\n        }\n        if window == target {\n            res = append(res, left)\n        }\n    }\n    return res\n}\n```\n\n## [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)\n\n给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。\n\n换句话说，第一个字符串的排列之一是第二个字符串的子串。\n\n**示例1:**\n\n```java\n输入: s1 = \"ab\" s2 = \"eidbaooo\"\n输出: True\n解释: s2 包含 s1 的排列之一 (\"ba\").\n```\n\n**示例2:**\n\n```java\n输入: s1= \"ab\" s2 = \"eidboaoo\"\n输出: False\n```\n\n**注意：**\n\n1. 输入的字符串只包含小写字母\n2. 两个字符串的长度都在 [1, 10,000] 之间\n\n**解法一**\n\n这题其实是 [76.最小覆盖子串](#76-最小覆盖子串) 的弱化版本，套路滑窗，但是有一些细节需要注意\n\n```java\npublic boolean checkInclusion(String s1, String s2) {\n    if(s1==null || s2==null || s1.length()>s2.length()){\n        return false;\n    }\n    int n1=s1.length();\n    int n2=s2.length();\n    int[] freq=new int[26];\n    int count=0;\n    for(int i=0;i<n1;i++){\n        int c=s1.charAt(i)-'a';\n        if(freq[c]==0){\n            count++;\n        }\n        freq[c]++;\n    }\n    int[] window=new int[26];\n    int match=0;\n    int left=0;\n    for(int right=0;right<n2;right++){\n        int cr=s2.charAt(right)-'a';\n        if(freq[cr]>0){\n            window[cr]++;\n            if(window[cr]==freq[cr]){\n                match++;\n            }\n        }\n        while(right-left+1>n1){\n            int cl=s2.charAt(left)-'a';\n            if(freq[cl]>0){\n                //WA点，开始写错了\n                //window[cl]--;\n                if(window[cl]==freq[cl]){\n                    match--; //match--的前提是原本是匹配的\n                }\n                window[cl]--;\n            }\n            left++;\n        } \n        if(match==count){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n一开始写完了，测试了用例发现都是对的，心里一喜，难道又bugfree了？提交，结果还是WA了🤣，debug了半天，根据错误的哪个长case自己构造了一个短case（长的不好debug），然后发现了问题，这个问题我看见评论区也有人问到，顺手还回了一下😁，其实错误的原因就是套模板没套好，没理解模板的细节\n\n这里的核心问题就是`match--`的时候有一个大前提：`cl`字符已经匹配好了，也就是`window[cl]==freq[cl]`\n\n这个时候你`left++`将`cl`移除窗口，才能做`match--`操作，否则像之前的模板中\n\n```java\nif (target[left]!=0) {\n    window[left]--;\n    //不满足了\n    if (window[left]<target[left]) {\n        match--;\n    }\n}\n```\n\n这样写就有可能window[left]还没有匹配上，这个时候直接减就错了，之前的模板中缩圈都是在match==count的前提下缩圈的，所以没问题，都是匹配的，其实也可以像之前的模板一样写，就像下面这样\n\n```java\npublic boolean checkInclusion(String s1, String s2) {\n    if(s1==null || s2==null || s1.length()>s2.length()){\n        return false;\n    }\n    int n1=s1.length();\n    int n2=s2.length();\n    int[] freq=new int[26];\n    int count=0;\n    for(int i=0;i<n1;i++){\n        int c=s1.charAt(i)-'a';\n        if(freq[c]==0){\n            count++;\n        }\n        freq[c]++;\n    }\n    int[] window=new int[26];\n    int match=0;\n    int left=0;\n    for(int right=0;right<n2;right++){\n        int cr=s2.charAt(right)-'a';\n        if(freq[cr]>0){\n            window[cr]++;\n            if(window[cr]==freq[cr]){\n                match++;\n            }\n        }\n        //****************************\n        //主要就是这里不一样\n        while(match==count){\n            if(right-left+1==n1) return true;\n            int cl=s2.charAt(left)-'a';\n            if(freq[cl]>0){\n                window[cl]--;\n                if(window[cl]<freq[cl]){\n                    match--;\n                }\n            }\n            left++;\n        } \n        //****************************\n    }\n    return false;\n}\n```\n这样就不用考虑先减还是后减的问题了\n\n**解法二**\n\n这题其实还可以暴力做，窗口大小固定，每滑动一次就判断窗口和`freq`是不是相等，因为题目说了都是小写字母所以也是行得通的，只是常数会大一些，这里我就不写了，笔试推荐这样写，代码好写一点\n\n## [面试题 17.18. 最短超串](https://leetcode-cn.com/problems/shortest-supersequence-lcci/)\n\n假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。\n\n返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。\n\n**示例 1:**\n\n```java\n输入:\nbig = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]\nsmall = [1,5,9]\n输出: [7,10]\n```\n\n**示例 2:**\n\n```java\n输入:\nbig = [1,2,3]\nsmall = [4]\n输出: []\n```\n\n**提示：**\n\n- `big.length <= 100000`\n- `1 <= small.length <= 100000`\n\n**解法一**\n\n也是属于 [76.最小覆盖子串](#76-最小覆盖子串)的弱化，虽然解法都一样，没啥好说的，注意细节\n\n```java\n//没啥好说的，套模板就行了\npublic int[] shortestSeq(int[] big, int[] small) {\n    if(big==null || big.length<=0) {\n        return new int[0];\n    }\n    int slen=small.length;\n    int blen=big.length;\n    int[] res=new int[2];\n    res[0]=-1;res[1]=-1;\n    int min=Integer.MAX_VALUE;\n    HashSet<Integer> set=new HashSet<>();\n    for(int i:small) set.add(i);\n    HashMap<Integer,Integer> window=new HashMap<>();\n    int match=0;\n    int left=0;\n    for(int right=0;right<blen;right++){\n        int wr=big[right];\n        if(set.contains(wr)){\n            window.put(wr,window.getOrDefault(wr,0)+1);\n            if(window.get(wr)==1){\n                match++;\n            }\n        }\n        while(match==slen){\n            if(right-left+1<min){\n                res[0]=left;\n                res[1]=right;\n                min=right-left+1;\n            }\n            int wl=big[left];\n            if(set.contains(wl)){\n                window.put(wl,window.get(wl)-1);\n                if(window.get(wl)==0){\n                    match--;\n                }\n            }\n            left++;\n        }\n    }\n    return res[0]==-1?new int[0]:res;\n}\n```\n\n## [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)\n\n给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。\n\n返回仅包含 1 的最长（连续）子数组的长度。\n\n**示例 1：**\n\n```java\n输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2\n输出：6\n解释： \n[1,1,1,0,0,1,1,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 6。\n```\n\n**示例 2：**\n\n```java\n输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\n输出：10\n解释：\n[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 10。\n```\n\n**提示：**\n\n1. `1 <= A.length <= 20000`\n2. `0 <= K <= A.length`\n3. `A[i]` 为 `0` 或 `1` \n\n**解法一**\n\n这题其实下面一题[424. 替换后的最长重复字符](#424-替换后的最长重复字符)的弱化版本\n\n```java\n//简单的滑窗\npublic int longestOnes(int[] A, int K) {\n    if(A==null || A.length<=0) return 0;\n    int N=A.length;\n    int left=0,res=0,countA=0;\n    for(int right=0;right<N;right++){\n        countA+=(A[right]&1);\n        //if也可以，个人喜欢while通用性更强\n        while(right-left+1-countA>K){ \n            countA-=(A[left++]&1);\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n按照模板来写简直是信手拈来（其实也没有什么模板，就是规范了写法而已）\n\n## [5434. 删掉一个元素以后全为 1 的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)\n\nDifficulty: **中等**\n\n\n给你一个二进制数组 `nums` ，你需要从中删掉一个元素。\n\n请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。\n\n如果不存在这样的子数组，请返回 0 。\n\n**提示 1：**\n\n```java\n输入：nums = [1,1,0,1]\n输出：3\n解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。\n```\n\n**示例 2：**\n\n```java\n输入：nums = [0,1,1,1,0,1,1,0,1]\n输出：5\n解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,1,1]\n输出：2\n解释：你必须要删除一个元素。\n```\n\n**示例 4：**\n\n```java\n输入：nums = [1,1,0,0,1,1,1,0,1]\n输出：4\n```\n\n**示例 5：**\n\n```java\n输入：nums = [0,0,0]\n输出：0\n```\n\n**提示：**\n\n*   `1 <= nums.length <= 10^5`\n*   `nums[i]` 要么是 `0` 要么是 `1` 。\n\n**解法一**\n\n29th双周赛的t3，秒切，其实是上一题[1004. 最大连续1的个数 III](#1004-最大连续1的个数-iii)的弱化\n```java\n   public int longestSubarray(int[] nums) {\n       int res=0, sum=0;\n       int left=0;\n       for(int right=0;right<nums.length;right++){\n           sum+=(nums[right]&1);\n           //区间和小于right-left-1说明中间不止一个0需要缩减窗口\n           while(left<right && sum<= right-left-1){\n               if(nums[left] == 1){\n                   sum--;\n               }\n               left++;\n           }\n           //至少删除一个，所以不用+1\n           res = Math.max(res,right-left);\n       }\n       return res;\n   }\n```\n很可惜这次前3题15分钟就做完了，都是直接web上写的，本以为有机会AK，最后一题搞了半天最后交了一发还是没过，貌似很多人写了假算法，贪心莽过了（lc数据太弱了）\n![UTOOLS1593333299362.png](https://upload.cc/i1/2020/06/28/mhTiQ9.png)\n\n## [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)\n\n给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。\n\n**注意:**\n字符串长度 和 k 不会超过 104。\n\n**示例 1:**\n\n```java\n输入:\ns = \"ABAB\", k = 2\n输出:\n4\n解释:\n用两个'A'替换为两个'B',反之亦然。\n```\n\n**示例 2:**\n\n```java\n输入:\ns = \"AABABBA\", k = 1\n输出:\n4\n解释:\n将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"\n子串 \"BBBB\" 有最长重复字母, 答案为 4\n```\n\n**解法一**\n\n上面一题的加强版\n\n```java\npublic int characterReplacement(String s, int k) {\n    int max = 0, start = 0, end = 0, cur = -1;\n    int[] count = new int[256];\n    while (end < s.length()) {\n        //当前窗口出现最多的字符\n        cur = Math.max(cur, ++count[s.charAt(end)]);\n        //不能替换了,不同字符太多了,需要缩减窗口\n        while (end - start + 1 - cur > k){\n            //缩减左边界的count\n            count[s.charAt(start)]--;\n            start++;//不能替换了，start++\n        }\n        //统计最大值\n        max = Math.max(max, end - start + 1);\n        end++;\n    }\n    return max;\n}\n```\n\n**UPDATE: (2020.5.5)**\n\n按照模板重写，果然滑窗的题都是一样的\n\n```java\npublic int characterReplacement(String s, int k) {\n    if(s==null || s.length()<=0){\n        return 0;\n    }\n    int n=s.length();\n    int res=1;\n    int left=0;\n    int[] freq=new int[128];\n    int maxFreq=0;\n    for(int right=0;right<n;right++){\n        char c=s.charAt(right);\n        freq[c]++;\n        maxFreq=Math.max(maxFreq,freq[c]);\n        while((right-left+1-maxFreq)>k){\n            freq[s.charAt(left)]--;\n            left++; //这里实际上只会执行一次，改成if也是可以的，不过为了统一写法就不改了\n        }\n        res=Math.max(res,right-left+1);\n    }\n    return res;\n}\n```\n\n重写这题的时候发现这题还是挺有意思的，这个里面的`maxFreq`是一个只增不减的量，是一个历史最大值，只有当出现更大的freq的时候才会更新`maxFreq`，当`maxFreq`保持不变的时候结果不会受到影响，只有出现了更大freq的时候才有可能会使结果变大\n\n> [拷贝自题解区](https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/hua-dong-chuang-kou-chang-gui-tao-lu-by-xiaoneng/) \n>\n> 因为我们只对最长有效的子字符串感兴趣，所以我们的滑动窗口不需要收缩，即使窗口可能覆盖无效的子字符串。我们可以通过在右边添加一个字符来扩展窗口，或者将整个窗口向右边移动一个字符。而且我们只在新字符的计数超过历史最大计数(来自覆盖有效子字符串的前一个窗口)时才增长窗口。也就是说，我们不需要精确的当前窗口的最大计数;我们只关心最大计数是否超过历史最大计数;这只会因为新字符而发生。\n\n**解法二**\n\n憨憨的解法，不过绝对是能AC的，时间复杂度并没有问题，依然是`O(N)`\n\n```java\npublic int characterReplacement(String s, int k) {\n    if(s==null || s.length()<=0){\n        return 0;\n    }\n    int n=s.length();\n    int res=1;\n    for(int c='A';c<='Z';c++){\n        int[] freq=new int[128];\n        int temp=1;\n        int left=0;\n        for(int right=0;right<n;right++){\n            if(s.charAt(right)==c){\n                freq[c]++;\n            }\n            while((right-left+1-freq[c])>k){\n                if(s.charAt(left)==c){\n                    freq[c]--;\n                }\n                left++;\n            }\n            temp=Math.max(temp,right-left+1);\n        }\n        res=Math.max(res,temp);\n    }\n    return res;\n}\n```\n既然题目说了只有大写字母，那就直接枚举所有的字符然后滑窗就行了😂，简单直白\n\n## [1234. 替换子串得到平衡字符串](https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/)\n\n有一个只含有 `'Q', 'W', 'E', 'R'` 四种字符，且长度为 n 的字符串。\n\n假如在该字符串中，这四个字符都恰好出现 `n/4` 次，那么它就是一个「平衡字符串」。\n\n给你一个这样的字符串 `s`，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。\n\n你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。\n\n请返回待替换子串的最小可能长度。\n\n如果原字符串自身就是一个平衡字符串，则返回 0 \n\n**示例 1：**\n\n```java\n输入：s = \"QWER\"\n输出：0\n解释：s 已经是平衡的了。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"QQWE\"\n输出：1\n解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 \"RQWE\" (或 \"QRWE\") 是平衡的。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"QQQW\"\n输出：2\n解释：我们可以把前面的 \"QQ\" 替换成 \"ER\"。 \n```\n\n**示例 4：**\n\n```java\n输入：s = \"QQQQ\"\n输出：3\n解释：我们可以替换后 3 个 'Q'，使 s = \"QWER\"。\n```\n\n**提示：**\n\n- 1 <= s.length <= 10^5\n- s.length 是 4 的倍数\n- s 中只含有 'Q', 'W', 'E', 'R' 四种字符\n\n**解法一**\n\n周赛题，说实话不多做做竞赛真不知道自己多菜\n\n(update: 2020.4.15)\n\n我拿到这题，首先想到的是无脑套路滑窗，既然要保证平衡，那么每个字符出现的次数都应该是`N/4`，所以我们可以统计下多出来的有几个，比如`QQQW`，那么多出来的就是2个**`Q`**，也就是说我们要求的窗口内**至少**有2个Q，这样问题其实就转换成了 [76. 最小覆盖子串](#76-最小覆盖子串)（这明明是个mid题，你咋还给转换成hard了，你是不是傻🤣）\n\n其实最小覆盖子串看起来好像挺难，但是是有套路的，我们直接套模板就可以了\n\n```java\npublic int balancedString(String s) {\n    if(s==null || s.length()<=0) return -1;\n    int N=s.length();\n    //这里用26有的浪费,为了方便写代码,就这样吧\n    int[] need=new int[26];\n    //初始化为-N/4这样最后得到的大于0的值就是多出来的\n    Arrays.fill(need,-N/4);\n    int[] cur=new int[26];\n    for(int i=0;i<N;i++){\n        need[s.charAt(i)-'A']++;\n    }\n    //有几个字符多出来了\n    int needCount=0; \n    for(int i=0;i<need.length;i++){\n        if(need[i]>0) needCount++;\n    } \n    if(needCount==0) return 0;\n    int res=N;\n    int left=0,right=0;\n    int matchCount=0;\n    //无脑套路滑窗\n    while(right<s.length()){\n        char c=s.charAt(right);\n        if(need[c-'A']>0){\n            cur[c-'A']++;\n            if(cur[c-'A']==need[c-'A']){\n                matchCount++;\n            }\n        }\n        while(left<=right && matchCount==needCount){\n            res=Math.min(right-left+1,res);\n            char cl=s.charAt(left);\n            if(need[cl-'A']>0){\n                cur[cl-'A']--;\n                if(cur[cl-'A']<need[cl-'A']){\n                    matchCount--;\n                }\n            }\n            left++;\n        }\n        right++;\n    }\n    return res;\n}\n```\n\n**解法二**\n\n上面的解法是考虑`窗口内`的元素组成，窗口内至少应该有哪些元素，反过来想，我们窗口内的元素是多出来的元素，我们是把多的元素放到窗口中，那么窗口外的元素就肯定都是`小于等于N/4`的了，那么我们就可以利用这一点进行滑窗，统计符合条件的窗口的最小值，这样代码就会简洁很多\n\n```java\n//code删掉了，之前的代码有点问题，最后的返回值有些情况过不去，lc的case太弱了，让我过了\n```\n\n**UPDATE: (2020.5.4)**\n\n按照先前的模板来分析下，这里要求的是最小的修改次数，很明显不能用`for-if`，所以采用`for-while`的结构，`for-while`最基本的结构就是外层枚举所有`right`，内层根据题目要求缩减`left`，但是这题left也需要控制边界，我这里用的是`left<=right` 但是实际上这样会有一类case结果不对，比如\"QWER\"这样的，返回的结果是1，~~我上面在最后做了特判~~（上面的特判是错的，比如“QWEE”这样的就返回0），其实这里还可以修改下边界，改成`left<N`，这样就没问题了，这样left就可以超过right达到right+1，这样对”QWER\"就能得到正确的结果，并且根据题目信息当`left=right+1`之后`left`就不会再增加了，while条件就无法满足了，但是有的题目`left`是不用设置限制的，基本上都是在达到right+1之后就不会继续增加了\n\n```java\nclass Solution {\n    public int balancedString(String s) {\n        if(s==null || s.length()<=0){\n            return 0;\n        }\n        int N=s.length();\n        int left=0;\n        int res=N;\n        int[] freq=new int[26];\n        for(int i=0;i<N;i++) {\n            freq[s.charAt(i)-'A']++;\n        }\n        for(int right=0;right<N;right++){\n            freq[s.charAt(right)-'A']--;\n            while(left<N && freq['Q'-'A']<=N/4 && freq['W'-'A']<=N/4 && freq['E'-'A']<=N/4 && freq['R'-'A']<=N/4){\n                res=Math.min(res,right-left+1);\n                freq[s.charAt(left++)-'A']++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n## [1358. 包含所有三种字符的子字符串数目](https://leetcode-cn.com/problems/number-of-substrings-containing-all-three-characters/)  \n\n给你一个字符串 s ，它只包含三种字符 a, b 和 c 。\n\n请你返回 a，b 和 c 都 **至少** 出现过一次的子字符串数目。\n\n**示例 1：**\n\n```java\n输入：s = \"abcabc\"\n输出：10\n解释：包含 a，b 和 c 各至少一次的子字符串为 \"abc\", \"abca\", \"abcab\", \"abcabc\", \"bca\", \"bcab\", \"bcabc\", \"cab\", \"cabc\" 和 \"abc\" (相同字符串算多次)。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"aaacb\"\n输出：3\n解释：包含 a，b 和 c 各至少一次的子字符串为 \"aaacb\", \"aacb\" 和 \"acb\" 。\n```\n\n**示例 3：**\n\n```java\n输入：s = \"abc\"\n输出：1\n```\n\n**提示：**\n\n- 3 <= s.length <= 5 x 10^4\n- s 只包含字符 a，b 和 c 。\n\n**解法一**\n\n20双周赛T3\n\n```java\npublic int numberOfSubstrings(String s) {\n    int[] freq=new int[3];\n    int left=0,right=-1,slen=s.length();\n    int res=0;\n    //abc\n    while(left<slen-2){\n        while(right+1<slen && !valid(freq)){\n            freq[s.charAt(++right)-'a']++;\n        }\n        res+=valid(freq)?(slen-right):0;\n        freq[s.charAt(left)-'a']--;\n        left++;\n    }\n    return res;\n}\n\npublic boolean valid(int[] freq){\n    return freq[0]!=0 && freq[1]!=0 && freq[2]!=0;\n}\n```\n枚举所有的左边界，然后找到最短的可以满足的右边界，那么包括右边界和之后的所有的都满足条件，直接计算就可以了，时间复杂度`O(N)`\n\n**解法二**\n\n2020.5.4 用自己总结的滑窗模板重写，也是`for-while`结构，right和left不能同时扩展。比如`\"aaacb\"`这样的case\n\n```java\npublic int numberOfSubstrings(String s) {\n    int left=0;\n    int res=0;\n    int n=s.length();\n    int[] freq=new int[3];\n    for(int right=0;right<n;right++){\n        freq[s.charAt(right)-'a']++;\n        while(freq[0]>0 && freq[1]>0 && freq[2]>0){\n            res+=n-right; //后面的都符合条件\n            freq[s.charAt(left)-'a']--;\n            left++;\n        }\n    }\n    return res;\n}\n```\n## [1423. 可获得的最大点数](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)\n\n几张卡牌 **排成一行**，每张卡牌都有一个对应的点数。点数由整数数组 `cardPoints` 给出。\n\n每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 `k` 张卡牌。\n\n你的点数就是你拿到手中的所有卡牌的点数之和。\n\n给你一个整数数组 `cardPoints` 和整数 `k`，请你返回可以获得的最大点数。\n\n**示例 1：**\n\n```java\n输入：cardPoints = [1,2,3,4,5,6,1], k = 3\n输出：12\n解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n```\n\n**示例 2：**\n\n```java\n输入：cardPoints = [2,2,2], k = 2\n输出：4\n解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。\n```\n\n**示例 3：**\n\n```java\n输入：cardPoints = [9,7,7,9,7,7,9], k = 7\n输出：55\n解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n```\n\n**示例 4：**\n\n```java\n输入：cardPoints = [1,1000,1], k = 1\n输出：1\n解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 \n```\n\n**示例 5：**\n\n```java\n输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3\n输出：202\n```\n\n**提示：**\n\n- `1 <= cardPoints.length <= 10^5`\n- `1 <= cardPoints[i] <= 10^4`\n- `1 <= k <= cardPoints.length`\n\n**解法一**\n\n186周赛T2，很明显的滑动窗口，前后拿K张最大，只需要求一个最小的`[n-k]`区间值就行了，也可以用前缀和，思路都一样\n\n```go\nfunc maxScore(cardPoints []int, k int) int {\n    if cardPoints == nil || len(cardPoints) == 0 {\n        return 0\n    }\n    n := len(cardPoints)\n    left := 0\n    right := n - k - 1\n    sum := 0\n    windowSum := 0\n    for i, num := range cardPoints {\n        sum += num\n        if i == right {\n            windowSum = sum\n        }\n    }\n    if k == n {\n        return sum\n    }\n    minWin := windowSum\n    for right+1 < n {\n        windowSum += (cardPoints[right+1] - cardPoints[left])\n        minWin = min(windowSum, minWin)\n        right++\n        left++\n    }\n    return sum - minWin\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\n```\n\nTag里面有dp，确实这题和前面的[石子游戏](http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/#877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F)有一点像，但是还是滑窗来的比较直接。。\n\n## [1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)\n\n给你两个长度相同的字符串，`s` 和 `t`。\n\n将 `s` 中的第 `i` 个字符变到 `t` 中的第 `i` 个字符需要 `|s[i] - t[i]|` 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。\n\n用于变更字符串的最大预算是 `maxCost`。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。\n\n如果你可以将 `s` 的子字符串转化为它在 `t` 中对应的子字符串，则返回可以转化的最大长度。\n\n如果 `s` 中没有子字符串可以转化成 `t` 中对应的子字符串，则返回 `0`。\n\n**示例 1：**\n\n```go\n输入：s = \"abcd\", t = \"bcdf\", cost = 3\n输出：3\n解释：s 中的 \"abc\" 可以变为 \"bcd\"。开销为 3，所以最大长度为 3。\n```\n\n**示例 2：**\n\n```go\n输入：s = \"abcd\", t = \"cdef\", cost = 3\n输出：1\n解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。\n```\n\n**示例 3：**\n\n```go\n输入：s = \"abcd\", t = \"acde\", cost = 0\n输出：1\n解释：你无法作出任何改动，所以最大长度为 1。\n```\n\n**提示：**\n\n- `1 <= s.length, t.length <= 10^5`\n- `0 <= maxCost <= 10^6`\n- `s` 和 `t` 都只含小写英文字母。\n\n**解法一**\n\n```go\nfunc equalSubstring(s string, t string, maxCost int) int {\n    left := 0\n    cost := 0\n    res := 0\n    for right := 0; right < len(s); right++ {\n        cost += getCost(s[right], t[right])\n        if cost <= maxCost {\n            res = max(res, right-left+1)\n        } else {\n            cost -= getCost(s[left], t[left])\n            left++\n        }\n    }\n    return res\n}\n\nfunc getCost(a, b byte) int {\n    if a < b { //a-b<0 byte是uint8直接这样减会变成正数\n        return int(b - a)\n    }\n    return int(a - b)\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n这个题本身不难，主要是为了学习滑窗类型的题，这题我又改了好长时间，果然做滑窗的题还是有点乱，不过做了这一题之后已经有点感觉了，目前打算把所有的滑窗都重做一遍，然后总结一下套路\n\n**思考**\n\n下面`for-while`的结构似乎更加统一，上面`for-if`的结构只能用在求**最长，最大**的情况下，这种时候`left`和`right`允许同时加加，所以用`if`也是可以的，但是求最短的时候，比如上面[209. 长度最小的子数组](#209-长度最小的子数组)就不能用`for-if` ，当right到达边界的时候left可能还需要继续移动，所以不能用`if`\n\n```go\nfunc equalSubstring(s string, t string, maxCost int) int {\n    left := 0\n    cost := 0\n    res := 0\n    for right := 0; right < len(s); right++ {\n        cost += getCost(s[right], t[right])\n        for cost > maxCost {\n            cost -= getCost(s[left], t[left])\n            left++\n        }\n        res = max(res, right-left+1)\n    }\n    return res\n}\n```\n\n## [1052. 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)\n\n今天，书店老板有一家店打算试营业 `customers.length` 分钟。每分钟都有一些顾客（`customers[i]`）会进入书店，所有这些顾客都会在那一分钟结束后离开。\n\n在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。\n\n书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `X` 分钟不生气，但却只能使用一次。\n\n请你返回这一天营业下来，最多有多少客户能够感到满意的数量。\n\n**示例：**\n\n```\n输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3\n输出：16\n解释：\n书店老板在最后 3 分钟保持冷静。\n感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n```\n\n**提示：**\n\n- `1 <= X <= customers.length == grumpy.length <= 20000`\n- `0 <= customers[i] <= 1000`\n- `0 <= grumpy[i] <= 1`\n\n**解法一**\n\n滑动窗口的感觉来了，越来越熟练了，这题直接bugfree了😁\n\n```java\npublic int maxSatisfied(int[] customers, int[] grumpy, int X) {\n    if(grumpy==null || grumpy.length<0) return 0;\n    int N=grumpy.length;\n    int left=0;\n    int window=0;//窗口内反转人数\n    int max=0; //最多反转人数\n    for(int right=0;right<N;right++){\n        if(grumpy[right]==1){\n            window+=customers[right];\n        }\n        //while和if都可以,个人比较喜欢while通用性比较强\n        while(right-left+1>X){\n            if(grumpy[left]==1){\n                window-=customers[left];\n            }\n            left++;\n        }\n        max=Math.max(window,max);\n    }\n    int res=0;\n    for(int i=0;i<N;i++){\n        res+=(grumpy[i]==0?customers[i]:0);\n    }\n    return res+max;\n}\n```\n可以看到仍然是前面总结的`for-while`结构，等我把所有的滑窗tag做完了再来总结一波\n\n## [1040. 移动石子直到连续 II](https://leetcode-cn.com/problems/moving-stones-until-consecutive-ii/)\n\n在一个长度**无限**的数轴上，第 `i` 颗石子的位置为 `stones[i]`。如果一颗石子的位置最小/最大，那么该石子被称作**端点石子**。\n\n每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。\n\n值得注意的是，如果石子像 `stones = [1,2,5]` 这样，你将**无法**移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。\n\n当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。\n\n要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：`answer = [minimum_moves, maximum_moves]` 。\n\n**示例 1：**\n\n```java\n输入：[7,4,9]\n输出：[1,2]\n解释：\n我们可以移动一次，4 -> 8，游戏结束。\n或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。\n```\n\n**示例 2：**\n\n```java\n输入：[6,5,4,3,10]\n输出：[2,3]\n解释：\n我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。\n或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。\n注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。\n```\n\n**示例 3：**\n\n```java\n输入：[100,101,104,102,103]\n输出：[0,0]\n```\n\n**提示：**\n\n1. `3 <= stones.length <= 10^4`\n2. `1 <= stones[i] <= 10^9`\n3. `stones[i]` 的值各不相同。\n\n**解法一**\n\n懵逼，某次周赛的T4，嗯抄，不会做，题目都差点没看懂\n\n```java\npublic int[] numMovesStonesII(int[] stones) {\n    if(stones==null || stones.length<=0){\n        return new int[2];\n    }\n    //0 1 2 3 4 5 6 7 8 9 10\n    //      0 1 2 3        4\n    int N=stones.length;\n    Arrays.sort(stones);\n    int left=0;\n    int[] res=new int[2];\n    res[0]=Integer.MAX_VALUE;\n    for(int right=0;right<N;right++){\n        //整个区间范围大于N了需要缩小区间\n        while(stones[right]-stones[left]+1>N){ \n            left++;\n        }\n        int windowStones=right-left+1;\n        if(windowStones==N-1&&stones[right]-stones[left]+1==N-1){\n            res[0]=Math.min(2,res[0]);\n        }else{\n            res[0]=Math.min(res[0],N-windowStones);\n        }\n    }\n    res[1]=Math.max(stones[N-1]-stones[1]-N+2,stones[N-2]-stones[0]-N+2);\n    return res;\n}\n```\n\n## [1456. 定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)\n\n给你字符串 s 和整数 k 。\n\n请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。\n\n英文中的 元音字母 为（a, e, i, o, u）。\n\n**示例 1：**\n\n```java\n输入：s = \"abciiidef\", k = 3\n输出：3\n解释：子字符串 \"iii\" 包含 3 个元音字母。\n```\n**示例 2：**\n\n```java\n输入：s = \"aeiou\", k = 2\n输出：2\n解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n```\n**示例 3：**\n\n```java\n输入：s = \"leetcode\", k = 3\n输出：2\n解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。\n```\n**示例 4：**\n\n```java\n输入：s = \"rhythms\", k = 4\n输出：0\n解释：字符串 s 中不含任何元音字母。\n```\n**示例 5：**\n\n```java\n输入：s = \"tryhard\", k = 4\n输出：1\n```\n\n**提示：**\n\n- 1 <= s.length <= 10^5\n- s 由小写英文字母组成\n- 1 <= k <= s.length\n\n**解法一**\n\n好久没写滑窗的题了，回顾下之前的模板，`for-while`结构\n```java\npublic int maxVowels(String s, int k) {\n    int left=0;\n    int res=0;\n    int count=0;\n    for(int right=0;right<s.length();right++){\n        if(vowel(s.charAt(right))){\n            count++;\n        }\n        while(right-left >= k){\n            if(vowel(s.charAt(left))){\n                count--;\n            }\n            left++;\n        }\n        res=Math.max(res,count);\n    }\n    return res;\n}\n\npublic boolean vowel(char ch){\n    return ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u';\n}\n\n```\n\n## [1461. 检查一个字符串是否包含所有长度为 K 的二进制子串](https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/)\n\nDifficulty: **中等**\n\n\n给你一个二进制字符串 `s` 和一个整数 `k` 。\n\n如果所有长度为 `k` 的二进制字符串都是 `s` 的子串，请返回 True ，否则请返回 False 。\n\n**示例 1：**\n\n```go\n输入：s = \"00110110\", k = 2\n输出：true\n解释：长度为 2 的二进制串包括 \"00\"，\"01\"，\"10\" 和 \"11\"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。\n```\n\n**示例 2：**\n\n```go\n输入：s = \"00110\", k = 2\n输出：true\n```\n\n**示例 3：**\n\n```go\n输入：s = \"0110\", k = 1\n输出：true\n解释：长度为 1 的二进制串包括 \"0\" 和 \"1\"，显然它们都是 s 的子串。\n```\n\n**示例 4：**\n\n```go\n输入：s = \"0110\", k = 2\n输出：false\n解释：长度为 2 的二进制串 \"00\" 没有出现在 s 中。\n```\n\n**示例 5：**\n\n```go\n输入：s = \"0000000001011100\", k = 4\n输出：false\n```\n\n**提示：**\n\n*   `1 <= s.length <= 5 * 10^5`\n*   `s` 中只含 0 和 1 。\n*   `1 <= k <= 20`\n\n\n**解法一**\n\n某次周赛的T2还是T3，忘了，我用了最暴力的方法，直接回溯生成了所有的二进制串，然后对比的，写的很快，也AC了，但是但是后面一直没时间重写，今天偶然发现了这道题，重写下\n\n经典for-while结构\n```golang\nfunc hasAllCodes(s string, k int) bool {\n    var set = make(map[int]bool)\n    var left = 0\n    var cur = 0\n    for right := 0; right < len(s); right++{\n        cur = cur * 2 + int(s[right] & 1)\n        for right - left + 1 > k{\n            cur &= ^(1 << k) //将首位置为0\n            left++\n        }\n        if right - left + 1 == k{\n            set[cur] = true   \n        }\n    }\n    return len(set) == 1 << k\n}\n```\n这个题也可以直接存字符串进去，但是存字符串的时间复杂度就不是O(N)了(N为字符长度)，而是O(KN)，因为字符串Hash的复杂度是O(K)，但是这里K很小，所以其实也无所谓，但是我们还是要追求更加优秀的解法，所以最好的做法还是将其转换成数字，然后存到哈希表中，这里看了别人的解法又学到了一手位运算的小技巧，`cur & ^(1<<k)`（k为cur长度-1）可以将cur首位置为0，也就是消去首位，原理也很简单，就不赘述了\n\n## [1498. 满足条件的子序列数目](https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/)\n\nDifficulty: **中等**\n\n\n给你一个整数数组 `nums` 和一个整数 `target` 。\n\n请你统计并返回 `nums` 中能满足其最小元素与最大元素的 **和** 小于或等于 `target` 的 **非空** 子序列的数目。\n\n由于答案可能很大，请将结果对 10^9 + 7 取余后返回。\n\n**示例 1：**\n\n```go\n输入：nums = [3,5,6,7], target = 9\n输出：4\n解释：有 4 个子序列满足该条件。\n[3] -> 最小元素 + 最大元素 <= target (3 + 3 <= 9)\n[3,5] -> (3 + 5 <= 9)\n[3,5,6] -> (3 + 6 <= 9)\n[3,6] -> (3 + 6 <= 9)\n```\n\n**示例 2：**\n\n```go\n输入：nums = [3,3,6,8], target = 10\n输出：6\n解释：有 6 个子序列满足该条件。（nums 中可以有重复数字）\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]\n```\n\n**示例 3：**\n\n```go\n输入：nums = [2,3,3,4,6,7], target = 12\n输出：61\n解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）\n有效序列总数为（63 - 2 = 61）\n```\n\n**示例 4：**\n\n```go\n输入：nums = [5,2,4,1,7,6,8], target = 16\n输出：127\n解释：所有非空子序列都满足条件 (2^7 - 1) = 127\n```\n\n**提示：**\n\n*   `1 <= nums.length <= 10^5`\n*   `1 <= nums[i] <= 10^6`\n*   `1 <= target <= 10^6`\n\n**解法一**\n\n双指针滑窗，很关键的一步就是排序，因为我们只关心最大最小值，而且是子序列，与顺序无关\n```java\n//双指针\npublic int numSubseq(int[] nums, int target) {\n    Arrays.sort(nums);\n    int MOD = (int)(1e9+7);\n    int n = nums.length;\n    //预处理出幂值表\n    int[] pow = new int[n];\n    pow[0] = 1;\n    for (int i = 1; i < n; i++){\n        pow[i] = (pow[i-1] << 1) % MOD;\n    }\n    int left = 0, right = n-1;\n    long count = 0;\n    while(left <= right){\n        while(left <= right && nums[left] + nums[right] > target) {\n            right--;\n        }\n        if (left <= right) {\n            //nums[left] + nums[right] <>= target \n            //包含left的子序列个数: left固定，在[left+1,right]选若干个，就有 2^(right-left) 种选法\n            count = (count + pow[right-left]) % MOD ;\n        }\n        left++;\n    }\n    return (int)count%MOD;\n}\n```\n**解法二**\n\n二分\n```java\n//二分\npublic int numSubseq(int[] nums, int target) {\n    Arrays.sort(nums);\n    int MOD = (int)(1e9+7);\n    int n = nums.length;\n    //预处理出幂值表\n    int[] pow = new int[n];\n    pow[0] = 1;\n    for (int i = 1; i < n; i++){\n        pow[i] = (pow[i-1] << 1) % MOD;\n    }\n    long count = 0;\n    for (int i = 0; i < n; i++) {\n        if (target-nums[i] < 0){\n            break;\n        }\n        int right = search(nums, target-nums[i]);\n        if (right >= i){\n            count = (count + pow[right-i]) % MOD;\n        }\n    }\n    return (int) count % MOD;\n}\n\n//搜索最后一个小于等于target的值\npublic int search(int[] nums, int target){\n    int left = 0, right = nums.length-1;\n    int res = -1;\n    while (left <= right) {\n        int mid = left + (right-left)/2;\n        if (nums[mid] <= target){\n            res = mid;\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n```\n## [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)\n\nDifficulty: **中等**\n\n\n在一排树中，第 `i` 棵树产生 `tree[i]` 型的水果。  \n你可以**从你选择的任何树开始**，然后重复执行以下步骤：\n\n1.  把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。\n2.  移动到当前树右侧的下一棵树。如果右边没有树，就停下来。\n\n请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。\n\n你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。  \n用这个程序你能收集的水果总量是多少？\n> 感觉这里想表达的应该是水果树的数量\n**示例 1：**\n\n```go\n输入：[1,2,1]\n输出：3\n解释：我们可以收集 [1,2,1]。\n```\n\n**示例 2：**\n\n```go\n输入：[0,1,2,2]\n输出：3\n解释：我们可以收集 [1,2,2].\n如果我们从第一棵树开始，我们将只能收集到 [0, 1]。\n```\n\n**示例 3：**\n\n```go\n输入：[1,2,3,2,2]\n输出：4\n解释：我们可以收集 [2,3,2,2].\n如果我们从第一棵树开始，我们将只能收集到 [1, 2]。\n```\n\n**示例 4：**\n\n```go\n输入：[3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：我们可以收集 [1,2,1,1,2].\n如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。\n```\n\n**提示：**\n\n1.  `1 <= tree.length <= 40000`\n2.  `0 <= tree[i] < tree.length`\n\n\n**解法一**\n\n题目意思其实就是求只包含2个元素的最长子串，题目表述的不太清楚，已经反馈了\n```golang\nfunc totalFruit(tree []int) int {\n    var left = 0\n    var Max = func (a, b int) int {if a>b {return a};return b}\n    var n = len(tree)\n    var freq [40001]int\n    var res, count = 0, 0\n    for right := 0; right < n; right++ {\n        if freq[tree[right]] == 0 {\n            count++\n        }\n        freq[tree[right]]++\n        for count > 2 {\n            freq[tree[left]]--\n            if freq[tree[left]] == 0 {\n                count--\n            }\n            left++\n        }\n        res = Max(res, right-left+1)\n    }\n    return res\n}\n```\n## [NC562.牛牛的魔法卡](https://www.nowcoder.com/practice/9b6fe52a68904c77aa81502f57ceac86)\n\n牛牛从小就有收集魔法卡的习惯，他最大的愿望就是能够集齐 k 种不同种类的魔法卡，现在有 n 张魔法卡，这 n 张魔法卡存在于一维坐标点上，\n每张魔法卡可能属于某一种类。牛牛如果想收集魔法卡就需要从当前坐标点跳跃到另外一个魔法卡所在的坐标点，花费的代价是两个跳跃坐标点之间的距离差。\n牛牛可以从任意的坐标点出发，牛牛想知道他集齐 k 种魔法卡所花费的最小代价是多少，如果集不齐 k 种魔法卡，输出-1。\n第一行输入两个整数 n,k, 分别表示魔法卡的个数和种类个数。\n接下来有n行，每行两个数x，y 分别表示属于哪一种魔法卡和魔法卡所在的坐标\n\n**示例1**\n```go\n输入: 7,3,[[0,1],[0,2],[1,5],[1,1],[0,7],[2,8],[1,3]]\n输出: 3\n说明: \n样例一：牛牛从坐标点5出发，经过7、8两个点就收集了3张不同种类的魔法卡，达成成就。所需代价 （7-5）+（8-7） = 3\n```\n**备注:**\n- 1<=n<=10^6\n- 1<=k<=50 0<=x<k\n- 0 <= y <= 1e9\n\n**解法一**\n\ntag是二分，但是想了一会儿感觉好像没啥好的二分的思路，二分答案貌似可行，不过这题滑窗的思路更简单，类似[76-最小覆盖子串](#76-最小覆盖子串)滑就完事儿了\n```java\npublic int solve (int n, int k, int[][] card) {\n    // write code here\n    Arrays.sort(card, (c1,c2)->c1[1]-c2[1]);\n    int INF = Integer.MAX_VALUE;\n    int left = 0;\n    int count = 0;\n    int[] freq = new int[k+1];\n    int res = INF;\n    for (int right = 0; right < n; right++) {\n        if (freq[card[right][0]] == 0) {\n            count++;\n        }\n        freq[card[right][0]]++;\n        while(left<=right && count == k){\n            res = Math.min(res, card[right][1] - card[left][1]);\n            freq[card[left][0]]--;\n            if (freq[card[left][0]]==0) {\n                count--;\n            }\n            left++;\n        }\n    }\n    if (res == INF) {\n        return -1;\n    }\n    return res;\n}\n```\n## [1870. 全零子串的数量（LintCode）](https://www.lintcode.com/problem/number-of-substrings-with-all-zeroes/description)\n\n给出一个只包含0或1的字符串str,请返回这个字符串中全为0的子字符串的个数 1<=|str|<=30000\n\n**例1:**\n```go\n输入:\"00010011\"\n输出:9\n解释:\n\"0\"子字符串有5个,\n\"00\"子字符串有3个,\n\"000\"子字符串有1个。\n所以返回9\n```\n**例2:**\n```go\n输入:\"010010\"\n输出:5\n```\n**解法一**\n\n直接滑就行了，统计所有0区间的长度，注意组合数的计算就行了\n```java\n// 1 1 1 1 1 (5+4+3+2+1) = n(n-1)/2 + n or n(n+1)/2\npublic int stringCount(String str) {\n    // Write your code here.\n    int left = 0, right = 0;\n    int res = 0;\n    while (right < str.length()) {\n        while(right < str.length() && str.charAt(right) == '0'){\n            right++;\n        }\n        // (0  0  0) 1 1\n        //  l  n     r\n        int n = right-left;\n        //C(n+1,2)/2\n        res += n*(n+1)/2;\n        right++;\n        left = right;\n    }\n    return res;\n}\n```\n\n## [1529. 绝对差不超过限制的三元子数组（LintCode](https://www.lintcode.com/problem/triplet-subarray-with-absolute-diff-less-than-or-equal-to-limit/description)）\n\n给定一个递增的整数数组nums，和一个表示限制的整数limit，请你返回满足条件的三元子数组的个数，使得该子数组中的任意两个元素之间的绝对差小于或者等于limit。\n\n如果不存在满足条件的子数组，则返回 0 。\n\n**数据范围：** 1 ≤ len(nums) ≤ 1e4，1 ≤ limit ≤ 1e6，0 ≤ nums[i] ≤ 1e6\n由于答案可能很大，请返回它对99997867取余后的结果。\n\n**样例 1:**\n```go\n输入：[1, 2, 3, 4], 3\n输出：4\n解释：可选方案有(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)。因此，满足条件的三元组有4个。\n```\n\n**样例 2:**\n```go\n输入：[1, 10, 20, 30, 50], 19\n输出：1\n解释：唯一可行的三元组是(1, 10, 20)，所以答案为1。\n```\n**挑战**\n你可以只用O(n)的时间复杂度解决这个问题吗？\n\n**解法一**\n\n我一开始看见是Hard想的挺复杂的，什么单调栈都搞出来了，但是仔细看题会发现题目给的数组是有序的，所以直接滑窗然后统计就行了，这里需要注意计算的方式，避免算重\n```java\n//LintCode上居然是Hard，感觉不是很难\npublic int tripletSubarray(int[] nums, int limit) {\n    // write your code here\n    int n = nums.length;\n    int left = 0, right = 0;\n    int res = 0;\n    while (left <= right) {\n        //找到最远的合法right\n        while (right < n && nums[right]-nums[left] <= limit) {\n            right++;\n        }\n        //  1  (2 3 4)  5\n        //left   len  right\n        int len = right-left-1;\n        left++;\n        if (len < 2) continue;\n        //C(len,2) 求以left开头，包含left的所有3元组，这样不会重复\n        res += len*(len-1)/2;\n    }\n    return res;\n}\n```\n> 感觉自己静下心来想的话很多题目还是可以自己做出来的，但是就是想的可能有点慢，特别是竞赛中，规定了时间后一慌就更慢了。。看来还是练少了\n\n## [1375. 至少K个不同字符的子串（LintCode）](https://www.lintcode.com/problem/substring-with-at-least-k-distinct-characters/description)\n\n给定一个仅包含小写字母的字符串 S.\n\n返回 S 中至少包含 k 个不同字符的子串的数量.\n\n- 10 ≤ length(S) ≤ 1,000,000\n- 1 ≤ k ≤ 26\n\n**样例 1:**\n```go\n输入: S = \"abcabcabca\", k = 4\n输出: 0\n解释: 字符串中一共就只有 3 个不同的字符.\n```\n**样例 2:**\n```go\n输入: S = \"abcabcabcabc\", k = 3\n输出: 55\n解释: 任意长度不小于 3 的子串都含有 a, b, c 这三个字符.\n    比如,长度为 3 的子串共有 10 个, \"abc\", \"bca\", \"cab\" ... \"abc\"\n    长度为 4 的子串共有 9 个, \"abca\", \"bcab\", \"cabc\" ... \"cabc\"\n    ...\n    长度为 12 的子串有 1 个, 就是 S 本身.\n    所以答案是 1 + 2 + ... + 10 = 55.\n```\n\n**解法一**\n\n经典滑窗，非常套路，想好怎么统计就行了\n```java\npublic long kDistinctCharacters(String s, int k) {\n    int n = s.length();\n    int left = 0;\n    int[] freq = new int[128];\n    int count = 0;\n    long res = 0;\n    for (int right = 0; right < n; right++) {\n        char cr = s.charAt(right);\n        if (freq[cr] == 0) {\n            count++;\n        }\n        freq[cr]++;\n        while (count >= k && left <= right) {\n            // abc | abcabcabc\n            // l r(2)          n(12)\n            //统计以s[left,right]开头的所有子串\n            //10+9+8+7+...+1\n            res += n-right;\n            char cl = s.charAt(left);\n            freq[cl]--;\n            if (freq[cl] <= 0) {\n                count--;\n            }\n            left++;\n        }\n    }\n    return res;\n}\n```\n\n## [386. 最多有k个不同字符的最长子字符串(LintCode)](https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description)\n\n给定字符串S，找到最多有k个不同字符的最长子串T。\n\n**样例 1:**\n```go\n输入: S = \"eceba\" 并且 k = 3\n输出: 4\n解释: T = \"eceb\"\n```\n**样例 2:**\n```go\n输入: S = \"WORLD\" 并且 k = 4\n输出: 4\n解释: T = \"WORL\" 或 \"ORLD\"\n```\n**挑战**： O(n) 时间复杂度\n\n**解法一**\n\n无脑滑窗就行了，太套路了\n```java\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    // write your code here\n    int n = s.length();\n    int left = 0;\n    int res = 0;\n    int[] freq = new int[128];\n    int count = 0;\n    for (int right = 0; right < n; right++) {\n        char cr = s.charAt(right);\n        if (freq[cr] == 0) {\n            count++;\n        }\n        freq[cr]++;\n        while (left <= right && count > k) {\n            char cl = s.charAt(left);\n            freq[cl]--;\n            if (freq[cl] <= 0) {\n                count--;\n            }\n            left++;\n        }\n        res = Math.max(res, right-left+1);\n    }\n    return res;\n}\n```\n## [1675. 数组的最小偏移量](https://leetcode-cn.com/problems/minimize-deviation-in-array/)\n\nDifficulty: **困难**\n\n\n给你一个由 `n` 个正整数组成的数组 `nums` 。\n\n你可以对数组的任意元素执行任意次数的两类操作：\n\n*   如果元素是偶数 ，除以 `2`\n    *   例如，如果数组是 `[1,2,3,4]` ，那么你可以对最后一个元素执行此操作，使其变成 `[1,2,3,2]`\n*   如果元素是奇数 ，乘上 `2`\n    *   例如，如果数组是 `[1,2,3,4]` ，那么你可以对第一个元素执行此操作，使其变成 `[2,2,3,4]`\n\n数组的 **偏移量** 是数组中任意两个元素之间的 **最大差值** 。\n\n返回数组在执行某些操作之后可以拥有的 **最小偏移量** 。\n\n**示例 1：**\n\n```c\n输入：nums = [1,2,3,4]\n输出：1\n解释：你可以将数组转换为 [1,2,3,2]，然后转换成 [2,2,3,2]，偏移量是 3 - 2 = 1\n```\n\n**示例 2：**\n\n```c\n输入：nums = [4,1,5,20,3]\n输出：3\n解释：两次操作后，你可以将数组转换为 [4,2,5,5,3]，偏移量是 5 - 2 = 3\n```\n\n**示例 3：**\n\n```c\n输入：nums = [2,10,8]\n输出：3\n```\n\n**提示：**\n\n*   n == nums.length\n*   2 <= n <= 10<sup><span style=\"display: inline;\">5</span></sup>\n*   1 <= nums[i] <= 10<sup>9</sup>\n\n**解法一**\n\n和上面[632-最小区间](#632-最小区间)一样，将数据变成和最小区间一样的形式，然后直接套用\n```java\npublic int minimumDeviation(int[] nums) {\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->a[2]-b[2]);\n    List<List<Integer>> lis = new ArrayList<>();\n    int max = 0;\n    for (int i = 0; i < nums.length; i++) {\n        ArrayList<Integer> tmp = new ArrayList<>();\n        if (nums[i] % 2 == 1) {\n            pq.add(new int[]{i, 0, nums[i]});\n            max = Math.max(max, nums[i]);\n            tmp.add(nums[i]);\n            tmp.add(nums[i] * 2);\n        } else {\n            tmp.add(nums[i]);\n            while (nums[i] % 2 == 0) {\n                tmp.add(nums[i]/2);\n                nums[i]/=2;\n            }\n            pq.add(new int[]{i, 0, nums[i]});\n            max = Math.max(max, nums[i]);\n            Collections.reverse(tmp);\n        }\n        lis.add(tmp);\n    }\n    int res = Integer.MAX_VALUE;\n    while (true) {\n        int[] min = pq.poll();\n        res = Math.min(res, max-min[2]);\n        if (min[1]+1 >= lis.get(min[0]).size()) {\n            break;\n        }\n        int next = lis.get(min[0]).get(min[1]+1);\n        pq.add(new int[]{min[0], min[1]+1, next});\n        max = Math.max(max, next);\n    }\n    return res;\n}\n```\n\n**解法二**\n\n```java\n    public int minimumDeviation2(int[] nums) {\n        int INF = 0x3f3f3f3f;\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b-a);\n        int min = INF;\n        for (int i = 0; i < nums.length; i++) {\n            if ((nums[i] & 1) == 1) {\n                nums[i] <<= 1;\n            }\n            min = Math.min(min, nums[i]);\n            pq.add(nums[i]);\n        }\n        int res = INF;\n        while (true) {\n            int max = pq.poll();\n            res = Math.min(res, max-min);\n            if ((max&1)==1) {\n                break;\n            }\n            pq.add(max/2);\n            min = Math.min(min, max/2);\n        }\n        return res;\n    }\n```","tags":["LeetCode","滑动窗口"],"categories":["算法"]},{"title":"Socket网络编程","url":"/2019/07/19/socket-wang-luo-bian-cheng/","content":"\n### Socket概述\n\n​\t套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。socket提供的函数是**操作系统内核将“TCP/IP协议栈 + 底层网卡”抽象出来的一个个用户友好的函数，用于操纵本地的“TCP/IP协议栈 + 底层网卡”与远端的服务器/主机完成通信的任务。**\n\n### TCP\n\n🔸 TCP是面向连接的通信协议\n\n🔸 通过`三次握手`建立连接，通讯完成时要拆除连接\n\n🔸 由于TCP是面向连接的所以只能用于端到端的通讯\n\n🔸 三次握手四次挥手\n\n🔸 具有校验机制，可靠，数据传输稳定\n\n#### 简单的Socket小案例\n\n**Socket客户端**\n\n```java\npackage TcpDemo;\nimport java.io.*;\nimport java.net.*;\nimport java.util.Scanner;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 9:45\n */\npublic class Client {\n    private static final int REMOTE_PORT = 20000;\n\n    private static final int LOCAL_PORT = 30000;\n\n    public static void main(String[] args) throws IOException {\n        Socket socket = creatSocket();\n        initSocket(socket);\n        //setRecessAddress前\n        socket.bind(new InetSocketAddress(InetAddress.getLocalHost(), LOCAL_PORT));\n        //连接远程server\n        socket.connect(new InetSocketAddress(InetAddress.getLocalHost(), REMOTE_PORT), 3000);\n        System.out.println(\"客户端已经发起连接\");\n        System.out.println(\"客户端信息:\" + socket.getLocalAddress() + \"port:\" + socket.getLocalPort());\n        System.out.println(\"服务端信息\" + socket.getInetAddress() + \"port:\" + socket.getPort());\n        try {\n            sendMsg(socket);\n        } catch (Exception e) {\n            System.err.println(\"连接异常关闭！！！！\");\n            e.printStackTrace();\n        } finally {\n            socket.close();\n        }\n    }\n\n    private static void initSocket(Socket socket) throws SocketException {\n        socket.setSoTimeout(3000);\n        //是否复用未完全关闭后的端口(TIME_WAIT状态)，必须在bind前，所以就不能通过构造器来绑定本地端口\n        socket.setReuseAddress(true);\n        //是否开启Nagle算法(默认开启) https://baike.baidu.com/item/Nagle%E7%AE%97%E6%B3%95\n        socket.setTcpNoDelay(false);\n        //长时间无数据相应的时候发送确认数据（心跳包）时间大约两个小时\n        socket.setKeepAlive(true);\n        \n        /*\n          close关闭后的处理\n          这个Socket选项可以影响close方法的行为。\n          false 0 默认情况 关闭后立即返回，底层系统接管输出流，将缓冲区的数据发送完成\n          true 0 关闭后直接返回 缓冲区数据直接抛弃 直接发送RES结束命令到对方，无需经过2MSL等待\n          true 200 关闭时最长阻塞200s 随后按第二情况处理\n          (是s不是ms,开始搞错了 设置了20重启就会端口占用。。。。)\n        */\n        socket.setSoLinger(true, 0);\n       \n        /*\n        设置紧急数据是否内敛,如果这个Socket选项打开，\n        可以通过Socket类的sendUrgentData方法\n        向服务器发送一个单字节的数据 这个单字节数据并不经过输出缓冲区，而是立即发出。\n        虽然在客户端并不是使用OutputStream向服务器发送数据，\n        但在服务端程序中这个单字节的数据是和其它的普通数据混在一起的\n        因此，在服务端程序中并不知道由客户\n        端发过来的数据是由OutputStream\n        还是由sendUrgentData发过来的\n        */\n        socket.setOOBInline(true);\n        //设置收发缓冲器大小，默认32K\n        socket.setReceiveBufferSize(64*1024);\n        socket.setSendBufferSize(64*1024);\n        //设置性能参数的 优先级  短链接 延迟 带宽\n        socket.setPerformancePreferences(1,1,1);\n    }\n    @SuppressWarnings(\"all\")\n    private static Socket creatSocket() throws IOException {\n        /*\n        //无代理模式, 相当于空构造函数\n        Socket socket = new Socket(Proxy.NO_PROXY);\n        //HTTP代理模式传输的数据将通过www.imlgw.top转发\n        socket = new Socket(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(Inet4Address.getByName(\"www.imlgw.top\"), 80)));\n\n        //下面两种方式回在创建的时候就去链接远程的服务器(具体看源码),然而一般情况下其实在连接之前我们还需要设置一些参数\n        //新建一个套接字 链接到远程服务器和端口（本地端口为系统分配）\n        socket = new Socket(\"imlgw.top\", REMOTE_PORT);\n        //新建套接字直接链接到远程端口 并绑定本地端口\n        socket=new Socket(\"imlgw.top\",REMOTE_PORT,InetAddress.getLocalHost(),LOCAL_PORT);\n        */\n\n        //新建socket然后绑定到本地端口\n        Socket socket = new Socket();\n        return socket;\n    }\n\n\n    private static void sendMsg(Socket socket) throws IOException {\n        //键盘的输入流\n        Scanner scanner = new Scanner(System.in);\n        //拿到socket的输出流\n        OutputStream socketOutputStream = socket.getOutputStream();\n        //转换为打印流\n        PrintStream printStream = new PrintStream(socketOutputStream);\n        //socket的输入流\n        InputStream inputStream = socket.getInputStream();\n        //转换位buffer流\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n        boolean flag = true;\n        do {\n            //客户端发送消息\n            printStream.println(scanner.nextLine());\n            //服务端的响应\n            String s = bufferedReader.readLine();\n            if (\"bye\".equals(s)) {\n                flag = false;\n            } else {\n                System.out.println(\"服务端响应：\" + s);\n            }\n        } while (flag);\n        bufferedReader.close();\n        printStream.close();\n        scanner.close();\n    }\n}\n```\n\n**Socket服务端**\n\n 这里为了同时处理多个客户端设计成了**多线程**异步的模式\n\n```java\npackage TcpDemo;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.*;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 9:46\n */\npublic class Server {\n\n    private static final int SERVER_PORT = 20000;\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket server = creatServerSocket();\n        initServerSocket(server);\n        //初始化之后再绑定，不然一些设置会失效，比如 setReuseAddress\n        server.bind(new InetSocketAddress(InetAddress.getLocalHost(), SERVER_PORT), 50);\n        System.out.println(\"服务器准备就绪\");\n        System.out.println(\"服务端信息\" + server.getInetAddress() + \" port:\" + server.getLocalPort());\n        //监听客户端的消息\n        while (true) {\n            //阻塞方法\n            Socket client = server.accept();\n            ClientHandle clientHandle = new ClientHandle(client);\n            new Thread(clientHandle).start();\n        }\n    }\n\n    private static void initServerSocket(ServerSocket server) throws SocketException {\n        //同client\n        server.setReuseAddress(true);\n        //设置accept的buffer\n        server.setReceiveBufferSize(64 * 1024);\n        //设置timeout\n        //server.setSoTimeout(2000);\n        //设置性能参数,连接前设置\n        server.setPerformancePreferences(1, 1, 1);\n    }\n\n    private static ServerSocket creatServerSocket() throws IOException {\n        ServerSocket server = new ServerSocket();\n        //绑定端口 backlog:新连接队列的长度限制,不是链接的数量,是允许等待的队列长度\n        //server.bind(new InetSocketAddress(InetAddress.getLocalHost(),SERVER_PORT),50);\n        //server =new ServerSocket(SERVER_PORT,50); 等效方案\n        //server =new ServerSocket(SERVER_PORT,50,InetAddress.getLocalHost());\n        return server;\n    }\n\n    private static class ClientHandle implements Runnable {\n        private Socket socket;\n\n        ClientHandle(Socket client) {\n            this.socket = client;\n        }\n\n        //接收消息\n        public void run() {\n            System.out.println(\"新客户端连接：\" + socket.getInetAddress() + \"port：\" + socket.getPort());\n            try {\n                //输入流获取信息\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                //输出流响应客户端\n                PrintStream printStream = new PrintStream(socket.getOutputStream());\n                boolean flag = true;\n                do {\n                    String s = reader.readLine();\n                    if (\"bye\".equalsIgnoreCase(s)) {\n                        flag = false;\n                        System.out.println(\"客户端关闭了连接\");\n                        printStream.println(\"bye\");\n                    } else {\n                        System.out.println(s);\n                        printStream.println(\"字符串长度#\" + s.length());\n                    }\n                } while (flag);\n                reader.close();\n                printStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n> 具体的一些常用的方法解释都在代码的注释中 [参考](https://elf8848.iteye.com/blog/1739598)\n\n![mark](http://static.imlgw.top/image/20190707/eBKfzShaiIHU.png?imageslim)\n\n#### 传输基本数据类型\n\n上面的哪个小案例传送的都是字符串类型的数据，也许有同学会说这些基本类型不都是可以通过字符串来传吗？为什么要费那个劲去传这些基本类型？其实不然，这里假设要传送的是 int类型的12345678 ，如果通过 `int` 来传输只要在范围内都是**4**个字节大小固定，然而通过`String`传送将会是\"12345678\" 也就是**8**个字节，消耗要比使用`int`要大，而且长度不固定，不方便后期接受的长度判断。\n\n **`int` 类型**  \n\n在网络上传输的都是以**Byte**为基本单位，如果要传送**int**我们就需要将**int**转换为**byte**，一个**int**是4个字节，我们可以将其转换为一个**byte[]**数组，废话不多说，上代码\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/11 13:23\n */\npublic class ByteTools {\n    public static byte[] int2byte(int a) {\n        //无符号右移\n        return new byte[]{\n                (byte) (a >>> 24),\n                (byte) (a >>> 16),\n                (byte) (a >>> 8),\n                (byte) (a)\n        };\n    }\n    public static int byte2int(byte[] a) {\n        //&0xff-->转换为int 将高位补0,低8位不变\n        //-127 ：10000001(补) &0xff --> 00000000 00000000 00000000 10000001\n        return a[3] & 0xff | (a[2] & 0xff) << 8 | (a[1] & 0xff) << 16 | (a[0] & 0xff) << 24;\n    }\n}\n```\n\n为什么这样做的一些细节可以参考 [这篇博客](https://www.cnblogs.com/think-in-java/p/5527389.html)\n\n有了这个工具类我们就可以将**int**转换为**byte[]**后进行传输，同时接收端也可以通过这个方法将数据还原。\n\n等等🙄 ，这样一来不是所有的类型对应的都要去写个这样的转换的方法？那还是有点麻烦的，而且也没有什么技术含量，所以这样的事情**JDK**帮我们做了\n\n**`ByteBuffer`**：nio中的一个包，这里我还不太熟悉这个具体的作用，目前只知道可以用来包装**byte[]**，然后可以实现上面的类型转换\n\n**Client发送端**\n\n```java\nbyte[] buffer=new byte[256];\n//包装buffer (装饰器模式？\nByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\n//byte  1\nbyteBuffer.put((byte) 126);\n//int 类型 4\nbyteBuffer.putInt(123);\n//char 2(unicode)\nbyteBuffer.putChar('A');\n//long 8\nbyteBuffer.putLong(323333231234124321L);\nboolean isOk=true;\n//byte 1\nbyteBuffer.put((byte) (isOk?1:0));\n//float 4\nbyteBuffer.putFloat(123.2132F);\n//double 8 =28\nbyteBuffer.putDouble(231.1412421321);\n//String 10\nbyteBuffer.put(\"HelloWorld\".getBytes());\n//发送 38 Byte \nsocketOutputStream.write(buffer,0,byteBuffer.position());\n```\n\n需要注意的地方就是最后**write**的时候，第二个参数**len**，直接传**position()**,就可以了，不用+1，这个position是下一个字节位置\n\n> 这里其实我看的教程这里是加1了的，最后接收过来的数据长度死活对不上，我开始还以为是什么**内存对齐**，什么乱七八糟的然后才发现是这里有问题。。。\n\n**Server接收端**\n\n基本类型的读取与上面对应的**get**，最后一个String需要注意，直接用原始的**buffer**就可以了，不需要借助**ByteBuffer**，这里同样后面不用-1\n\n```java\nString str = new String(buffer, byteBuffer.position(), readByteCount-byteBuffer.position());\n```\n\n**测试结果**\n\n```java\n服务器准备就绪\n服务端信息LAPTOP-V5R5ABUJ/192.168.25.1 port:20000\n新客户端连接：/192.168.25.1port：30000\n当前下标28\n接受到Client数据长度(byte)：38\nClient发送的数据:\n126\n123\nA\n323333231234124321\ntrue\n123.2132\n231.1412421321\nHelloWorld\n```\n\n### UDP\n\n🔸  UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。\n\n🔸  UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。\n\n🔸   UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。\n\n🔸   UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如IP电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP正好符合这种要求。\n\n🔸   UDP支持一对一、一对多、多对一和多对多的交互通信。\n\n🔸   UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。\n\n#### 单播\n\n**消息接收者**\n\n```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketAddress;\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\npublic class UDPProvide {\n    public static void main(String[] args) throws IOException {\n        //监听20000端口\n        DatagramSocket socket=new DatagramSocket(20000);\n        System.out.println(\"UDPProvide is start....\");\n        final byte[] buf=new byte[512];\n        //构建接受的DatagramPacket\n        DatagramPacket udp_receive=new DatagramPacket(buf,buf.length);\n        //构建接受的DatagramPacket (阻塞)\n        socket.receive(udp_receive);\n        //获取发送人的SocketAddress\n        SocketAddress socketAddress = udp_receive.getSocketAddress();\n        int datalen = udp_receive.getLength();\n        //获取发送的数据\n        String receive=new String(udp_receive.getData(),0,datalen);\n        System.out.println(\"receive from the: \"+socketAddress);\n        System.out.println(\"receive data: \"+ receive);\n        //构建响应的DatagramPacket\n        byte[] bytes = (\"provider receive the data success \"+datalen).getBytes();\n        DatagramPacket udp_sendBack=new DatagramPacket(bytes,bytes.length,socketAddress);\n        socket.send(udp_sendBack);\n        //结束\n        System.out.println(\"UDPProvide Finished.\");\n        socket.close();\n    }\n}\n```\n\n**消息发送者**\n\n```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\n\npublic class UDPSearch {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"UDPSearch is ready...\");\n        //构建socket\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buff= \"hello world\".getBytes();\n        //构建发送段\n        DatagramPacket udp_send=new DatagramPacket(buff,buff.length);\n        //指定对方ip\n        udp_send.setAddress(InetAddress.getLocalHost());\n        udp_send.setPort(20000);\n        socket.send(udp_send);\n        //获取响应段\n        final byte[] buf=new byte[512];\n        DatagramPacket udp_receive=new DatagramPacket(buf,buf.length);\n        socket.receive(udp_receive);\n        String s = new String(udp_receive.getData(), 0, udp_receive.getLength());\n        System.out.println(s);\n        System.out.println(\"UDPSearch is over\");\n        socket.close();\n    }\n}\n```\n\n#### 多播&广播\n\n**消息建造器**\n\n```java\n/**\n * @author imlgw.top\n * @date 2019/7/8 8:48\n */\npublic class MessageCreator {\n    private static final String SN_HEADER = \"收到暗号,我是SN:\";\n    private static final String PORT_HEADER = \"这是暗号,请回送到该端口:\";\n\n    public static String buildWithPort(int port) {\n        return PORT_HEADER + port;\n    }\n\n    public static int parsePort(String sn) {\n        if (sn.startsWith(PORT_HEADER)) {\n            return Integer.parseInt(sn.substring(PORT_HEADER.length()));\n        }\n        return  -1;\n    }\n\n    public static String buildWithSn(String sn){\n        return SN_HEADER+sn;\n    }\n\n    public static String parseSn(String sn){\n        if(sn.startsWith(SN_HEADER)){\n            return sn.substring(SN_HEADER.length());\n        }\n        return null;\n    }\n}\n```\n\n**消息接受者**\n\n```java\npackage UdpDemo2;\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.UUID;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\npublic class UDPProvide {\n    public static int PROVIDE_LISTEN_PORT = 20000;\n\n    public static void main(String[] args) throws IOException {\n        String sn = UUID.randomUUID().toString();\n        Provider provider = new Provider(sn);\n        new Thread(provider).start();\n        System.in.read();\n        provider.shutdown();\n    }\n\n    public static class Provider implements Runnable {\n        public volatile boolean isDone = false;\n        public DatagramSocket socket = null;\n        public final String sn;\n\n        public Provider(String sn) {\n            this.sn = sn;\n        }\n\n        public void run() {\n            System.out.println(\"UDPProvide is start....\");\n            try {\n                socket = new DatagramSocket(PROVIDE_LISTEN_PORT);\n                while (!isDone) {\n                    final byte[] buf = new byte[512];\n                    //构建接受的DatagramPacket\n                    DatagramPacket udp_receive = new DatagramPacket(buf, buf.length);\n                    //接受DatagramPacket (阻塞)\n                    socket.receive(udp_receive);\n                    //获取发送人的SocketAddress\n                    InetSocketAddress socketAddress = (InetSocketAddress) udp_receive.getSocketAddress();\n                    int datalen = udp_receive.getLength();\n                    //获取发送过来的数据\n                    String receive = new String(udp_receive.getData(), 0, datalen);\n                    //打印获取到的数据\n                    System.out.println(\"receive from the: \" + socketAddress);\n                    System.out.println(\"receive data: \" + receive);\n                    //解析sn,获取需要回送的端口\n                    int port = MessageCreator.parsePort(receive);\n                    if (port != -1) {\n                        //构建回送的DatagramPacket\n                        byte[] responseBody = MessageCreator.buildWithSn(sn).getBytes();\n                        DatagramPacket udp_sendBack = new DatagramPacket(responseBody, 0, responseBody.length, socketAddress.getAddress(), port);\n                        socket.send(udp_sendBack);\n                    }\n                }\n            } catch (IOException e) {\n                // e.printStackTrace();\n            } finally {\n                closeRes();\n            }\n            //结束\n            System.out.println(\"UDPProvide Finished.\");\n        }\n\n        public void shutdown() {\n            isDone = true;\n            //这里仅仅isDone=true 远远不够,因为socket.receive是一个永久阻塞的方法\n            //所以下面还要close这个socket这样就会捕获到一个异常然后结束\n            closeRes();\n        }\n\n        private void closeRes() {\n            if (socket != null) {\n                socket.close();\n                socket = null;\n            }\n        }\n    }\n}\n```\n\n与上面不同的是这里为了随时可以停止将其构建成了异步线程，当接受到终止信号的时候就会改变状态量，并close资源，然后利用异常停止线程。\n\n**消息发送者**\n\n```java\npackage UdpDemo2;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n/**\n * @author imlgw.top\n * @date 2019/7/7 21:31\n */\n\npublic class UDPSearch {\n    private static final int SEARCH_LISTEN_PORT = 30000;\n    private static DatagramSocket socket = null;\n    public static void main(String[] args) throws IOException, InterruptedException {\n        System.out.println(\"UDPSearch is start...\");\n        Listener listen = listen();\n        sendBoard();\n        System.in.read();\n        List<Device> devices = listen.closeAndGetDeviceList();\n        for (Device device : devices) {\n            System.out.println(device);\n        }\n    }\n\n    private static Listener listen() throws InterruptedException {\n        System.out.println(\"UDPSearch Listener is start\");\n        CountDownLatch countDownLatch=new CountDownLatch(1);\n        Listener listener=new Listener(SEARCH_LISTEN_PORT,countDownLatch);\n        new Thread(listener).start();\n        countDownLatch.await();\n        return listener;\n    }\n\n    public static void sendBoard() throws IOException {\n        //系统自动分配的端口\n        DatagramSocket socket = new DatagramSocket();\n        //构建socket\n        byte[] buff = MessageCreator.buildWithPort(SEARCH_LISTEN_PORT).getBytes();\n        //构建发送段\n        DatagramPacket udp_send = new DatagramPacket(buff, buff.length);\n        //广播地址\n        udp_send.setAddress(InetAddress.getByName(\"255.255.255.255\"));\n        //接收方的端口\n        udp_send.setPort(UDPProvide.PROVIDE_LISTEN_PORT);\n        socket.send(udp_send);\n        socket.close();\n        System.out.println(\"UDPSearch Board is over\");\n    }\n\n    private static class Device {\n        int port;\n        String ip;\n        String sn;\n\n        public Device(int port, String ip, String sn) {\n            this.port = port;\n            this.ip = ip;\n            this.sn = sn;\n        }\n        @Override\n        public String toString() {\n            return \"Device{\" +\n                    \"port=\" + port +\n                    \", ip='\" + ip + '\\'' +\n                    \", sn='\" + sn + '\\'' +\n                    '}';\n        }\n    }\n\n    public static class Listener implements Runnable {\n        private final int listenPort;\n        private final CountDownLatch countDownLatch;\n        private final List<Device> deviceList = new ArrayList<Device>();\n        //private static DatagramSocket socket = null;\n\n        private boolean isDone = false;\n\n        public Listener(int listenPort, CountDownLatch countDownLatch) {\n            this.listenPort = listenPort;\n            this.countDownLatch = countDownLatch;\n        }\n\n        public void run() {\n            //通知已经启动\n            countDownLatch.countDown();\n            try {\n                socket = new DatagramSocket(listenPort);\n                while (!isDone) {\n                    final byte[] buf = new byte[512];\n                    //构建接受的DatagramPacket\n                    DatagramPacket udp_receive = new DatagramPacket(buf, buf.length);\n                    //接受DatagramPacket (阻塞)\n                    socket.receive(udp_receive);\n                    //获取发送人的SocketAddress\n                    InetSocketAddress socketAddress = (InetSocketAddress) udp_receive.getSocketAddress();\n                    int datalen = udp_receive.getLength();\n                    //获取发送过来的数据\n                    String sn = new String(udp_receive.getData(), 0, datalen);\n                    System.out.println(\"back from the：\" + socketAddress);\n                    System.out.println(\"back data：\" + sn);\n                    sn=MessageCreator.parseSn(sn);\n                    if (sn != null) {\n                        deviceList.add(new Device(socketAddress.getPort(), socketAddress.getAddress().toString(), sn));\n                    }\n                }\n            } catch (IOException e) {\n               //e.printStackTrace();\n            } finally {\n                closeRes();\n            }\n            System.out.println(\"UDPSearch Listener is Finished...\");\n        }\n\n        public void closeRes() {\n            if (socket != null) {\n                socket.close();\n                socket = null;\n            }\n        }\n\n        List<Device> closeAndGetDeviceList() {\n            isDone = true;\n            closeRes();\n            return deviceList;\n        }\n    }\n}\n\n```\n\n这里需要注意的就是广播的地址**255.255.255.255**\n\n> 如果是在局域网内和其他机器通信需要关闭虚拟机的网卡，不然是走的虚拟机的网卡，其他机器接收不到。(我说怎么发送的**IP**不是我的本机的**IP**)\n\n🔸UDP是面向无连接的通讯协议，基于用户数据报的协议\n\n🔸UDP数据包括目的端口号和源端口号信息\n\n🔸通讯不需要连接，所以可以实现广播发送，并不局限于端到端\n\n🔸结构简单，无校验，速度快，容易丢包，可广播\n\n🔸他一旦把应用程序发给网络层的数据发送出去就不保留数据备份\n\n### UDP辅助TCP 实现点对点传输\n\n客户端先利用`UDP`向局域网发送广播，然后对应的服务器接收到之后就会将对应的`TCP`的端口回送给客户端，然后二者进行TCP的双向通信，代码太多这里就只放一下`Server`端的`Handler`\n\n```java\npackage udp_tcp_concurrency.server.handle;\n\nimport udp_tcp_concurrency.utils.CloseUtils;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * 用来处理客户端的类\n * @author imlgw.top\n * @date 2019/7/17 11:48\n */\npublic  class ClientHandler {\n\n    private final Socket socket;\n    private final ServerReadHandler serverReadHandler;\n    private final ServerWriterHandler serverWriterHandle;\n\n    private final CloseNotify closeNotify;\n\n    public ClientHandler(Socket socket, CloseNotify closeNotify) throws IOException {\n        this.socket = socket;\n        this.serverReadHandler = new ServerReadHandler(socket.getInputStream());\n        this.serverWriterHandle = new ServerWriterHandler(socket.getOutputStream());\n        this.closeNotify = closeNotify;\n        System.out.println(\"新客户端连接：\" + socket.getInetAddress() + \"port：\" + socket.getPort());\n    }\n\n    public void send(String str) {\n        serverWriterHandle.send(str);\n    }\n\n    //从外界关闭\n    public void stop() {\n        serverReadHandler.stopRead();\n        serverWriterHandle.stopWriter();\n        CloseUtils.close(socket);\n        System.out.println(\"客户端已经退出\");\n        System.out.println(\"address:\" + socket.getInetAddress() + \",port:\" + socket.getPort());\n    }\n\n    //自我关闭--->自闭\n    private void stopByMyself() {\n        stop();\n        closeNotify.onSelfClosed(this);\n    }\n\n    //读取并打印到屏幕(启动ClientReadHandle线程)\n    public void read2Print() {\n        new Thread(serverReadHandler).start();\n    }\n\n    /**\n     *  将已经关闭的handle暴露给TCPServer然后从list中移除\n     */\n    public interface CloseNotify{\n        void onSelfClosed(ClientHandler clientHandler);\n    }\n\n    /**\n     * 处理服务端用于读取客户端消息的 Handle\n     */\n    class ServerReadHandler implements Runnable {\n        private boolean done = false;\n        private final InputStream inputStream;\n\n        public ServerReadHandler(InputStream inputStream) {\n            this.inputStream = inputStream;\n        }\n\n        public void run() {\n            try {\n                //输入流获取信息\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                do {\n                    String s = reader.readLine();\n                    if (s == null) {\n                        System.out.println(\"客户端已经无法发送数据\");\n                        //结束当前Handle\n                        ClientHandler.this.stopByMyself();\n                        break;\n                    }\n                    //打印到屏幕\n                    System.out.println(s);\n                } while (!done);\n            } catch (IOException e) {\n                if (!done) {\n                    //非正常关闭\n                    System.err.println(\"连接异常断开\"+e.getMessage());\n                    ClientHandler.this.stopByMyself();\n                }\n            } finally {\n                CloseUtils.close(inputStream);\n            }\n        }\n\n        public void stopRead() {\n            done = true;\n            CloseUtils.close(inputStream);\n        }\n    }\n\n    /**\n     * 处理服务端向客户端发送消息的Handle\n     */\n    class ServerWriterHandler  {\n        private boolean done = false;\n        private final PrintStream printStream;\n        //线程池\n        private final ExecutorService executorService;\n\n        public ServerWriterHandler(OutputStream outputStream) {\n            this.printStream = new PrintStream(outputStream);\n            //单例线程池\n            executorService = Executors.newSingleThreadExecutor();\n        }\n\n        public void send(String str) {\n            //这里如果不用线程池\n            executorService.submit(new WriteRunnable(str));\n        }\n\n        //线程池的Runnable\n        class WriteRunnable implements Runnable {\n            private final String msg;\n\n            public WriteRunnable(String msg) {\n                this.msg = msg;\n            }\n\n            @Override\n            public void run() {\n                if(ServerWriterHandler.this.done){\n                    return;\n                }\n                try {\n                    ServerWriterHandler.this.printStream.println(msg);\n                }catch (Exception e){\n                    System.out.println(\"write 异常退出：\"+e.getMessage());\n                }\n            }\n        }\n        \n        public void stopWriter() {\n            done = true;\n            CloseUtils.close(printStream);\n            executorService.shutdownNow();\n        }\n    }\n}\n\n```\n\n完整代码放在 [github](https://github.com/imlgw/socketDemo) 有一点需要注意的是这里用了一个单线程池去处理服务端发送消息的功能，这里其实用线程通信机制`wait/notify`也可以做到但是相比使用线程池会复杂许多。\n\n### 局域网聊天室实现\n\n> 这里的聊天室，其实关键的地方就在于对客户端发送的消息交由服务端进行转发。\n\n基于上面的进行改造\n\n```java\n/**\n* 回调接口\n*/\npublic interface ClientHandleCallBack {\n    /**\n    * 将已经关闭的handle暴露给TCPServer然后从list中移除\n    */\n\tvoid onSelfClosed(ClientHandler clientHandler);\n\n\n    /**\n    * 将消息交给服务器转发\n    * @param clientHandler\n    * @param msg\n    */\n\tvoid onNewMessageArrived(ClientHandler clientHandler,String msg);\n}\n```\n\n增加一个消息抵达的接口，然后为了避免阻塞交给异步的单线程池去处理\n\n```java\n\t@Override\n    public void onNewMessageArrived(ClientHandler clientHandler, String msg) {\n        System.out.println(\"Receive from:\"+clientHandler.getClientInfo()+\" msg:\"+msg);\n        forwardThreadPool.submit(()->{\n            for (ClientHandler clientHandle : clientHandles) {\n                //跳过自己\n                if(clientHandle.equals(clientHandler)){\n                    continue;\n                }\n                //对其他客户端发送消息\n                clientHandle.send(msg);\n            }\n        });\n    }\n```\n\n详细代码 见[Github](https://github.com/imlgw/socketDemo)\n\n","tags":["Socket"],"categories":["网络编程"]},{"title":"JMeter压测","url":"/2019/06/06/jmeter-ya-ce-gong-ju/","content":"\n## JMeter入门\n\n[官网地址](http://jmeter.apache.org/) 下载好之后直接运行jar包 \n\n### 简单上手\n\n**添加线程组**\n\n![mark](http://static.imlgw.top/image/20190529/wBWwVD5chqtc.png?imageslim)\n\n**设置线程个数和配置**\n\n![mark](http://static.imlgw.top/image/20190529/KonWE6pHVdMz.png?imageslim)\n\nRamp-Up就是多长时间内启动这些线程设置位0就是同时启动。\n\n**设置HTTP请求默认值**\n\n![mark](http://static.imlgw.top/image/20190529/73A4su1jMAWM.png?imageslim)\n\n设置好后再添加具体的请求的时候就不用再写这个了\n\n![mark](http://static.imlgw.top/image/20190529/Uwy5zrWzFsji.png?imageslim)\n\n**添加HTTP请求**\n\n![mark](http://static.imlgw.top/image/20190529/iVbmgkdG7D88.png?imageslim)\n\n这里对我们的秒杀商品列表进行压测。\n\n**添加监听器**\n\n![mark](http://static.imlgw.top/image/20190529/yVm6imNhWYKe.png?imageslim)\n\n这里添加比较常用的聚合报告就可以了\n\n**结果**\n\n![mark](http://static.imlgw.top/image/20190531/C3pwAwyh7BhG.png?imageslim)\n\n这里我们可以需要关注的就是吞吐量这个参数，一开始可能会不太准多测几次。\n\n同时我们也可以用Linux的`top`命令查看当前CPU的利用率。\n\n### 添加自定义参数\n\n![mark](http://static.imlgw.top/image/20190601/VQ9adD8KBfvA.png?imageslim)\n\n![mark](http://static.imlgw.top/image/20190601/j1XB0mewqvJG.png?imageslim)\n\n```java\n17362363659,3d3ae96d381d4376b87cb7ebf14aadb6\n12012341234,fbb11e35f16b4a54be1315a0a1619193\n11012341234,58d63f1d9482472f907829da2ae3b4ff\n10012341234,09fe09587b924c49b6db64f763c1ad10\n```\n\n**效果**\n\n![mark](http://static.imlgw.top/image/20190601/5up85aDbSTWM.png?imageslim)\n\n### 生成token\n\n方便后面的压测，可以直接写一个工具类生成token供后面的redis使用\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest\npublic class TokenUtils {\n\n    @Autowired\n    private SpikeUserService spikeUserService;\n\n    static String str=\"0123456789\";\n\n    static  Random random = new Random();\n\n    static HttpServletResponse resp;\n\n    @Test\n    public  void test() throws IOException {\n        FileOutputStream outputStream=new FileOutputStream(new File(\"D:\\\\AliyunKey\\\\config.txt\"));\n        for (int i=0;i<20000;i++){\n            String phone = creatPhone();\n            RegisterVo registerVo = new RegisterVo(phone,\"123456\",\"user-\"+i);\n            spikeUserService.register(registerVo);\n            //需要在service层token返回出来\n            String token= spikeUserService.login(resp, new LoginVo(registerVo.getMobile(), registerVo.getPassword()));\n            outputStream.write((phone+\",\"+token+\"\\n\").getBytes());\n        }\n    }\n\n    public  String creatPhone(){\n        String res=\"1\";\n        for (int i=0;i<10;i++){\n            res+=str.charAt(random.nextInt(10));\n        }\n        return res;\n    }\n}\n```\n\n### Redis压测\n\n①redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000\n\n100个并发，十万个请求，对常用的一些命令进行测试\n\n![mark](http://static.imlgw.top/image/20190601/oPkioXCFgL8R.png?imageslim)\n\n②redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100\n\n100 bytes payload \n\n-q 是quiet输出信息较少\n\n③ redis-benchmark -n 100000 -q script load \"redis.call('set','foo','bar')\"\n\n对特定的语句压测\n\n\n\n##  搭建压测环境\n\n### 命令行压测\n\n其实还是需要借助图形界面来录好jmx文件然后上传到Linux上，然后执行\n\nsh jmeter.sh -n -t Xxx.jmx -l result.jtl\n\n然后再用图形界面导入result.jtl就可以看到结果\n\n> 上面的测试都是在我的开发机(win)上进行的，压测和服务都在本地，结果可能并不准确，这里为了隔离环境我开了了2个虚拟机，一个是部署服务的机器（2G 4核），一个是部署mysql和redis的机器（2G 4核），这里在Linux上运行部署项目有两种方式，一种是打成war包放在tomcat目录下，一种是打成jar包直接运行。\n\n### 环境\n\n✔ 192.168.25.123   Centos6  mysql+redis  2G4核\n\n✔ 192.168.25.4     Centos7   SpikeServer+压测  2.5G 4核\n\n✔~~win10开发机     Jmeter压测 SpikeServer~~ \n\n✔~~192.168.25.129 Centos7 压测设备 2G4核~~\n\n### SpringBoot打war包\n\n**添加tomcat依赖(编译时依赖)**\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n\t<scope>provided</scope>\n</dependency>\n```\n\n**添加一个maven插件**\n\n```java\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-war-plugin</artifactId>\n\t<configuration>\n    \t<failOnMissingWebXml>false</failOnMissingWebXml>\n\t</configuration>\n</plugin>\n```\n\n**修改pom打包方式位war**\n\n```java\n<packaging>war</packaging>\n```\n\n**boot类添加一个方法**\n\n```java\n@SpringBootApplication\npublic class SpikeApplication extends SpringBootServletInitializer {\n    public static void main(String[] args) {\n        SpringApplication.run(SpikeApplication.class, args);\n    }\n    /**\n     * @param builder\n     * @return 打 war包\n     */\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\n        return builder.sources(SpikeApplication.class);\n    }\n}\n```\n\n然后在项目目录下执行`mvn clean package`就会在target目录下生成war包，然后将war包拷到tomcat里面就可以直接运行了。\n\n### SpringBoot打jar包\n\n**pom里的打包方式改为jar(默认就是jar)**\n\n```java\n<packaging>war</packaging>\n```\n\n**添加一个maven插件**\n\n```java\n<!--打jar包的插件-->\n<plugin>\n    <groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-maven-plugin</artifactId>\n</plugin>\n```\n\n**执行mvn clean package**\n\n同上会在target目录下生成一个jar包，jar包内容大致如下\n\n```java\nManifest-Version: 1.0\nImplementation-Title: Spike\nImplementation-Version: 1.0-SNAPSHOT\nBuilt-By: priva\nImplementation-Vendor-Id: top.imlgw\nSpring-Boot-Version: 2.1.2.RELEASE\nMain-Class: org.springframework.boot.loader.JarLauncher\nStart-Class: top.imlgw.spike.SpikeApplication\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nCreated-By: Apache Maven 3.5.3\nBuild-Jdk: 1.8.0_172\nImplementation-URL: https://projects.spring.io/spring-boot/#/spring-bo\n ot-starter-parent/Spike\n```\n\n如果确少一些信息比如Main-Class和Start-Class，说明jar包打的有问题，运行会报`没有主清单属性`，我一开始没注意，我的`plugins`上层还有个`pluginmanagement`插件根本没加载进来，去掉就行了。\n\n## 开始压测\n\n### 压测商品列表页面\n\n```java\n@RequestMapping(\"/to_list\")\npublic String tolist(Model model,SpikeUser spikeUser) {\n    List<GoodsVo> goodsVos = goodsService.goodsVoList();\n    model.addAttribute(\"user\", spikeUser);\n    model.addAttribute(\"goodsList\",goodsVos);\n\treturn \"goods_list\";\n}\n```\n\n这个接口主要就做了一个查询的mysql的操作，没有cookie所以不会去操作redis\n\n### 遇到的问题\n\n一开始直接设置了 5000*10 的并发，然后服务端报了   打开文件过多的错误\n\n```java\njava.io.IOException: 打开的文件过多\n        at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method) ~[na:1.8.0_171]\n        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422) ~[na:1.8.0_171]\n        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250) ~[na:1.8.0_171]\n        at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:448) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14]\n        at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:70) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14]\n        at org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:95) ~[tomcat-embed-core-9.0.14.jar!/:9.0.14]\n        at java.lang.Thread.run(Thread.java:748) [na:1.8.0_171]\n```\n\ngoogle后发现是句柄太少的原因，Linux默认是1024，而我们同时起了5000个线程自然就出问题了。\n\n通过`ulimit -a` 可以查看到当前的最大句柄数`open files` ，这里我们可以通过 `ulimit -n 2048`临时的设置一个较大的值，但是重启后就会失效。\n\n```java\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 14707\nmax locked memory       (kbytes, -l) 64\nmax memory size         (kbytes, -m) unlimited\nopen files                      (-n) 1024\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 14707\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n这里最好是直接修改  /etc/security/limits.conf\n\n```java\n*  soft nofile  32768\n*  hard nofile 65536\n```\n\n就可以将文件句柄限制统一改成软32768，硬65536。配置文件最前面的是指domain，设置为星号代表全局，另外你也可以针对不同的用户做出不同的限制。\n\n注意：这个当中的硬限制是实际的限制，而软限制，是warnning限制，只会做出warning，其实ulimit命令本身就有分软硬设置，加-H就是硬，加-S就是软\n\n修改后记得重启才会生效 [参考资料](https://www.cnblogs.com/ibook360/archive/2012/05/11/2495405.html) \n\n一开始是打算直接用win开发机做压测的，但是发现在进程开大了之后老是跑不完，跑一半就停了（可能是内存给小了），而且数据出入也比较大，然后改用秒杀服务的那条机器来压测，一开始只增大了跑秒杀服务的虚拟机，发现还是会有异常，然后我把mysql和redis的虚拟机也调大了就没报异常了，但是在压测的时候秒杀服务的虚拟机cpu飙到了 `9.0+`，4核的机子，cpu飙到这么高就有点问题了一般来说应该维持在 `4*0.7` 左右。\n\n![mark](http://static.imlgw.top/image/20190604/LedMcRvfSXeb.png?imageslim)\n\n![mark](http://static.imlgw.top/image/20190604/UbcTCaTGiEJ9.png?imageslim)\n\n可以看到平均等待时间都在2s以上。\n\n为了更准确的模拟，我又开了一台~~1G2核~~ 2G4核的虚拟机专门来做压测（8G内存吃不消了）。\n\n![mark](http://static.imlgw.top/image/20190604/pr4yMAE2Jamf.png?imageslim)\n\n这里用top观察了两台虚拟机的情况发现mysql的那台机器负载一直很低，SpikeServer那台机器（1G双核）负载一路飙到6.0+。吞吐率也明显的下降了，这里我连续测试了两次都是400多。\n\n### 最终配置\n\n经过一上午的折腾，我决定还是值利用两台你虚拟机，一台跑SpikeServer和压测，另外一台跑mysql和redis，再启动一台成本太大了，这里主要根据这个做一个标准量，后期优化后拿来对比\n\n#### 结果\n\n![mark](http://static.imlgw.top/image/20190604/IEGxtWU8pujI.png?imageslim)\n\n后面在调整机器或连续测试了5，6次 在5000的并发下QPS大概是1000左右的样子，小于1000。\n\n### 压测Redis查询的性能\n\n上面的goods_list实际上只对mysql进行了一个查询操作，而mysql的并发量并不大。\n\n下面我们单独对redis做一下压测，看下系统的QPS（这里）\n\n![mark](http://static.imlgw.top/image/20190604/h2NOJszwC7Lo.png?imageslim)\n\n#### 结果\n\n一开测试忘了调大redis链接池的大小，一直跑不出来，后来改大之后测了4，5次，同样的5000并发10次，QPS大概在3000左右\n\n![mark](http://static.imlgw.top/image/20190606/58L5ieKaxR7a.png?imageslim)\n\n可以说是相当快了，而且`top`观察redis那台机器发现负载依然很低，说明这点并发确实对redis来说是小意思，前面其实也单独对redis用它自带的压测工具测试过，大概每秒10 0000的GET是没问题的\n\n### 重头戏—压测do_spike接口\n\n```java\n @RequestMapping(\"/do_spike\")\n public String do_spike(Model model, SpikeUser spikeUser, @RequestParam(\"goodsId\") long goodsId) {\n        if (spikeUser==null) { //没有登录\n            return \"login\";\n        }\n        //检查库存\n        GoodsVo goodsVo= goodsService.getGoodsVoByGoodsId(goodsId);\n        int stock=goodsVo.getStockCount(); //这里拿的秒杀商品里面的库存,不是商品里面的库存\n        if(stock<=0){\n            model.addAttribute(\"failMsg\",CodeMsg.STOCK_EMPTY);\n            return \"spike_fail\";\n        }\n        //看是否重复秒杀\n        SpikeOrder spikeOrder=spikeService.getGoodsVoByUserIdAndGoodsId(spikeUser.getId(), goodsId);\n        if(spikeOrder!=null){\n            model.addAttribute(\"failMsg\",CodeMsg.SKIPE_REPEAT);\n            return \"spike_fail\";\n        }\n        OrderInfo orderInfo=spikeService.doSpike(spikeUser.getId(),goodsVo);\n        model.addAttribute(\"orderInfo\",orderInfo);\n        model.addAttribute(\"goods\",goodsVo);\n        return \"order_detail\";\n }\n```\n\n步骤都跟上面一样，不过要多加一个商品id的参数，这里依然是5000的并发10次，其实这里测出来的结果和上面的商品列表差不太多，差不多950左右QPS，毕竟这里有判断库存的操作，一旦小于0之后就不会对mysql再进行操作，进行复杂的**减库存**和**生成订单**操作\n\n#### 超卖问题\n\n本来只有10件商品，硬生生给减成了负数😂\n\n![mark](http://static.imlgw.top/image/20190606/m5RhIzmdXRV1.png?imageslim)\n\n可以看到有16个人秒杀到了这个商品这显然是不合理的\n\n![mark](http://static.imlgw.top/image/20190606/nJmnvKvVzAHt.png?imageslim)\n\n这个问题会在后面的文章中提出解决方案，这一篇主要熟悉下压测。","tags":["JMeter","秒杀"],"categories":["Web"]},{"title":"WebMvcConfigurer小结","url":"/2019/05/20/webmvcconfigurer/","content":"\n## 起源\n\n利用Redis做分布式session，因为没有借助Spring-session或者其他的session共享方案，手动处理session的存取，在控制层获取cookie中的数据是较为麻烦，所以希望直接将cookie的数据转化为需要的bean然后绑定到参数中，这里就可以借助**WebMvcConfigurer**来实现这个需求简化代码\n\n## WebMvcConfigurer是干嘛的？\n\nSpring把实现了WebMvcConfigurer接口的bean都看作为SpringMvc的**扩展配置**，如果既想要使用SpringBoot对SpringMvc的自动配置，又想要对自动配置进行扩展，添加一些用户自己的配置，像拦截器，消息转换器或者下文中的参数绑定，只需要写一个实现了WebMvcConfigurer接口的配置类，实现相关方法就能够添加自己的配置了。\n\n> SpringBoot2.0之前也就是Spring5之前可以直接继承**WebMvcConfigurationAdapter**+**@EnableWebMvc**注解来实现上述需求，但是这个方法在之后的版本中弃用了(还可以用但是不太好)，因为jdk8之后的接口中可以有**默认方法**了，所以这个抽象类就并没有存在的意义了\n\n### WebMvcConfigurationSupport\n\n其实还有一种方法就是直接继承这个WebMvcConfigurationSupport，上面的WebMvcConfigurer只是扩展配置，如果直接继承WebMvcConfigurationSupport，那么就可以重写默认的配置，如果对原理不是很清楚的开发者不小心重写错了默认的配置，springmvc可能相关功能就无法生效。\n\n## WebMvcConfigurer内的方法\n\n```java\npublic interface WebMvcConfigurer {\n    default void configurePathMatch(PathMatchConfigurer configurer) {\n    }\n\n    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n    }\n\n    default void configureAsyncSupport(AsyncSupportConfigurer configurer) {\n    }\n\n    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n    }\n\n    default void addFormatters(FormatterRegistry registry) {\n    }\n\t\n    //添加拦截器\n    default void addInterceptors(InterceptorRegistry registry) {\n    }\n\t//添加资源处理器\n    default void addResourceHandlers(ResourceHandlerRegistry registry) {\n    }\n\n    default void addCorsMappings(CorsRegistry registry) {\n    }\n\t//视图控制器\n    default void addViewControllers(ViewControllerRegistry registry) {\n    }\n\n    default void configureViewResolvers(ViewResolverRegistry registry) {\n    }\n\t//添加参数解析器\n    default void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {\n    }\n\n    default void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers) {\n    }\n\t//消息转换器\n    default void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n    }\n\n    default void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n    }\n\n    default void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n    }\n\n    default void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n    }\n\n    @Nullable\n    default Validator getValidator() {\n        return null;\n    }\n\n    @Nullable\n    default MessageCodesResolver getMessageCodesResolver() {\n        return null;\n    }\n}\n```\n\n## 注意事项\n\n在**SpringBoot**下自定义的WebMvcConfigurer实现配置类上是不需要添加**@EnableWebMvc**的，因为**SpringBoot**已经实例化了WebMvcConfigurationSupport，如果添加了该注解，默认的WebMvcConfigurationSupport配置类就会失效，mvc默认的配置会失效，也就是以用户定义的为主，一般建议还是不覆盖默认的好。\n\n这点可以从SpringBoot的**WebMvcAutoConfiguration**中看到。（@EnableWebMvc会导入一个WebMvcConfigurationSupport的子类，叫 DelegatingWebMvcConfiguration）。\n\n![mark](http://static.imlgw.top///20190520/p5I6RuWHJPMy.png?imageslim)\n\n当没有WebMvcConfigurationSupport的时候自动配置才会生效\n\n> [官方文档](https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration)\n>\n> If you want to keep Spring Boot MVC features and you want to add additional [MVC configuration](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc) (interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer` but **without** `@EnableWebMvc`. If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter`, or `ExceptionHandlerExceptionResolver`, you can declare a `WebMvcRegistrationsAdapter` instance to provide such components.\n\n## 实例\n\n### Controller参数绑定\n\n在SpringMVC里面可以轻松的把表单的数据映射到对应的bean中，但是有时候这并不能满足我们的需求，比如下面的例子。\n\n```java\n@RequestMapping(\"/to_list\")\npublic String tolist(HttpServletResponse response, Model model,\n                         @CookieValue(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String cookie,\n                         @RequestParam(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String param) {\n        /*手机浏览器，有可能将cookie放在参数中*/\n        if (param == null && cookie == null) {\n            return \"login\";\n        }\n        String cook = cookie != null ? cookie : param;\n        SpikeUser user = spikeUserService.getUserByToken(response, cook);\n        System.out.println(user);\n        model.addAttribute(\"user\", user);\n        return \"goods_list\";\n }\n```\n\n可以看到这里为了获取这个**SpikeUser**对象并不能直接从表单中获取，需要借助cookie然后从redis里面查询，如果下面还有一些其他的controller需要获取这个对象，又要写很多重复的代码。这个时候我们就可以通过上面介绍的WebMvcConfigurer来实现简化代码。\n\n####  重写addArgumentResolvers\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    \n    @Autowired //注入我们的参数解析器\n    SpikeUserArgumentResolver spikeUserArgumentResolver;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(spikeUserArgumentResolver);\n    }\n}\n```\n\n这里只需要实现**addArgumentResolvers**就可以了，注意加上**@Configuration**注解将WebConfig托付给Spring，使我们添加的参数解析器生效。\n\n#### 实现HandlerMethodArgumentResolver\n\n```java\n@Service\npublic class SpikeUserArgumentResolver implements HandlerMethodArgumentResolver {\n\n    @Autowired\n    SpikeUserService userService;\n\n    public boolean supportsParameter(MethodParameter parameter) {\n        Class<?> clazz = parameter.getParameterType();\n        //处理SpikeUser类型的\n        return clazz==SpikeUser.class;\n    }\n\n\n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\n        String paramToken = request.getParameter(SpikeUserService.COOK1_NAME_TOKEN);\n        String cookieToken = getCookieValue(request, SpikeUserService.COOK1_NAME_TOKEN);\n        if(StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {\n            return null;\n        }\n        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;\n        return userService.getUserByToken(response,token);\n    }\n\n    private String getCookieValue(HttpServletRequest request, String cookiName) {\n        Cookie[]  cookies = request.getCookies();\n        for(Cookie cookie : cookies) {\n            if(cookie.getName().equals(cookiName)) {\n                return cookie.getValue();\n            }\n        }\n        return null;\n    }\n}\n```\n\n然后就可以直接在在控制器中拿到SpikeUser了，代码变得清爽简洁\n\n```java\n\t@RequestMapping(\"/to_list\")\n    public String tolist(Model model,SpikeUser spikeUser) {\n        if (spikeUser==null) {\n            return \"login\";\n        }\n        model.addAttribute(\"user\", spikeUser);\n        return \"goods_list\";\n    }\n\n\t//未优化\n    @SuppressWarnings(\"all\")\n    @RequestMapping(\"/to_list0\")\n    @Deprecated\n    public String tolist0(HttpServletResponse response, Model model,\n                         @CookieValue(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String cookie,\n                         @RequestParam(value = SpikeUserService.COOK1_NAME_TOKEN, required = false) String param) {\n                            //手机浏览器，有可能将cookie放在参数中\n        System.out.println(\"cookie:\" +cookie);\n        System.out.println(\"param \" +param);\n        if (param == null && cookie == null) {\n            return \"login\";\n        }\n        String cook = cookie != null ? cookie : param;\n        SpikeUser user = spikeUserService.getUserByToken(response, cook);\n        System.out.println(user);\n        model.addAttribute(\"user\", user);\n        return \"goods_list\";\n    }\n\n```\n\n这也算是对SpringMVC原理的初次接触吧，后面关于框架还是多看源码啊。\n\n关于**Spring-Session**的内容后面用到再来介绍。\n\n### 拦截器\n\n依然是SpringBoot2，所以还是实现的**WebMvcConfigurer**接口\n\n先看下拦截器的执行流程\n\n![来自慕课](http://static.imlgw.top/image/20190609/vUv7FDoickvl.png?imageslim)\n\n#### 自定义注解\n\n```java\npackage top.imlgw.spike.intercept;\n\nimport java.lang.annotation.*;\n\n/**\n * @author imlgw.top\n * @date 2019/6/9 15:13\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface NeedLogin {\n    boolean needLogin() default true;\n}\n```\n\n#### 重写HandlerInterceptor\n\n```java\npackage top.imlgw.spike.intercept;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.method.HandlerMethod;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport top.imlgw.spike.entity.SpikeUser;\nimport top.imlgw.spike.service.SpikeUserService;\nimport top.imlgw.spike.utils.UserContext;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author imlgw.top\n * @date 2019/6/8 23:22\n */\n@Component\npublic class LoginIntercept implements HandlerInterceptor {\n\n    @Autowired\n    SpikeUserService spikeUserService;\n\n    /**\n     * @param request\n     * @param response\n     * @param handler\n     * @return 在登陆前拦截\n     * @throws Exception\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        if(!(handler instanceof HandlerMethod)){\n            return true;\n        }\n        HandlerMethod hm=(HandlerMethod) handler;\n        SpikeUser spikeUser = getSpikeUser(request, response);\n        //有的页面不需要登陆(二次登陆)但是需要用户信息(订单页面...)，所以需要先存进去\n        UserContext.setUser(spikeUser);\n        //获取方法上的注解\n        NeedLogin needLogin = hm.getMethodAnnotation(NeedLogin.class);\n        if(needLogin==null || ! needLogin.needLogin()){\n            //没有注解后者注解为false,就直接放过\n            return true;\n        }\n        //有注解，没登陆\n        if(spikeUser==null){\n            return false;\n        }\n        return true;\n    }\n\n\n    /** 视图渲染完毕后调用(收尾工作)\n     * @param request\n     * @param response\n     * @param handler\n     * @param ex\n     * @throws Exception\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        //删除ThreadLocal中的User否则会产生错乱\n        UserContext.removeUser();\n    }\n\n\t\n    private SpikeUser getSpikeUser(HttpServletRequest request,HttpServletResponse response){\n        //拿参数中的token\n        String paramToken = request.getParameter(SpikeUserService.COOK_NAME_TOKEN);\n        //拿cookie中的token\n        String cookieToken = getCookieValue(request, SpikeUserService.COOK_NAME_TOKEN);\n        if(StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {\n            //没登陆cookie为空\n            return null;\n        }\n        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;\n        SpikeUser user = spikeUserService.getUserByToken(response, token);\n        return user;\n    }\n\n\n    /*\n     * 获取cookie中的User\n     * */\n    private String getCookieValue(HttpServletRequest request, String cookieName) {\n        Cookie[]  cookies = request.getCookies();\n        if(cookies == null || cookies.length <= 0){\n            return null;\n        }\n        for(Cookie cookie : cookies) {\n            if(cookie.getName().equals(cookieName)) {\n                return cookie.getValue();\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### WebConfig里面添加拦截器\n\n```java\npackage top.imlgw.spike.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport top.imlgw.spike.intercept.LoginIntercept;\nimport java.util.List;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer{\n\t//自动装配或者 手动创建bean,加到Ioc容器中，否则取不到service\n    @Autowired\n    SpikeUserArgumentResolver spikeUserArgumentResolver;\n\n    @Autowired\n    LoginIntercept loginIntercept;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(spikeUserArgumentResolver);\n    }\n    \n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(loginIntercept).addPathPatterns(\"/**\").\n            excludePathPatterns(\"/login/*\");\n    }\n}\n```\n\n### 视图解析器\n\n不用为了跳转页面而专门写一个**controller**\n\n```java\n@Override\npublic void addViewControllers(ViewControllerRegistry registry) {\n    //这里如果是用的模板引擎，就只能是模板引擎template里面的文件\n    //这里后面默认指的是static里面的文件，后缀为html\n    registry.addViewController(\"/\").setViewName(\"login\");\n    registry.addViewController(\"/goodslist\").setViewName(\"goods_list\");\n    registry.addViewController(\"/register\").setViewName(\"register\");\n}\n```\n\n> 其他的以后用到会继续补充\n\n","tags":["SpringMVC"],"categories":["Web"]},{"title":"数据库大作业","url":"/2019/05/20/shu-ju-ku-da-zuo-ye/","content":"\n## 准备工作\n\n### 环境\n\n- JDK(建议1.8以上)\n- 开发工具，Eclipse或者idea ...\n- **mysql**或者**mssql**(我是用的**mysql5.7.17**，给的demo是mysql的)\n\n### 测试给的Demo \n\n①装好mysql之后启动它，然后用管理工具我用的是**navicat**，打开然后将给的demo里面的sql脚本导入进去(导入不好的可以手动建立一个，用脚本文件导入后的名字是tb_demo，我这里是手动建的)\n\n<video controls=\"controls\" src=\"http://static.imlgw.top/image/20190530/M2IOTaKdyaQO.mp4\" width=\"100%\"></video>\n\n\n\n\n\n![mark](http://static.imlgw.top/image/20190524/oNHeEFJhHEYX.png?imageslim)\n\n\n\n最后差不多是这样的结构\n\n②在**Eclipse**里面**import**项目，这里我**import**会有个感叹号，**最好重新建一个项目，不然可能会有奇怪的错误**下面是**如何新建的步骤视频**\n\n<video controls=\"controls\" src=\"http://static.imlgw.top/f0xim-iyaow.mp4\" width=\"100%\"></video>\n\n这里要改的地方就是DbUtil里面数据库配置\n\n```java\npublic class DbUtil {\n\t//com.microsoft.sqlserver.jdbc.SQLServerDriver\n    //数据库驱动的名字（1.6还是1.8之后就不需要了，这里还是加上吧）\n\tString driverName = \"com.mysql.jdbc.Driver\";\n\t//jdbc:sqlserver://127.0.0.1:1433;DatabaseName=demo\n    //连接数据库的地址，前面的不用改，这里要改的就是后面的 demo 换成你的数据库名字（我上面的是demo）\n\tString dbURL = \"jdbc:mysql://localhost:3306/demo\";\n    //你的数据库的帐号\n\tString userName = \"root\";\n    //装mysql时设置的密码\n\tString userPwd = \"admin\"; \n\n\tpublic Connection getCon() throws ClassNotFoundException, SQLException {\n\t\tClass.forName(driverName);\n\t\tConnection conn = DriverManager.getConnection(dbURL, userName, userPwd);\n\t\treturn conn;\n\t}\n\n\tpublic void closeCon(Connection conn) throws SQLException {\n\t\tif (conn != null)\n\t\t\tconn.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDbUtil dbUtil = new DbUtil();\n\t\ttry {\n\t\t\tdbUtil.getCon();\n\t\t\tSystem.out.println(\"连接成功\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n#### 注意事项\n\n```java\n\t//com.microsoft.sqlserver.jdbc.SQLServerDriver\n    //数据库驱动的名字（1.6还是1.8之后就不需要了，这里还是加上吧）\n\tString driverName = \"com.mysql.jdbc.Driver\";\n\t//jdbc:sqlserver://127.0.0.1:1433;DatabaseName=demo\n    //连接数据库的地址，这里要改的就是后面的 demo 换成你的数据库名字（我上面的是demo）\n\tString dbURL = \"jdbc:mysql://localhost:3306/demo\";\n    //你的数据库的帐号\n\tString userName = \"root\";\n    //密码\n\tString userPwd = \"admin\"; \n```\n\n要改的差不多就是这4个配置\n\n①如果是**mysql**并且版本是8以下的，那么**driverName** 可以不用改，如果是8以上的（群里面那个是8以上的）就需要改成\n\n**com.mysql.cj.jdbc.Driver**，并且**找到适合版本的驱动拷贝到lib目录然后右键bulidpath**（在这之前先将老的驱动删掉，bulidpath的作用是将jar包**真正的**加到你的项目中去）\n\n- 8 以上 驱动下载地址 链接：https://pan.baidu.com/s/1WXjAAHX5gQC6v5pfiTOqmQ  提取码：5lf5 \n\n- sqlServer需要改的地方我也注释在上面但是我电脑上没sqlserver我没有测试，老师给的包里面有sqlserver的驱动\n\n②**dbURL**，前面的不用改，这里只需要改一下后面的数据库名字，比如我上面建的数据库名字是**demo**,后面就应该是**/demo**（如果用脚本直接导入生成的数据库名字是db_demo，这里就要改成jdbc:mysql://localhost:3306/db_demo\n\n- 对应sqlserver的我也放在上面但是我没装sqlserver所以没测试。\n\n③**userName**，数据库账号（一般默认就是root）\n\n④**password**，数据库密码\n\n### 启动\n\n在view包下的**MainPage**，这是用java的swing组件开发的一个GUI页面，最下面有一个main函数直接启动它就行，（如果有乱码，需要将eclipes的工作空间的编码方式换为**utf-8**），到此环境就基本ok了，后面的就是写代码的事了。\n\n### 改用自己的数据库\n\n> 后面的部分主要是代码的问题了，每个人数据库不同也会有一些差距\n\n- 导入自己的数据\n\n  数据库名字，字段名不要用中文！\n\n  数据库名字，字段名不要用中文 ！\n\n  数据库名字，字段名不要用中文！\n\n- 实体类改成自己的\n\n```java\nimport java.util.Date;\n\npublic class StuInfo {\n\n\tprivate Long stuId;\n\tprivate String stuName;\n\tprivate String stuSex;\n\tprivate Date stuDob;\n\tprivate String stuMajor;\n\t\n\tpublic Long getStuId() {\n\t\treturn stuId;\n\t}\n\n\tpublic void setStuId(Long stuId) {\n\t\tthis.stuId = stuId;\n\t}\n\n\tpublic String getStuName() {\n\t\treturn stuName;\n\t}\n\n\tpublic void setStuName(String stuName) {\n\t\tthis.stuName = stuName;\n\t}\n\n\tpublic String getStuSex() {\n\t\treturn stuSex;\n\t}\n\n\tpublic void setStuSex(String stuSex) {\n\t\tthis.stuSex = stuSex;\n\t}\n\n\tpublic Date getStuDob() {\n\t\treturn stuDob;\n\t}\n\n\tpublic void setStuDob(Date stuDob) {\n\t\tthis.stuDob = stuDob;\n\t}\n\n\tpublic String getStuMajor() {\n\t\treturn stuMajor;\n\t}\n\n\tpublic void setStuMajor(String stuMajor) {\n\t\tthis.stuMajor = stuMajor;\n\t}\n\t\n\tpublic StuInfo() {\n\n\t}\n\n\tpublic StuInfo(String stuName, String stuSex, Date stuDob, String stuMajor) {\n\t\tthis.stuName = stuName;\n\t\tthis.stuSex = stuSex;\n\t\tthis.stuDob = stuDob;\n\t\tthis.stuMajor = stuMajor;\n\t}\n}\n```\n\n这里实体类是和数据库的表和字段对应的，一个StuInfo对象就对应一条数据。\n\n- 增删改查的修改\n\n```java\n\npublic class UserDao {\n\tpublic ResultSet getUsers(User user, Connection con) throws SQLException {\n\t\tStringBuffer sql = new StringBuffer(\"select * from t_user \");\n\t\tif (user.getUserName()!= null) {\n\t\t\tsql.append(\" where userName like '%\"+user.getUserName()+\"%'\");\n\t\t}\n\t\tPreparedStatement ps = con.prepareStatement(sql.toString());\n\t\treturn ps.executeQuery();\n\t}\n\t\n\tpublic int delete(User user, Connection con) throws SQLException{\n\t\tString sql=\"delete from t_user where userName='\"+user.getUserName()+\"'\";\n\t\tPreparedStatement ps = con.prepareStatement(sql);\n\t\treturn ps.executeUpdate();\n\t}\n\t\n\tpublic int add(User user, Connection con) throws SQLException{\n\t\tString sql=\"insert into t_user  values(?,?)\";\n\t\tPreparedStatement ps = con.prepareStatement(sql);\n\t\tps.setString(1, user.getUserName());\n\t\tps.setString(2, user.getTel());\n\t\treturn ps.executeUpdate();\n\t}\n\t\n\tpublic int modify(User user, Connection con) throws SQLException{\n\t\tString sql=\"update t_user  set userName=?, tel=? where userName = '\"+user.getUserName()+\"'\";\n\t\tPreparedStatement ps = con.prepareStatement(sql);\n\t\tps.setString(1, user.getUserName());\n\t\tps.setString(2, user.getTel());\n\t\tSystem.out.println(sql);\n\t\treturn ps.executeUpdate();\n\t}\n}\n\n```\n\n最终都是通过调用这个Dao类实现的增删改查。\n\n- 页面的修改\n\n按照老师的要求是对我们常用的数据库做增删改查，因为我们用的数据库和给的demo的表结构不一样，所以需要修改MainPage，这个是用java的swing写的一个GUI，所以需要改这些界面上的一些元素，我记的好像有个插件可以直接拖动生成swing这些界面的(看见刘勇用过)，我对swing不熟悉（早就过时了，没有学的意义），我用web写的界面\n\n![mark](http://static.imlgw.top/image/20190530/96gB7wwVz4Xj.png?imageslim)\n\n### Mysql\n\n[Mysql5.7解压版的安装和卸载及常见问题](https://blog.csdn.net/mr_green1024/article/details/53222526?tdsourcetag=s_pcqq_aiomsg)\n\n","tags":["工具"],"categories":["工具"]},{"title":"JSR303-参数检验","url":"/2019/05/13/jsr303-can-shu-xiao-yan/","content":"\n## JSR303\n\n目前最新的规范已经是JSR380了，也就是Bean Validation 2.0.\n\n![mark](http://static.imlgw.top///20190513/qa5DNu5Nsq26.png?imageslim)\n\n\n\n参数校验是一个成熟的网站必须的功能，然而有的时候为了校验参数也要费好大的劲，免不了写很多if-else，一点也不优雅。\n\n## 上手\n\n### 引入依赖\n\n```java\n <!--SpringBootWeb 这个包里面自带了hibernate的校验包-->\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n### JSR提供的注解\n\n```java\n@Null   被注释的元素必须为 null    \n@NotNull    被注释的元素必须不为 null    \n@AssertTrue     被注释的元素必须为 true    \n@AssertFalse    被注释的元素必须为 false    \n@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值    \n@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值    \n@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值    \n@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值    \n@Size(max=, min=)   被注释的元素的大小必须在指定的范围内    \n@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内    \n@Past   被注释的元素必须是一个过去的日期    \n@Future     被注释的元素必须是一个将来的日期    \n@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式\n```\n\n### Hibernate提供的\n\n```\n@NotBlank(message =)   验证字符串非null，且长度必须大于0    \n@Email  被注释的元素必须是电子邮箱地址    \n@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内    \n@NotEmpty   被注释的字符串的必须非空    \n@Range(min=,max=,message=)  被注释的元素必须在合适的范围内\n```\n\n### 自定义校验注解\n\n**@IsMobile注解**\n\n```java\npackage top.imlgw.spike.validator;\nimport javax.validation.Constraint;\nimport javax.validation.Payload;\nimport java.lang.annotation.*;\n/**\n * @author imlgw.top\n * @date 2019/5/13 17:50\n */\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Constraint(\n        validatedBy = {IsMobileValidator.class} //指定真正校验的类\n)\npublic @interface IsMobile {\n    boolean required() default true;\n\n    String message() default \"号码格式错误\";\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n}\n```\n\n**IsMobileValidator类**\n\n> 自定义的校验器要实现 ConstraintValidator接口\n\n```java\npackage top.imlgw.spike.validator;\n\nimport org.apache.commons.lang3.StringUtils;\nimport top.imlgw.spike.utils.ValidatorUtil;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\n/**\n * @author imlgw.top\n * @date 2019/5/13 18:12\n */\npublic class IsMobileValidator implements ConstraintValidator<IsMobile, String> {\n\n    private boolean required=false;\n\n    @Override\n    public void initialize(IsMobile constraintAnnotation) {\n        required=constraintAnnotation.required();\n    }\n\n    @Override\n    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {\n        if(required){\n            return  ValidatorUtil.isMobile(s);\n        }else {\n            if(StringUtils.isEmpty(s)){\n                return true;\n            }else {\n                return  ValidatorUtil.isMobile(s);\n            }\n        }\n    }\n}\n```\n\n### 字段上加注解\n\n```java\npackage top.imlgw.spike.entity;\nimport org.hibernate.validator.constraints.Length;\nimport javax.validation.constraints.NotNull;\n/**\n * @author imlgw.top\n * @date 2019/5/11 15:56\n */\npublic class User {\n    @NotNull(message = \"id不能为空\")\n    private Integer id;\n    @NotNull(message = \"名字不能为空\")\n    private String name;\n    private Integer age;\n    @Length(min = 6,message = \"密码长度至少6位\")\n    private String password;\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", password='\" + password + '\\'' +\n                '}';\n    }\n\n    public User(Integer id, String name, Integer age, String password) {\n        this.name = name;\n        this.age = age;\n        this.password = password;\n        this.id=id;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n}\n```\n\n**@Valid 加BindingResult**\n\n![mark](http://static.imlgw.top///20190513/ILDAz6Bdj3cz.png?imageslim)\n\n在Controlle层待校验的的参数上加上`@Valid`注解，然后在后面紧跟一个 `BindingResult`，校验的结果会封装在这个对象里面，BindingResult 的作用是当参数不合法时能够捕捉到错误，不会直接抛异常，感觉还是有点麻烦。\n\n**@Valid加全局异常捕获**\n\n上面的方法如果不加后面的BindingResult在校验失败后就会抛一个BindException\n\n```java\norg.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors\nField error in object 'user' on field 'id': rejected value [null]; codes [NotNull.user.id,NotNull.id,NotNull.long,NotNull]; arguments .......\n```\n\n那我们就可以利用`@ControllerAdvice+@ExceptionHandler`来定义一个全局的异常处理器来处理这个异常，`@ExceptionHandle`，针对的仅仅是单个controller，加上`@ControllerAdvice`就可以对所有的Controller层异常进行捕获，这里的全局仅仅指的是controller层。\n\n### 自定义异常\n\n```java\npackage top.imlgw.spike.exception;\nimport top.imlgw.spike.result.CodeMsg;\n\n/**\n * 全局通用异常\n * @author imlgw.top\n * @date 2019/5/14 20:51\n */\npublic class GlobalException extends RuntimeException {\n    private static final long serialVersionUID = 1L;\n    private CodeMsg cm;\n\n    public GlobalException(CodeMsg cm) {\n        super(cm.toString());\n        this.cm = cm;\n    }\n\n    public CodeMsg getCm() {\n        return cm;\n    }\n\n}\n\n```\n\n### 全局异常处理器\n\n```java\n/**\n * Controller层异常处理器\n *\n * @author imlgw.top\n * @date 2019/5/13 18:21\n */\n@ControllerAdvice\n@ResponseBody //直接返回给客户端，需要json的转换\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(value = Exception.class) //处理controller层所有异常\n    public Result<String> exceptionHandle(HttpServletRequest request, Exception e) {\n        e.printStackTrace();\n        if (e instanceof GlobalException) {\n            //全局异常\n            GlobalException ex = (GlobalException) e;\n            return Result.error(ex.getCm());\n        } else if (e instanceof BindException) {\n            //@Validated 检验器的异常\n            BindException ex = (BindException) e;\n            List<ObjectError> errors = ex.getAllErrors();\n            ObjectError error = errors.get(0);\n            String msg = error.getDefaultMessage();\n            return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));\n        } else {\n            return Result.error(CodeMsg.SERVER_ERROR);\n        }\n    }\n\n    //测试Demo 看先处理那个\n    @ExceptionHandler(value = GlobalException.class) //处理controller层所有异常\n    public Result<String> GLe(HttpServletRequest request, Exception e) {\n        System.out.println(\"优先处理了这个GlobalException\");\n        e.printStackTrace();\n        //全局异常\n        GlobalException ex = (GlobalException) e;\n        return Result.error(ex.getCm());\n    }\n}\n```\n\n这里也做了个小测试，可以看到我定义了两个@ExceptionHandle，一个是另一个的子类，看会先处理那个，测试后发现会先处理小异常，那个最大的异常其实相当于''兜底''的。其实后面我为了跟精细的处理，将绑定异常和自定义的异常分开处理了。\n\n> @ControllerAdvice :\n>\n> It is typically used to define {@link ExceptionHandler **@ExceptionHandler**},\n>\n> {@link InitBinder **@InitBinder**}, and {@link ModelAttribute **@ModelAttribute**}\n>\n> methods that **apply to all** {@link RequestMapping **@RequestMapping**} methods.\n>\n> @author Rossen Stoyanchev\n>\n> @since 3.2\n\n### 分组校验\n\n只需要在vo里加上对应分组的接口然后在注解上加上就可以了\n\n```java\npublic class LoginVo {\n    @NotNull(message = \"手机号不能为空\")\n    @IsMobile(groups = Test1.class) //只有在Test1分组下才生效\n    private String mobile;\n\n    @NotNull(message = \"密码不能为空\")\n    @Length(min=6 ,groups = Test2.class,message = \"密码长度过短\") //只有在Test2分组下才生效\n    private String password;\n\n    public String getMobile() {\n        return mobile;\n    }\n    public void setMobile(String mobile) {\n        this.mobile = mobile;\n    }\n    public String getPassword() {\n        return password;\n    }\n    public void setPassword(String password) {\n        this.password = password;\n    }\n    @Override\n    public String toString() {\n        return \"LoginVo [mobile=\" + mobile + \", password=\" + password + \"]\";\n    }\n\n    public interface Test1{}\n\n    public interface Test2{}\n}\n```\n\n使用时注意用`@Validated`，这个其实是Spring对Hibernate的二次封装，增加了一些功能。\n\n```java\n@RequestMapping(\"/jsr303-2\")\n@ResponseBody\npublic void testJSR(@Validated({LoginVo.Test2.class}) LoginVo vo){\n\t  //........\t\n}\n```\n\n这样在这个Controller里post密码就没有长度的限制了。\n\n> 其实还有一些校验的方法，基于方法校验，基于少量参数的校验，以后用到再来记录\n\n","tags":["参数校验","JSR"],"categories":["Web"]},{"title":"LeetCode数组","url":"/2019/05/04/leetcode-shu-zu/","content":"\n## LeetCode 数组\n\n> 善用ctrl+f\n\n## [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n给定一个已按照**升序排列** 的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2*。*\n\n**说明:**\n\n- 返回的下标值（index1 和 index2）不是从零开始的。\n- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n**示例:**\n\n```java\n输入: numbers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n```\n\n两数之和的变种，看见**有序**其实也可以使用二分来做，但是时间复杂度是`O(NlogN)`，相对较高\n\n```java\npublic int[] twoSum(int[] numbers, int target) {\n    if(numbers==null||numbers.length<=0){\n        return null;\n    }\n    int left=0,right=numbers.length-1;\n    while(right>left){\n        int sum=numbers[right]+numbers[left];\n        if(sum==target){\n            return new int[]{left+1,right+1};\n        }if(sum<target){\n            left++;\n        }else{\n            right--;\n        }\n    }\n    return null;\n}\n```\n\n**对撞指针**，很基础的题。\n\n## [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n\n给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。\n\n**说明：**你不能倾斜容器，且 *n* 的值至少为 2。\n\n![mark](http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim)\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n**示例:**\n\n```java\n输入: [1,8,6,2,5,4,8,3,7]\n输出: 49\n```\n\n**解法一**\n\n```java\npublic int maxArea(int[] height) {\n        int len=height.length;\n        if(len==0){\n            return 0;\n        }\n        int max=Integer.MIN_VALUE;\n        for(int i=0;i<len-1;i++){\n            for(int j=i+1;j<len;j++){\n                int minHight=height[i]>height[j]?height[j]:height[i];\n                max=max>(j-i)*minHight ? max:(j-i)*minHight;\n            }\n        }\n        return max;\n }\n```\n\n522ms，13% 垫底了，别问，问就是暴力🤣\n\n```java\npublic int maxArea(int[] height) {\n        int len=height.length;\n        if(len==0){\n            return 0;\n        }\n        int head=0,tail=len-1;\n        int max=Integer.MIN_VALUE;\n        while(head<len){\n            tail=len-1; //开始改的时候这一句忘了加\n            while(head!=tail){\n                int minHight=height[tail]>height[head]?height[head]:height[tail];\n                max=max>(tail-head)*minHight ? max:(tail-head)*minHight;\n                if(height[head]<=height[tail]){\n                    break;\n                }else{\n                    tail--;\n                }\n            }\n            head++;\n        }\n        return max;\n}\n```\n\n212ms，40%，利用双指针稍微优化了下，依然是遍历找每个柱的最大值，但是尾指针在移动时先判断下，如果比头指针大就直接break，因为**已经是最大值**了，tail是从右向左移动的\n\n> 开始改的时候忘了将尾指针归位，结果还对了，而且90%的beats.....哈哈哈，误打误撞搞了个最优解出来。\n\n**解法二**\n\n上面两种其实都是暴力，时间复杂度都很高\n\n```java\n//update: 2020.4.18\npublic int maxArea(int[] height) {\n    if(height==null || height.length<=0) return 0;\n    int left=0,right=height.length-1;\n    int max=0;\n    while(left<right){\n        max=Math.max((right-left)*Math.min(height[left],height[right]),max);\n        //if(left<right){ 隐约记得之前也这样写过。。。没想到这次又在这里WA了\n        if(height[left]<height[right]){\n            left++;\n        }else{\n            right--;\n        }\n    }\n    return max;\n}\n```\n\n**标准**的最优解，这题主要考察的就是双指针，两个指针一头一尾，先算出这个头尾的面积大小，然后下一步思考怎么扩大这个区域的面积，结合题上面的图（最左边为头，最右边为尾）\n\n![mark](http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim)\n\n这个时候如果移动尾指针，明显面积只可能减小，所以只有移动头指针才有可能增大这个区域的面积，这样一来就可以省掉很多没必要的计算，有点像贪心，时间复杂度O(N)\n\n## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![rainwatertrap.png](https://i.loli.net/2019/05/14/5cda71129045d93180.png)\n\n\n\n\n上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n**示例:**\n\n```java\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n```\n\n**解法一**\n\n> 我最开始思路是填满后用总面积减数组和，跑过了130+个，有一种特殊的跑不过了，懒得去处理那个边界了，不太优雅\n\n这个题目的关键就是每个柱子能接的水是**左右最长柱子(都大于当前柱子)中的较小的那个减去当前柱子**。\n\n所以我们可以用两个数组分别存储每个柱子左右的最长柱子（做预处理），这样就得到了一种有点动态规划意思的解法\n\n```java\npublic static int trap(int []height){\n    if (height==null || height.length<=0) {\n        return 0;\n    }\n    int len=height.length;\n    int[] leftMax=new int[len];\n    leftMax[0]=height[0];\n    int[] rightMax=new int[len];\n    rightMax[len-1]=height[len-1];\n    int res=0;\n    //左右最大柱子包含当前柱子\n    for (int i=1;i<len;i++) {\n        leftMax[i]=Math.max(leftMax[i-1],height[i]);\n    }\n    for (int i=len-2;i>=0;i--) {\n        rightMax[i]=Math.max(rightMax[i+1],height[i]);\n    }\n    for (int i=0;i<len;i++) {\n        res+=Math.min(rightMax[i],leftMax[i])-height[i];\n    }\n    return res;\n}\n```\n\n利用**双指针**就行空间的优化\n\n```java\npublic static int trap(int []height){\n    if (height==null || height.length<=0) {\n        return 0;\n    }\n    int len=height.length;\n    int leftMax=0,rightMax=0;\n    int left=0,right=len-1,res=0;\n    while(left<=right){\n        leftMax=Math.max(leftMax,height[left]);\n        rightMax=Math.max(rightMax,height[right]);\n        //leftMax小于rightMax,那么靠近leftMax的柱子left可以接的雨水就可以确定了\n        if (leftMax<rightMax) {\n            res+=leftMax-height[left]; \n            left++;\n        }else{ //反之leftMax大于rightMax,那么考近rightMax的柱子right可以接的最多的雨水就可以i确定了\n            res+=rightMax-height[right];\n            right--;\n        }\n    }\n    return res;\n}\n```\n\n个人感觉这个是最好理解的版本，我这里最开始的哪个版本不是这样写的，当时自己肯定也没搞懂，包括现在我也没搞懂那种写法\n\n![[图片来自liweiwei1419大佬](https://leetcode-cn.com/u/liweiwei1419/)](http://static.imlgw.top/blog/20200129/Dy8M19G4XwSn.png?imageslim)\n\n这两种情况对应的就是循环中的if的两个分支，双指针向中间靠拢，当`leftMax`小于`rightMax`的时候我们不用去考虑当前`left`柱子右边实际的最大的右边的柱子是谁，我们只需要知道`left`柱子 左边最大值`leftMax`的值就ok，因为此时`left` 柱子能接水的量是由`leftMax`决定的，反之对应第二种情况，`right`柱子的接水量则是由`rightMax` 决定的，最后遍历完所有的柱子就可以确定整体的接水量\n\n> 这里的if分支的条件有的解法中写的是leftMax < nums[right]甚至nums[left] < nums[right] 这也是我上面说的不理解的地方，因为这样写也是可以AC的😅，后面有时间再回头看看吧\n\n**解法二**\n\n还有一种很巧妙的方法，也比较好理解，找到最大值，然后分别对两边的柱子进行遍历，如果当前的柱子小于前面柱子的最大值，就说明一定可以接到水，这个过程中需要记录柱子左边和右边的最大值，用于计算可以接水的量，最后计算总和\n\n```java\npublic static int trap5(int []height){\n    //\n    int n=height.length,idx=0,lefth=0,righth=0,area=0;\n    for (int i=0;i<n;i++) idx=height[idx]<=height[i]?i:idx;\n    for (int i=0;i<idx;i++){\n        if(height[i]<lefth) area+=lefth-height[i]; \n        else lefth=height[i]; //更新最大值\n    }\n    for (int i=n-1;i>idx;i--){\n        if(height[i]<righth) area+=righth-height[i]; \n        else righth=height[i]; //更新最大值\n    }\n    return area;\n}\n```\n\n**解法三**\n\n利用栈的\n\n```java\npublic static int trap6(int[] height) {\n    if (height == null || height.length == 0) return 0;\n    Deque<Integer> stack = new ArrayDeque<>(); //栈里面维护一个递减序列\n    int res = 0;\n    for (int i = 0; i < height.length; i++){\n        while ( ! stack.isEmpty() && height[stack.peek()] < height[i]) { //当遍历的元素大于栈顶元素\n            int tmp = stack.pop(); //栈顶弹出来\n            if (stack.isEmpty()) break;\n            res += (Math.min(height[i],height[stack.peek()]) - height[tmp]) * (i - stack.peek() - 1);\n        }\n        //维护递减序列\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n这种有点不好理解，其实是按照层来计算的，栈里面是递减的元素，如果读到比栈顶大的元素就**按层**计算递减栈**底部元素**到**当前元素**能蓄水的面积。\n\n> 2020/1/29回顾\n>\n> 这个解法其实就是单调栈😂，当时还是菜鸟根本就不懂，现在回头一看就懂了hahaha~ \n>\n> 放到[单调栈专题](http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/#%E5%8D%95%E8%B0%83%E6%A0%88)里面解释了\n\n## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)\n\n给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？找出所有满足条件且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n```java\n例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n**解法一**\n\n想太多了，没做出来，看了评论才做出来。\n\n```java\npublic static List<List<Integer>> threeSum(int[] nums) {\n    List<List<Integer>> list = new ArrayList();\n    Arrays.sort(nums);\n    // 先排序  o(nlogn)\n    int len = nums.length;\n    if(nums == null || len < 3) return list;\n    // 完备性\n    for (int i = 0; i < len-2; i++) {\n        if(nums[i]>0){\n            //大于0了，后面的和加起来肯定>0了\n            break;\n        }\n        //遍历数组，相同的元素只需要遍历一遍，不然会重复\n        if(i > 0 && nums[i] == nums[i-1]) continue;\n        // 一次去重优化\n        //当前元素的下一个元素。\n        int L = i+1;\n        //尾元素\n        int R = len-1;\n        while(L<R){\n            int sum = nums[i] + nums[L] + nums[R];\n            if(sum == 0){\n                list.add(Arrays.asList(nums[i],nums[L],nums[R]));\n                //-4 -1 -1 0 1 2\n                while (L<R && nums[L] == nums[L+1]) L++;\n                //二次去重优化\n                while (L<R && nums[R] == nums[R-1]) R--;\n                L++;\n                R--;\n            } else if (sum < 0){ //小于0所以要增大L,逼近0 else R--;\n                 L++;   \n            } else R--; //大于0就减小R\n        }\n    }\n    return list;\n}\n```\n\n代码思路就是遍历数组，然后从**i**位置后面的数组中找能和**i**凑成一对的元素，这里关键就是这里怎么找这两个元素 满足nums[L]+nums[R]=-nums[i]，问题就转化成了上面的**两数之和**，但是这里用暴力法肯定是过不了的，hashMap这里也不好用，所以这里我们可以先给数组排个序，然后利用**双指针对撞**，逐渐逼近0，还有一个很需要注意的地方就是二次去重，如下图\n\n![mark](http://static.imlgw.top///20190505/5YlNbCLe57fb.png?imageslim)\n\n当找到一组时有可能L，R的下一个位置的值没变这样就会导致重复。\n\n## [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)\n\n给定一个包括 *n* 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n```java\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n```\n\n**解法一**\n\n跟上面的题其实是一样的，这里主要时为了检测下自己上面的搞懂了没\n\n```java\npublic int threeSumClosest(int[] nums, int target) {\n    int len=nums.length;\n    if(nums==null||len<3) return 0;\n    Arrays.sort(nums);\n    int closest=nums[0]+nums[1]+nums[2];\n    for (int i=0;i<len-2;i++) {\n        if(i!=0&&nums[i]==nums[i-1])continue;\n        //跳过重复元素提高效率\n        int L=i+1;\n        int R=len-1;\n        while(L<R){\n            int sum=nums[L]+nums[R]+nums[i];\n            closest=Math.abs(closest-target)>Math.abs(sum-target)?sum:closest;\n            if(sum==target){\n                return target;\n            } else if(sum>target){\n                while(L<R && nums[R]==nums[R-1])R--;\n                R--;\n            } else{\n                while(L<R && nums[L]==nums[L+1])L++;\n                L++;\n            }\n        }\n    }\n    return closest;\n}\n```\n\n一遍**bugfree**，其实都挺简单，这两题我一直在考虑别的算法，我想的是排序后从两遍向中间然后...就不bb了，反之很多没考虑到的地方。\n\n## [18. 四数之和](https://leetcode-cn.com/problems/4sum/)\n\n给定一个包含 n 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 a，b，c 和 d ，使得 `a + b + c + d` 的值与 `target` 相等？找出所有满足条件且不重复的四元组。\n\n**注意：**\n\n答案中不可以包含重复的四元组。\n\n**示例：**\n\n```java\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n**解法一**\n\n和三数之和一样，但是更加繁琐了，提交了5，6次才AC，还是看了别人的代码的\n\n```java\npublic static List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> res=new ArrayList<>();\n    Arrays.sort(nums);\n    int n=nums.length;\n    //0 0 -1 1\n    for (int i=0;i<n-3;i++) {\n        //这里我开始写的是和后一个比较，0，0，0，0这种过不了\n        if(i>0 && nums[i]==nums[i-1])continue;\n        if (nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\n        if (nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target) continue;\n        for (int j=i+1;j<n-2;j++) {\n            //同上\n            if(j>i+1&&nums[j]==nums[j-1])continue;\n            if (nums[i]+nums[j]+nums[j+2]+nums[j+1]>target) break;\n            if (nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\n            int two=nums[i]+nums[j];\n            //左右边界\n            int left=j+1,right=n-1;\n            while(left<right){\n                if (target-two==nums[left]+nums[right]) {\n                    res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));\n                    //想清楚什么时候跳,放外面就错了\n                    while(left<right && nums[left]==nums[left+1]){left++;};\n                    while(left<right && nums[right]==nums[right-1]){right--;};\n                    left++;\n                    right--;\n                }else if (target-two>nums[left]+nums[right]) {\n                    left++;\n                }else{\n                    right--;\n                }\n            }\n        }\n    }\n    return res;\n}\n```\n\n\n## [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n\n给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n**示例 1:**\n\n```java\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```java\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**解法一**\n\n实不相瞒，这题一开始我暴力做的，冒泡的思想，太蠢了😅 ，注意题目要求空间复杂度O(1)\n\n```java\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            nums[i++] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n双指针，真的用的挺多的。\n\n## [80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)\n\n给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n**示例 1:**\n\n```java\n给定 nums = [1,1,1,2,2,3],\n\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```java\n给定 nums = [0,0,1,1,1,1,2,3,3],\n\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```java\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n**解法一**\n\n上面题目加一点，在前后相等的时候判断index前是否已经有两个相等\n\n```java\npublic int removeDuplicates(int[] nums) {\n    int index=2;\n    for (int i=2;i<nums.length;i++){\n        if(nums[i]!=nums[i-1] || (nums[i]==nums[i-1] && nums[index-2]!=nums[index-1])){\n            nums[index++]=nums[i];\n        }\n    }\n    return index;\n}\n```\n\n## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)\n\n给定一个数组 *nums* 和一个值 *val*，你需要**原地**移除所有数值等于 *val* 的元素，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n**示例 1:**\n\n```java\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```java\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**解法一**\n\n目标元素多时\n\n```java\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i++] = nums[j];\n        }\n    }\n    return i;\n}\n```\n\n目标元素少时\n\n```java\npublic int removeElement2(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[--n];\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n```\n\n## [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**示例:**\n\n```java\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**说明**:\n\n- 必须在原数组上操作，不能拷贝额外的数组。\n\n- 尽量减少操作次数。\n\n**解法一**\n\n```java\npublic void moveZeroes(int[] nums) {\n    if(nums==null||nums.length<=1){\n        return;\n    }\n    int index=0;\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]!=0){\n            nums[index++]=nums[i];\n        }\n    }\n    for(int i=index;i<nums.length;i++){\n        nums[i]=0;\n    }\n}\n```\n\n其实就是借助上面题目的思路，最后再补0就ok了，其实也还可以优化下\n\n**解法二**\n\n保持`[0,m)` 为非0元素，遇到非0元素就和右边界进行交换\n\n```java\npublic void moveZeroes(int[] nums) {\n    int m=0; //[0,m)为非0元素\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]!=0){\n            if(i!=m){\n                int temp=nums[i];\n                nums[i]=nums[m];\n                nums[m]=temp;   \n            }\n            m++;\n        }\n    }\n}\n```\n\n## [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)\n\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须**原地**修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n\n```java\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n```\n\n**解法一**\n\n直接上最优解吧，这题暴力法O(N!)，空间也超过了\n\n```java\npublic void nextPermutation(int[] nums) {\n    int len=nums.length;\n    if(nums==null||len<=1){\n        return;\n    }\n    for (int i=len-2;i>=0;i--) {\n        while(i>=0 &&nums[i]>=nums[i+1]){\n            //找到第一个峰值左相邻的元素（从左到右）\n            i--;\n        }\n        //逆序的, 没有最大值\n        if(i==-1){\n            reverse(nums,0);\n            return;\n        }\n        //找到峰值右边 [i+1 , len-1] 最后一个比i 大的元素\n        for (int j=len-1;j>i;j--) {\n            if(nums[j]>nums[i]){\n                swap(nums,j,i);\n                reverse(nums,i+1);\n                return;\n            }\n        }\n    }\n}\n\n//翻转数组\nprivate void reverse(int[] nums, int start) {\n    for (int i=start,j=nums.length-1;i<j;i++,j--) {\n        swap(nums,i,j);\n    }\n}\n\nprivate  static void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n```\n\n- 第一步，逆序找到第一个峰值的左边第一个元素 `a[i-1]`。\n\n- 将峰值右边的**最小的**比`a[i-1]`大的`a[j]`(其实就是`右边最后一个比它大的元素`)元素与**a[i-1]**交换。\n- 翻转刚刚调整过`a[i-1]`后面的逆序的数组(`a[i]-->a[len-1]`)。\n\n![mark](http://static.imlgw.top/blog/20190728/G6uqlPyjPLdV.png?imageslim)\n\n至于为什么这样做自己模拟下就懂了，逆序部分是没有下一个比它大的排列的，所以如果想让整个排列变大只能从这个逆序的排列里面选一个比逆序前最后一个''稍微''大一点的元素与之交换，然后将整个逆序的部分翻转就是下一个排列，这题看了题解后处理边界又处理了半天，**循环里面的循环边界条件一定要注意**\n\n## [556. 下一个更大元素 III](https://leetcode-cn.com/problems/next-greater-element-iii/)\n\n给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。\n\n**示例 1:**\n\n```java\n输入: 12\n输出: 21\n```\n\n**示例 2:**\n\n```java\n输入: 21\n输出: -1\n```\n\n**解法一**\n\n和上面那一题一样，权当复习了一下\n\n```java\npublic int nextGreaterElement(int n) {\n    StringBuilder sb=new StringBuilder();\n    while(n/10>0){\n        sb.append(n%10);\n        n/=10;\n    }\n    sb.append(n);\n    System.out.println(sb);\n    char[] nums=sb.reverse().toString().toCharArray();\n    int len=nums.length;\n    for (int i=len-1;i>0;i--) {\n        if (nums[i]>nums[i-1]) { //逆序的峰值i\n            if (i==0) return -1; \n            for (int j=len-1;j>=i;j--) {\n                if (nums[j]>nums[i-1]) {\n                    swap(nums,j,i-1);\n                    reverse(nums,i,len-1);\n                    return Long.valueOf(new String(nums))>Integer.MAX_VALUE?-1:Integer.valueOf(new String(nums));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\npublic void reverse(char[] nums,int begin,int end){\n    for (int i=begin,j=end;i<j;i++,j--) {\n        swap(nums,i,j);\n    }\n}\n\npublic void swap(char[] nums,int a,int b){\n    char temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n## [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n**示例 1:**\n\n```java\n输入: [3,2,3]\n输出: 3\n```\n\n\n**示例 2:**\n\n```java\n输入: [2,2,1,1,1,2,2]\n输出: 2\n```\n\n**解法一**\n\n分治法， (`HashMap`或者排序什么的方法就不说了，笔试可以那样写，面试就不能这样了)\n\n```java\npublic int majorityElement(int[] nums) {\n    return majorityElement(nums,0,nums.length-1);\n}\n\npublic int majorityElement(int[] nums,int lo,int hi) {\n    if (lo==hi) {\n        return nums[lo];\n    }\n    int mid=lo+(hi-lo)/2;\n    int leftMode=majorityElement(nums,lo,mid);\n    int rightMode=majorityElement(nums,mid+1,hi);\n    if (leftMode==rightMode) {\n        return rightMode;\n    }\n    return countMode(nums,lo,mid,leftMode)>countMode(nums,mid+1,hi,rightMode)?leftMode:rightMode;\n}\n\npublic int countMode(int[] nums,int left,int right,int mode){\n    int count=0;\n    for (int i=left;i<=right;i++) {\n        if (mode==nums[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n并不是最优解，时间复杂度`O(NlogN)`，只是一种思路吧，而且是通用的求众数的方法\n\n**解法二**\n\n摩尔投票法\n\n```java\npublic int majorityElement(int[] nums) {\n    int sum=1;\n    int res=nums[0]; \n    for (int i=1;i<nums.length;i++) {\n        if (sum==0) {\n            res=nums[i];\n        }\n        //将众数看做1,其他的看作-1,最后和一定是大于0的\n        if (res!=nums[i]) {\n            sum--;\n        }else{\n            sum++;\n        }\n    }\n    return res;\n}\n```\n**解法三**\n\n刚刚看见一种解法，当作求第k大，用快选就行了，时间复杂度`O(N)`\n\n## [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)\n\n给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。\n\n**说明:** 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。\n\n**示例 1:**\n\n```java\n输入: [3,2,3]\n输出: [3]\n```\n\n\n**示例 2:**\n\n```java\n输入: [1,1,1,3,3,2,2,2]\n输出: [1,2]\n```\n\n**解法一**\n\n和上面的方法一样，抵消去除三个不同的元素对众数没有任何影响，但是最后需要判断是否都是符合条件的\n\n```go\n//update：2020.4.23 用go在web上随手写了一个，感觉比之前java写的哪个好理解\nfunc majorityElement(nums []int) []int {\n    var res []int\n    //超过n/3的元素最多2个\n    cand1:=-1 //设置成nums中不存在的值比较好,比如-1\n    count1:=0\n    cand2:=-1\n    count2:=0\n    for _,num:=range nums{\n        if num==cand1{ //投1\n            count1++\n        }else if num==cand2{ //投2\n            count2++\n        }else { //都不投\n            if count1==0 {\n                cand1=num\n                count1=1\n            }else if count2==0{\n                cand2=num\n                count2=1\n            }else{\n                count1--\n                count2--\n            }\n        }\n    }\n    temp1:=0\n    temp2:=0\n    for _,num:= range nums{\n        if num==cand1{\n            temp1++\n        }\n        if num==cand2{\n            temp2++\n        }\n    }\n\n    if temp1>len(nums)/3 {\n        res=append(res,cand1)\n    }\n    if temp2>len(nums)/3 {\n        res=append(res,cand2)\n    }\n    return res\n}\n```\n\n## [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)\n\n给定一个未排序的整数数组，找出其中没有出现的最小的正整数。\n\n**示例 1:**\n\n```java\n输入: [1,2,0]\n输出: 3\n```\n\n**示例 2:**\n\n```java\n输入: [3,4,-1,1]\n输出: 2\n```\n\n**示例 3:**\n\n```java\n输入: [7,8,9,11,12]\n输出: 1\n```\n\n**解法一**\n\nHead题，想到了桶排序，但是空间不符合要求，看了评论扣了半天边界也没抠出来\n\n```java\npublic int firstMissingPositive(int[] nums) {\n    if(nums==null||nums.length<=0){\n        return 1;\n    }\n    for (int i=0;i<nums.length;++i){\n        //将每个元素归位，我开始只有一层循环，那样会漏掉很多元素（可能被交换的元素后面也需要交换），这样的就是一次直接到位。\n        while(nums[i]>=1&&nums[i]<=nums.length&&nums[nums[i]-1]!=nums[i])\n        {\n            int temp=nums[nums[i]-1];\n            nums[nums[i]-1]=nums[i];\n            nums[i]=temp;\n        }\n    }\n    for (int i=0;i<nums.length;++i){\n        if(nums[i]!=i+1)\n            return i+1;\n    }\n    return nums.length+1;\n}\n```\n\n其实也是桶排序的思想，不过这里是利用交换来定位每个元素，首相我们将原数组看作桶，题目要求的正整数，所以我们桶中存的应该是`【1，nums.length】`，也就是0位置应该存放的是1，1位置存放的应该是2....再归位后重新遍历数组，如果某个位置的`nums[i]!=i+1` 就说明这个是第一个缺失的正数，遍历完了之后没有找到，全部对应上了，那就说明我们缺少的第一个正数是`nums.length+1`\n\n**Update:2020.6.27**\n```golang\nfunc firstMissingPositive(nums []int) int {\n    for i:=0;i<len(nums);i++{\n        for nums[i]>0 && nums[i]<len(nums) && nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]{\n            nums[nums[i]-1],nums[i]=nums[i],nums[nums[i]-1]\n        }\n    }\n    for i,n := range nums{\n        if n!=i+1{\n            return i+1\n        }\n    }\n    return len(nums)+1\n}\n```\n\n**解法二**\n\n不考虑空间复杂度利用桶排序的思想\n\n```java\npublic int firstMissingPositive2(int[] nums) {\n        if(nums==null||nums.length<=0){\n            return 1;\n        }\n        int [] bucket=new int[nums.length];\n        for(int i=0;i<nums.length;++i){\n            if(nums[i]>0 && nums[i]<=nums.length){\n                bucket[nums[i]-1]=1; //代表这个桶有元素了\n            }\n        }\n        for(int i=0;i<bucket.length;++i){\n            if(bucket[i]==0)\n                return i+1;\n        }\n        return nums.length+1;\n}\n```\n\nlc上提交后的空间消耗居然比上面的还小一点😂\n\n## [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)\n\n给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。\n\n找到所有出现两次的元素。\n\n你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？\n\n**示例：**\n\n```java\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[2,3]\n```\n\n**解法一**\n\n同上，抽屉原理，直接秒掉这三题 hard，mid，easy\n\n```java\npublic List<Integer> findDuplicates(int[] nums) {\n    for (int i=0;i<nums.length;i++) {\n        while(nums[i]!=i+1 && nums[i]!=nums[nums[i]-1]){\n            int temp=nums[nums[i]-1];\n            nums[nums[i]-1]=nums[i];\n            nums[i]=temp;\n        }\n    }\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]!=i+1) {\n            res.add(nums[i]);\n        }\n    }\n    return res;\n}\n```\n\n**解法二**\n\n技巧性的思路，和上一题一样，将对应位置置反，如果遇到已经置反的就说明当前位置重复了\n\n```java\n//5 1 1 3 2\npublic List<Integer> findDuplicates(int[] nums) {\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[Math.abs(nums[i])-1]<0) {\n            res.add(Math.abs(nums[i]));\n        }\n        nums[Math.abs(nums[i])-1]=-Math.abs(nums[Math.abs(nums[i])-1]);\n    }\n    return res;\n}\n```\n\n## [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)\n\n给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n**示例:**\n\n```java\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[5,6]\n```\n\n**解法一**\n\n首先想到的解法，利用的和上面缺失的第一个正数一样的思路，抽屉原理，归位每个数字，最后没有归为的index就是消失的数字\n\n```java\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    //nums[i]=i+1\n    for (int i=0;i<nums.length;i++) {\n        while(nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]){\n            int temp=nums[i];\n            nums[i]=nums[temp-1];\n            nums[temp-1]=temp;\n            //nums[i]=nums[nums[i]-1]; 最开始的错误写法\n            //nums[nums[i]-1]=temp;\n        }\n    }\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]!=i+1) {\n            res.add(i+1);\n        }\n    }\n    return res;\n}\n```\n\n中间写出了一个小`bug`，交换两个元素的时候先交换了`nums[i]`，导致了后面的`nums[nums[i]+1]` 发生了变化，然后就死循环了😂，调试了一下才看出来，太菜了\n\n**解法二**\n\n很巧妙的方法\n\n```java\n//很巧妙\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    //nums[i]=i+1\n    //5 1 4 2 3\n    for (int i=0;i<nums.length;i++) {\n        nums[Math.abs(nums[i])-1]=-Math.abs(nums[Math.abs(nums[i])-1]);\n    }\n    List<Integer> res=new LinkedList<>();\n    for (int i=0;i<nums.length;i++) {\n        if (nums[i]>0) {\n            res.add(i+1);\n        }\n    }\n    return res;\n}\n```\n\n题目给定了数值的范围就是`[1,n]`所以可以遍历每个元素，将该元素正确位置的值取反置为负数\n\n比如 `5 1 1 3 2` 遍历到5的时候就会将末尾的2变为-2，依次类推，最后得到的就是`[-5,-1,-1,3,-2]` ，最后再遍历一遍，其中值为正数的元素的索引+1就是消失的数字\n\n## [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)\n\n给定一个包含红色、白色和蓝色，一共 *n* 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n**注意:**\n不能使用代码库中的排序函数来解决这道题。\n\n**示例:**\n\n```java\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n```\n\n**进阶：**\n\n- 一个直观的解决方案是使用计数排序的两趟扫描算法。\n  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n- 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n**解法一**\n\n题目上已经有了提示，很直观的做法就是利用桶排序的方法\n\n```java\npublic static void sortColors(int[] nums) {\n    int [] bucket=new int[3];\n    //基于桶排序\n    for (int i=0;i<nums.length;i++){\n        bucket[nums[i]]++;\n    }\n    int index=0;\n    //重新构造出来\n    for (int i=0;i<nums.length;i++) {\n        while (bucket[index]<=0) {\n            index++;\n        }\n        nums[i]=index;\n        bucket[index]--;\n    }\n}\n```\n\n当然还有更优秀的做法，利用**三向切分快排**的思想(荷兰国旗问题)\n\n```java\npublic static void sortColors(int[] nums) {\n    int less=-1,more=nums.length-1;\n    int l=0;\n    while(l<=more){\n        if(nums[l]<1){\n            swap(nums,++less,l++);\n        } else if(nums[l]>1){\n            swap(nums,more--,l);\n        } else{ \n            l++;\n        }\n    }\n}\n\npublic static swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n## [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n**说明：**本题中，我们将空字符串定义为有效的回文串。\n\n**示例 1:**\n\n```java\n输入: \"A man, a plan, a canal: Panama\"\n输出: true\n```\n\n**示例 2:**\n\n```java\n输入: \"race a car\"\n输出: false\n```\n\n**解法一**\n\neasy题，对撞指针\n\n```java\npublic Boolean isPalindrome(String s) {\n    if(s==null||s.length()<=1){\n        return true;\n    }\n    s=s.toLowerCase();\n    int left=0,right=s.length()-1;\n    while(left<right){\n        char lch=s.charAt(left);\n        char rch=s.charAt(right);\n        if(isNumOrchar(lch) && isNumOrchar(rch)){\n            //System.out.println(lch+\",\"+rch);\n            if(lch==rch){\n                left++;\n                right--;\n            } else{\n                return false;\n            }\n        } else if((!isNumOrchar(lch)) && isNumOrchar(rch)){\n            left++;\n        } else if(isNumOrchar(lch) && !isNumOrchar(rch)){\n            right--;\n        } else{\n            left++;\n            right--;\n        }\n    }\n    return true;\n}\n\npublic Boolean isNumOrchar(char ch){\n    if((ch>='0' && ch<='9') || (ch>='a' && ch<='z') || (ch>='A' &&  ch<='Z')){\n        return true;\n    }\n    return false;\n}\n```\n\n代码写多了，不够简洁，其实可以直接用**Character**的API\n\n```java\npublic Boolean isPalindrome(String s) {\n    if (s == null) return false;\n    if (s.length() == 0) return true;\n    int i = 0;\n    int j = s.length() - 1;\n    while (i < j) {\n        while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n        while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n        if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))){\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n```\n\n\n\n## [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)\n\nWrite a function that takes a string as input and reverse only the vowels of a string.\n\n**Example 1:**\n\n```\nInput: \"hello\"\nOutput: \"holle\"\n```\n\n**Example 2:**\n\n```\nInput: \"leetcode\"\nOutput: \"leotcede\"\n```\n\n**Note:**\nThe vowels does not include the letter \"y\".\n\n```java\npublic String reverseVowels(String s) {\n    if(s==null||s.length()<=0){\n        return s;\n    }\n    char[] ss=s.toCharArray();\n    int left=0,right=s.length()-1;\n    while(left<right){\n        while(left<right && !isYy(ss[left])){\n            left++;\n        }\n        while(left<right && !isYy(ss[right])){\n            right--;\n        }\n        swap(left++,right--,ss);\n    }\n    return new String(ss);\n}\n\npublic Boolean isYy(char ch){\n    char temp=Character.toLowerCase(ch);\n    return temp=='a'|| temp=='e'||temp=='i'||temp=='o'||temp=='u';\n}\n\npublic void swap(int a,int b,char[] s){\n    char temp=s[a];\n    s[a]=s[b];\n    s[b]=temp;\n}\n```\n\n很简单的对撞指针题\n\n## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)\n\nGiven two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n\n**Note:**\n\n- The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.\n- You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.\n\n**Example:**\n\n```java\nInput:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\nOutput: [1,2,2,3,5,6]\n```\n\n**解法一**\n\n典型的二路归并\n\n```java\npublic static void merge(int[] nums1, int m, int[] nums2, int n) {\n    if(nums1.length<=0||nums2.length<=0){\n        return;\n    }\n    int []res=new int[m+n];\n    int i1=0,i2=0;\n    for (int i=0;i1<m&&i2<n;i++) {\n        if(nums1[i1]<=nums2[i2]) {\n            res[i]=nums1[i1++];\n        } else if(nums1[i1]>nums2[i2] ){\n            res[i]=nums2[i2++];\n        }\n    }\n    if(i1>=m){\n        System.arraycopy(nums2,i2,res,i2+m,n-i2);\n    } else{\n        System.arraycopy(nums1,i1,res,i1+n,m-i1);\n    }\n    System.arraycopy(res,0,nums1,0,res.length);\n}\n```\n\n1ms ，98%beats.\n\n**解法二**\n\n看了下评论区发现自己还是太年轻了，原来这题是可以在**O(1)**的空间复杂度下完成的\n\n```java\npublic static void merge3(int[] nums1, int m, int[] nums2, int n) {\n    if(nums1.length<=0||nums2.length<=0){\n        return;\n    }\n    int i1=m-1,i2=n-1;\n    for (int i=m+n-1;i>=0;i--) {\n        if(i1<0){\n            nums1[i]=nums2[i2--];\n        } else if(i2<0){\n            nums1[i]=nums1[i1--];\n        } else if(nums1[i1]>nums2[i2]) {\n            nums1[i]=nums1[i1--];\n        } else if(nums1[i1]<=nums2[i2] ){\n            nums1[i]=nums2[i2--];\n        }\n    }\n}\n```\n\n合并后的长度确定，nums1的空间也足够，所以完全可以从后往前，从大到小，从而避免了使用额外的空间储存结果，学到了学到了👏\n\n**解法三**\n\n时隔多年，LeetCode打卡又做了一遍，这次直接想到了最优解，而且代码很简洁\n\n```java\npublic void merge(int[] A, int m, int[] B, int n) {\n    if(n==0 )  return;\n    int len=A.length,ai=m-1,bi=n-1,i=len-1;\n    while(ai>=0 && bi>=0) A[i--]=A[ai] > B[bi] ? A[ai--]:B[bi--];\n    while(bi>=0) A[i--]=B[bi--];\n    //ai剩余的不用管\n}\n```\n## [532. 逆序对](https://www.lintcode.com/problem/reverse-pairs/description)\n\n（来自领扣）\n\n在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给你一个数组，求出这个数组中逆序对的总数。\n概括：如果a[i] > a[j] 且 i < j， a[i] 和 a[j] 构成一个逆序对。\n\n**样例1**\n\n```java\n输入: A = [2, 4, 1, 3, 5]\n输出: 3\n解释:\n(2, 1), (4, 1), (4, 3) 是逆序对\n```\n\n**样例2**\n\n```java\n输入: A = [1, 2, 3, 4]\n输出: 0\n解释:\n没有逆序对\n```\n\n**解法一**\n\n```java\npublic long reversePairs(int[] A) {\n    if (A==null || A.length<=0) {\n        return 0;\n    }\n    return reversePairs(A,0,A.length-1);\n}\n\npublic long reversePairs(int[] A,int left,int right) {\n    if (left == right) {\n        return 0;\n    }\n    int mid=left+(right-left)/2;\n    long l=reversePairs(A,left,mid);\n    long r=reversePairs(A,mid+1,right);\n    return merge(A,left,mid,right)+l+r;\n}\n\npublic long merge(int[] nums,int left,int mid,int right){\n    long res=0;\n    int[] help=new int[right-left+1];\n    int i=left,j=mid+1;\n    int index=0;\n    while(i<=mid && j<=right){\n        //小于等于的时候让i先进栈\n        //help[index++]=nums[i]<=nums[j] ? nums[i++]:nums[j++];\n        if (nums[i]<=nums[j]) {\n            help[index++] = nums[i++];\n        }else{\n            help[index++] = nums[j++];\n            res+= mid-i+1; //j和i-mid间的所有元素形成逆序对\n        }\n    }\n    while(i<=mid){\n        help[index++]=nums[i++];\n    }\n    while(j<=right){\n        help[index++]=nums[j++];\n    }\n\n    for (int k=0;k<help.length;k++) {\n        nums[left+k]=help[k];\n    }\n    return res;\n}\n```\n\n归并排序的思路，最开始我是在每次i>j和最后收尾的时候res++，然后结果总是不对，然后取查了答案才意识到不能这样算，当`nums[i] > nums[j]` 的时候，`i~j` 形成的逆序对其实不只一个，而是`[i,mid]` 区间的所有元素，如果你只是+1的话就会漏掉许多情况，因为下一步 `j++` 就会将 `j` 向后移动，那些情况就考虑不到了\n\n## [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n\n给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。\n\n**示例:**\n\n```java\n输入: [5,2,6,1]\n输出: [2,1,1,0] \n解释:\n5 的右侧有 2 个更小的元素 (2 和 1).\n2 的右侧仅有 1 个更小的元素 (1).\n6 的右侧有 1 个更小的元素 (1).\n1 的右侧有 0 个更小的元素.\n```\n\n**错误解法一**\n\n这个bug我大概看了有两三个小时，人都看傻了，必须放上来纪念下\n\n```go\nimport(\n    \"fmt\"\n)\ntype Element struct{\n    idx int\n    val int\n}\n\nfunc countSmaller(nums []int) []int {\n    n:=len(nums)\n    count:=make([]int,n)\n    elements:=make([]Element,n)\n    for i,num:=range nums{\n        elements[i].idx=i\n        elements[i].val=num\n    }\n    fmt.Println(elements);\n    mergeSort(elements,0,n-1,count)\n    return count\n}\n\nfunc mergeSort(num []Element,left int,right int,count []int){\n    if left>=right{\n        return\n    }\n    mid:=left+(right-left)/2\n    mergeSort(num,left,mid,count)\n    mergeSort(num,mid+1,right,count)\n    merge(num,left,mid,right,count)\n}\n\nfunc merge(num []Element,left int,mid int,right int,count []int){\n    help:=make([]int,right-left+1)\n    i:=left\n    j:=mid+1\n    index:=0\n    for i<=mid && j<=right {\n        if num[i].val<=num[j].val{ //说明j前面的元素都小于i\n            count[num[i].idx]+=(j-mid-1)\n            help[index]=num[i].val\n            i++\n        }else{\n            help[index]=num[j].val\n            j++\n        }\n        index++\n    }\n    for i<=mid{\n        count[num[i].idx]+=(j-mid-1)\n        help[index]=num[i].val\n        index++\n        i++\n    }\n    for j<=right{\n        help[index]=num[j].val\n        index++\n        j++\n    }\n    for i:=left;i<=right;i++{\n        num[i].val=help[i-left]\n    }\n}\n```\n\n一开始用go写的，调了半天没调出来，我以为是go的啥问题（刚学go不太熟）然后用Java又写了一遍\n\n```java\nclass Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        Pair[] pair=new Pair[nums.length];\n        for(int i=0;i<nums.length;i++){\n            pair[i]=new Pair(i,nums[i]);\n        }\n        int[] count=new int[nums.length];\n        mergeSort(pair,0,nums.length-1,count);\n        List<Integer> res=new ArrayList<>();\n        for(int i=0;i<count.length;i++){\n            res.add(count[i]);\n        }\n        return res;\n    }\n\n    public void mergeSort(Pair[] nums,int left,int right,int[] count){\n        if(left>=right){\n            return;\n        }\n        int mid=left+(right-left)/2;\n        mergeSort(nums,left,mid,count);\n        mergeSort(nums,mid+1,right,count);\n        merge(nums,left,mid,right,count);\n    }\n\n    public void merge(Pair [] nums,int left,int mid,int right,int[] count){\n        int i=left,j=mid+1;\n        //出Bug的地方，应该用 Pair[] \n        int[] helper=new int[right-left+1];\n        int index=0;\n        while(i<=mid && j<=right){\n            if(nums[i].value>nums[j].value){\n                helper[index++]=nums[j++].value;\n            }else{\n                count[nums[i].index]+=j-mid-1;\n                helper[index++]=nums[i++].value;\n            }\n        }\n        while(i<=mid){\n            count[nums[i].index]+=j-mid-1;\n            helper[index++]=nums[i++].value;\n        }\n        while(j<=right){\n            helper[index++]=nums[j++].value;\n        }\n        for(int k=0;k<helper.length;k++){\n            //这里无形之中将索引和数据的对应关系打乱了。。。。。\n            nums[left+k].value=helper[k];\n        }\n    }\n\n    class Pair{\n        int index;\n        int value;\n        public Pair(int i,int v){\n            index=i;\n            value=v;\n        }\n    }\n}\n```\n\n还是不对，和之前go的结果是一样的，这段代码我反复地看了3个小时，楞是没看出来哪里写错了，我是真的菜啊！！！！！！！！！\n\n**解法一**\n\n其实和逆序对的解法是类似的，思路都在注释中\n\n```java\npublic List<Integer> countSmaller(int[] nums) {\n    Pair[] pair=new Pair[nums.length];\n    for(int i=0;i<nums.length;i++){\n        pair[i]=new Pair(i,nums[i]);\n    }\n    int[] count=new int[nums.length];\n    mergeSort(pair,0,nums.length-1,count);\n    List<Integer> res=new ArrayList<>();\n    for(int i=0;i<count.length;i++){\n        res.add(count[i]);\n    }\n    return res;\n}\n\npublic void mergeSort(Pair[] nums,int left,int right,int[] count){\n    if(left>=right){\n        return;\n    }\n    int mid=left+(right-left)/2;\n    mergeSort(nums,left,mid,count);\n    mergeSort(nums,mid+1,right,count);\n    merge(nums,left,mid,right,count);\n}\n\npublic void merge(Pair [] nums,int left,int mid,int right,int[] count){\n    int i=left,j=mid+1;\n    Pair[] helper=new Pair[right-left+1];\n    int index=0;\n    while(i<=mid && j<=right){\n        if(nums[i].value>nums[j].value){\n            helper[index++]=nums[j++];\n        }else{\n            //i<=j 那么mid+1~j-1的肯定都比i小\n            //(j-1)-(mid+1)+1=j-mid-1\n            count[nums[i].index]+=j-mid-1;\n            helper[index++]=nums[i++];\n        }\n    }\n    while(i<=mid){\n        //j没了，那么所有的j的元素都比i小\n        //等价于right-mid\n        count[nums[i].index]+=j-mid-1;\n        helper[index++]=nums[i++];\n    }\n    while(j<=right){\n        helper[index++]=nums[j++];\n    }\n    for(int k=0;k<helper.length;k++){\n        nums[left+k]=helper[k];\n    }\n}\n\nclass Pair{\n    int index;\n    int value;\n    public Pair(int i,int v){\n        index=i;\n        value=v;\n    }\n}\n```\n\n> 这题还可以用**树状数组**解，但是我暂时还不会，后面有时间学了再来补充，其实还可以用线段树，二叉搜索树等等，有点麻烦，算了\n\n## [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)\n\nGiven a non-negative integer *numRows*, generate the first *numRows* of Pascal's triangle.\n\n![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n\n**Example:**\n\n```java\nInput: 5\nOutput:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n```\n\n递归专题里面的题目，所以直接用递归来实现了下。\n\n```java\npublic static List<List<Integer>> generate(int numRows) {\n    if(numRows<=0) {\n        return new ArrayList();\n    }\n    List<List<Integer>> res = new ArrayList<>();\n    res.add(new ArrayList<Integer>() {\n        {\n            add(1);\n        }\n    }\n    );\n    generate(1, res.get(0), res, numRows);\n    return res;\n}\n\npublic static void generate(int numRow, List<Integer> preRow, List<List<Integer>> res, int rowMax) {\n    if (rowMax == numRow) {\n        return;\n    }\n    List<Integer> row = new ArrayList<>();\n    row.add(1);\n    for (int i = 1; i < preRow.size(); i++) {\n        row.add(preRow.get(i - 1) + preRow.get(i));\n    }\n    row.add(1);\n    res.add(row);\n    generate(numRow + 1,row,res,rowMax);\n}\n```\n\n尾递归，很鸡肋。\n\n## [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\nGiven a non-negative index *k* where *k* ≤ 33, return the *k*th index row of the Pascal's triangle.\n\nNote that the row index starts from 0.\n\n![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n\n**Example:**\n\n```java\nInput: 3\nOutput: [1,3,3,1]\n```\n\n**Follow up:**\n\nCould you optimize your algorithm to use only *O*(*k*) extra space?\n\n```java\n public List<Integer> getRow(int rowIndex) {\n        List<Integer> res=new ArrayList<>();\n        long cur=1;\n        res.add((int)cur);\n        for(int i=1;i<=rowIndex;i++){\n            cur=cur*(rowIndex-i+1)/i;\n            res.add((int)cur);\n        }\n        return res;\n }\n```\n\n直接利用组合数的公式，m列第n个元素等于C(n-1,M-1)\n\n## [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)\n\n给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n\n**示例 1:**\n\n```java\n输入:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n输出: [1,2,3,6,9,8,7,4,5]\n```\n\n**示例 2:**\n\n```java\n输入:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n输出: [1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n**解法一**\n\n这题很久之前做过，这次又来做的时候还是没做出来，忘了之前咋做的了，用模拟的方法搞了半天，没搞出来，然后瞄了一眼之前写的才写出来....\n\n```java\npublic static List<Integer> spiralOrder2(int[][] matrix) {\n    List<Integer> res=new ArrayList<>();\n    if(matrix.length<=0){\n        return res;\n    }\n    //a: 行\n    //b: 列\n    int la=0,lb=0,ra=matrix.length-1,rb=matrix[0].length-1;\n    //终止条件\n    while(lb<=rb && la<=ra){\n        //缓存各个坐标\n        int tla=la,tlb=lb,tra=ra,trb=rb;\n        //特殊情况，特殊处理\n        if(tla==tra){//同一行\n            while(tlb<=trb){\n                res.add(matrix[tla][tlb++]);\n            }\n            return res;\n        }else if(tlb==trb){//同一列\n            while(tla<=tra){\n                res.add(matrix[tla++][tlb]);\n            }\n            return res;\n        }else{\n            //向左\n            while(tlb<rb){\n                res.add(matrix[tla][tlb++]);\n            }\n\t\t\t//向下\n            while(tla<ra){\n                res.add(matrix[tla++][tlb]);\n            }\n\t\t\t//向右\n            while(trb>lb){\n                res.add(matrix[tra][trb--]);\n            }\n\t\t\t//向上\n            while(tra>la){\n                res.add(matrix[tra--][trb]);\n            }\n        }\n        //向内靠拢(缩圈)\n        la++;\n        lb++;\n        ra--;\n        rb--;\n    }\n    return res;\n}\n```\n\n模拟的方式相对要复杂点，需要记录每个节点是否访问然后在选择，这里的方式就很巧妙，直接按层遍历，由外到内，不用考虑那么多。时间复杂度`O(NM)`空间复杂度`O(NM)`。\n\n## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)\n\n给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n\n**示例:**\n\n```java\n输入: 3\n输出:\n[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]\n```\n\n**解法一**\n> UPDATE(2020.12.17)：更新了通用的解法，对应[AcWing756.蛇形矩阵](https://www.acwing.com/problem/content/description/758/)，美化了下代码\n```java\nimport java.io.*;\nimport java.util.*;\n\nclass Main {\n\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int v = 1;\n        int[][] res = new int[n][m];\n        int la = 0, lb = 0;\n        int ra = n-1, rb = m-1;\n        while (la <= ra && lb <= rb) {\n            int tla = la, tlb = lb;\n            int tra = ra, trb = rb;\n            if (la == ra) {\n                while (tlb <= rb) res[la][tlb++] = v++;\n                break;\n            }\n            if (lb == rb) {\n                while (tla <= ra) res[tla++][rb] = v++;\n                break;\n            }\n            while (tlb < rb) res[la][tlb++] = v++;\n            while (tla < ra) res[tla++][rb] = v++;\n            while (trb > lb) res[ra][trb--] = v++;\n            while (tra > la) res[tra--][lb] = v++;\n            la++; lb++;\n            ra--; rb--;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                System.out.print(res[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    } \n}\n```\n\n上一题的简化版，2020.2.11白板写的，还行\n\n## [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)\n\n给定一个 *n* × *n* 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n**说明：**\n\n你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。\n\n**Example 1:**\n\n```java\nGiven input matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix in-place such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n\n**Example 2:**\n\n```java\nGiven input matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\nrotate the input matrix in-place such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n```\n\n**解法一**\n\n这题和上面哪一题放在一起很有必要，很类似的题型\n\n```java\npublic void rotate(int[][] matrix) {\n    if (matrix==null || matrix.length==0) {\n        return;\n    }\n    int len=matrix.length-1;\n    int lx=0,ly=0,rx=len,ry=len;\n    while(lx<=rx){\n        //len=ry-ly;\n        for (int i=0;i<len;i++) {\n            int temp=matrix[lx][ly+i];\n            matrix[lx][ly+i]=matrix[rx-i][ly];\n            matrix[rx-i][ly]=matrix[rx][ry-i];\n            matrix[rx][ry-i]=matrix[lx+i][ry];\n            matrix[lx+i][ry]=temp;\n        }\n        //缩圈\n        len-=2; //写ry-ly可能会好一点，无所谓\n        lx++;ly++;\n        rx--;ry--;\n    }\n}\n```\n和上一题一样，都是从整体出发，从外层到内层，考虑每一层的前`n-1`个节点的旋转过程，这个过程需要自己在纸上画一画，空想容易搞错\n\n**解法二**\n\n新学到的解法，挺有意思的，整体沿对角线交换，然后每行沿中点交换，这个其实可以通过观察数组结构得到\n\n```java\npublic void rotate(int[][] matrix) {\n    if(matrix==null || matrix.length<=0) return;\n    int N=matrix.length;\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            int temp=matrix[i][j];\n            matrix[i][j]=matrix[j][i];\n            matrix[j][i]=temp;\n        }\n    }\n\n    for(int i=0;i<N;i++){\n        for(int j=0,k=N-1;j<k;j++,k--){\n            int temp=matrix[i][j];\n            matrix[i][j]=matrix[i][k];\n            matrix[i][k]=temp;\n        }\n    }\n}\n```\n\n## [498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)\n\n给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。\n\n**示例:**\n\n```\n输入:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\n输出:  [1,2,4,7,5,3,6,8,9]\n```\n\n ![JXlfOg.png](https://s1.ax1x.com/2020/05/01/JXlfOg.png)\n\n**说明:**\n\n1. 给定矩阵中的元素总数不会超过 100000 。\n\n**解法一**\n\n因为是先做的下面的那一题，所以我这里直接延用了前面的思路，借助了map额外的空间，其实做复杂了\n\n```go\n//借助额外空间\nfunc findDiagonalOrder(matrix [][]int) []int {\n    var res []int\n    m := len(matrix)\n    if matrix == nil || m == 0 {\n        return res\n    }\n    n := len(matrix[0])\n    hmap := make(map[int][]int)\n    flagRow := false //行开头标志位\n    for i, row := range matrix {\n        flagColumn := flagRow //列标志位\n        for j, num := range row {\n            if flagColumn {\n                hmap[i+j] = append(hmap[i+j], num)\n            } else {\n                hmap[i+j] = append([]int{num}, hmap[i+j]...)\n            }\n            flagColumn = !flagColumn\n        }\n        flagRow = !flagRow\n    }\n    for i := 0; i <= m*n; i++ {\n        res = append(res, hmap[i]...)\n    }\n    return res\n}\n```\n\n**解法二**\n\n模拟，不过是从整体上模拟，比较好的解法，不借助map\n\n```go\n//比较好的解法\nfunc findDiagonalOrder(matrix [][]int) []int {\n    var res []int\n    m := len(matrix)\n    if matrix == nil || m == 0 {\n        return res\n    }\n    n := len(matrix[0])\n    leftX := 0\n    leftY := 0\n    rightX := 0\n    rightY := 0\n    flag := true\n    //左右端点沿着矩形边缘移动就行了\n    for leftX < m && leftY < n {\n        help(matrix, leftX, leftY, rightX, rightY, flag, &res)\n        if leftX == m-1 { //左端点到达边界\n            leftY++\n        } else {\n            leftX++\n        }\n        if rightY == n-1 { //右端点到达边界\n            rightX++\n        } else {\n            rightY++\n        }\n        flag = !flag //反转\n    }\n    return res\n}\n\n//获取 (lx,ly) 和 (rx,ry)之间的点\nfunc help(matrix [][]int, lx, ly, rx, ry int, flag bool, res *[]int) {\n    for lx >= rx && ly <= ry {\n        if flag {\n            *res = append(*res, matrix[lx][ly])\n            lx--\n            ly++\n        } else {\n            *res = append(*res, matrix[rx][ry])\n            rx++\n            ry--\n        }\n    }\n}\n```\n\n## [1424. 对角线遍历 II](https://leetcode-cn.com/problems/diagonal-traverse-ii/)\n\n给你一个列表 `nums` ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 `nums` 中对角线上的整数。\n\n \n\n**示例 1：**\n\n![JOOOEt.png](https://s1.ax1x.com/2020/05/01/JOOOEt.png)\n\n```java\n输入：nums = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,4,2,7,5,3,8,6,9]\n```\n\n**示例 2：**\n\n![JOXkEq.png](https://s1.ax1x.com/2020/05/01/JOXkEq.png)\n\n```go\n输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n```\n\n**示例 3：**\n\n```go\n输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]\n输出：[1,4,2,5,3,8,6,9,7,10,11]\n```\n\n**示例 4：**\n\n```go\n输入：nums = [[1,2,3,4,5,6]]\n输出：[1,2,3,4,5,6]\n```\n\n**提示：**\n\n- `1 <= nums.length <= 10^5`\n- `1 <= nums[i].length <= 10^5`\n- `1 <= nums[i][j] <= 10^9`\n- `nums` 中最多有 `10^5` 个数字。\n\n**解法一**\n\n186th周赛的t3，还是挺有意思的，这题我拿到的第一想法其实是找一下关系直接排序，但是实际上有更好的方法\n\n```go\nfunc findDiagonalOrder(nums [][]int) []int {\n    //最大的行列值\n    n := 0\n    m := make(map[int][]int)\n    for i, row := range nums {\n        for j, num := range row {\n            //逆序添加\n            m[i+j] = append([]int{num}, m[i+j]...)\n            n = max(n, i+j)\n        }\n    }\n    //res := make([]int, n)\n    var res []int\n    for i := 0; i <= n; i++ {\n        res = append(res, m[i]...)\n    }\n    return res\n}\n\nfunc max(a, b int) int {\n    if a < b {\n        return b\n    }\n    return a\n}\n```\n\n上面的解法其实和N皇后里面对行列的处理是一样的，两条对角线，一条行列和相等，一条行列差相等\n\n> 这题我还看到了至少3种不同的方法，有一种把这个数组旋转一下，然后当成二叉树，直接做BFS层次遍历😂，脑洞挺大的\n\n## [215.数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\nFind the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\n**Example 1:**\n\n```\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n```\n\n**Example 2:**\n\n```\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\n```\n\n**Note:** \nYou may assume k is always valid, 1 ≤ k ≤ array's length.\n\n> 这题必须多说几句\n\n**解法一**\n\n大根堆的做法（首先想到的方法，不是常规用堆的做法）\n\n```java\npublic static int findKthLargest(int[] nums, int k) {\n    //构建了大根堆\n    for (int i=0;i<nums.length;i++){\n        siftUp(nums,i);\n    }\n    int size=nums.length-1;\n    for (int i=0;i<k-1;i++) {\n        swap(nums,0,size);//和堆顶交换K次\n        siftDown(nums,0,--size);//重新调整堆\n    }\n    return nums[0];\n}\n\npublic static void siftUp(int[] nums,int i){\n    while(nums[i]>nums[(i-1)/2]){\n        swap(nums,i,(i-1)/2);\n        i=(i-1)/2;\n    }\n}\n\n//i 变小 下沉\npublic static void siftDown(int[] nums,int i,int size){\n    //判断有没有子节点（左孩子）\n    int left=i*2+1;\n    while(left<size){\n        int right=left+1;\n        //左右节点最大值\n        int larger=left+1<size && nums[left]<nums[left+1] ?left+1:left;\n        if(nums[larger]>nums[i]){\n            swap(nums,larger,i);\n            i=larger;\n            left=larger*2+1;\n        } else{\n            break;\n        }\n    }\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n70%左右的beat，当时感觉还行，时间复杂度应该是`O(KlogN)`，后来越想越不对，又去看了下堆排序，发现我之前写的堆排序都是有问题的\n\n**优化后的大根堆做法**\n\n```java\npublic static int findKthLargest(int[] nums, int k) {\n    int last=nums.length-1;\n    for (int i=nums.length/2-1;i>=0;i--) {\n        siftDown(nums,i,last);\n    }\n    for (int i=0;i<k-1;i++) {\n        swap(nums,0,last);\n        siftDown(nums,0,--last);\n    }\n    return nums[0];\n}\n\n//i 变小 下沉\npublic static void siftDown(int[] nums,int i,int last){\n    //判断有没有子节点（左孩子）\n    int left=i*2+1;\n    while(left<=last){\n        int right=left+1;\n        //左右节点最大值\n        int larger=right<=last && nums[right] > nums[left]?right:left;\n        if(nums[larger]>nums[i]){\n            swap(nums,larger,i);\n            i=larger;\n            left=larger*2+1;\n        } else{\n            break;\n        }\n    }\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n95% beat，比上面的要快很多，相比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的insert方式时间复杂度是O(NlogN)，其实想想，这两种方式是完全相反的，insert的方式，最后一层每个元素最坏都可能调整`logN`次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的`swim`方式最后一层都只需要调整`1`次，而根节点需要调整`logN`次，而根节点只有一个，时间复杂度就会大大降低，最终的时间复杂度就是`O(N)`，[具体推算可以看这篇文章](https://www.zhihu.com/question/20729324)， 现在的时间复杂度才真的是`O(KlogN)`\n\n![mark](http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim)\n\n> 💥💥 上面这两种做法是有问题的，失去了用堆的优势，大根堆的做法必须要阿将整个堆构建完成后才能去找topk这样的话内存消耗比较大，应该维护一个小根堆，这样如果数据量很大的时候不用全读入内存中，  这题因为是我自己实现的堆，所以建堆的复杂度是O(N)（如果使用官方的API，建堆的时间复杂度就是NlogN），最终大根堆小根堆复杂度取决于K和N的大小关系，但是面试的时候最好不要说用大根堆的做法\n\n**解法二**\n\n小根堆的做法\n\n```java\npublic int findKthLargest(int[] nums, int k) {\n    int size=nums.length;\n    //先维护一个大小为k的小根堆 ,这里要注意k不是下标，k=index+1\n    for (int i = k/2; i >=0; i--) {\n        heapIfy(nums,i,k);\n    }\n\t//再从k开始向里面插入元素\n    for (int i=k;i<size;i++) {\n        if(nums[i]>nums[0]) { //大于小根堆堆顶,进取代它\n            //小根堆求第K大,保证这个堆的元素是整个堆的前k大的元素，堆顶就是第k大\n            swap(nums,i,0);\n            heapIfy(nums,0,k);\n        }\n        //小于堆顶就不用管了\n    }\n    return nums[0];\n}\n\n//小根堆调整\npublic  void heapIfy(int[] nums, int i, int size) {\n    int left = 2 * i + 1;\n    while (left < size) {\n        int right = left + 1;\n        int small = right < size && nums[right] < nums[left] ? right: left;\n        if(nums[small]<nums[i]) {\n            swap(nums,small,i);\n            i=small;\n            left=2*i+1;\n        } else {\n            return;\n        }\n    }\n}\n\nprivate  void swap(int[] nums, int l, int r) {\n    int temp = nums[l];\n    nums[l] = nums[r];\n    nums[r] = temp;\n}\n```\n\n2ms，99%beat，一般情况下的topK问题，如果用堆解决的话应该都是采用**小根堆**这种做法来做，时间复杂度为`O(NlogK)`，维护一个大小为k的小根堆，然后再遍历后面n-k个元素，依次和当前最小堆的堆顶比较（当前topK中的最小元素，堆顶），如果比它小就和它交换然后调整堆，这样就始终保持了这个堆是当前的topK小，最后的堆顶就是第K大的元素。\n\n_关于节省空间的问题，其实很好理解，去找一个OJ试一下就懂了_\n\n```java\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int K=sc.nextInt();\n        PriorityQueue<Integer> queue=new PriorityQueue<>((a,b)->b-a);\n        for(int i=0;i<N;i++){\n            int num=sc.nextInt(); //一个个的读入,而不是一起读入\n            queue.add(num);\n            if(queue.size()>K){\n                queue.poll();\n            }\n        }\n        System.out.println(queue.peek());\n    }\n}\n```\n\n**解法三**\n\n其实还有一类做法，利用`快排+二分`的思想，一般也被称为快选\n\n```java\npublic static int findKthLargest(int[] nums, int k) {\n    int n=nums.length;\n    int left=0,right=nums.length-1;\n    while(left<=right){\n        //分治\n        int base=partion(nums,left,right); //拿到划分点\n        if(base<n-k){\n            left=base+1;\n        } else if(base>n-k){\n            right=base-1;\n        } else{\n            return nums[base];\n        }\n    }\n    return -1;\n}\n\npublic static int partion(int []nums,int left,int right){\n    //随机取值\n    swap(nums,left,left+(int) (Math.random() * (right - left + 1)));\n    int base=left;\n    while(left<right){\n        while(left<right&&nums[right]>nums[base]){\n            right--;\n        }\n        while(left<right&&nums[left]<=nums[base]){\n            left++;\n        }\n        if(left<right){\n            swap(nums,left,right);\n        }\n    }\n    //归位\n    swap(nums,left,base);\n    return left;\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n这里最好用**随机**的**partition**，我试了下**不随机**大概`50+ms 30%beat`，这种随机的大概`3ms 97%beats `，差距还是很大的，时间复杂度是**O(N)**\n\n> 至于为什么是O(N)，我们可以来分析下，这里**假设每次划分都是差不多中点的位置**，如果是快排，那么在**partition**之后依然需要两边的子数组进行**partition**，分治整个递归栈的高度就是`logN`，每层都是N，所以整体的复杂度就**O(NlogN)**....扯远了，回到正题\n>\n> 来说说我们这里为什么是O(N)，这里我们沿用前面的分析过程，递归栈深度依然是`logN`，但是我们在这里第一次确定划分点的相对**k**的位置后，下一步**只需要划分其中一边的元素，不用对另一边的元素继续**，也就是n/2，再往下就是n/4，n/8，n/16 ....   而 `(1+1/2+1/4+1/8+......1/2^n)n <=2n` ，也就是说整体的复杂度是低于O(2N)的，所以这里复杂度就是O(N)\n\n**三切分快排优化**\n\nACWing上交的，wa了好几次，发现是二分写错了，哎，二分真难，其实还可以做一下随机处理\n\n```java\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int K=sc.nextInt()-1;\n        int[] nums=new int[N];\n        for(int i=0;i<N;i++) nums[i]=sc.nextInt();\n        int left=0,right=N-1;\n        while(left<right){\n            int[] equ=partition(nums,left,right);\n            if(K>equ[1]){\n                left=equ[1]+1;\n            }else if(K<equ[0]){\n                right=equ[0]-1;\n            }else{\n                System.out.println(nums[equ[0]]);\n                return;\n            }\n        }\n        System.out.println(nums[left]);\n    }\n\n    public static int[] partition(int[] nums,int left,int right){\n        int less=left-1,more=right,base=nums[right];\n        int i=left;\n        while(i<more){\n            if(nums[i]<base){\n                swap(nums,++less,i++);\n            }else if(nums[i]>base){\n                swap(nums,--more,i);\n            }else{\n                i++;\n            }\n        }\n        //归位\n        swap(nums,right,more++);\n        return new int[]{less+1,more-1}; //返回等于区域\n    }\n\n    public static void swap(int[] nums,int a,int b){\n        int temp=nums[a];\n        nums[a]=nums[b];\n        nums[b]=temp;\n    }\n}\n```\n\n**Update: 2020.6.28**\n\n用go重写下，又写了半天。。。真的菜，主要是最后划分元素的时候，区间只有1也应该继续划分，也就是`left <= right`，上面的解法就没考虑这个，而是在循环退出后返回left，实际上并不是好方法。。。（后面还是会再写的，尽量缩短code时间）\n```golang\n//1 2 3 4 5 6\nfunc findKthLargest(nums []int, k int) int {\n    k = len(nums) - k //转换下\n    var left = 0\n    var right = len(nums)-1\n    for left <= right{ //第一个WA点，这里是最容易写错的\n        mid := partition(nums, left, right)\n        if mid[1] < k{\n            left = mid[1]+1 //WA点\n        }else if mid[0] > k{\n            right = mid[0]-1 //WA点\n        }else{\n            return nums[mid[0]]\n        }\n    }\n    return -1\n}\n\nfunc partition(nums []int, left int, right int) []int{\n    base := left\n    var less = left\n    var more = right+1 //WA点\n    var i = left\n    for i < more{ //WA点\n        if nums[i] < nums[base]{\n            less++\n            nums[less], nums[i] = nums[i], nums[less]\n            i++\n        }else if nums[i] > nums[base]{\n            more--\n            nums[more], nums[i] = nums[i], nums[more]\n        }else{\n            i++\n        }\n    }\n    nums[less], nums[base] = nums[base], nums[less]\n    return []int{less,more-1} //WA点，注意配合上面的二分\n}\n```\n\n**解法四**\n\n[BFPRT算法](https://zhuanlan.zhihu.com/p/31498036) 大佬们提出来的根据上面快排改进而来，其实面试把小根堆和快排的解法答出来应该就差不多了，这个解法还是有些不容易写出来\n\n```java\npublic static int findKthLargest(int []nums,int k){\n    return findKthLargest(nums,0,nums.length-1,k);\n}\n\npublic static int findKthLargest(int[] nums,int l,int r,int k) {\n    int mid=findMid(nums,l,r);\n    swap(nums,mid,l);\n    int m=partition(nums,l,r);\n    if(m==nums.length-k){\n        return nums[m];\n    }\n    //下面的类似了\n    if(m>nums.length-k){\n        return findKthLargest(nums,l,m-1,k);\n    }\n    return findKthLargest(nums,m+1,r,k);\n}\n\n//中位数的中位数，主要的核心就是在这里\npublic static int  findMid(int []nums,int l,int r){\n    int leftSub=l;\n    //分组求中位数，5等分\n    for (int i=l;i<r-4;i+=5) {\n        insertSort(nums,i,i+4);\n        //将每一组的中位数统一放到左侧，用于递归\n        swap(nums,leftSub++,i+2);\n    }\n    //处理剩下的不足5个的\n    if (r-l<4) {\n        insertSort(nums,l,r);\n        swap(nums,leftSub,l+(r-l)/2);\n    }\n    //找到了\n    if(l==leftSub){\n        return l;\n    }\n    return findMid(nums,l,leftSub);\n}\n\n//五等分的插入\npublic static void insertSort(int []nums,int l,int r){\n    for (int i=0;i<r;i++) {\n        for (int j=i+1;j>=l&&nums[j]<nums[i];j--) {\n            swap(nums,j,i);\n        }\n    }\n}\n\n//快排partition\npublic static int partition(int []nums,int left,int right){\n    int base=left;\n    while(left<right){\n        while(left<right&&nums[right]>nums[base]){\n            right--;\n        }\n        while(left<right&&nums[left]<=nums[base]){\n            left++;\n        }\n        if(left<right){\n            swap(nums,left,right);\n        }\n    }\n    //归位\n    swap(nums,left,base);\n    return left;\n}\n\npublic static void swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n[具体的时间复杂度证明](https://zhuanlan.zhihu.com/p/31498036)，当n取5时候，在划分的时候**至少**会大于**3n/10**的元素，避免了极端情况，保证在最坏情况下也不会太坏。\n\n![mark](http://static.imlgw.top/image/20190617/Lc4M5f2qkegH.png?imageslim)\n\n如上图，每一列为分好的一组元素，中间黄色部分为每组的中位数，红色块为**中位数的中位数**，这个中位数至少会大于等于左上角黑框框住的部分，所以在划分的时候会保证至少减小大约3n/10 的规模。\n\n所以时间复杂度   `T(N)<=T(n/5)+T( 7n/10)+c*n`  总体时间复杂度**O(N)**，至于为什么不用其他的元素可以看看上面的那篇文章。\n\n## [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\n给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\n\n**示例 1:**\n\n```java\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n```\n\n**示例 2:**\n\n```java\n输入: nums = [1], k = 1\n输出: [1]\n```\n\n**说明：**\n\n```java\n你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。\n```\n\n也是TopK问题，但是这题其实还有个条件，`不会给出有歧义的数据` ，举个例子\n\n`nums=[1,1,1,2,2,2,3,3,3] ，k=2` 这样的就是有歧义的\n\n但是题目中也没有规定这样的如何处理，经过测试，发现官方的解在遇到这种情况会抛一个异常。\n\n**解法一**\n\n大根堆的做法\n\n```java\npublic static List<Integer> topKFrequent(int[] nums, int k) {\n    if(nums==null||nums.length<=0){\n        return null;\n    }\n    HashMap<Integer,Integer> fre=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        //fre.get(i) nums[i]出现的频次\n        fre.put(nums[i],fre.getOrDefault(nums[i],0)+1);\n    }\n    //1:3,2:3,3:1\n    PriorityQueue<HashMap.Entry<Integer,Integer>> pq=new PriorityQueue(new ComparatorMap());\n    for (HashMap.Entry ent:fre.entrySet()) {\n        pq.add(ent);\n    }\n    ArrayList<Integer> res=new ArrayList<>();\n    for (int i=0;i<k;i++) {\n        res.add(pq.poll().getKey());\n    }\n    return res;\n}\n\n//比较器\nstatic class ComparatorMap implements Comparator<HashMap.Entry<Integer,Integer>>{\n    @Override\n    public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\n        return o2.getValue()-o1.getValue();\n    }\n}\n```\n用大根堆不太好，容易爆内存，但是在这一题可以保证顺序，`但是题目并没有要求顺序`，时间复杂度~~O(KlogN)~~\n\n这里错了，建堆的时间复杂度就是`O(NlogN)`了，只有自己手写的堆，采用自底向上的方式建堆时间复杂度才是O(N) ，可以参考 [之前的文章](http://imlgw.top/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%9B%B4%E4%BC%98%E7%9A%84%E5%81%9A%E6%B3%95) ，这也是上面topK问题中提到的\n\n**解法二**\n\n小根堆的做法\n\n```java\n//UPDATE：2020.9.7之前的解法太丑陋了\npublic int[] topKFrequent(int[] nums, int k) {\n    HashMap<Integer,Integer> freq = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        freq.put(nums[i], freq.getOrDefault(nums[i], 0)+1);\n    }\n    //int[0]: count int[1]: val \n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->a[0]-b[0]);\n    //freq.forEach();\n    for (int key : freq.keySet()) {\n        pq.offer(new int[]{freq.get(key), key});\n        if (pq.size() > k) {\n            pq.poll();\n        }\n    }\n    int[] res = new int[k];\n    int i = 0;\n    while (!pq.isEmpty()) {\n        res[i++] = pq.poll()[1];\n    }\n    return res;\n}\n```\n\n时间复杂度`O(NlogK)`因为只维护了一个K大小的小根堆 ，时间复杂度和大根堆~~O(KlogN)~~ `O(NlogN)`相比会快很多，除此之外，如果N和K很接近的话可以考虑`O(Nlog(N-K))` 的做法，维护一个N-K的大根堆，里面存频率最低的那些元素，最后返回其他的元素（no code， just talk）\n\n**解法三**\n\n桶排序，这题的最优解应该就是桶排序\n\n```java\npublic static List<Integer> topKFrequent(int[] nums, int k) {\n    if(nums==null||nums.length<=0){\n        return null;\n    }\n    HashMap<Integer,Integer> fre=new HashMap<>();\n    for (int i=0;i<nums.length;i++) {\n        //记录nums[i]出现的频次\n        fre.put(nums[i],fre.getOrDefault(nums[i],0)+1);\n    }\n    ArrayList<Integer> [] bucket=new ArrayList[nums.length+1];\n    for (Integer num:fre.keySet()) {\n        if(bucket[fre.get(num)]==null){\n            bucket[fre.get(num)]=new ArrayList<>();\n        }\n        //桶排序\n        bucket[fre.get(num)].add(num); //所有出现fre.get(num)次的元素构成一条链表\n    }\n    ArrayList<Integer> res=new ArrayList<>();\n    int topk=bucket.length-1;\n    while (true) {\n        //从后向前遍历（从频次大到小）\n        //指针移动到合适的位置\n        while(bucket[topk]==null&&topk>0){\n            topk--;\n        }\n        res.addAll(bucket[topk--]);\n        if(res.size()==k){\n            return res;\n        }\n    }\n}\n```\n\n桶排序的思路，时间复杂度`O(N)`，空间复杂度也是`O(N)`，在leetcode提交三种方法的差距不大，可能是数据量太少了\n\n**解法四** (UPDATE:2020.9.7)\n\n基于快选的做法，时间复杂度O(N)，之前一直懒得写，今天补一下\n```golang\ntype Node struct {\n    Val   int\n    Count int\n}\n\nfunc topKFrequent(nums []int, k int) []int {\n    var n = len(nums)\n    var freq = make(map[int]int)\n    for i := 0; i < n; i++ {\n        freq[nums[i]]++\n    }\n    var nodes []*Node\n    for val, count := range freq {\n        nodes = append(nodes, &Node{val, count})\n    }\n    //7 0 1 2 9 10\n    var res []int\n    var left, right = 0, len(nodes) - 1\n    for left <= right {\n        mid := partition(nodes, left, right)\n        if mid == k-1 {\n            for i := 0; i <= mid; i++ {\n                res = append(res, nodes[i].Val)\n            }\n            return res\n        }\n        if mid > k-1 {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return res\n}\n\nfunc partition(nums []*Node, i int, j int) int {\n    //7 9 10 0 1 2\n    //随机下会好一点\n    var base = i\n    for i < j {\n        for i < j && nums[j].Count <= nums[base].Count {\n            j--\n        }\n        for i < j && nums[i].Count >= nums[base].Count {\n            i++\n        }\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    nums[i], nums[base] = nums[base], nums[i]\n    return i\n}\n```\n\n\n## [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)\n\n中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。\n\n例如，\n\n[2,3,4] 的中位数是 3\n\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n\n设计一个支持以下两种操作的数据结构：\n\n- void addNum(int num) - 从数据流中添加一个整数到数据结构中。\n- double findMedian() - 返回目前所有元素的中位数。\n\n**示例：**\n\n```java\naddNum(1)\naddNum(2)\nfindMedian() -> 1.5\naddNum(3) \nfindMedian() -> 2\n```\n\n\n**进阶:**\n\n- 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？\n- 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？\n\n**解法一**\n\n这题很久之前就听人讲过，不过忘记了，最佳策略就是利用小根堆+大根堆，分别维护前半部分和后半部分的最值\n\n```java\n/** initialize your data structure here. */\nPriorityQueue<Integer> minQue=null;\n\nPriorityQueue<Integer> maxQue=null;\n\npublic MedianFinder295() {\n    minQue=new PriorityQueue<>();\n    maxQue=new PriorityQueue<>((a,b)->b-a);\n}\n\npublic void addNum(int num) {\n    minQue.add(num);\n    maxQue.add(minQue.poll());\n    if(minQue.size()<maxQue.size()){\n        minQue.add(maxQue.poll());\n    }\n}\n\npublic double findMedian() {\n    if(minQue.size()==maxQue.size()){\n        return (minQue.peek()+maxQue.peek())/2.0;\n    }\n    return minQue.peek();\n}\n```\n\n前半部分用大跟堆，后半部分小根堆，每次将一个堆的最值放到另一个堆中，这样保证了大跟堆的最大值一定小于小根堆的最小值，另外我们还需要保证两个堆的差距不能大于1，这里我将多的放到小根堆中，最后在奇数的时候将小根堆的堆顶弹出就可以了\n\n## [66. 加一](https://leetcode-cn.com/problems/plus-one/)\n\n给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n**示例 1:**\n\n```java\n输入: [1,2,3]\n输出: [1,2,4]\n解释: 输入数组表示数字 123。\n```\n\n**示例 2:**\n\n```java\n输入: [4,3,2,1]\n输出: [4,3,2,2]\n解释: 输入数组表示数字 4321。\n```\n\n**解法一**\n\n模拟进位\n\n```go\nfunc plusOne(digits []int) []int {\n    n := len(digits) - 1\n    carry := 1\n    for n >= 0 {\n        digits[n] += carry\n        carry = digits[n] / 10\n        digits[n] %= 10\n        n--\n    }\n    if carry == 1 {\n        digits = append([]int{1}, digits...)\n    }\n    return digits\n}\n```\n\n## [67. 二进制求和](https://leetcode-cn.com/problems/add-binary/) \n\n给定两个二进制字符串，返回他们的和（用二进制表示）。\n\n输入为非空字符串且只包含数字 1 和 0。\n\n**示例 1:**\n\n```java\n输入: a = \"11\", b = \"1\"\n输出: \"100\"\n```\n\n**示例 2:**\n\n```java\n输入: a = \"1010\", b = \"1011\"\n输出: \"10101\"\n```\n\n**解法一**\n\n这题和下面的题目是我有意放在一起的，这题也可以作为大数相加的模板\n\n```java\npublic String addBinary(String a, String b) {\n    StringBuilder res=new StringBuilder(); \n    int idxA=a.length()-1;\n    int idxB=b.length()-1;\n    boolean carry=false;\n    //int carry=0;\n    while(idxA >=0 || idxB >=0){\n        char bina=idxA>=0?a.charAt(idxA):'0';\n        char binb=idxB>=0?b.charAt(idxB):'0';\n        if(bina == '1' && binb =='1'){\n            res.append(carry?1:0);\n            carry=true;\n        }else if((bina == '1' && binb =='0') ||(bina == '0' && binb =='1')){\n            res.append(carry?0:1);\n        }else{\n            res.append(carry?1:0);\n            carry=false;\n        }\n        idxA--;idxB--;\n    }\n    if(carry) res.append(1);\n    return res.reverse().toString();\n}\n```\n\n\n**解法二**\n\n上面的解法是完全的模拟解法，不够优雅\n```java\npublic String addBinary(String a, String b) {\n    StringBuilder res=new StringBuilder(); \n    int idxA=a.length()-1;\n    int idxB=b.length()-1;\n    int carry=0;\n    while(idxA >=0 || idxB >=0){\n        int sum=carry;\n        sum+=idxA>=0?a.charAt(idxA)-48:0;\n        sum+=idxB>=0?b.charAt(idxB)-48:0;\n        res.append(sum%2);\n        carry=sum/2;\n        idxA--;idxB--;\n    }\n    if(carry==1) res.append(1);\n    return res.reverse().toString();\n}\n```\n## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)\n\n给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。\n\n**注意：**\n\n1. num1 和num2 的长度都小于 5100.\n2. num1 和num2 都只包含数字 0-9.\n3. num1 和num2 都不包含任何前导零。\n4. 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。\n\n**解法一**\n\n一开始没找到这题，后面偶然发现的，随手写一下\n\n```java\npublic String addStrings(String num1, String num2) {\n    StringBuilder sb=new StringBuilder();\n    int m=num1.length()-1;\n    int n=num2.length()-1;\n    int carry=0;\n    while(n>=0 || m>=0){\n        int a= m>=0?num1.charAt(m)-48:0;\n        int b= n>=0?num2.charAt(n)-48:0;\n        int sum=a+b+carry;\n        carry=sum/10;\n        sb.append(sum%10);\n        m--;n--;\n    }\n    if (carry==1) {\n        sb.append(\"1\");\n    }\n    return sb.reverse().toString();\n}\n```\n\n## [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n\n给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n\n**示例 1:**\n\n```java\n输入: num1 = \"2\", num2 = \"3\"\n输出: \"6\"\n```\n\n**示例 2:**\n\n```java\n输入: num1 = \"123\", num2 = \"456\"\n输出: \"56088\"\n```\n\n\n**说明：**\n\n1. num1 和 num2 的长度小于110。\n2. num1 和 num2 只包含数字 0-9。\n3. num1 和 num2 均不以零开头，除非是数字 0 本身。\n4. 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。\n\n**解法一**\n\n```java\npublic static String multiply2(String num1, String num2) {\n    // 1 2 3 \n    // 4 5 6\n    // 501 6\n    int n1=num1.length();\n    int n2=num2.length();\n    //n1*n2 结果最长为 n1+n2\n    int[] res=new int[n1+n2];\n    for (int i=n1-1;i>=0;i--) {\n        for (int j=n2-1;j>=0;j--) {\n            //主要就是对这个i+j+1的理解\n            res[i+j+1]+=(num1.charAt(i)-48)*(num2.charAt(j)-48);\n        }\n    }\n    //处理进位\n    for(int i=res.length-1;i>=0;i--) {\n        if(res[i]>=10){\n            res[i-1]+=res[i]/10;\n            res[i]%=10;\n        }\n    }\n    //去掉前面多余的0\n    int index=0;\n    while (index<res.length-1&&res[index]==0) { \n        index++;\n    }\n    StringBuilder sb=new StringBuilder();\n    for (int i=index;i<res.length;i++) {\n        sb.append(res[i]);\n    }\n    return sb.toString();\n}\n```\n其实就是模拟的手算的过程，关键的地方就是 `i+j+1` 的理解\n\n![mark](http://static.imlgw.top/blog/20190928/4xnHi4yd4hwA.png?imageslim)\n\n**解法二**\n\n其实仔细分析，会发现上面的代码其实有很多多余的操作，比如去掉前面的0，因为两个**非0的数相乘**，最后的结果最多n1+n2位，最少n1+n2-1位，所以前面的0**最多就一个**\n\n```java\npublic static String multiply(String num1, String num2) {\n    if (num1.equals(\"0\") || num2.equals(\"0\")) {\n        return \"0\";\n    }\n    int n1=num1.length();\n    int n2=num2.length();\n    int[] res=new int[n1+n2];\n    for (int i=n1-1;i>=0;i--) {\n        for (int j=n2-1;j>=0;j--) {\n            //注意这里的i+j+1\n            res[i+j+1]+=(num1.charAt(i)-48)*(num2.charAt(j)-48);\n        }\n    }\n    //处理进位(其实这里res[0]是不可能大于10的)，模拟下知道了\n    for(int i=res.length-1;i>=0;i--) {\n        if(res[i]>=10){\n            res[i-1]+=res[i]/10;\n            res[i]%=10;\n        }\n    }\n    StringBuilder sb=new StringBuilder();\n    for (int i=0;i<res.length;i++) {\n        //前面最多只有一个0(除了两个数中有一个为0的时候)\n        if (i==0 && res[i]==0) continue;\n        sb.append(res[i]);\n    }\n    return sb.toString();\n}\n```\n**解法三**\n\n其实上面的进位和计算对应位置的值可以同时处理，这是最接近人手算的思路了\n\n```java\n//update: 2020.4.16 在web上重新推了一遍\n//idx : 0 1 2\n//i :   4 5 6\n//j :   1 2 3\n//   ——————————\n//    1 3 6 8 (i+j+1)\n//    9 1 2\n//  4 5 6\n//  ——————————\n//0 1 2 3 4 5\n//0 5 6 0 8 8  \npublic String multiply(String num1, String num2) {\n    if(num1==null || num2==null) return num1;\n    int n1=num1.length(),n2=num2.length();\n    int[] res=new int[n1+n2];\n    //如果想同时处理进位的话就必须倒推\n    for(int i=n1-1;i>=0;i--){\n        for(int j=n2-1;j>=0;j--){\n            int sum=res[i+j+1]+(num1.charAt(i)-48)*(num2.charAt(j)-48);\n            res[i+j+1]=sum%10;\n            //res[i+j]会超过10,但是由于我们是倒推的,所以这个会在下一轮进行处理,否则就无法处理了\n            res[i+j]+=sum/10; \n        }\n    }   \n    //n*m位数 乘积应该是 (m+n-1 ~ m+n)位\n    //前两个为0一定是0\n    if(res[0]==0 && res[1]==0) return \"0\";\n    //去除前导0（最多一个）\n    StringBuilder sb=new StringBuilder();\n    for(int i=0;i<res.length;i++){\n        if(res[i]==0 && i==0)continue;\n        sb.append(res[i]);\n    }\n    return sb.toString();\n}\n```\n\n## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)\n\n请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。\n\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n\n**说明：**\n\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 `[−231,  231 − 1]`。如果数值超过这个范围，请返回  `INT_MAX (231 − 1)` 或 `INT_MIN (−231)` \n\n**示例 1:**\n\n```java\n输入: \"42\"\n输出: 42\n```\n\n\n**示例 2:**\n\n```java\n输入: \"   -42\"\n输出: -42\n解释: 第一个非空白字符为 '-', 它是一个负号。\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n```\n\n\n**示例 3:**\n\n```java\n输入: \"4193 with words\"\n输出: 4193\n解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。\n```\n\n**解法一**\n\n之前一直很排斥这道题，知道这次朋友阿里面试问了这道题。。。\n\n```java\npublic int myAtoi(String str) {\n    if(str==null || str.length()<=0) return 0;\n    int MAX=Integer.MAX_VALUE,MIN=Integer.MIN_VALUE;\n    int res=0,index=0;\n    //过滤空格\n    while(index<str.length()&&str.charAt(index)==' ')index++;\n    if(index==str.length()) return 0;\n    //取正负号\n    char firstChar=str.charAt(index);\n    boolean positive=true;\n    if(!isDigit(firstChar)){\n        if(firstChar!='+'&&firstChar!='-') return 0;\n        index++;\n        positive = firstChar!='-';\n    }\n    //正负数的边界\n    int limit=positive?-MAX:MIN;\n    //过滤0\n    while(index<str.length()&&str.charAt(index)=='0')index++;\n    //取每一位,在非字符截止\n    while(index<str.length()&&isDigit(str.charAt(index))){\n        int digit=str.charAt(index++)-'0';\n        if(res<(limit+digit)/10){\n            return positive?MAX:MIN;\n        }\n        //这里的res>=limit\n        res=res*10-digit;\n    }\n    //if(index!=str.length()) return 0; //中途遇到非数字(也是合法的)\n    return positive?-res:res;\n}\n\npublic boolean isDigit(char c){\n    return c>='0' && c<='9';\n}\n```\n\n参考了`Integer.parseInt(String s, int radix)`方法对边界的处理方式, **用负数来表示正负数的边界**\n\n1. 这样正数的边界就是`-INT_MAX`,负数是`INT_MIN`\n\n2. 然后我们同样也用负数来保存结果, `res=res\\*10-digit`\n\n3. 我们需要保证这个值是在`INT`范围内的, 也就是 res*10-digit>=limit (负边界)\n\n4. 所以我们需要对`res`做判断,但是直接判断可能会溢出,所以进行移项,变换为 `res<(limit+digit)/10`\n\n5. 最后如果是正数就返回 `-res`,负数就返回`res`\n\n还是十分巧妙的 👏👏\n\n## [1071. 字符串的最大公因子](https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/)\n\n对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。\n\n返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。\n\n**示例 1：**\n\n```java\n输入：str1 = \"ABCABC\", str2 = \"ABC\"\n输出：\"ABC\"\n```\n\n**示例 2：**\n\n```java\n输入：str1 = \"ABABAB\", str2 = \"ABAB\"\n输出：\"AB\"\n```\n\n\n**示例 3：**\n\n```java\n输入：str1 = \"LEET\", str2 = \"CODE\"\n输出：\"\"\n```\n\n**解法一**\n\n首先想到的方法，其实也是根据辗转相除法来的（这种好像叫更相减损术 ?）\n\n```java\n//6 4 gcd(6,4)=gcd(4,2)=gcd(2,0) return 2\npublic String gcdOfStrings(String str1, String str2) {\n    if(str1.equals(str2)){\n        return str1;\n    }\n    int index1=0,index2=0;\n    //用减法替代除法求余数\n    while(str1.length()>=str2.length() && index1<str1.length() && index2<str2.length()){\n        if(str1.charAt(index1)!=str2.charAt(index2)) return \"\";\n        index2++;\n        index1++;\n    }\n    //gcd(str2,余数)\n    return gcdOfStrings(str2,str1.substring(index1,str1.length()));\n}\n```\n**解法二**\n\n数学方法，比较巧妙\n\n```java\npublic String gcdOfStrings(String str1, String str2) {\n    if(!(str1+str2).equals(str2+str1)){\n        return \"\";\n    }\n    return str1.substring(gcd(str1.length(),str2.length()));\n}\n\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n```\n第一个条件充分性的证明还是有点不太理解，不过后面的最大公因子的长度就是str1和str2长度倒是可以通过反证来证明出来，这里直接copy题解[大佬](https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/tan-tan-zheng-ming-wei-shi-yao-liang-zi-fu-chuan-c/) 的证明\n\n假设两字符串的长度分别为l1, l2, 他们的最大公约数是k。\n现已知道两字符串存在最大公因子（第一行代码），假设该字串的长度为`k'`。\n\n下面开始反证，\n若`k' < k`，而根据题意`k'`也为`l1, l2` 的公约数，则`k'`必能被`k`整除，这说明我们可以将该字串的长度扩充到`k`，同时保持它仍然为`str1`和`str2`的公因子，所以这种情况下这个长度为`k`的公因子就不是最大公因子。\n若`k' > k`， 根据题意`k'`为`l1`, `l2` 的公约数， 而k为最大公约数，而这时出现了一个比最大公约数还大的公约数，这是矛盾的，所以这种情况也是不可能的。\n\n综合以上，最大公因子的长度必然等于两串长度的最大公约数。\n\n## [914. 卡牌分组](https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/)\n\n给定一副牌，每张牌上都写着一个整数。\n\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n\n- 每组都有 X 张牌。\n- 组内所有的牌上都写着相同的整数。\n\n仅当你可选的 X >= 2 时返回 true。\n\n**示例 1：**\n\n```java\n输入：[1,2,3,4,4,3,2,1]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\n```\n\n**示例 2：**\n\n```java\n输入：[1,1,1,2,2,2,3,3]\n输出：false\n解释：没有满足要求的分组。\n```\n\n**示例 3：**\n\n```java\n输入：[1]\n输出：false\n解释：没有满足要求的分组。\n```\n\n**示例 4：**\n\n```java\n输入：[1,1]\n输出：true\n解释：可行的分组是 [1,1]\n```\n\n**示例 5：**\n\n```java\n输入：[1,1,2,2,2,2]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[2,2]\n```\n\n**提示：**\n\n- `1 <= deck.length <= 10000`\n- `0 <= deck[i] < 10000`\n\n**解法一**\n\n```java\npublic boolean hasGroupsSizeX(int[] deck) {\n    HashMap<Integer,Integer> map=new HashMap<>();\n    for(int i=0;i<deck.length;i++){\n        map.put(deck[i],map.getOrDefault(deck[i],0)+1);\n    }\n    int g=-1;\n    for (Integer key:map.keySet()) {\n        int freq=map.get(key);\n        if(g==-1) {\n            g=freq;\n        }else{\n            if(freq<2) return false;\n            g=gcd(freq,g);\n        }\n    }\n    return g>=2;\n}\n\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n```\nwa一次就知道咋做了，一开始以为只要所有元素出现次数可以整除就行了，wa了之后就意识到只要求一个最大公约数就可以了\n\n**解法二**\n\n给定了范围，直接用数组模拟\n\n```java\npublic int gcd(int a,int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n\npublic boolean hasGroupsSizeX2(int[] deck) {\n    int[] hash=new int[10001];\n    for(int i=0;i<deck.length;i++){\n        hash[deck[i]]++;\n    }\n    int g=-1;\n    for (int i=0;i<hash.length-1;i++) {\n        if(hash[i]!=0){\n            if(hash[i]<2) return false;\n            g= g!=-1?gcd(g,hash[i]):hash[i];\n            if(g==1) return false; //优化,提前终止\n        }\n    }\n    return g>=2;\n}\n```\n## [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)\n\n比较两个版本号 version1 和 version2。\n如果 `version1 > version2` 返回 1，如果 `version1 < version2` 返回 -1， 除此之外返回 0。\n\n你可以假设版本字符串非空，并且只包含数字和 . 字符。\n\n . 字符不代表小数点，而是用于分隔数字序列。\n\n例如，`2.5`  不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。\n\n你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。\n\n**示例 1:**\n\n```java\n输入: version1 = \"0.1\", version2 = \"1.1\"\n输出: -1\n```\n\n**示例 2:**\n\n```java\n输入: version1 = \"1.0.1\", version2 = \"1\"\n输出: 1\n```\n\n\n**示例 3:**\n\n```java\n输入: version1 = \"7.5.2.4\", version2 = \"7.5.3\"\n输出: -1\n```\n\n\n**示例 4：**\n\n```java\n输入：version1 = \"1.01\", version2 = \"1.001\"\n输出：0\n解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。\n```\n\n\n**示例 5：**\n\n```java\n输入：version1 = \"1.0\", version2 = \"1.0.0\"\n输出：0\n解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。\n```\n\n**提示：**\n\n1. 版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。\n2. 版本字符串不以点开始或结束，并且其中不会有两个连续的点。\n\n**解法一**\n\n貌似笔试喜欢出这题，挺简单的，用java分割的时候要注意 `\".\"` 是一个正则表达式，匹配任意单个字符，我们如果要将它看作一个普通字符需要加上双斜线`\"\\\\.\"`\n\n```java\npublic int compareVersion(String version1, String version2) {\n    String[] v1=version1.split(\"\\\\.\");\n    String[] v2=version2.split(\"\\\\.\");\n    int len1=v1.length,len2=v2.length;\n    int i=0,j=0;\n    while(i<len1 || j<len2) {\n        int a=Integer.valueOf(i<len1?v1[i++]:\"0\");\n        int b=Integer.valueOf(j<len2?v2[j++]:\"0\");\n        if (a<b) {\n            return -1;\n        }else if (a>b){\n            return 1;\n        }\n    }\n    return 0;\n}\n```\n\n## [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 `\"LEETCODEISHIRING\"` 行数为 3 时，排列如下：\n\n```java\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n```java\nstring convert(string s, int numRows);\n```\n\n**示例 1:**\n\n```java\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n```\n\n**示例 2:**\n\n```java\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n**解法一**\n\n比较脑残，但是勉强还是过了\n\n```java\npublic String convert(String s, int numRows) {\n    if (s==null || s.length()<=0 || numRows==1) {\n        return s;\n    }\n    int len=s.length();\n    //足够的空间\n    int[][] strs=new int[((len/((numRows-1)*2))+1)*(numRows-1)][numRows];\n    int index=0,x=0,y=0;\n    boolean flag=false;\n    while(index < s.length()) {\n        if (!flag) {\n            strs[x][y++]=s.charAt(index++);\n            if (y==numRows-1) {\n                flag=true;\n            }\n        }else{\n            strs[x++][y--]=s.charAt(index++);\n            if (y==0) {\n                flag=false;\n            }\n        }\n    }\n    StringBuilder sb=new StringBuilder();\n    for (int j=0;j<strs[0].length;j++) {\n        for (int i=0;i<strs.length;i++) {\n            if (strs[i][j]!=0) {\n                sb.append((char)strs[i][j]);\n            }\n        }\n    }\n    return sb.toString();\n}\n```\n\n就是将字符按照之字形填入一个二维数组中，然后按规则取出来就ok，最优解看了，明天再来写！\n\n**解法二**\n\n今天还是不够清晰，后天再写\n\n## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`\"ace\"`是`\"abcde\"`的一个子序列，而`\"aec\"`不是）。\n\n**示例 1:**\n\n```java\ns = \"abc\", t = \"ahbgdc\"\n返回 true.\n```\n\n**示例 2:**\n\n```java\ns = \"axc\", t = \"ahbgdc\"\n返回 false.\n```\n\n**后续挑战 :**\n\n如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n**解法一**\n\n```java\npublic boolean isSubsequence(String s, String t) {\n    if (s==null || t==null) {\n        return false;\n    }\n    int sindex=0,tindex=0;\n    while(sindex<s.length()) {\n        while(tindex<t.length() && sindex<s.length()){\n            if (s.charAt(sindex)==t.charAt(tindex)) {\n                sindex++;\n            }\n            tindex++;\n        }\n        if (tindex==t.length()) {\n            break; \n        }\n    }\n    return sindex==s.length();\n}\n```\n可以改成递归（多练习递归）\n\n```java\npublic boolean isSubsequence(String s,String t){\n    return subsequence(s,t,0,0);\n}\n\npublic boolean subsequence(String s,String t,int sindex,int tindex){\n    if (sindex == s.length()) {\n        return true;\n    }\n    //上下if不能交换,可能最后一个才相等\n    if (tindex == t.length()) {\n        return false;\n    }\n    return s.charAt(sindex)==t.charAt(tindex)?subsequence(s,t,sindex+1,tindex+1):subsequence(s,t,sindex,tindex+1);\n}\n```\n**解法二**\n\n```java\n//大量的s字符串 处理\npublic boolean isSubsequence3(String s, String t) {\n    //预处理\n    ArrayList<ArrayList<Integer>> hash=new ArrayList<>();\n    for (int i=0;i<26;i++) {\n        hash.add(new ArrayList());\n    }\n    for (int i=0;i<t.length();i++) {\n        hash.get(t.charAt(i)-'a').add(i);\n    }\n    //经过上面的预处理,后面的处理就会很快,不用再遍历t字符串\n    int lastIndex=-1;\n    for (int i=0;i<s.length();i++) {\n        List<Integer> indexList=hash.get(s.charAt(i)-'a');\n        int temp=binarySearch(indexList,lastIndex);\n        if (temp==indexList.size()) {\n            return false;\n        }\n        lastIndex=indexList.get(temp);\n    }\n    return true;\n}\n\n//找到第一个比target大的元素\npublic int binarySearch(List<Integer> list,int target){\n    int left=0,right=list.size()-1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if (list.get(mid)>target) {\n            right=mid-1;\n        }else{\n            left=mid+1;\n        }\n    }\n    return left;\n}\n```\n\n## [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)\n\n给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n\n**示例 1:**\n\n```java\n输入: [1,2,3,4,5,6,7] 和 k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n```\n\n\n**示例 2:**\n\n```java\n输入: [-1,-100,3,99] 和 k = 2\n输出: [3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n```\n\n**说明:**\n\n- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n- 要求使用空间复杂度为 O(1) 的 **原地** 算法 \n\n**解法一**\n\n常规解法，每次保留数组最后一个元素，从后往前将每个元素赋值为前一个元素的值，这样就相当于将数组整体向后循环移动一次，循环移动k次就是最后的结果\n\n```java\npublic void rotate(int[] nums, int k) {\n    if(nums==null||nums.length<=1||k==0){\n        return;\n    }\n    int len=nums.length;\n    k=k%len;\n    for (int i=0;i<k;i++) {\n        int temp=nums[len-1];\n        for (int j=len-1;j>=0;j--) {\n            nums[j]=nums[j-1];\n        }\n        nums[0]=temp;\n    }\n}\n```\n时间复杂度较高，`O(NK)` Java可以过，但是C/C++可能过不了\n\n**解法二**\n\n这个做法就相当巧妙了，三次翻转🐂🍺\n\n```java\n//翻转的方法\npublic void rotate(int[] nums, int k) {\n    if(nums==null||nums.length<=1||k==0){\n        return;\n    }\n    int len=nums.length;\n    k=k%len;\n    if(k==0)return;\n    reverse(nums,0,len-k-1);\n    reverse(nums,len-k,len-1);\n    reverse(nums,0,nums.length-1);\n}\n\npublic void reverse(int []nums,int left,int right){\n    while(left<right){\n        swap(nums,left++,right--);\n    }\n}\n\npublic void swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n`O(N)` 应该是最优解了\n\n## [1232. 缀点成线](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/)\n\n在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。\n\n请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 `true`，否则请返回  `false`\n\n**解法一**\n\n10.20竞赛第一题，判断给定的点是不是再一条直线上，判断和前两个点是不是在一条直线上，注意不要直接除算斜率，那样是不准确的\n\n```java\npublic boolean checkStraightLine(int[][] coordinates) {\n    for (int i=2;i<coordinates.length;i++) {\n        if((coordinates[i][1]-coordinates[i-1][1])*(coordinates[i-1][0]-coordinates[i-2][0])!=\n           (coordinates[i][0]-coordinates[i-1][0])*(coordinates[i-1][1]-coordinates[i-2][1])){\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## [1233. 删除子文件夹](https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/)\n\n你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。\n\n我们这样定义「子文件夹」：\n\n- 如果文件夹 `folder[i]` 位于另一个文件夹 `folder[j]` 下，那么 `folder[i]` 就是 `folder[j]` 的子文件夹。\n  文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：\n\n- `/` 后跟一个或者多个小写英文字母。\n  例如，`/leetcode` 和 `/leetcode/problems` 都是有效的路径，而空字符串和 `/` 不是。\n\n **示例 1：**\n\n```java\n输入：folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n输出：[\"/a\",\"/c/d\",\"/c/f\"]\n解释：\"/a/b/\" 是 \"/a\" 的子文件夹，而 \"/c/d/e\" 是 \"/c/d\" 的子文件夹。\n```\n\n\n**示例 2：**\n\n```java\n输入：folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\n输出：[\"/a\"]\n解释：文件夹 \"/a/b/c\" 和 \"/a/b/d/\" 都会被删除，因为它们都是 \"/a\" 的子文件夹。\n```\n\n\n**示例 3：**\n\n```java\n输入：folder = [\"/a/b/c\",\"/a/b/d\",\"/a/b/ca\"]\n输出：[\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n```\n\n**提示：**\n\n- 1 <= folder.length <= 4 * 10^4\n- 2 <= folder[i].length <= 100\n- folder[i] 只包含小写字母和 /\n- folder[i] 总是以字符 / 起始\n- 每个文件夹名都是唯一的\n\n**解法一**\n\n`2019.10.20`的竞赛题，当时没做出来。。。一直超时，太菜了\n\n```java\npublic List<String> removeSubfolders(String[] folder) {\n    Arrays.sort(folder);\n    List<String> res=new LinkedList<>();\n    int root=0;\n    res.add(folder[0]);\n    for (int i=1;i<folder.length;i++) {\n        if (!folder[i].startsWith(folder[root]+\"/\")) {\n            res.add(folder[i]);\n            root=i;\n        }\n    }\n    return res;\n}\n```\n当时我想到了排序，但是并没处理好，排序之后还是傻傻的一个个去对比，其实排序后就很清楚了\n\n`folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]` 题目其实也在暗示我们要排序，给的case都是排好序的\n\n当然这里很精髓的一步就是在对比的时候在 `folder[root]` 后面加上一个 `\"/\"` ，这样就不会将 `a/b/c` 判断为 `a/b/ca` 的根目录了~\n\n## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n**示例 1：**\n\n```java\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n```\n\n\n**示例 2：**\n\n```java\n输入: \"cbbd\"\n输出: \"bb\"\n```\n\n**解法一**\n\n是面试经常考的一题，还是挺有意思的，除了这个还有几道回文的题我放在动态规划专题中\n\n```java\npublic String longestPalindrome(String s) {\n    if (s==null || s.length()<=0) {\n        return \"\";\n    }\n    String res=s.charAt(0)+\"\";//只有1个字符\n    for (int i=1;i<s.length();i++) {\n        String even=palindrome(s,i-1,i); //偶数长度回文,从两个字符中间开始扩散\n        String odd=palindrome(s,i,i); //奇数长度回文,从某一个字符开始扩散\n        String temp=odd.length()>even.length()?odd:even;\n        if (temp.length()>res.length()) {\n            res=temp;\n        }\n    }\n    return res;\n}\n\npublic String palindrome(String s,int i,int j){\n    while(i>=0 && j<=s.length()-1 && s.charAt(i)==s.charAt(j)){\n        i--;\n        j++;\n    }\n    return s.substring(i+1,j);\n}\n```\n如果采用暴力法的话就是枚举所有子串，判断是不是回文串，最后求个最长的，时间复杂度`O(N^3)` ，但是我们可以利用回文的特征，利用中心扩散法，以`str`的**各个位置**作为中心，向两边扩散，最后求得最大值，注意得这里说的是**各个位置**，这个里面其实就包含了元素之间的间隙，其实整体思路还是挺简单的，但经过我们小小的转换思路，时间复杂度就降低到了`O(N^2)`，当然，这里还不是最优解，最优应该是[Manacher](https://oi-wiki.org/string/manacher/) （马拉车）算法，等后面有时间我再来研究这种算法\n\n## [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)\n\nDifficulty: **困难**\n\n\n给定一组 **互不相同** 的单词， 找出所有**不同**的索引对`(i, j)`，使得列表中的两个单词， `words[i] + words[j]` ，可拼接成回文串。\n\n**示例 1：**\n\n```go\n输入：[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n输出：[[0,1],[1,0],[3,2],[2,4]] \n解释：可拼接成的回文串为 [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]\n```\n\n**示例 2：**\n\n```go\n输入：[\"bat\",\"tab\",\"cat\"]\n输出：[[0,1],[1,0]] \n解释：可拼接成的回文串为 [\"battab\",\"tabbat\"]\n```\n\n**解法一**\n\n枚举单词的所有前缀or后缀，如果除了前缀or后缀剩余部分是回文串，并且在dict中存在前缀or后缀的翻转，那么这两个单词就能构成回文对\n```golang\nfunc palindromePairs(words []string) [][]int {\n    var dict = make(map[string]int)\n    for i := 0; i < len(words); i++ {\n        dict[reverse(words[i])] = i\n    }\n    var res [][]int\n    for i := 0; i < len(words); i++ {\n        for j := 0; j <= len(words[i]); j++ {\n            if idx, ok := dict[words[i][:j]]; ok && idx != i && isPalindrome(words[i][j:]) {\n                res = append(res, []int{i, idx})\n            }\n            //这里需要判断下j!=0，避免重复的判断，s[0:] == s[:len(s)]\n            if idx, ok := dict[words[i][j:]]; j != 0 && ok && idx != i && isPalindrome(words[i][:j]) {\n                res = append(res, []int{idx, i})\n            }\n        }\n    }\n    return res\n}\n\nfunc reverse(s string) string {\n    var bs = []byte(s)\n    for i, j := 0, len(bs)-1; i < j; i, j = i+1, j-1 {\n        bs[i], bs[j] = bs[j], bs[i]\n    }\n    return string(bs)\n}\n\nfunc isPalindrome(s string) bool {\n    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n        if s[i] != s[j] {\n            return false\n        }\n    }\n    return true\n}\n```\n属于比较暴力的解法，这题也可以使用马拉车&字典树，这里我就不多写了\n## [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)\n\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n在构造过程中，请注意区分大小写。比如 `\"Aa\"` 不能当做一个回文字符串。\n\n**注意:**\n假设字符串的长度不会超过 1010。\n\n**示例 1:**\n\n```java\n输入:\n\"abccccdd\"\n\n输出:\n7\n\n解释:\n我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\n```\n\n**解法一**\n\n和上面的题目名字一样，但是请注意审题！！！\n\n```java\npublic int longestPalindrome(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int[] hash=new int[128];\n    for(int i=0;i<s.length();i++){\n        hash[s.charAt(i)]++;\n    }\n    //Arrays.sort(hash);\n    int res=0;boolean flag=false;\n    for(int i=hash.length-1;i>=0;i--){\n        if(hash[i]!=0){\n            if(hash[i]%2==0){\n                res+=hash[i]; //偶数直接加\n            }else{\n                flag=true;\n                res+=(hash[i]-1); //奇数减一再加\n            }\n        }\n    }\n    return flag?res+1:res;\n}\n```\n\n## [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)\n\n给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。\n\n**示例 1:**\n\n```java\n输入: \"aba\"\n输出: True\n```\n\n**示例 2:**\n\n```java\n输入: \"abca\"\n输出: True\n解释: 你可以删除c字符。\n```\n\n**注意:**\n\n1. 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。\n\n**解法一**\n\n模拟就行了\n\n```java\npublic boolean validPalindrome(String s) {\n    if(s==null || s.length()<=0) return true;\n    int left=0,right=s.length()-1;\n    while(left<right){\n        if(s.charAt(left)==s.charAt(right)){\n            left++;right--;\n        }else{\n            return valid(s,left+1,right) || valid(s,left,right-1);\n        }\n    }\n    return true;\n}\n\npublic boolean valid(String s,int left,int right){\n    while(left<=right){\n        if(s.charAt(left)==s.charAt(right)){\n            left++;right--;\n        }else{\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## [1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)\n\n给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 **子序列**。\n\n返回删除给定字符串中所有字符（字符串为空）的最小删除次数。\n\n「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。\n\n「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 \n\n**示例 1：**\n\n```java\n输入：s = \"ababa\"\n输出：1\n解释：字符串本身就是回文序列，只需要删除一次。\n```\n\n**示例 2：**\n\n```java\n输入：s = \"abb\"\n输出：2\n解释：\"abb\" -> \"bb\" -> \"\". \n先删除回文子序列 \"a\"，然后再删除 \"bb\"。\n```\n\n\n**示例 3：**\n\n```java\n输入：s = \"baabb\"\n输出：2\n解释：\"baabb\" -> \"b\" -> \"\". \n先删除回文子序列 \"baab\"，然后再删除 \"b\"。\n```\n\n\n**示例 4：**\n\n```java\n输入：s = \"\"\n输出：0\n```\n\n**提示：**\n\n- `0 <= s.length <= 1000`\n- `s` 仅包含字母 'a'  和 'b'\n\n**解法一**\n\n某一次周赛的第一题，乍一看最长回文子串？最长回文序列？这题当时还是难到了不少人，我那次没参加，后台听说了第一题是个坑，然后这里审题的时候就很注意，没踩坑😁\n\n```java\npublic int removePalindromeSub(String s) {\n    if (s==null || s.length()<=0) {\n        return 0;\n    }\n    for(int i=0,j=s.length()-1;i<=j;i++,j--){\n        if (s.charAt(i)!=s.charAt(j)) {\n            return 2;\n        }\n    }\n    return 1;\n}\n```\n\n题目说了只有两个字母a和b，而且要删除的是**回文子序列**，这样一说就清楚了，这才是简单题的水准呐~还是挺有意思的，脑筋急转弯hahaha\n\n\n## [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)\n\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n注意:\n\n- 可以认为区间的终点总是大于它的起点。\n- 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n**示例 1:**\n\n```java\n输入: [ [1,2], [2,3], [3,4], [1,3] ]\n\n输出: 1\n\n解释: 移除 [1,3] 后，剩下的区间没有重叠。\n```\n\n**示例 2:**\n\n```java\n输入: [ [1,2], [1,2], [1,2] ]\n\n输出: 2\n\n解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n```\n\n**示例 3:**\n\n```java\n输入: [ [1,2], [2,3] ]\n\n输出: 0\n\n解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n```\n\n**解法一**\n\n动态规划，其实和最长递增子序列是一样的\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    int[]dp=new int[intervals.length];\n    int max=-1;\n    for (int i=0;i<intervals.length;i++) {\n        dp[i]=1;\n        for (int j=0;j<i;j++) {\n            if(intervals[i][0]>=intervals[j][1]){\n                dp[i]=Math.max(dp[j]+1,dp[i]);\n            }\n        }\n        max=Math.max(max,dp[i]);\n    }\n    return intervals.length-max;\n}\n```\n171ms，8%，感觉快要过不了了。。。本来是是写的记忆化递归的，结果过不了。。。卡在倒数第二个case上\n\n```java\nHashMap<Pair,Integer> cache=new HashMap<>();//TLE\n\npublic int eraseOverlapIntervals2(int[][] intervals) {\n    Arrays.sort(intervals,(a,b)->a[0]-b[0]);\n    return intervals.length-dfs(intervals,0,Integer.MIN_VALUE);\n}\n\n//背包问题,返回最多可以留下的区间\npublic int dfs(int[][] intervals,int index,int prev) {\n    if (index==intervals.length) {\n        return 0;\n    }\n    Pair key=new Pair(index,prev);\n    if (cache.containsKey(key)) {\n        return cache.get(key);\n    }\n    int res=dfs(intervals,index+1,prev);\n    if (intervals[index][0]>=prev) {\n        res=Math.max(res,dfs(intervals,index+1,intervals[index][1])+1);\n    }\n    cache.put(key,res);\n    return res;\n}\n```\n**解法二**\n\n贪心，时间复杂度降低为线性\n\n```java\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals==null || intervals.length<=0) {\n        return 0;\n    }\n    //按照起点排序,重叠的时候选择保留结尾小的那一个\n    //Arrays.sort(intervals,(a,b)->a[0]-b[0]); lambda初始化效率会低一点\n    Arrays.sort(intervals,new Comparator<int[]>(){\n        @Override\n        public int compare(int[] a,int[] b){\n            return a[0]-b[0];\n        }\n    });\n    int res=1;\n    int prev=0;\n    for (int i=1;i<intervals.length;i++) {\n        if (intervals[i][0]>=intervals[prev][1]) {\n            res++;\n            prev=i;\n        }else if(intervals[i][1]<intervals[prev][1]){\n            prev=i; //选择结尾小的那一个\n        }\n    }\n    return intervals.length-res;\n}\n```\n按照起点排序，在重叠的时候优先选择结尾小的哪一个，这样就可能得到更多的区间组合，关于这个算法的正确性我就不证明了\n\n\n\n## [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)\n\n编写一个程序判断给定的数是否为丑数。\n\n丑数就是只包含质因数 2, 3, 5 的正整数。\n\n**示例 1:**\n\n```java\n输入: 6\n输出: true\n解释: 6 = 2 × 3\n```\n\n**示例 2:**\n\n```java\n输入: 8\n输出: true\n解释: 8 = 2 × 2 × 2\n```\n\n**示例 3:**\n\n```java\n输入: 14\n输出: false \n解释: 14 不是丑数，因为它包含了另外一个质因数 7。\n```\n\n**说明：**\n\n1. `1` 是丑数。\n2. 输入不会超过 `32` 位有符号整数的范围: `[−231,  231 − 1]`。\n\n**解法一**\n\n直接暴力，还是比较简单\n\n```java\npublic boolean isUgly(int num) {\n    if (num<=0) {\n        return false;\n    }\n    if(num==1) {\n        return true;\n    }\n    return num%2==0?isUgly(num/2):false || num%3==0?isUgly(num/3):false || num%5==0?isUgly(num/5):false;\n}\n```\n\n## [1333. 餐厅过滤器](https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/)\n\n给你一个餐馆信息数组 `restaurants`，其中  `restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]`。你必须使用以下三个过滤器来过滤这些餐馆信息。\n\n其中素食者友好过滤器 `veganFriendly` 的值可以为 `true` 或者 `false`，如果为 `true` 就意味着你应该只包括 `veganFriendlyi` 为 `true` 的餐馆，为 `false` 则意味着可以包括任何餐馆。此外，我们还有最大价格 `maxPrice` 和最大距离 `maxDistance` 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。\n\n过滤后返回餐馆的 `id`，按照 `rating` 从高到低排序。如果 `rating` 相同，那么按 `id` 从高到低排序。简单起见， `veganFriendlyi` 和 `veganFriendly` 为 `true` 时取值为 1，为 `false` 时，取值为 0 。\n\n**示例一**\n\n```java\n输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n输出：[3,1,5] \n解释： \n这些餐馆为：\n餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\n餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\n餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\n餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\n餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \n在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 \n```\n\n**示例 2：**\n\n```java\n输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n输出：[4,3,2,1,5]\n解释：餐馆与示例 1 相同，但在 veganFriendly = 0 的过滤条件下，应该考虑所有餐馆。\n```\n\n\n**示例 3：**\n\n```java\n输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n输出：[4,5]\n```\n\n**提示：**\n\n- `1 <= restaurants.length <= 10^4`\n- `restaurants[i].length == 5`\n- `1 <= idi, ratingi, pricei, distancei <= 10^5`\n- `1 <= maxPrice, maxDistance <= 10^5`\n- `veganFriendlyi` 和 `veganFriendly` 的值为 0 或 1 。\n- 所有 `idi` 各不相同。\n\n**解法一**\n\n看到这个题，javaer不用stream可太可惜了hahaha\n\n```java\npublic List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n    return Stream.of(restaurants)\n        .filter(r-> (veganFriendly==1?r[2]==veganFriendly:true) && r[4]<=maxDistance && r[3]<=maxPrice)\n        .sorted((r1,r2)->r1[1]!=r2[1]?r2[1]-r1[1]:r2[0]-r1[0])\n        .map(r->r[0])\n        .collect(Collectors.toList());\n}\n```\n\n## [5313. 时钟指针的夹角](https://leetcode-cn.com/problems/angle-between-hands-of-a-clock/)\n\n给你两个数 `hour` 和 `minutes` 。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。\n\n这题就懒得copy了，19场双周赛的第三题，不应该是mid题的。。。\n\n**解法一**\n\n```java\npublic double angleClock(int hour, int minutes) {\n    double m=minutes/60.0 * 360;\n    double h=((hour/12.0)*360)%360 + 30*minutes/60.0;\n    return Math.min(Math.abs(m-h),360-Math.abs(m-h));\n}\n```\n\n化简一下是 **h时m分的夹角为：5.5m-30h**\n\n## [5169. 日期之间隔几天](https://leetcode-cn.com/problems/number-of-days-between-two-dates/)\n\n请你编写一个程序来计算两个日期之间隔了多少天。\n\n日期以字符串形式给出，格式为 `YYYY-MM-DD`。\n\n**解法一**\n\n177周赛的T1\n\n```java\nimport java.time.*;\nimport java.time.temporal.ChronoUnit;\nclass Solution {\n    public int daysBetweenDates(String date1, String date2) {\n        return (int)Math.abs(LocalDate.parse(date1).until(LocalDate.parse(date2),ChronoUnit.DAYS));\n    }\n}\n```\n\n做LeetCode少数导包了的题🤣\n\n**解法二**\n\ncopy大佬的原生解法\n\n```java\n\nprivate int[] months = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\npublic int daysBetweenDates(String date1, String date2) {\n    String[] d1 = date1.split(\"-\");\n    String[] d2 = date2.split(\"-\");\n    int day1 = getYears(Integer.valueOf(d1[0]) - 1) + getMonths(Integer.valueOf(d1[0]), Integer.valueOf(d1[1]) - 1) + Integer.valueOf(d1[2]);\n    int day2 = getYears(Integer.valueOf(d2[0]) - 1) + getMonths(Integer.valueOf(d2[0]), Integer.valueOf(d2[1]) - 1) + Integer.valueOf(d2[2]);\n    return Math.abs(day1 - day2);\n}\n\nprivate int getYears(int year) {\n    int sum = (year - 1971) * 365;\n    for (int i = 1971; i <= year; ++i) {\n        if (isRun(i)) {\n            ++sum;\n        }\n    }\n    return sum;\n}\n\nprivate int getMonths(int year, int month) {\n    int sum = 0;\n    for (int i = 1; i <= month; ++i) {\n        sum += months[i];\n    }\n    if (isRun(year) && month >= 2) {\n        ++sum;\n    }\n    return sum;\n}\n\nprivate boolean isRun(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n```\n\n## [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)\n\n给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。\n\n**示例 1:**\n\n```java\n输入: \"Let's take LeetCode contest\"\n输出: \"s'teL ekat edoCteeL tsetnoc\" \n```\n\n**注意：**在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格\n\n**解法一**\n\n原生的做法\n\n```java\npublic String reverseWords(String s) {\n    s+=\" \";//统一操作\n    char[] cs=s.toCharArray();\n    int start=0;\n    for (int i=0;i<cs.length;i++) {\n        if (cs[i]==' ') {\n            reverse(cs,start,i-1);\n            start=i+1;\n        }\n    }\n    return new String(cs,0,cs.length-1);\n}\n\npublic void reverse(char[] s,int left,int right){\n    for (int i=left,j=right;i<j;i++,j--) {\n        char temp=s[i];\n        s[i]=s[j];\n        s[j]=temp;\n    }\n}\n```\n\n## [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)\n\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n**示例 1：**\n\n```java\n输入: \"the sky is blue\"\n输出: \"blue is sky the\"\n```\n\n\n**示例 2：**\n\n```java\n输入: \"  hello world!  \"\n输出: \"world! hello\"\n解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n```\n\n\n**示例 3：**\n\n```java\n输入: \"a good   example\"\n输出: \"example good a\"\n解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n```\n\n**说明：**\n\n- 无空格字符构成一个单词。\n- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n**进阶：**\n\n请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。\n\n**解法一**\n\n```java\npublic String reverseWords(String s) {\n    if(s==null || s.length()<=0) return \"\";\n    Deque<String> stack=new ArrayDeque<>();\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)==' '){\n            continue;\n        }\n        int j=i;\n        while(i<s.length() && s.charAt(i)!=' '){\n            i++;\n        }\n        stack.push(s.substring(j,i));\n    }\n    if(stack.isEmpty()) return \"\";\n    StringBuilder sb=new StringBuilder();\n    sb.append(stack.pop());\n    while(!stack.isEmpty()){\n        sb.append(\" \"+stack.pop());\n    }\n    return sb.toString();\n}\n```\n比较原生的做法，最开始写的借助split等方法的，比较简单就不多说了\n\n**解法二**\n\n原地的做法，比较繁琐，后面有时间再来实现下\n\n1. 翻转整个字符\n2. 翻转单个字符\n3. 去除多余空格\n\n## [面试题 01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)\n\n字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。\n\ncase就不粘了\n\n**解法一**\n\n直接写就行了\n\n```java\npublic String compressString(String S) {\n    StringBuilder sb=new StringBuilder();\n    int index=0;\n    while(index<S.length()){\n        sb.append(S.charAt(index));\n        int r=1;\n        while(index<S.length()-1&&S.charAt(index)==S.charAt(index+1)){\n            ++index;\n            r++;\n        }\n        sb.append(r);\n        index++;\n    }\n    return sb.length()<S.length()?sb.toString():S;\n}\n```\n## [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)\n\n给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n**示例:**\n\n```java\n输入: [1,2,3,4]\n输出: [24,12,8,6]\n说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n```\n\n**进阶：**\n你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）\n\n**解法一**\n\n还行，独立的想到了解法，没啥好说的\n\n```java\npublic int[] productExceptSelf(int[] nums) {\n    if (nums==null || nums.length<=0) {\n        return new int[0];\n    }\n    int[] left=new int[nums.length+1]; \n    left[0]=1;//left[i]: [0 ~ i-1]的累积\n    int[] right=new int[nums.length+1];\n    right[nums.length]=1; //right[i]: [i ~ nums.length-1]的累积\n    for (int i=1;i<=nums.length;i++) {\n        left[i]=left[i-1]*nums[i-1];\n    }\n    for (int i=nums.length-1;i>=0;i--) {\n        right[i]=right[i+1]*nums[i];\n    }\n    int[] res=new int[nums.length];\n    //1 2 3\n    res[0]=right[1];\n    for (int i=1;i<nums.length;i++) {\n        res[i]=left[i]*right[i+1];\n    }\n    return res;\n}\n```\n\n**解法二**\n\nO(1)进阶版有时间再来补\n\n## [5341. 最后 K 个数的乘积](https://leetcode-cn.com/problems/product-of-the-last-k-numbers/)\n\n请你实现一个「数字乘积类」`ProductOfNumbers`，要求支持下述两种方法：\n\n1. add(int num)\n\n- 将数字 num 添加到当前数字列表的最后面。\n\n2. getProduct(int k)\n\n- 返回当前数字列表中，最后 k 个数字的乘积。\n- 你可以假设当前列表中始终 至少 包含 k 个数字。\n- 题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。\n\n**示例：**\n\n```java\n输入：\n[\"ProductOfNumbers\",\"add\",\"add\",\"add\",\"add\",\"add\",\"getProduct\",\"getProduct\",\"getProduct\",\"add\",\"getProduct\"]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n\n输出：\n[null,null,null,null,null,null,20,40,0,null,32]\n\n解释：\nProductOfNumbers productOfNumbers = new ProductOfNumbers();\nproductOfNumbers.add(3);        // [3]\nproductOfNumbers.add(0);        // [3,0]\nproductOfNumbers.add(2);        // [3,0,2]\nproductOfNumbers.add(5);        // [3,0,2,5]\nproductOfNumbers.add(4);        // [3,0,2,5,4]\nproductOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20\nproductOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40\nproductOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0\nproductOfNumbers.add(8);        // [3,0,2,5,4,8]\nproductOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 \n```\n\n**提示：**\n\n```java\nadd 和 getProduct 两种操作加起来总共不会超过 40000 次。\n0 <= num <= 100\n1 <= k <= 40000\n```\n\n**解法一**\n\n176周赛的第二题，思路倒是很容易想到，维护一个前缀积，然后用全积除以对应k位置的就行了，但是细节的处理出了大问题haha~\n\n```java\nLinkedList<Integer> product=null;\n\npublic ProductOfNumbers() {\n    product=new LinkedList<>();\n    product.add(1);\n}\n\npublic void add(int num) {\n    if(num==0){ //重新构建\n        product=new LinkedList<>();\n        product.add(1);\n    }else{\n        product.add(num*product.getLast());\n    }\n}\n\n//1| 1 0 2 3  k=3\npublic int getProduct(int k) {\n    if(k>=product.size()){\n        return 0;\n    }\n    return product.getLast()/product.get(product.size()-k-1);\n}\n```\n一开始维护了所有的前缀积，结果后面的case过不了，出现了除0异常，很显然把0换成1，后面的case大了之后累乘的结果太大了，溢出为0了。\n\n上面代码的处理方式是参考了大佬的解法，遇到0的时候就直接重置队列，最后如果k大于队列长度说明这个序列肯定是包含了0，直接返回0就可以了\n\n## [面试题64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)\n\n求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n\n**示例 1：**\n\n```java\n输入: n = 3\n输出: 6\n```\n\n\n**示例 2：**\n\n```java\n输入: n = 9\n输出: 45\n```\n\n**限制：**\n\n- 1 <= n <= 10000\n\n**解法一**\n\n我一开始想的是把 `n*(n-1)/2`  展开，变成平方，用pow代替，除2用移位代替，但是想了想感觉pow底层应该也是用了乘\n\n所以还是得用递归，但是递归必须有出口，这里的关键就是怎么停止\n\n```java\npublic int sumNums(int n) {\n    int sum = n;\n    //逻辑与短路\n    boolean ans = (n > 0) && ((sum += sumNums(n - 1)) > 0);\n    return sum;\n}\n```\n\n## [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)\n\n已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n\n不要使用系统的 Math.random() 方法。\n\n**解法一**\n\n拒绝采样，两次Rand7()拒绝大于40的情况\n\n```java\npublic int rand10() {\n    int a,b,idx;\n    do{\n        a=rand7();\n        b=rand7();\n        idx=a+(b-1)*7;\n    }while(idx>40);\n    return 1+(idx-1)%10;\n}\n```\n\n概率论里面学过的，都忘了\n\n![38nhYn.png](https://s2.ax1x.com/2020/02/24/38nhYn.png)\n\n期望其实还可以更低，这里后面有时间再来研究\n\n## [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)\n\n打乱一个没有重复元素的数组。\n\n**示例:**\n\n```java\n// 以数字集合 1, 2 和 3 初始化数组。\nint[] nums = {1,2,3};\nSolution solution = new Solution(nums);\n\n// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。\nsolution.shuffle();\n\n// 重设数组到它的初始状态[1,2,3]。\nsolution.reset();\n\n// 随机返回数组[1,2,3]打乱后的结果。\nsolution.shuffle();\n```\n\n**解法一**\n\n洗牌算法，确保至少会出现`N!`种情况，且每种情况出现的概率是相同的\n\n```java\nint[] origin=null;\n\nint[] nums=null;\n\nRandom random=new Random();\n\npublic Solution(int[] nums) {\n    this.nums=nums;\n    origin=nums.clone();\n}\n\n/** Resets the array to its original configuration and return it. */\npublic int[] reset() {\n    return origin;\n}\n\n/** Returns a random shuffling of the array. */\npublic int[] shuffle() {\n    for (int i=nums.length-1;i>=0;i--) {\n        //从尾部开始这样对于Java会简单一点点\n        int rand=(int)(random.nextInt(i+1)); //随机【0,i】的元素\n        swap(nums,i,rand);\n    }\n    return nums;\n}\n\npublic void swap(int[] nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n## [面试题61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)\n\n从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n\n**示例 1:**\n\n```java\n输入: [1,2,3,4,5]\n输出: True\n```\n\n**示例 2:**\n\n```java\n输入: [0,0,1,2,5]\n输出: True\n```\n\n**限制：**\n\n数组长度为 5 \n\n数组的数取值为 [0, 13] .\n\n**解法一**\n\n只有5张牌，先排除对子，然后求最大和最小的牌面之差就行了，小于等于4就肯定是顺子\n\n```java\npublic boolean isStraight(int[] nums) {\n    int[] bucket=new int[14];\n    for(int i=0;i<5;i++){\n        bucket[nums[i]]++;\n        //有非0的对子,直接false\n        if(nums[i]!=0 && bucket[nums[i]] >1 ){\n            return false;\n        }\n    }\n    //记录起手牌和最大牌\n    int start=-1,end=-1;\n    for(int i=1,j=13;end==-1||start==-1;i++,j--){\n        if(bucket[i]==1 && start==-1) start=i;\n        if(bucket[j]==1 && end==-1) end=j;\n    }\n    //小于等于4就行,多的用0补\n    return end-start<=4;\n}\n```\n代码可以优化成一个循环内\n\n```java\n//缩减成一个循环\npublic boolean isStraight(int[] nums) {\n    int[] bucket=new int[14];\n    int min=14,max=-1;\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]==0) continue;\n        if(bucket[nums[i]]==1) return false;\n        bucket[nums[i]]++;\n        min=Math.min(min,nums[i]);\n        max=Math.max(max,nums[i]);\n    }\n    return max-min<=4;\n}\n```\n## [1103. 分糖果 II](https://leetcode-cn.com/problems/distribute-candies-to-people/)\n\n排排坐，分糖果。\n\n我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。\n\n给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。\n\n然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。\n\n重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。\n\n返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。\n\n**示例 1：**\n\n```java\n输入：candies = 7, num_people = 4\n输出：[1,2,3,1]\n解释：\n第一次，ans[0] += 1，数组变为 [1,0,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3,0]。\n第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。\n```\n\n**示例 2：**\n\n```java\n输入：candies = 10, num_people = 3\n输出：[5,2,3]\n解释：\n第一次，ans[0] += 1，数组变为 [1,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3]。\n第四次，ans[0] += 4，最终数组变为 [5,2,3]。\n```\n\n**提示：**\n\n- `1 <= candies <= 10^9`\n- `1 <= num_people <= 1000`\n\n**解法一**\n\n```java\n//暴力模拟\npublic int[] distributeCandies(int candies, int num_people) {\n    int[] res=new int[num_people];\n    int index=0;\n    for (int i=1;candies>0;i++) {\n        res[index%num_people]+=Math.min(candies,i);\n        candies-=i;\n        index++;\n    }\n    return res;\n}\n```\n数学的方法：每个人得到的糖果分批次的都是一个等差数列，可以通过求和公式直接算，过程有点繁琐，后面有时间再来研究\n\n## [1013. 将数组分成和相等的三个部分](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/) \n\n  给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。\n\n形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。\n\n **示例 1：**\n\n```java\n输出：[0,2,1,-6,6,-7,9,1,2,0,1]\n输出：true\n解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n```\n\n\n**示例 2：**\n\n```java\n输入：[0,2,1,-6,6,7,9,-1,2,0,1]\n输出：false\n```\n\n\n**示例 3：**\n\n```java\n输入：[3,3,6,5,-2,2,5,1,-9,4]\n输出：true\n解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n```\n\n**提示：**\n\n1. 3 <= A.length <= 50000\n2. -10^4 <= A[i] <= 10^4\n\n**解法一**\n\n这个解法算是被群友误导了的，群里面有人说这题是前缀和，然后我就往哪个上面想的，其实没必要\n\n```java\npublic boolean canThreePartsEqualSum(int[] A) {\n    int[] preSum=new int[A.length+1];\n    preSum[0]=0;\n    for(int i=1;i<=A.length;i++){\n        preSum[i]=preSum[i-1]+A[i-1];\n    }\n    for(int i=1;i<preSum.length-2;i++){ //保证剩下2个\n        if(preSum[A.length]-preSum[i]==preSum[i]*2){\n            for(int j=i+1;j<preSum.length-1;j++){ //保证剩下1个\n                if(preSum[A.length]-preSum[i]==(preSum[j]-preSum[i])*2){\n                    //System.out.println(i+\" \"+j);\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    return false;\n}\n```\n**解法二**\n\n这才是正常的思路\n\n```java\npublic boolean canThreePartsEqualSum(int[] A) {\n    int sum=0;\n    for(int i=0;i<A.length;i++) sum+=A[i];\n    if(sum%3!=0) return false;\n    int count=0,tempSum=0;\n    //i到达A.length-1保证有第3段,否则有可能target=0 只分为两段就没了\n    for(int i=0;i<A.length-1;i++){ \n        tempSum+=A[i];\n        if(tempSum==sum/3){\n            ++count;\n            if(count==2) return true;\n            tempSum=0;\n        }\n    }\n    return false;\n}\n```\n这题的WA点就是 sum=0的时候，有可能按照划分的逻辑只将数组划分为两段，所以要注意边界\n\n## [调整数组顺序使奇数位于偶数前面（牛客）](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&&tqId=11166&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking)\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n**解法一**\n\n其实就是稳定的排序，插入，冒泡，归并都可以\n\n```java\npublic void reOrderArray(int [] array) {\n    for(int i=0;i<array.length;i++){\n        for(int j=i;j>=1;j--){\n            if(array[j]%2==1 && array[j-1]%2==0){\n                swap(array,j,j-1);\n            }\n        }\n    }\n}\n\npublic void swap(int[] array,int a,int b){\n    int temp=array[a];\n    array[a]=array[b];\n    array[b]=temp;\n}\n```\n## [836. 矩形重叠](https://leetcode-cn.com/problems/rectangle-overlap/)\n\n矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。\n\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n\n给出两个矩形，判断它们是否重叠并返回结果。\n\n**示例 1：**\n\n```java\n输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n输出：true\n```\n\n**示例 2：**\n\n```java\n输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n输出：false\n```\n\n**提示：**\n\n1. 两个矩形 `rec1` 和 `rec2` 都以含有四个整数的列表的形式给出。\n2. 矩形中的所有坐标都处于 `-10^9` 和 `10^9` 之间。\n3. `x` 轴默认指向右，`y` 轴默认指向上。\n4. 你可以仅考虑矩形是正放的情况。\n\n**解法一**\n\n憨憨解法，最后还被一个大case越界给卡了\n\n```java\npublic boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n    int x=Math.max(rec2[2]-rec1[0],rec1[2]-rec2[0]);\n    int y=Math.max(rec2[3]-rec1[1],rec1[3]-rec2[1]);\n    long maxX=((long)rec1[2]-(long)rec1[0]+(long)rec2[2]-(long)rec2[0]);\n    long maxY=((long)rec1[3]-(long)rec1[1]+(long)rec2[3]-(long)rec2[1]);\n    return x<maxX && y <maxY;\n}\n```\n**解法二**\n\n```java\npublic boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n    return !(rec1[3]<=rec2[1]||rec2[3]<=rec1[1]||rec1[2]<=rec2[0]||rec2[2]<=rec1[0]);\n}\n```\n## [892. 三维形体的表面积](https://leetcode-cn.com/problems/surface-area-of-3d-shapes/)\n\n在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。\n\n每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。\n\n请你返回最终形体的表面积。\n\n**示例 1：**\n\n```java\n输入：[[2]]\n输出：10\n```\n\n**示例 2：**\n\n```java\n输入：[[1,2],[3,4]]\n输出：34\n```\n\n\n**示例 3：**\n\n```java\n输入：[[1,0],[0,2]]\n输出：16\n```\n\n**示例 4：**\n\n```java\n输入：[[1,1,1],[1,0,1],[1,1,1]]\n输出：32\n```\n\n\n**示例 5：**\n\n```java\n输入：[[2,2,2],[2,1,2],[2,2,2]]\n输出：46\n```\n\n**提示：**\n\n- `1 <= N <= 50`\n- `0 <= grid[i][j] <= 50` \n\n**解法一**\n\n做加法\n\n```java\n//加法思路\npublic int surfaceArea(int[][] grid) {\n    if(grid==null || grid.length<=0 ) return 0;\n    int N=grid.length;\n    int res=0;\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<N;j++) {\n            //正面,背面暴露的面积\n            res+= Math.max(j<N-1?grid[i][j+1]-grid[i][j]:grid[i][j],0);\n            res+= Math.max(j>0?grid[i][j-1]-grid[i][j]:grid[i][j],0);\n            //左和右边暴露的面积\n            res+= Math.max(i<N-1?grid[i+1][j]-grid[i][j]:grid[i][j],0);\n            res+= Math.max(i>0?grid[i-1][j]-grid[i][j]:grid[i][j],0);\n            //上和下的面积\n            res+= grid[i][j]!=0?2:0;\n        }\n    }\n    return res;\n}\n```\n我太蠢了，开始直接分别算6个面，然后发现有坑，又去算坑的面积。。。结果就陷进去了\n\n**解法二**\n\n巧妙的减法思路，算贴合的时候的重合的面积\n\n```java\n//巧妙的减法思路\npublic int surfaceArea(int[][] grid) {\n    if(grid==null || grid.length<=0 ) return 0;\n    int N=grid.length;\n    int x=0,y=0,count=0;\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<N;j++) {\n            if(grid[i][j]!=0){\n                x+=grid[i][j]-1;\n                count+=grid[i][j];\n            }\n            if(i>=1 && grid[i-1][j]!=0){\n                y+=Math.min(grid[i][j],grid[i-1][j]);\n            }\n            if(j>=1 && grid[i][j-1]!=0){\n                y+=Math.min(grid[i][j],grid[i][j-1]);\n            }\n        }\n    }\n    return count*6-2*x-2*y;\n}\n```\n## [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)\n\n给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n\n**示例 :**\n\n```java\n输入:\n[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n\n输出: 16\n```\n\n**解法一**\n\n偶然翻到的题，发现和上面的是一样的\n\n```java\n//和892类似的解法，简化版\npublic int islandPerimeter(int[][] grid) {\n    int count=0;\n    int left=0,up=0;\n    for(int i=0;i<grid.length;i++){\n        for(int j=0;j<grid[0].length;j++){\n            if(grid[i][j]==1){\n                if(i-1>=0 && grid[i-1][j]==1){\n                    up++;\n                }\n                if(j-1>=0 && grid[i][j-1]==1){\n                    left++;\n                }\n                count++;\n            }\n        }\n    }\n    return count*4-(up+left)*2;\n}\n```\n> 看到题解区有大佬dfs的，通过方格的变化统计有效的边，比如从1->0就可以增加一条边，而从1->边界又可以增加一条边，还是挺秒的\n\n## [999. 车的可用捕获量](https://leetcode-cn.com/problems/available-captures-for-rook/)\n\n题目太长，不想复制了，模拟题，题目意思搞清楚就行了\n\n```java\npublic int numRookCaptures(char[][] board) {\n    int[][] direction=new int[][]{{-1,0},{0,-1},{1,0},{0,1}};\n    int res=0;\n    for (int i=0;i<board.length;i++) {\n        for (int j=0;j<board[0].length;j++) {\n            if(board[i][j]=='R'){\n                for (int k=0;k<4;k++) {\n                    int nx=i+direction[k][0];\n                    int ny=j+direction[k][1];\n                    while(nx>=0 && nx<board.length && ny>=0 && ny<board[0].length){\n                        if(board[nx][ny]=='B'){\n                            break;\n                        }\n                        if(board[nx][ny]=='p'){\n                            res++;\n                            break;\n                        }\n                        nx+=direction[k][0];\n                        ny+=direction[k][1];\n                    }\n                }\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n```\n## [289. 生命游戏](https://leetcode-cn.com/problems/game-of-life/)\n\n根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\n\n给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n\n1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；\n\n2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；\n\n3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；\n\n4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；\n\n根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。\n\n**示例：**\n\n```java\n输入： \n[\n  [0,1,0],\n  [0,0,1],\n  [1,1,1],\n  [0,0,0]\n]\n输出：\n[\n  [0,0,0],\n  [1,0,1],\n  [0,1,1],\n  [0,1,0]\n]\n```\n\n**进阶：**\n\n- 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。\n- 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？\n\n**解法一**\n\nbugfree\n\n```java\nint[][] dir={{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,-1},{-1,1},{1,-1}};\n\npublic void gameOfLife(int[][] board) {\n    if(board==null || board.length<=0) return;\n    int m=board.length,n=board[0].length;\n    boolean[][] change=new boolean[m][n];\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(board[i][j]==0 && aliveCell(board,i,j,change)==3){\n                board[i][j]=1;\n                change[i][j]=true;\n            }else if(board[i][j]==1){\n                int alive=aliveCell(board,i,j,change);\n                if(alive<2 || alive>3){\n                    board[i][j]=0;\n                    change[i][j]=true;\n                }\n            }\n        }\n    }\n}\n\npublic int aliveCell(int[][] board,int x,int y,boolean[][] change){\n    int alive=0;\n    for(int k=0;k<dir.length;k++){\n        int nx=x+dir[k][0];\n        int ny=y+dir[k][1];\n        if(valid(board,nx,ny)&&(board[nx][ny]==1 && !change[nx][ny] || (board[nx][ny]==0 && change[nx][ny]))){\n            alive++;\n        }\n    }\n    return alive;\n}\n\npublic boolean valid(final int[][] board,int x,int y){\n    return x>=0 && x<board.length && y>=0 && y<board[0].length;\n}\n```\n我理解的原地就是在原数组上做修改，但是并没有说不能用额外空间吧。。。但是看了评论区大佬们都不是这样写的，都是用的位运算，用int空的位保存状态，最后移位，懒得写了，感觉没啥意思，水题\n\n## [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)\n\n统计所有小于非负整数 *n* 的质数的数量。\n\n**示例:**\n\n```java\n输入: 10\n输出: 4\n解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n```\n\n**解法一**\n\n[厄拉多塞筛法](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) 简称埃式筛\n\n```java\npublic int countPrimes(int n) {\n    boolean[] prime=new boolean[n];\n    //为了不那么别扭\n    Arrays.fill(prime,true);\n    for(int i=2;i*i<n;i++){\n        if(prime[i]){\n            //从i*i开始,i*(i-1)已经被前面的统计了\n            for(int j=i*i;j<n;j+=i){\n                prime[j]=false;\n            }\n        }\n    }\n    int res=0;\n    for(int i=2;i<prime.length;i++){\n        if(prime[i]) res++;\n    }\n    return res;\n}\n```\n## [171. Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)\n\n给定一个Excel表格中的列名称，返回其相应的列序号。\n\n例如，\n\n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n**示例 1:**\n\n```java\n输入: \"A\"\n输出: 1\n```\n\n**示例 2:**\n\n```java\n输入: \"AB\"\n输出: 28\n```\n\n**示例 3:**\n\n```java\n输入: \"ZY\"\n输出: 701\n```\n\n**解法一**\n\n朋友作业帮面试问了这道题，其实就是进制的转换，写了个回转的\n\n```java\n//26进制转10进制\npublic int titleToNumber(String s) {\n    if(s==null || s.length()<=0) return 0;\n    int res=0,n=s.length();\n    int temp=1;\n    for (int i=n-1;i>=0;i--) {\n        res+=(s.charAt(i)-'A'+1)*temp;\n        temp*=26;\n    }\n    return res;\n}\n\n//10进制转26进制\npublic String numberToTitle(int s) {\n    StringBuilder res=new StringBuilder();\n    while(s!=0){\n        //这个s-1要注意啊woc\n        res.append((char)((s-1)%26+65));\n        s=(s-1)/26;\n    }\n    return res.reverse().toString();\n}\n```\n## [168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)\n\n给定一个正整数，返回它在 Excel 表中相对应的列名称。\n\n例如，\n\n```java\n1 -> A\n2 -> B\n3 -> C\n...\n26 -> Z\n27 -> AA\n28 -> AB \n...\n```\n**示例 1:**\n\n```java\n输入: 1\n输出: \"A\"\n```\n\n**示例 2:**\n\n```java\n输入: 28\n输出: \"AB\"\n```\n\n**示例 3:**\n\n```java\n输入: 701\n输出: \"ZY\"\n```\n\n**解法一**\n\n```java\npublic String numberToTitle(int s) {\n    StringBuilder res=new StringBuilder();\n    while(s!=0){\n        //这个s-1要注意啊woc\n        res.append((char)((s-1)%26+65));\n        s=(s-1)/26;\n    }\n    return res.reverse().toString();\n}\n```\n\ngo写法\n\n```go\nfunc convertToTitle(n int) string {\n    var res string\n    for n>0{\n        res=string((n-1)%26+'A')+res\n        n=(n-1)/26\n    }\n    return res\n}\n```\n\n## [724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)\n\n给定一个整数类型的数组 `nums`，请编写一个能够返回数组**“中心索引”**的方法。\n\n我们是这样定义数组**中心索引**的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n**示例 1:**\n\n```java\n输入: \nnums = [1, 7, 3, 6, 5, 6]\n输出: 3\n解释: \n索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。\n同时, 3 也是第一个符合要求的中心索引。\n```\n\n**示例 2:**\n\n```java\n输入: \nnums = [1, 2, 3]\n输出: -1\n解释: \n数组中不存在满足此条件的中心索引。\n```\n\n**说明:**\n\n- `nums` 的长度范围为 `[0, 10000]`。\n- 任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。\n\n**解法一**\n\n唉，不知道为啥，直接写了个前缀后缀和判断的，很暴力直白的思路，咋就想不到简单的思路？\n\n```go\nfunc pivotIndex(nums []int) int {\n    //前缀和，后缀和\n    n:=len(nums)\n    if n==0{\n        return -1\n    }\n    pre:=make([]int,n+1) //i之前的元素和,不包含i\n    pre[0]=0\n    last:=make([]int,n+1) //(i-1)之后元素和,不包含(i-1)\n    last[n]=0\n    for i,j := 1,n-1;i<=n && j>=0; i,j = i+1,j-1 {\n        //这里其实只要代入值验证第一次的转移是正确的就行了,不用考虑太多\n        pre[i]=pre[i-1]+nums[i-1]\n        last[j]=last[j+1]+nums[j]\n    }\n    for i:=0;i<n;i++{\n        //联系上面数组的定义思考这里的判断\n        if pre[i]==last[i+1]{\n            return i;\n        }\n    }\n    return -1\n}\n```\n\n**解法二**\n\n简单的思路，脑子瓦特了一下没想到\n\n```go\nfunc pivotIndex(nums []int) int {\n    n:=len(nums)\n    if n==0{\n        return -1\n    }\n    sum:=0\n    for _,num:= range nums{\n        sum+=num\n    }\n    temp:=0 //包含了边界0\n    for i:=0;i<n;i++{\n        if temp*2+nums[i]==sum{\n            return i\n        }\n        temp+=nums[i]\n    }\n    return -1\n}\n```\n\n## [945. 使数组唯一的最小增量](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)\n\n给定整数数组 A，每次 *move* 操作将会选择任意 `A[i]`，并将其递增 `1`。\n\n返回使 `A` 中的每个值都是唯一的最少操作次数。\n\n**示例 1:**\n\n```java\n输入：[1,2,2]\n输出：1\n解释：经过一次 move 操作，数组将变为 [1, 2, 3]。\n```\n\n**示例 2:**\n\n```java\n输入：[3,2,1,2,1,7]\n输出：6\n解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。\n可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。\n```\n\n**提示：**\n\n1. `0 <= A.length <= 40000`\n2. `0 <= A[i] < 40000`\n\n**解法一**\n\n之前写了，没记录，这次PDD笔试考了这题\n\n```java\npublic int minIncrementForUnique(int[] A) {\n    Arrays.sort(A);\n    int move=0;\n    for(int i=1;i<A.length;i++){\n        if(A[i]<=A[i-1]){\n            move+=A[i-1]-A[i];\n            A[i]=A[i-1]+1;\n        }\n    }\n    return move;\n}\n```\n\n暴力的解法很好想，首先肯定要排序，然后遇到小于等于前面的时候就`move+1`，直到不相等，但是这里是可以优化的，一次次的加没有啥意义，可以直接一步到位直接从`A[i]`增加到`A[i-1]+1`\n\n> 这题还有一些方法优化，首先是排序可以用桶排序，然后还可以用并查集（比较麻烦），或者也有数学分析找规律的方法\n\n## [面试题05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)\n\n请实现一个函数，把字符串 `s` 中的每个空格替换成\"%20\"。\n\n**示例 1：**\n\n```java\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n```\n\n**限制：**\n\n```java\n0 <= s 的长度 <= 10000\n```\n\n**解法一**\n\n这题的标准做法\n\n```java\npublic String replaceSpace(String s) {\n    char[] res=new char[s.length()*3];\n    int idx=0;\n    for(int i=0;i<s.length();i++){\n        if(s.charAt(i)==' '){\n            res[idx++]='%';\n            res[idx++]='2';\n            res[idx++]='0';\n        }else{\n            res[idx++]=s.charAt(i);\n        }\n    }\n    return new String(res,0,idx);\n}\n```\n\n**解法二**\n\n原题是要求O(1)空间的，这里虽然无法做到，但是可以模拟下\n\n```java\n//原题目的要求应该是在O(1)空间下,但是Java的String是不可变的\n//所以不可能O(1),我们需要改一下函数签名\npublic String replaceSpace(/*StringBuilder*/ String ss) {\n    StringBuilder s=new StringBuilder(ss); //这里是为了验证\n    int oldLen=s.length();\n    for (int i=0;i<oldLen;i++) {\n        if(s.charAt(i)==' ') s.append(\"xx\"); //扩充字符长度\n    }\n    int newLen=s.length();\n    //逆序,避免覆盖\n    int i=oldLen-1,j=newLen-1;\n    while(i>=0){\n        char c=s.charAt(i--);\n        if(c==' '){\n            s.setCharAt(j--,'0');\n            s.setCharAt(j--,'2');\n            s.setCharAt(j--,'%');\n        }else{\n            s.setCharAt(j--,c);\n        }\n    }\n    return s.toString();\n}\n```\n\n## [面试题45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)\n\n输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n\n**示例 1:**\n\n```java\n输入: [10,2]\n输出: \"102\"\n```\n**示例 2:**\n\n```java\n输入: [3,30,34,5,9]\n输出: \"3033459\"\n```\n\n**提示:**\n- `0 < nums.length <= 100`\n\n**说明:**\n\n输出结果可能非常大，所以你需要返回一个字符串而不是整数；拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0\n\n**解法一**\n\n一开始贼sb，想了一大堆有的没的😅\n![UTOOLS1592838604659.png](https://upload.cc/i1/2020/06/22/zOQcTL.png)\n```java\npublic String minNumber(int[] nums) {\n    String[] strs=new String[nums.length];\n    for(int i=0;i<nums.length;i++) strs[i]=nums[i]+\"\";\n    Arrays.sort(strs,(a,b)->(a+b).compareTo(b+a));\n    StringBuilder sb=new StringBuilder();\n    for(String i:strs) sb.append(i);\n    return sb.toString();\n}\n```\n虽然绕了一大圈，所幸还是自己做出来了，但是为什么这样就是对的呢？其实这里我也是想当然了，严谨的应该对这个排序规则的传递性进行证明，也就是`xy>yx && yz>zy ==> xz>xz ?`这个成立，排序的结果才是对的，这里我就不copy了，证明也不是很难，大家可以去原题[题解区](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/378553)看看\n\n## [179. 最大数](https://leetcode-cn.com/problems/largest-number/)\n\n给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。\n\n**示例 1:**\n\n```java\n输入: [10,2]\n输出: 210\n```\n**示例 2:**\n\n```java\n输入: [3,30,34,5,9]\n输出: 9534330\n说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。\n```\n**解法一**\n\n和上一题一摸一样，借机学习下golang的自定义排序\n```golang\ntype StringSlice []string\n\nfunc (p StringSlice) Len() int           { return len(p) }\nfunc (p StringSlice) Less(i, j int) bool { return p[i]+p[j] > p[j]+p[i] }\nfunc (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n\nfunc largestNumber(nums []int) string {\n    strs := make([]string, len(nums))\n    for i, n := range nums {\n        strs[i] = strconv.Itoa(n)\n    }\n    sort.Sort(StringSlice(strs))\n    //return strings.Join(strs,\"\") 要去前导0...\n    // var res = \"\"\n    // var idx = 0\n    // for idx < len(strs)-1 && strs[idx] == \"0\" {\n    //     idx++\n    // }\n    // for idx < len(strs) {\n    //     res += strs[idx]\n    //     idx++\n    // }\n    res := strings.Join(strs, \"\")\n    if res[0] == '0' { //第一个为0肯定就全部是0了...前面的写法明显没动脑子\n        return \"0\"\n    }\n    return res\n}\n```\n看了大佬们的提交记录发现go 1.8在sort包中引入了\n\n`func Slice(slice interface{}, less func(i, j int) bool)`\n\n通过这个就不用很麻烦的去实现3个函数了，只需要实现`Less`比较器就可以了（其实这才是正常的做法，其他语言中也都是类似的，其他两个`len`和`swap`感觉意义不大，一般不会改这两个函数，完全可以自动生成）\n> 看评论区又看到一个很好的[反证的思路](https://leetcode-cn.com/problems/largest-number/solution/zui-da-shu-bi-jiao-gui-ze-chuan-di-xing-yi-ji-suan/344160)，大致意思就是：假设存在序列`\"...ab...\"`为最大数，且不满足该排序规则`ab>ba`，也就是说`ab<ba`，那我们交换序列中ab的位置变为`\"...ba...\"`很明显`\"...ba...\"`>`\"...ab...\"`，与假设矛盾，所以最大数一定满足该排序规则\n\n## [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)\n\nDifficulty: **中等**\n\n\n给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。\n\n数学表达式如下:\n\n> 如果存在这样的 _i, j, k, _ 且满足 0 ≤ _i_ < _j_ < _k_ ≤ _n_-1，  \n> 使得 _arr[i]_ < _arr[j]_ < _arr[k]_ ，返回 true ; 否则返回 false 。\n\n**说明:** 要求算法的时间复杂度为 O(_n_)，空间复杂度为 O(_1_) 。\n\n**示例 1:**\n\n```go\n输入: [1,2,3,4,5]\n输出: true\n```\n\n**示例 2:**\n\n```go\n输入: [5,4,3,2,1]\n输出: false\n```\n\n**解法一**\n\n题目限制了空间复杂度O(1)时间复杂度O(N)，所以利用额外空间的方案就不适用了，我们只需要记录当前元素**之前的最小值**，和最小值**右边的次小值**就ok了，在循环中不断的更新这两个值\n```golang\nfunc increasingTriplet(nums []int) bool {\n    var INT_MAX = int(^uint(0)>>1)\n    var n = len(nums)\n    var a = INT_MAX\n    var b = INT_MAX\n    for i := 0; i < n; i++{\n        if nums[i] <= a{\n            a = nums[i]\n            //b = a 这里不用更新次小值，因为我们要保证a在b前面\n        }else if nums[i] <= b{\n            b = nums[i]\n        }else{\n            return true\n        }\n    }\n    return false\n}\n```\n很可惜是在看了题解区才明白，真的菜啊，一开始想劈叉了，我一直在考虑中间的元素，想怎么求左右的最小最大值。。。\n\n## [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)\n\nDifficulty: **简单**\n\n\n给定一个整数 _n_，返回 _n_! 结果尾数中零的数量。\n\n**示例 1:**\n\n```go\n输入: 3\n输出: 0\n解释: 3! = 6, 尾数中没有零。\n```\n\n**示例 2:**\n\n```go\n输入: 5\n输出: 1\n解释: 5! = 120, 尾数中有 1 个零.\n```\n\n**说明:** 你算法的时间复杂度应为 _O_(log _n_)。\n\n**解法一**\n\n首先需要明确题目要求什么，`n!`结尾0的个数，直接算阶乘的值显然是不可能的，值会很大很容易溢出，而且大数相乘的时间复杂度也很高\n\n我们考虑下末尾的0是怎么来的，我们知道一个数x10，末尾就会多一个0，这里也一样，所以我们要求的就是在阶乘的过程中乘了多少个10，那么10从哪里来呢？\n\n我们将10拆解成`2*5`，问题就又转化成了，阶乘中产生了多少对`2*5`的因子，注意这个并不是单纯指1~n中某一个值2，或者5，而是中间每个数拆分出来的因子，比如15就拆分成3*5，中间就有一个5的因子，现在问题明确了，我们如何去求2或者5的因子个数呢？\n\n根据**短板理论**，很明显这两个因子我们只需要求其中**个数较少**的那一个就可以了，少的那个一定可以找到配对的另一个因子，举个例子，假设我们`n!`中产生了2个**5的因子**，和5个**2的因子**，那么很明显最后我们最后配对的`2x5`只有2对，也就是结尾会有2个0，那么2和5我们求哪一个呢？或者说2和5的因子数量一定会有固定的大小关系么？\n\n其实上面的问题凭直觉就能看出来，明显5的个数会少一些，应该求5的个数，但是秉承着严谨的态度，我们还是应该实际的算一算，而且后面code的时候也是需要算的\n\n首先看2的个数，我们每隔2个数就会产生一个2的因子，比如2，4，6，8，10...，但是同时有的数会有多个因子，这个里面也会产生2，比如4就可以拆解成`2x2`，也就是每隔`4`个元素，抛开原来每隔`2`个元素产生的2，会额外的再产生一个2的因子，同理8可以拆解成`2x2x2`，也就是所每隔8个元素又会产生一个额外的2，所以总体的n!中，包含2的因子个数是 `n/2 + n/4 + n/8 + ...`，同理也可推出5的因子个数，如下：\n![mark](http://static.imlgw.top/blog/20200630/lFrypQIJu57J.png?imageslim)\n很明显同样项数m的情况下，5的因子的个数要更少，所以我们直接求因子5的个数就行了\n\n有了上面的结论，代码就很容易写了，直接模拟就行了，时间复杂度`O(log(5,N))`\n```golang\nfunc trailingZeroes(n int) int {\n    var count = 0\n    for n > 0{\n        n /= 5\n        count += n\n    }\n    return count\n}\n```\n\n## [793. 阶乘函数后K个零](https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/)\n\nDifficulty: **困难**\n\n\n `f(x)` 是 `x!` 末尾是0的数量。（回想一下 `x! = 1 * 2 * 3 * ... * x`，且`0! = 1`）\n\n例如， `f(3) = 0` ，因为3! = 6的末尾没有0；而 `f(11) = 2` ，因为11!= 39916800末端有2个0。给定 `K`，找出多少个非负整数`x` ，有 `f(x) = K` 的性质。\n\n```golang\n示例 1:\n输入:K = 0\n输出:5\n解释: 0!, 1!, 2!, 3!, and 4! 均符合 K = 0 的条件。\n\n示例 2:\n输入:K = 5\n输出:0\n解释:没有匹配到这样的 x!，符合K = 5 的条件。\n```\n\n**注意：**\n\n*   `K`是范围在 `[0, 10^9]` 的整数**。**\n\n**解法一**\n\n上一题的逆向，挺有意思的，可惜了，一开始没想出来，我知道答案肯定是0 or 5但是不知道咋验证了。。。明明上一题之前就做过了，真菜啊，看了评论区才恍然大悟\n```golang\n//ans: 0 or 5\nfunc preimageSizeFZF(K int) int {\n    //n/5 + n/25 + ... +  = K ==> n < 5*K\n    var left = 0 \n    var right = 5*K+1\n    for left <= right {\n        mid := left + (right-left)/2\n        var zero = trailingZeroes(mid)\n        if zero == K {\n            return 5\n        }\n        if zero > K {\n            right = mid - 1\n        }else{\n            left = mid + 1\n        }\n    }\n    return 0\n}\n​\n//172.阶乘后的0\nfunc trailingZeroes(n int) int {\n    var count = 0\n    for n > 0 {\n        n/=5\n        count += n\n    }\n    return count\n}\n```\n\n## [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)\n\nDifficulty: **中等**\n\n给定一个 m*n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。\n\n**示例 1:**\n\n```go\n输入: \n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n输出: \n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n```\n\n**示例 2:**\n\n```go\n输入: \n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n输出: \n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n```\n\n**进阶:**\n\n*   一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n*   一个简单的改进方案是使用 O(m+n) 的额外空间，但这仍然不是最好的解决方案。\n*   你能想出一个常数空间的解决方案吗？\n\n\n**解法一**\n\n傻逼题\n```golang\nfunc setZeroes(matrix [][]int)  {\n    r, c := false, false\n    for j := 0; j < len(matrix[0]); j++{\n        if matrix[0][j] == 0{\n            r = true\n            break\n        }\n    }\n    for i := 0; i < len(matrix); i++{\n        if matrix[i][0] == 0{\n            c = true\n            break\n        }\n    }\n    \n    for i :=1; i < len(matrix); i++{\n        for j := 1; j < len(matrix[0]); j++{\n            if matrix[i][j] == 0{\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    for j :=1; j < len(matrix[0]); j++{\n        if matrix[0][j] == 0{\n            for i :=0; i < len(matrix);i++{\n                matrix[i][j] = 0\n            }\n        }\n    }\n    for i :=1; i < len(matrix); i++{\n        if matrix[i][0] == 0{\n            for j :=0; j < len(matrix[0]); j++{\n                matrix[i][j] = 0   \n            }\n        }\n    }\n    if r {\n        for j :=0; j < len(matrix[0]); j++{\n            matrix[0][j] = 0\n        }\n    }\n    if c {\n        for i :=0; i < len(matrix); i++{\n            matrix[i][0] = 0\n        }\n    }\n}\n```\n\n## [面试题 16.11. 跳水板](https://leetcode-cn.com/problems/diving-board-lcci/)\n\nDifficulty: **简单**\n\n\n你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为`shorter`，长度较长的木板长度为`longer`。你必须正好使用`k`块木板。编写一个方法，生成跳水板所有可能的长度。\n\n返回的长度需要从小到大排列。\n\n**示例：**\n\n```go\n输入：\nshorter = 1\nlonger = 2\nk = 3\n输出： {3,4,5,6}\n```\n\n**提示：**\n\n*   0 < shorter <= longer\n*   0 <= k <= 100000\n\n**解法一**\n\ntag里面有递归，记忆化什么的。。。加上看见群友的讨论，又先入为主了，唉，写了半天的回溯，想着怎么去重，突然意识到直接一个循环就能解决了。。。菜啊\n```golang\nfunc divingBoard(shorter int, longer int, k int) []int {\n    if k == 0{\n        return []int{}\n    }\n    if shorter == longer{\n        return []int{ k * shorter}\n    }\n    var res []int\n    for i := 0; i <= k; i++{\n        res = append(res, i * longer + (k - i) * shorter)\n    }\n    return res\n}\n```\n\n## [NC82.苹果树](https://www.nowcoder.com/practice/145b8d917c1e44c0b2b2462433b3029d?tpId=110&&tqId=33503&rp=1&ru=/ta/job-code&qru=/ta/job-code/question-ranking)\n牛牛有一个苹果园。又到了一年一度的收获季，牛牛现在要去采摘苹果买给市场的摊贩们。\n牛牛的果园里面有n棵苹果树，第i棵苹果树上有a[i]个果子。\n牛牛为了保证果子的新鲜程度，每天都会去苹果树上采摘果子。\n牛牛特意安排一个计划表：\n\n计划m天去采摘果子。对于第i天，它会去所有果树上轮流采摘b[i]个果子。\n如果对于第i天，某棵果树上没有b[i]个果子，那么它只会把当前果树上的果子采摘完。\n\n牛牛想知道它每天能供应多少个苹果给市场的摊贩们。\n\n**输入**\n\n- 1 <= a[i] , b[i] <= 1e9\n- 1 <= len(a), len(b) <= 1e5\n\n**示例1**\n```go\n输入 : [10,20,10],[5,7,2]\n输出 : [15,17,2]\n说明 :\n苹果树上的果子变化[10,20,10]-->[5,15,5]-->[0,8,0]-->[0,6,0]\n```\n\n**解法一**\n\n在牛客看见是头条二面的一道题，找到了牛客对应的题目，尝试了下，首先写了楼主的 前缀和+二分的解法\n\n很可惜通过率0，报错的数据很大，一看就知道溢出了\n```java\n//前缀和+二分的做法（容易溢出，random稍微调大点就溢出了，过不了OJ）\npublic static long[] solve2 (int[] a, int[] b) {\n    if(a==null || a.length==0){\n        return new long[0];\n    }\n    // write code here\n    Arrays.sort(a);\n    int d = b.length;\n    int al = a.length;\n    long sum = 0;\n    long[] preSum = new long[al];\n    preSum[0] = a[0];\n    for(int i = 1; i < al; i++){\n        preSum[i] = preSum[i-1] + a[i];\n    }\n    long[] res = new long[d];\n    int sb = 0;\n    for(int i = 0; i < d; i++){\n        sb += b[i];\n        int idx = search(a, sb);\n        if(idx == -1){\n            res[i] = sb * al - sum;\n        }else{\n            res[i] = preSum[idx] + sb * (al-idx-1) - sum;\n        }\n        sum += res[i];\n    }\n    return res;\n}\n\n//小于target的最后一个\npublic static int search(int[] a, int target){\n    int left = 0;\n    int right = a.length-1;\n    int res = -1;\n    while(left <= right){\n        int mid = left + (right - left)/2;\n        if(a[mid] < target){\n            res = mid;\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return res;\n}\n```\n**解法二**\n\n双指针的解法，还是很巧妙的，这题如果考虑去减掉每棵树的果子其实就走远了，那样时间复杂度肯定是O(N^2)的，其实我们完全不用每次都把果子的数量给减掉，首先我们对果树进行排序，这样方便进行区间的摘取，对整体分区变为 `无剩余 | 剩余不足 | 剩余足够`三个区间\n\n每次摘取都是将前n天的合并起来一起摘，然后看**剩余不足**和**剩余足够**分界线在哪里，剩余不足的部分就直接加起来，然后减去前`n-1`天在该果树上采摘的数量，得到就是剩下的当天可以采摘的数量，之后这部分**剩余不足**的就变成了**无剩余**\n\n最后，在分界线以后的部分就都是剩余足够的部分，直接乘法计算就行了（小心溢出）\n\n```java\n//正解 双指针，时间复杂度O(m+n)\npublic static long[] solve (int[] a, int[] b) {\n    Arrays.sort(a);\n    int p = 0;\n    int sb = 0;\n    long[] res = new long[b.length];\n    for (int i = 0; i < b.length; i++) {\n        sb += b[i];\n        while(p < a.length && a[p] < sb){\n            //该果树果子不够了，拿取剩下所有的\n            res[i] += (a[p] - (sb - b[i]));\n            //下一颗果树\n            p++;\n        }\n        //后面的都够\n        res[i]+=(a.length - p) * (long)b[i];\n    }\n    return res;\n}\n```\n> 其实和解法一的思路类似，但是这种做法不考虑溢出且时间复杂度更低\n\n## [453. 最小移动次数使数组元素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)\n\nDifficulty: **简单**\n\n\n给定一个长度为 _n_ 的**非空**整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 _n_ - 1 个元素增加 1。\n\n**示例:**\n\n```go\n输入:\n[1,2,3]\n\n输出:\n3\n\n解释:\n只需要3次移动（注意每次移动会增加两个元素的值）：\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\n```\n\n**解法一**\n\nn-1个元素+1，就相当于1个元素-1，思维的转换，题目就变得简单了\n```golang\nfunc minMoves(nums []int) int {\n    var min = math.MaxInt32\n    for i := 0; i < len(nums); i++ {\n        if nums[i] < min {\n            min = nums[i]\n        }\n    }\n    var res = 0\n    for i := 0; i < len(nums); i++ {\n        res += (nums[i]-min)\n    }\n    return res\n}\n```\n\n## [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)\n\nDifficulty: **简单**\n\n\n给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。\n\n重复出现的子串要计算它们出现的次数。\n\n**示例 1 :**\n\n```golang\n输入: \"00110011\"\n输出: 6\n解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。\n\n请注意，一些重复出现的子串要计算它们出现的次数。\n\n另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。\n```\n\n**示例 2 :**\n\n```golang\n输入: \"10101\"\n输出: 4\n解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。\n```\n\n**注意：**\n\n*   `s.length` 在1到50,000之间。\n*   `s` 只包含“0”或“1”字符。\n\n**解法一**\n\n将字符转换为连续字符个数的排列，比如111100011000-->4323，然后我们将相邻两个数的最小值加入结果集就行了，3+2+2=7，下面的解法合并了两步操作\n```golang\nfunc countBinarySubstrings(s string) int {\n    var n = len(s)\n    var last, cur = 0, 0\n    var res = 0\n    var Min = func (a, b int) int {if a<b {return a};return b}\n    var p = 0\n    for p < n {\n        c := s[p]\n        for p < n && s[p] == c {\n            p++\n            cur++\n        }\n        res += Min(cur, last)\n        last = cur\n        cur = 0\n    }\n    return res\n}\n```\n\n## [844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)\n\nDifficulty: **简单**\n\n给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>\n\n<p>\n\n给定 `S` 和 `T` 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 `#` 代表退格字符。\n\n**注意**：如果对空文本输入退格字符，文本继续为空。\n\n**示例 1：**\n\n```go\n输入：S = \"ab#c\", T = \"ad#c\"\n输出：true\n解释：S 和 T 都会变成 “ac”。\n```\n\n**示例 2：**\n\n```go\n输入：S = \"ab##\", T = \"c#d#\"\n输出：true\n解释：S 和 T 都会变成 “”。\n```\n\n**示例 3：**\n\n```go\n输入：S = \"a##c\", T = \"#a#c\"\n输出：true\n解释：S 和 T 都会变成 “c”。\n```\n\n**示例 4：**\n\n```go\n输入：S = \"a#c\", T = \"b\"\n输出：false\n解释：S 会变成 “c”，但 T 仍然是 “b”。\n```\n\n**提示：**\n\n1.  `1 <= S.length <= 200`\n2.  `1 <= T.length <= 200`\n3.  `S` 和 `T` 只含有小写字母以及字符 `'#'`。\n\n**进阶：**\n\n*   你可以用 `O(N)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？\n\n\n\n**解法一**\n\nO（N）空间的就不写了，随便搞搞就行了，关键是O(1)空间的解法，这里核心就是双指针从后想前扫描，然后注意边界就ok了\n```java\npublic boolean backspaceCompare(String S, String T) {\n    int i = S.length()-1;\n    int j = T.length()-1;\n    while (i >= 0 || j >= 0) {\n        i = back(S, i);\n        j = back(T, j);\n        //都匹配完了\n        if (i < 0 && j < 0) {\n            return true;\n        }\n        //只有一个匹配完了，两个对位字符不匹配\n        if (i < 0 || j < 0 || S.charAt(i) != T.charAt(j)) {\n            return false;\n        }\n        i--; j--;\n    }\n    //都匹配完了\n    return i < 0 && j < 0;\n}\n\npublic int back(String s, int i) {\n    if (i < 0 || s.charAt(i) != '#') {\n        return i;\n    }\n    int cnt = 0;\n    while (i >= 0) {\n        if (s.charAt(i) == '#') {\n            cnt++;\n        } else {\n            if (cnt==0) break;\n            cnt--;\n        }\n        i--;\n    }\n    return i;\n}\n```","tags":["LeetCode","数组"],"categories":["算法"]},{"title":"JNI初探","url":"/2019/05/02/jni-chu-tan/","content":"\n## JNI简介\n\n> JNI是**Java Native Interface**的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是[C](https://baike.baidu.com/item/C/7252092)&[C++](https://baike.baidu.com/item/C%2B%2B)）。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少要保证本地代码能工作在任何Java 虚拟机环境。\n\n相信大家在看源码的时候都看见过用**native**修饰的方法，这些方法就是用C/C++语言实现的，那到底java是如何调用的这些方法的呢？\n\n## 上手\n\n**准备工作**\n\n> 文中环境为Linux下Centos6版本\n\n✅ 首先需要有`JDK`(我的是jdk1.7)，编译java\n\n✅ 然后需要`gcc` 用来编译C/C++\n\n**Java代码**\n\n```java\npublic class JniTest {\n\n    public static void main(String[] args) {\n        new JniTest().hi();\n    }\n\t\n    static {\n        //加载一个动态链接库\n        System.loadLibrary(\"jniTest\");\n    }\n\n    private native void hi();\n}\n```\n\n在静态代码块里面加载了一个[动态链接库](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%96%87%E4%BB%B6)\n\n编写完之后直接`javac JniTest.java`编译一下，然后执行`javah -jni  JniTest`，会在当前目录下生成一个`JniTest.h`的头文件如下\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class JniTest */\n\n#ifndef _Included_JniTest\n#define _Included_JniTest\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     JniTest\n * Method:    hi\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_JniTest_hi\n  (JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n**C代码**\n\n```java\n#include<stdio.h>\n#include \"JniTest.h\"\n#include <jni.h>\n//这一段来自上面的头文件\nJNIEXPORT void JNICALL Java_JniTest_hi\n  (JNIEnv *env, jobject o){\n        printf(\"you  successfully called the c code\\n\");\n}\n```\n\n- `JNIEnv*`：用于引用JNI环境，该指针变量可以访问所有JNI函数\n- `jobject`：引用`this` Java对象，也就是可以用来访问当前java调用者\n\n写完之后执行如下命令编译它\n\n```java\ngcc -fPIC -D_REENTRANT  -I\"$JAVA_HOME/include\"  -I\"$JAVA_HOME/include/linux\" -c JniTest.c\n```\n\n会在当前目录下生成一个`JniTest.o`的可执行文件。\n\n然后执行\n\n`gcc -shared JniTest.o -o libjniTest.so`\n\n注意`linux`上动态链接库必须以`lib`开头，所以这里是`libjniTest`后面的是前面`java`代码中加载的哪个动态链接库名称`jniTest`，最后会在当前目录下生成一个`libjniTest.so`的动态库\n\n**执行**\n\n首先给`libjniTest.so`赋予可执行权限\n\n`chmod 777 libjniTest.so`\n\n因为我这里没有设置`java.library.path`所以需要在运行的时候加上路径\n\n`java -Djava.library.path=/usr/jnitest JniTest`\n\n**结果**\n\n![mark](http://static.imlgw.top///20190502/rKdNPEwUmstf.png?imageslim)\n\n>  篇文章中只是简单的调用了C语言的代码，关于如何传递参数，如何返回值，后面遇到之再做记录","tags":["JNI"],"categories":["JVM"]},{"title":"Volatile关键字详解","url":"/2019/04/29/volatile-guan-jian-zi/","content":"\n## JMM&CPU缓存\n\n### CPU缓存\n\n其实这个并不是指某一个具体的部件，`寄存器(Register)`，`高速缓存(Cache)`，`写缓冲器(Store Buffer)`，`无效化队列(Invalidate Queue)`等等都可以称为 CPU缓存。\n\n#### 为什么要有CPU缓存？\n\n`缓存`通常意义下都是为了加快速度，这里同样也是，因为CPU的速度比`主内存(RAM)`快很多，`主内存`会拖CPU后腿影响整体的效率，所以缓存就出现了，缓存的速度比`主内存`快很多(造价高)CPU会直接通过缓存来对主内存进行读写操作，所以缓存里面实际上相当于是`主内存`的副本。\n\n#### 使用CPU缓存带来的问题\n\n正常情况下CPU执行计算的过程如下\n\n1️⃣程序以及数据被加载到主内存\n\n2️⃣指令和数据被加载到CPU缓存\n\n3️⃣CPU执行指令，把结果写到高速缓存\n\n4️⃣高速缓存中的数据写回主内存\n\n如果是单核CPU，上面的步骤没有任何问题，但如果是多核CPU就可能会出现一些意料之外的问题，假设有两个核\n\n下面这种情况也是有可能发生的\n\n1️⃣核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存\n\n2️⃣核1做了上面同样的工作，这样核0与核1的缓存拥有同样的数据\n\n3️⃣核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存\n\n4️⃣核1访问该字节，由于核0并未将数据写回主存，数据不同步\n\n#### 解决方案\n\n🔶LOCK# 总线锁，效率很低，同时只能有一个CPU对内存操作，其他的CPU只能干等着\n\n🔶缓存一致性`协议`，缓存一致性协议有多种，`MESI`协议是当前最主流的缓存一致性协议\n\n![MESI状态](http://static.imlgw.top///20190411/GYdTPdVBGCQB.png?imageslim)日常处理的大多数计算机设备都属于`嗅探(snooping)`协议，CPU缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去`读写内存`时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一`写内存`，其它处理器马上知道这块内存在它们的缓存段中`已失效(Invaid)`，如果这个时候有处理器想`读内存`(会被立即察觉到，因为一直在嗅探总线)，那么已修改的缓存行(Cache line)就会立即刷新到主存中，然后设置为`Share`状态，这样一来读取到的数据就不是脏数据了。\n\n再放一张 处理器&缓存&主内存交互的图（来自组成原理书上的图）\n\n![Cache基本结构](http://static.imlgw.top///20190415/lJzPTl3yQWBn.jpg?imageslim)\n\n既然有了MESI协议，是不是就不需要volatile的可见性语义了？当然不是\n\n- **并不是所有的硬件架构都提供了相同的一致性保证，JVM需要volatile统一语义**（就算是MESI，也只解决CPU缓存层面的问题，没有涉及其他层面）。\n- 可见性问题不仅仅局限于CPU缓存内，JVM自己维护的`内存模型`中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。\n- [这个回答应该很好的解释了](https://www.zhihu.com/question/277395220) 大概就是缓存一致性协议并不能保证实时性，而有时候我们需要保证严格的实时性\n\n### Java内存模型(JMM)\n\n> 为了屏蔽各个操作系统和硬件的差异，使得 Java 程序在所有平台下都能达到一致的内存访问效果，所以 Java 虚拟机定义了一种 Java 内存模型。\n\nJava内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。（这里的变量不包括局部变量和方法参数，因为那是线程私有的，不会产生竞争）\n\nJava 虚拟机规定所有的变量都存储在主内存（Main Memory），每个线程都有自己的工作线程（Work Memory 有些地方称为线程栈）。\n\n线程的工作内存中保存了使用到的变量的主内存副本拷贝，线程对变量的操作是在自己的工作内存中，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，而不能直接对主内存的变量进行读取赋值。\n\n不同线程之间无法直接访问对方工作内存中的变量，需要通过主内存来进行传递。\n\n![JMM](http://static.imlgw.top///20190411/PjL8vV724vXx.png?imageslim)\n\n（来自 [zejian](https://blog.csdn.net/javazejian/article/details/72772461)）\n\n工作内存实际上就是对上面**CPU缓存**的抽象。\n\n#### 内存间交互\n\nJava 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。\nread：把一个变量的值从主内存传输到工作内存中\nload：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中\nuse：把工作内存中一个变量的值传递给执行引擎\nassign：把一个从执行引擎接收到的值赋给工作内存的变量\nstore：把工作内存的一个变量的值传送到主内存中\nwrite：在 store 之后执行，把 store 得到的值放入主内存的变量中\nlock：作用于主内存的变量\nunlock：对应lock\n\n**JMM**还定义了一些关于`happens-before`关系的规则如下\n\n- 代码的执行顺序，编写在前面的发生在编写在后面的。\n\n- unlock 必须发生在lock之后\n\n- volatile 修饰的 写操作先发生在读之前\n\n- 传递规则 ，A 先于B B先于C A肯定先于C\n\n- 线程启动规则，start肯定现场发生与run\n\n- 线程中断方法，interrupt 必须发生在捕获之前\n\n- 对象的初始化必须发生在finalize前\n\n- 线程终结规则，所有操作都发生在线程死亡前\n\n[参考](https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html)\n\n## Volatile干了什么？\n\n### 保证可见性\n\n这里我们来看一个具体的Demo。\n\n```java\n//线程1\nboolean stop = false;\nwhile(!stop){\n    //doSomething();\n}\n \n//线程2\nstop = true;\n```\n\n其实在上一篇 [Java多线程基础](<http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/>) 里面 \"优雅的结束线程\" 里面有类似的代码\n\n![mark](http://static.imlgw.top///20190428/LQuwmhuMiwxp.png?imageslim)\n\n当时没有说明为啥要加`Volatile`，其实这里上面的代码如果不给状态量加上 `volatile`  并且用`server`模式运行有可能就会陷入死循环，即使在主线程里面将`isCancel`修改为`true`仍然无法结束，线程陷入了死循环，永远无法停止！！!为什么会这样？？？\n\n![mark](http://static.imlgw.top///20190410/nCcFbqyGiqIz.png?imageslim)\n\n🔸 在`server`模式下JIT对我们的代码进行了优化（这也是为什么要用server模式运行的原因，**Client VM的编译器没有像Server VM一样执行许多复杂的优化算法**）。它会将代码优化为类似下面这样的效果\n\n```java\nif(!stop){\n \twhile (stop){\n\t\t//do something....\n \t}\n}\n```\n\n`JIT`认为只有一个线程对其进行访问，所以为了避免重复的读取状态变量`stop`就将代码进行了 [循环不变表达式外提](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E4%BB%A3%E7%A0%81%E5%A4%96%E6%8F%90)（wikipedia），而这恰恰导致了死循环\n\n🔸另一方面，也和计算机的储存系统有关，也就是上面`CPU缓存`的问题中提到的，这里 `stop`就是共享变量，当线程①和②运行的时候先将主内存的`stop`拷贝了一份到`工作内存`中，其中一个线程修改了`stop`的值但是其他的线程无法感知到这个变化就可能会陷入死循环。\n\n📢 `volatile`在这里起到的作用就是\n\n① 阻止`JIT`的异常优化\n\n② 在一个线程修改了`volatile`修饰的共享变量后会**立即刷新到主内存**当中，这个过程称为_冲刷处理器缓存_。如果一个线程在读`voaltile`修饰的变量就会使相应的处理器**必须从主内存中进行同步**，这个过程称之为_刷新处理器缓存_，从而保证了可见性，通俗的讲就是`读必须从主内存中读，写必须同步到主内存中`。\n\n### 保证有序性\n\n**重排序**\n\n提到有序性就不得不说重排序，先来看一个`Demo`\n\n```java\nprivate boolean isReady=false;\n\npublic void writer(){\n    int data=getFromXxx(); //①\n    isReady=true \t\t//②\n}\n\npublic void reader(){\n    if(isReady){\n        //doSth\n    }\n}\n```\n\n这一看似乎没有什么问题，writer线程完成后开始read，问题就出来这里，**有可能data数据还没获取到，isReady就已经是true了**也就是说②和①的执行交换了顺序，也就是所谓的**重排序**，这样的重排序将会导致不可预知的错误，而导致这种现象的来源很多，比如编译器(JIT)，处理器和存储子系统(Cache)，至于为什么要重排序，主要还是为了提升性能，当然重排序对单线程来讲是没有影响的(有影响那还得了😂)\n\n**其实不只是上面那种比较显而易见的重排序，还有下面这种比较隐含的**\n\n```java\npublic class SingletonObjectPlus {\n    private static  SingletonObjectPlus singletonObjectPlus =null;\n    public static SingletonObjectPlus getSingletonObject3(){\n    \tif(singletonObjectPlus==null){\n        \tsynchronized(SingletonObject.class){\n            \tif(singletonObjectPlus==null){\n                \tsingletonObjectPlus= new SingletonObjectPlus();\n            \t}\n        \t}\n    \t}\n     \treturn singletonObjectPlus;\n\t}\n}\n```\n\n熟悉的朋友可能看出来了，这是一个DCL单例，那它有什么问题呢？它也会被重排序么？那么会在哪里重排序呢？\n\n上述代码确实有问题，问题在**new SingletonObjectPlus();**里面，实际上new这个操作可以划分为如下好几步\n\n1. 分配对象所需的空间 `objRef=allocate(SingleObjectPlus.class);`\n2. 初始化引用的对象 `invokeConstructor(objRef);`\n3. 设置`singletonObjectPlus`指向刚分配的内存地址`singletonObjectPlus=objRef`\n\n而这些步骤有可能就会被重排序，比如将③排到②之前，也就是对象还没有初始化完成就会被返回(已经分配空间了，就不为null了)，这样在`最外层if`判断的时候就可能会直接返回一个初始化未完成的对象\n\n> 发生这样重排序的概率很低，并不是必然出现的，重排序也不是随意的顺序调整，而是按照一定的规则去重排序，保证不会对单线程程序运行结果造成影响，显而易见，如果两条语句之间存在依赖关系，肯定是不会重排序的，具体就是两条语句访问同一个变量地址，至少有一条为写操作，那么这两条指令就存在依赖关系就不会被重排序比如 x=1;x=2;这样的 就不会被重排序。\n\n其实上面的问题都很好解决，只要在**isReady**和**singletonObjectPlus**上加上`volatile`就ok了，在这里volatile会禁止指令的重排序（底层通过调用处理器提供的内存屏障）\n\n### 保障Long/Double变量写的原子性\n\n这一点其实很容易被遗忘，实际上Java对所有除了Long和Double的变量的**读写**操作都是原子性的，包括基础类型(byte，boolean，short，float，和int)和引用类型。因为Double和Long类型的变量会占用64位，如果在`32位机器`上JVM对这种变量的读写可能就是会被分解为两个操作而在多线程的情况下就会出现问题，这里就不做演示了，知道有这么个事就行了。在加上`Volatile`之后就可以保证该操作的原子性了。\n\n### 注意\n\n> volatile在保障可见性的时候仅仅只能保障能够读取到该共享变量的相对新值，对于引用类型变量和数组类型的变量，volatile能保证的也仅仅是该变量本身的可见性，而对于数组中的元素，引用类型中的字段（实例变量，静态变量）则无法保证其可见性，对于这些变量可见性的保障可以利用JUC工具包中的`Atomic原子类`。\n\n## 内存屏障\n\n先简单了解两个指令：\n\n- Store：将处理器缓存的数据刷新到内存中。\n- Load：将内存存储的数据拷贝到处理器的缓存中。\n\n| 屏障类型            | 指令示例                   | 说明                                                         |\n| ------------------- | -------------------------- | ------------------------------------------------------------ |\n| LoadLoad Barriers   | Load1;`LoadLoad`;Load2     | 该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作 |\n| StoreStore Barriers | Store1;`StoreStore`;Store2 | 该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作 |\n| LoadStore Barriers  | Load1;`LoadStore`;Store2   | 确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作 |\n| StoreLoad Barriers  | Store1;`StoreLoad`;Load2   | 该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令 |\n\nStoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为`全能屏障`（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵\n\n- 按照可见性划分，内存屏障可以分为**加载屏障**(Load Barrier)，和**存储屏障**(Store Barrier)\n\n- 按照有序性划分可分为**获取屏障**(Acquire Barrier)和**释放屏障**(Release Barrier)\n\n具体那个充当加载屏障，那个充当存储屏障，我并不想讨论，各种博客各种资料各有各的说法，其实关于究竟底层是如何实现，如何插入，插入的哪一种这些细节我们不用去关心，不同的CPU不同的架构实现的方式都不一样，太过深入也没有多大的意义，很多博客介绍的也`完全不同`，我们只需要知道大概的原理就行了。如果想了解更多可以参考下列文章\n\n[聊聊原子变量、锁、内存屏障那点事](http://www.0xffffff.org/2017/02/21/40-atomic-variable-mutex-and-memory-barrier/)\n\n[一文解决内存屏障](https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/)\n\n[面试必问的volatile，你了解多少？](https://www.jianshu.com/p/506c1e38a922)\n\n[深入理解 Java 内存模型（四）——volatile](https://www.infoq.cn/article/java-memory-model-4/?utm_source=infoq&%253Butm_medium=related_content_link&%253Butm_campaign=relatedContent_articles_clk)\n\n### 锁与内存屏障\n\n用**OneNote**画了几张图\n\n![mark](http://static.imlgw.top///20190428/EUPpWHTPnlH8.png?imageslim)\n\n\n\n实际上锁就是通过**内存屏障**来保证了有序性和可见性，通过**互斥排它**来保证了原子性\n\n### Volatile和内存屏障\n\n**Volatile写操作和内存屏障**\n\n![volatile变量的写操作](http://static.imlgw.top///20190428/PImPUeLGqau6.png?imageslim)\n\n🔔 写线程对于`volatile变量的写操作`会产生类似于`锁释放`的效果。在写完成后会`冲刷处理器缓存`将结果立即刷新到主存中让其他处理器对应的缓存行失效，让其他处理器可同步该数据\n\n> volatile变量在原子性方面仅仅保证对被修饰的变量的读写`本身`的原子性。也就是说这个操作不能涉及任何共享变量(包括volatile变量本身)的访问，比如 volatile1=volatile2+1，volatile++ 这样的操作无法保证它的原子性，另外，voaltile可以保证`long`和`double`变量在`32位`机上写的原子性\n\n这里我们再回头看看前面的单例的例子\n\n①分配对象所需的空间 objRef=allocate(SingleObjectPlus.class);\n\n②初始化引用的对象 invokeConstructor(objRef);\n\n③设置singletonObjectPlus指向刚分配的内存地址 singletonObjectPlus=objRef\n\n虽然这里volatile子保证了子操作③的原子性 但是①②操作只涉及到了局部变量没有涉及到共享变量，由于内存屏障的作用①②操作不可能重排序到③之后，所以可以保证在得到返回之前对象一定已经初始化完毕了，不会出现没初始化完毕就返回的情况\n\n**Volatile读操作和内存屏障**\n\n![volatile变量的读操作](http://static.imlgw.top///20190428/tJcC98zgp532.png?imageslim)\n\n🔔 读线程对于`volatile变量的读操作`会产生类似于`获得锁`的效果。读volatile变量前会先`刷新处理器缓存`从主存或其他处理器缓存中`同步`该数据\n\n> volatile只能保证读线程读到共享变量的相对新值，对于引用类型和数组类型的并不能保证实例的字段或数组的元素的相对新值，只是保障了`引用地址`的相对新值(`相对新值`表示读的过程中其他线程有可能更改了这个值，对应的还有`最新值`，读的过程中写线程无法更改)\n\n### Volatile变量的开销&场景\n\n**开销**\n\nvolatile变量的读写都不会导致上下文切换，所以开销比锁要小，从上面的介绍中可以看出 写一个voaltile会使该操作和该操作前的所有写操作对后面的线程是可见的，所以它的成本会比普通变量大一些但是比锁小一点，读一个volatile变量也会比锁小，但是会比普通变量大因为变量都会从内存或其他处理器高速缓存中去拿无法直接从寄存器中去拿，但是也很快了。\n\n**应用场景**\n\n🔶 使用volatile变量作为状态标志位，应用程序的某个状态由一个线程设置，其他线程会读取该状态作为后面操作的依据，此时用volatile作为同步机制好处就是一个线程可以及时\"通知\"另一个线程某种事件(例如掉线重连)而避免使用锁造成较大开销\n\n🔶使用volatile保障可见性，一个线程更新了共享变量其他线程无需加锁也可以看到该更新\n\n🔶volatile bean模式（下面是我的个人理解可以直接跳过）\n\n```java\npublic class Person {\n    private volatile String firstName;\n    private volatile String lastName;\n    private volatile int age;\n    \n    public Person(String firstName,String lastName,int age){\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n    }\n\tpublic String getFirstName() { return firstName; }\n\tpublic String getLastName() { return lastName; }\n\tpublic int getAge() { return age; }\n \n\tpublic void setFirstName(String firstName) { \n    \tthis.firstName = firstName;\n\t}\n \n\tpublic void setLastName(String lastName) { \n    \tthis.lastName = lastName;\n\t}\n \n\tpublic void setAge(int age) { \n    \tthis.age = age;\n\t}\n}\n```\n\n关于这个场景的我理解的就是会保证类似volatile Person  preson=new Person(xx,xx,xx,xx);这样的操作具有可见性或者说完整性，不会初始化一半就返回对象要么为null要么就初始化完毕，类似于上面的提到的dcl单例的例子。\n\n🔶简易读写锁\n\n允许读线程读取的时候写线程进行更新，典型的例子就是实现一个计数器如下\n\n```java\npublic class Counter {\n    private volatile int value;\n    public int getValue() { return value; }\n    public synchronized int increment() {\n        return value++;\n    }  \t\n}\n```\n\n想了解更多去看看IBM这篇文章[Java 理论与实践:正确使用 Volatile 变量](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html)\n\n## 一个小问题\n\n![可见性的例子](http://static.imlgw.top///20190428/4CYfervOyHH3.png?imageslim)\n\n上面可见性的问题，图中的代码如果循环里面加上图中框内类似的代码，会发现即使共享变量上面不加**volatile**程序依然可以正常退出，上面出现的死循环并没有出现 (我的JDK版本是1.8，不同的版本情况可能不一样)，那是不是说这些操作也达到了保证可见性的作用呢？其实仔细分析这几行代码，后面三种都会刷新或冲刷处理器缓存(print里面也是加锁了的)，我一开始觉得可能是这个原因导致的，但是按道理应该是只会保证同步块内部的变量的可见性，但是sleep并没有加锁，是个本地方法为啥还是会导致这样的结果呢？这里我也不想深究了，我感觉也没啥必要了，具体的场景下该加**volatile**还是老老实实加**volatile**，如果继续探究下可以看下[这篇文章 ](http://www.importnew.com/19434.html)。\n\n## 参考资料\n\n- 《Java多线程编程实战指南：核心篇》\n\n- [javazejian](https://blog.csdn.net/javazejian/article/details/72772461)\n\n- ...","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"CAS与原子变量","url":"/2019/04/22/cas-yu-yuan-zi-bian-liang/","content":"\n## CAS\n\n_这个**CAS**可不是单点登陆的那个CAS😄!!!_\n\n> CAS（Compare-and-Swap），是对一种处理器指令的称呼，很多Java多线程相关的类库的最终实现都会借助CAS\n\n​\t从所周知，类似`i++`自增这样的操作并不是原子的，是一个`read-modify-write`的操作 ，如果要保证这种操作的原子性按照之前的做法可以使用`synchronized`内部锁来解决，但是这样似乎有点太小题大做了，锁确实可以解决这个问题，但是前面的文章也提到过，锁是很消耗性能的，并不是最好的做法，比较好的做法就是**CAS**，它能够将这些操作转换为原子操作。\n\n​\tCompare and Swap，比较并交换，顾名思义是一种`if-then-act`的操作，而这个操作的原子性由`处理器`保证(硬件锁)，如果一个线程想要将变量V的值由A变为B，借助CAS就会产生类似下面代码的作用\n\n```java\nboolean comapreAndSet(Variable V,Object A,Objext B){\n    if(V.get()==A){ //判断是否和当前V的值相同（是否被修改）\n        V.set(B);   //没被修改就更新\n        return true;\n    }\n    return false; //被修改过就直接return\n}\n```\n\n这样一来就是先下手为强了，当你最先修改了V的值，后面的所有线程都会直接失败，所以实际上也是一种快速失败策略，当然你也可以尝试再次请求直到成功为止。\n\n## 原子变量类\n\n_原子变量类_是基于CAS实现的一组保证共享变量`read-modify-write`操作(例如自增)原子性的工具类\n\n| 分组         | 类                                                           |\n| ------------ | ------------------------------------------------------------ |\n| 基础数据类型 | AtomicInteger，AtomicLong，AtomicBoolean                     |\n| 数组类       | AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray    |\n| 字段更新器   | AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater |\n| 引用型       | AtomicReference，AtomicStampedReference，AtomicMarkableReference |\n\n关于怎么使用就不多介绍，API上都写的明明白白，这里有个地方需要注意，数组类单纯的GET/SET并不是原子操作。\n\n### 利用CAS写一个锁\n\n[前面的文章](http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/)  利用内部锁实现过一个**BooleanLock**，这里利用CAS再实现一个简易的锁\n\n**getLockException**\n\n```java\npublic class GetLockException extends Exception{\n    public GetLockException(String message) {\n        super(message);\n    }\n\n    public GetLockException() {\n        super();\n    }\n}\n```\n\n**CASLock** \n\n```java\npublic class CASLock {\n    private static final AtomicInteger value = new AtomicInteger();\n\n    private Thread lockedThread;\n\n    public void trylock() throws GetLockException {\n        boolean success = value.compareAndSet(0, 1);\n        if (!success) {\n            throw new GetLockException(\"获得锁失败\");\n        }\n        lockedThread = Thread.currentThread();\n    }\n\n    public void unlock() {\n        if (0 == value.get()) {\n            return;\n        }\n        if (lockedThread == Thread.currentThread()) {\n            //解铃还须系铃人\n            boolean success = value.compareAndSet(1, 0);\n            System.out.println(Thread.currentThread().getName() + \" 释放了锁\");\n        }\n    }\n}\n```\n\n其实挺简单的，值得注意的地方就是释放锁的时候别忘了判断是不是当前线程加的锁，解铃还须系铃人😂\n\n### ABA问题\n\n> 从所周知，CAS成立的条件就是共享变量当前值和当前线程所提供的旧值相同，我们就可以认为这个变量没有被修改过，那么问题来了，对于一个共享变量**V**，如果当前线程看到它的时候它的值是A，当它想执行CAS修改这个变量的时候，另一个线程将**V**的值从A-->B-->A，那么这时当前线程再来执行CAS的时候，是否可以认为变量**V**没有被修改过呢？这里执行肯定是会成功的，但是这样结果是否可以接受呢 ?\n\n#### 无法接受的例子\n\n![mark](http://static.imlgw.top///20190423/vakfPgUQChGb.png?imageslim)\n\n上图为用**单链表**实现的栈结构，若T2先抢到了执行权，将A，B弹出栈，然后依次`push`了D，C，A，然后T1执行，利用CAS，head.compareAndSet(A，B)，执行成功，栈顶变为B，然而B就是个孤儿节点，这样一来C，D节点就被莫名其妙被丢掉了这显然是有问题的\n\n#### 如何解决ABA问题\n\n其实ABA问题并非完全无法接受，要考虑具体的场景，当然Java中也提供了解决的方案:\n\n`AtomicStampedReference` 这个类看名字就知道是带了戳的，带了一个类似版本号的东西，直接上源码吧。\n\n```java\npublic class AtomicStampedReference<V> {\n    private static class Pair<T> {\n        final T reference;\n        final int stamp;\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n\n    private volatile Pair<V> pair;\n\n    public AtomicStampedReference(V initialRef, int initialStamp) {\n        pair = Pair.of(initialRef, initialStamp);\n    }\n\n    /**\n     * Returns the current value of the reference.\n     *\n     * @return the current value of the reference\n     */\n    public V getReference() {\n        return pair.reference;\n    }\n\n    public int getStamp() {\n        return pair.stamp;\n    }\n\n    public V get(int[] stampHolder) {\n        Pair<V> pair = this.pair;\n        stampHolder[0] = pair.stamp;\n        return pair.reference;\n    }\n\n    public boolean weakCompareAndSet(V   expectedReference,\n                                     V   newReference,\n                                     int expectedStamp,\n                                     int newStamp) {\n        return compareAndSet(expectedReference, newReference,\n                             expectedStamp, newStamp);\n    }\n\n    /**\n     * Atomically sets the value of both the reference and stamp\n     * to the given update values if the\n     * current reference is {@code ==} to the expected reference\n     * and the current stamp is equal to the expected stamp.\n     *\n     * @param expectedReference the expected value of the reference\n     * @param newReference the new value for the reference\n     * @param expectedStamp the expected value of the stamp\n     * @param newStamp the new value for the stamp\n     * @return {@code true} if successful\n     */\n    public boolean compareAndSet(V   expectedReference,\n                                 V   newReference,\n                                 int expectedStamp,\n                                 int newStamp) {\n        Pair<V> current = pair;\n        return\n            expectedReference == current.reference && //期望值和当前值相等\n            expectedStamp == current.stamp &&\t//期望的戳和当前的戳一致\n            ((newReference == current.reference && //新的值是不是和当前的值一样\n              newStamp == current.stamp) ||\t\t//新的戳是不是和当前的戳一样\n             casPair(current, Pair.of(newReference, newStamp))); //如果不一样就利用CAS设置新值\n    }\n\n    public void set(V newReference, int newStamp) {\n        Pair<V> current = pair;\n        if (newReference != current.reference || newStamp != current.stamp)\n            this.pair = Pair.of(newReference, newStamp);\n    }\n\n    public boolean attemptStamp(V expectedReference, int newStamp) {\n        Pair<V> current = pair;\n        return\n            expectedReference == current.reference &&\n            (newStamp == current.stamp ||\n             casPair(current, Pair.of(expectedReference, newStamp)));\n    }\n\n    // Unsafe mechanics 底层调用unsafe的方法\n    private static final sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();\n    private static final long pairOffset =objectFieldOffset(UNSAFE, \"pair\", AtomicStampedReference.class);\n    //cas设置新值\n    private boolean casPair(Pair<V> cmp, Pair<V> val) {\n        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);\n    }\n\n    static long objectFieldOffset(sun.misc.Unsafe UNSAFE,\n                                  String field, Class<?> klazz) {\n        try {\n            return UNSAFE.objectFieldOffset(klazz.getDeclaredField(field));\n        } catch (NoSuchFieldException e) {\n            // Convert Exception to corresponding Error\n            NoSuchFieldError error = new NoSuchFieldError(field);\n            error.initCause(e);\n            throw error;\n        }\n    }\n}\n```\n\n\n这里删掉了部分注释， 可以看到里面封装了一个`Pair`里面有对象的引用和一个戳，在进行CAS的时候会判断`期望的引用`（传进来的引用）和`当前实际的引用`是不是一致，`期望的戳`（传进来的戳）和`当前实际的戳`是不是一致的，不一致就会直接`fail`，关键的CAS代码：\n\n```java\npublic boolean compareAndSet(V   expectedReference,\n                                 V   newReference,\n                                 int expectedStamp,\n                                 int newStamp) {\n        Pair<V> current = pair;\n        return  \n            expectedReference == current.reference && //期望值和当前值相等\n            expectedStamp == current.stamp &&\t//期望的戳和当前的戳一致\n            ((newReference == current.reference && //新的值是不是和当前的值一样\n              newStamp == current.stamp) ||\t\t//新的戳是不是和当前的戳一样\n             casPair(current, Pair.of(newReference, newStamp))); //如果不一样就利用CAS设置新值\n }\n```\n\n**测试AtomicStampedReference**\n\n```java\npublic class AtomicRefStampedTest {\n   static AtomicStampedReference<Integer> reference=new AtomicStampedReference<>(100,0);\n\n    public static void main(String[] args) {\n        //第一个线程进行ABA操作\n        new Thread(()->{\n            try {\n                TimeUnit.SECONDS.sleep(1);\n                System.out.println(\"t1 \"+reference.compareAndSet(100, 101, reference.getStamp(), reference.getStamp()+1));\n                System.out.println(reference.getStamp()+\",\"+reference.getReference());\n                System.out.println(\"t1 \"+ reference.compareAndSet(101, 100,reference.getStamp() , reference.getStamp()+1));\n            } catch (InterruptedException e) {\n\n            }\n\n        }).start();\n\n\t\t//第二个线程等待第一个线程执行完\n        new Thread(()->{\n            try {\n                int stamp = reference.getStamp();\n                //假设执行到这里发生上下文切换\n                System.out.println(\"Before sleep:stamp=\"+stamp);\n                TimeUnit.SECONDS.sleep(5);\n                System.out.println(\"After sleep:stamp=\"+reference.getStamp());\n                boolean b = reference.compareAndSet(100, 101, stamp, stamp + 1);\n                System.out.println(b);\n            } catch (InterruptedException e) {\n\n            }\n        }).start();\n    }\n}\n/**\n\tBefore sleep:stamp=0\n\tt1 true\n\t1,101\n\tt1 true\n\tAfter sleep:stamp=2\n\tfalse\n**/\n```\n\n结果肯定是t2执行失败了，毕竟戳不一样了，就算引用一样也没用。\n\n#### 小插曲(Integer缓存)\n\n这里一开始发生了一个小插曲，首先这里是的引用类型是 `Integer`类型的，然后我在进行CAS的时候从100--->200 ,然后又从200-->100，可能细心的朋友已经知道啥问题了，后面的从200-->100会失败，为啥？这个200和前面的200不是一个对象，引用不一样，那为啥101就可以呢？对，Integer有一个缓冲池，大小在-128--127之间的数，可以直接从缓冲池中拿，我开始在这里纠结了好一会儿😂\n\n### 字段更新器\n\n如果我们只需要某个类里的某个字段，也就是说让普通的变量也享受原子操作，可以使用原子更新字段类，如在某些时候由于项目前期考虑不周全，项目需求又发生变化，使得某个类中的变量需要执行多线程操作，由于该变量多处使用，改动起来比较麻烦，而且原来使用的地方无需使用线程安全，只要求新场景需要使用时，可以借助原子更新器处理这种场景，Java中提供了几种字段更新器`AtomicIntegerFieldUpdater`，`AtomicLongFieldUpdater`，`AtomicReferenceFieldUpdater`，看名字就知道是对应啥的\n\n#### AtomicIntegerFieldUpdater测试\n\n```java\npublic class AtomicIntegerFieldUpdaterTest {\n    public static void main(String[] args) {\n        AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(TestUpdate.class, \"num\");\n        TestUpdate testUpdate = new TestUpdate();\n        Stream.of(\"t1\", \"t2\", \"t3\", \"t4\", \"t5\").forEach(s -> {\n            new Thread(() -> {\n                int MAX = 100;\n                for (int i = 0; i < MAX; i++) {\n                    System.out.println(updater.getAndIncrement(testUpdate));\n                }\n            }, s).start();\n        });\n    }\n\n\n    static class TestUpdate {\n        volatile int num;\n    }\n}\n```\n\n这样就保证了Integer字段自增操作的原子性，另外两个与之类似。\n\n**需要注意的地方**\n\n- 操作的字段不能是static类型。\n\n- 操作的字段不能是final类型的，因为final根本没法修改。\n\n- 字段必须是volatile修饰的，也就是数据本身是读一致的。\n\n- 属性必须对当前的Updater所在的区域是可见的，也就是说无论何时都应该保证操作类与被操作类间的可见性。\n\n![mark](http://static.imlgw.top///20190430/hIuzU4rePaAe.png?imageslim)\n\n> 使用字段更新器比起直接使用原子类要节约内存，但是操作起来不方便\n\n## Unsafe双刃剑\n\n**Unsafe**类，看名字就知道不安全，并不是它写的不安全，而是用起来不安全，因为它可以像c/c++一样去操作内存地址，**unsafe**里面的所有方法都是**native**的，底层都是c/c++实现的，直接与操作系统底层交互，上面CAS执行也依赖于**unsafe**类中的方法，其实整个并发包里的类都依赖于**unsafe**，但是官方并不建议用户使用这个类\n\n- Unsafe有可能在未来的Jdk版本移除或者不允许Java应用代码使用，这一点可能导致使用了Unsafe的应用无法运行在高版本的Jdk\n- Unsafe的不少方法中必须提供原始地址(内存地址)和被替换对象的地址，偏移量要自己计算，一旦出现问题就是JVM崩溃级别的异常，会导致整个JVM实例崩溃，表现为应用程序直接崩掉。\n- Unsafe提供的直接内存访问的方法中使用的内存不受JVM管理(无法被GC)，需要手动管理，一旦出现疏忽很有可能成为内存泄漏的源头。\n\n### 获取Unsafe\n\n```java\n    //获取Unsafe\n    public static Unsafe getUnsafe() {\n        Field f = null;\n        try {\n            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            f.setAccessible(true);\n            return (Unsafe)f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException();\n        }\n    }\n```\n\n### CAS相关\n\nJava中的CAS实现调用的就是三个本地方法，第一个参数代表的就是实例对象，第二个参数代表需要CAS字段在该实例上的偏移量（不用自己计算，Unsafe提供了方法计算偏移量），第三个参数就是期望值，最后一个参数就是更新的值\n\n```java\npublic final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\n\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n```\n\n### 利用Unsafe自己写一个原子Counter\n\n```java\nclass CASCounter implements Counter {\n    private volatile long counter = 0;\n\n    public CASCounter() throws NoSuchFieldException {\n        unsafe = getUnsafe();\n        //获取counter字段的内存偏移量\n        offset= unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(\"counter\"));\n        System.out.println(offset);\n    }\n\t\n    private Unsafe unsafe;\n    private long offset;\n    \n    public static Unsafe getUnsafe() {\n        Field f = null;\n        try {\n            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            f.setAccessible(true);\n            return (Unsafe)f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException();\n        }\n    }\n\n    @Override\n    public void increment() {\n        long current=counter;\n        while (!unsafe.compareAndSwapLong(this,offset,current,current+1)){\n            current=counter;\n        }\n    }\n\n    @Override\n    public long getCounter() {\n        return counter;\n    }\n}\n\ninterface Counter {\n    void increment();\n\n    long getCounter();\n}\n```\n\n### Unsafe的骚操作\n\n**绕过构造器创建对象**\n\n```java\npublic class UnsafeFooTest {\n    public static void main(String[] args) throws ClassNotFoundException,InstantiationException, NoSuchFieldException {\n        Unsafe unsafe = UnsafeTest.getUnsafe();\n        //绕过构造器创建对象\n        Simple simple = (Simple) unsafe.allocateInstance(Simple.class);\n        System.out.println(simple.get()); //null\n        System.out.println(simple.getClass().getClassLoader());\n    }\n\n    static class Simple {\n        private String a = \"a\";\n        public Simple() {\n            a = \"new\";\n            System.out.println(\"============== \");\n        }\n\n        public String get() {\n            return a;\n        }\n        static {\n            System.out.println(\"静态代码块\");\n        }\n    }\n}\n```\n\n**修改字段在内存中的值**\n\n```java\npublic class UnsafeFooTest {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, NoSuchFieldException {\n        Unsafe unsafe = UnsafeTest.getUnsafe();\n        Permission permission = new Permission();\n        permission.doSth();\n        //通过反射也可以做到，但是unsafe直接是到内存地址中将值修改了\n        Field access_allow = permission.getClass().getDeclaredField(\"ACCESS_ALLOW\");\n        //获取字段再对象中的内存偏移量，可以简单理解为指针（内存地址）\n        unsafe.putLong(permission,unsafe.objectFieldOffset(access_allow),-1);\n        permission.doSth();\n    }\n}\n\nclass Permission {\n    private int ACCESS_ALLOW = 0;\n\n    private boolean isAllow() {\n        return  ACCESS_ALLOW==-1;\n    }\n\n    public void doSth() {\n        if (isAllow()) {\n            System.out.println(\"i am workind\");\n        }\n    }\n}\n```\n\n**defindClass加载类文件**\n\n```java\npublic class UnsafeFooTest {\n\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n        Unsafe unsafe = UnsafeTest.getUnsafe();\n        byte[] bytes = loadClassContent();\n        Class<?> aClass = unsafe.defineClass(null, bytes, 0, bytes.length, ClassLoader.getSystemClassLoader(), null);\n        int get = (int) aClass.getMethod(\"get\").invoke(aClass.newInstance(), null);\n        System.out.println(get);\n    }\n    \n    //将class字节码加载到内存中\n    public static byte[] loadClassContent() {\n        File f = new File(\"D:\\\\ClassLoaderTest\\\\Res.class\");\n        FileInputStream stream = null;\n        byte[] bytes=null;\n        try {\n            stream = new FileInputStream(f);\n             bytes = new byte[(int) f.length()];\n            stream.read(bytes);\n            stream.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return bytes;\n    }\n}\n```\n\n将编译好的class文件放到对应的目录下\n\n```java\npublic class Res {\n    private int i=0;\n\n    public Res(){\n        this.i=1;\n    }\n\n    public int get() {\n        return i;\n    }\n}\n```\n\n**结果**，是不是很牛皮？🐂🍺是🐂🍺但是这个玩意尽量的别用。。\n\n![mark](http://static.imlgw.top/blog/20190720/zLJJUhQ6GAdc.png?imageslim)\n\n**Unsafe**里面的方法还有很多这里就不都列举了，毕竟暂时还用不到，如果想了解更多可以看看这几篇文章\n\n- [JAVA中神奇的双刃剑--Unsafe](https://www.cnblogs.com/throwable/p/9139947.html)\n\n- [R大关于Unsafe的使用建议](https://www.zhihu.com/question/29266773?sort=created)\n\n- [Java魔法类：Unsafe应用解析](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"Java多线程之设计模式","url":"/2019/04/09/java-duo-xian-cheng-li-mian-de-she-ji-mo-shi/","content":"\n## 观察者模式\n\n>  观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程\n\n**观察者接口**\n\n```java\npublic  abstract class Observer {\n    protected Subject subject;\n\n    public Observer(Subject subject){\n        this.subject=subject;\n        subject.attach(this);\n    }\n\n    public  abstract  void update();\n}\n```\n\n**观察者1**\n\n```java\npublic class BinaryObserver extends Observer{\n\n    public BinaryObserver(Subject subject) {\n        super(subject);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"Binarry String :\"+ Integer.toBinaryString(subject.getState()));\n    }\n}\n```\n\n**观察者2**\n\n```java\npublic class OctalOberver extends Observer{\n    public OctalOberver(Subject subject) {\n        super(subject);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"Octal String:\"+Integer.toOctalString(subject.getState()));\n    }\n}\n```\n\n**被观察者**\n\n```java\npublic class Subject {\n    //观察者们\n    private  List<Observer> observers = new ArrayList<>();\n\n    private int state;\n\n    public int getState(){\n        return this.state;\n    }\n\t\n    //注册观察者\n    public void attach(Observer observer){\n        observers.add(observer);\n    }\n\n    public void setState(int state){\n        if(state==this.state){\n            return;\n        }\n        this.state=state;\n        notifyAllObserver();\n    }\n    //通知所有观察者线程\n    private  void  notifyAllObserver(){\n        observers.stream().forEach(Observer::update);\n    }\n}\n```\n\n**测试**\n\n```java\npublic class ObserverCLi {\n    public static void main(String[] args) {\n        final Subject subject=new Subject();\n        BinaryObserver binary=new BinaryObserver(subject);\n        OctalOberver octalOberver = new OctalOberver(subject);\n        System.out.println(\"==================\");\n        subject.setState(10);\n        System.out.println(\"==================\");\n        subject.setState(12);\n    }\n}\n```\n\n## 读写锁分离模式\n\n```java\npublic class ReadWriteLock {\n    private int readingR = 0;\n    private int waitingR = 0;\n    private int writingW = 0;\n    private int waitingW = 0;\n\n    public synchronized void readLock() throws InterruptedException{\n        this.waitingR++;\n        try {\n            //如果有线程在写就不能读\n            while (writingW > 0) {\n                this.wait();\n            }\n            this.readingR++;\n        }finally {\n            this.waitingR--;\n        }\n    }\n\n    public synchronized void readUnlock() throws InterruptedException{\n        this.readingR--;\n        notifyAll();\n    }\n\n    public synchronized void writeLock() throws InterruptedException{\n        this.waitingW++;\n        try {\n            while (readingR>0||writingW>0){\n                this.wait();\n            }\n            this.writingW++;\n        }finally {\n            this.waitingW--;\n        }\n    }\n\n    public synchronized void writeUnlock() throws InterruptedException{\n        this.writingW--;\n        notifyAll();\n    }\n\n}\n```\n\n只有读的时候不加锁，其他的时候加锁，在读的操作多于写的操作时，效率提升明显。\n\n## 不可变对象设计模式\n\n这个设计模式还是很重要也很常见的，`不可变`顾名思义，一个对象在被创建后对象所有的状态和属性都在其生命周期内都不会发生任何变化。\n\n> 不可变对象一定是线程安全的(里面的任何属性或者应用类型的都不能被修改)，可变对象不一定是线程安全的(SrtingBuffer)。J2EE里面，Servlet就不是线程安全的，struts1的Action也不是线程安全的。\n\n通常来说，创建不可变类原则有以下几条：\n\n① 所有成员变量必须是`private`\n\n② 最好同时用`final`修饰(非必须)\n\n③ 不提供能够修改原有对象状态的方法\n\n- 最常见的方式是不提供setter方法\n\n- 如果提供修改方法，需要新创建一个对象，并在新创建的对象上进行修改\n\n④ 通过构造器初始化所有成员变量，引用类型的成员变量必须进行深拷贝(deep copy)\n\n⑤ getter方法不能对外泄露this引用以及成员变量的引用\n\n⑥ 最好不允许类被继承(非必须)\n\n　　JDK中提供了一系列方法方便我们创建不可变集合，如：\n\n`Collections.unmodifiableList(List<? extends T> list)`\n\n```java\nfinal public class Person {\n    //定义成final\n    private final String name;\n    private final String address;\n\n    public Person(final String name,final String address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    public String getAddress() {\n\n        return address;\n    }\n\n    public String getName() {\n\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n虽然说是不可变对象，但是其实通过反射等方法还是可以改变的。\n\n```java\npublic class StringTest {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n        /*String s=\"Hello\";\n        String s1=s.replace(\"l\",\"K\");\n        System.out.println(s.hashCode());\n        System.out.println(s1.hashCode());*/\n        String s = \"Hello World\";\n        System.out.println(\"s = \" + s);//Hello World\n\t\t//String类里面的char[]\n        Field valueFieldOfString = String.class.getDeclaredField(\"value\");\n        valueFieldOfString.setAccessible(true);\n\n        char[] value = (char[]) valueFieldOfString.get(s);\n        value[5] = '_';\n        System.out.println(\"s = \" + s); //Hello_World\n    }\n}\n```\n\n## Future设计模式(异步)\n\n`Future`接口\n\n```java\npublic interface Future<T> {\n    T get() throws InterruptedException;\n}\n\n```\n\n`FutureTask`接口\n\n```java\npublic interface FutureTask<T> {\n    T call();\n}\n```\n\n`AsynFuture`异步\n\n```java\npublic class AsynFuture<T> implements Future<T> {\n    private volatile boolean done = false;\n\n    private T result;\n\n    public void done(T result) {\n        synchronized (this) {\n            this.result = result;\n            this.done = true;\n            //完成任务通知调用者\n            this.notifyAll();\n        }\n    }\n\n    @Override\n    public T get() throws InterruptedException {\n        synchronized (this) {\n            while (!done) {\n                this.wait();\n            }\n        }\n        return result;\n    }\n}\n```\n\n`FutureService`连接`Future`和`FutureTask`\n\n```java\npublic class FutureService {\n\n    public <T> Future<T> submit(final FutureTask<T> task) {\n        AsynFuture<T> asynFuture = new AsynFuture<>();\n        new Thread(() -> {\n            T result = task.call();\n            asynFuture.done(result);\n        }).start();\n        return asynFuture;\n    }\n\n    //java8 回调 callback\n    public <T> Future<T> submit(final FutureTask<T> task, final Consumer<T> consumer) {\n        AsynFuture<T> asynFuture = new AsynFuture<>();\n        new Thread(() -> {\n            T result = task.call();\n            asynFuture.done(result);\n            consumer.accept(result);\n        }).start();\n        return asynFuture;\n    }\n}\n```\n测试`Future`\n\n```java\npublic class SyncInvoker {\n    public static void main(String[] args) throws InterruptedException {\n\n        FutureService futureService = new FutureService();\n        Future<String> submit = futureService.submit(() -> {\n            try {\n                Thread.sleep(10000l);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"FINISH\";\n        },System.out::println);\n\n        System.out.println(\"===========\");\n        System.out.println(\" do other thing.\");\n        Thread.sleep(1000);\n        System.out.println(\"===========\");\n    }\n\n    private static String get()\n            throws InterruptedException {\n        Thread.sleep(10000l);\n        return \"FINISH\";\n    }\n}\n```\n\n> Future   ->未来的票据\n>\n> FutureTask   ->实际执行的任务\n>\n> FutureService  ->桥接Future和FutureTask\n\n## Guarded Suspension设计模式\n\n`保护性暂挂模式`\n\nGuarded是被守护的意思。Suspension是暂停的意思，Guarded Suspension模式通过让线程等待来保证实例的安全性。\n\n> 核心思想: 如果某个线程执行特定的操作前需要满足一定的条件，则在该条件未满足时将线程暂停运行（即暂挂线程，使其处于等待（waiting）状态，直到该条件满足时才继续运行）\n\n**Request对象**\n\n```java\npublic class Request {\n    final private String value;\n\n    public Request(String value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\n\n**RequestQueue**\n\n```java\npublic class RequestQueue {\n    private final LinkedList<Request> queue = new LinkedList<>();\n\n    public Request getRequest() {\n        synchronized (queue) {\n            while (queue.size() <= 0) {\n                try {\n                    //队列为空等一下\n                    queue.wait();\n                } catch (InterruptedException e) {\n                    return null;\n                }\n            }\n            Request request = queue.removeFirst();\n            return request;\n        }\n    }\n\n    public void putRequest(Request request) {\n        synchronized (queue) {\n            queue.addLast(request);\n            queue.notifyAll();\n        }\n    }\n}\n```\n\n**Server**\n\n```java\npublic class ServerThread extends Thread{\n    private final RequestQueue queue;\n\n    private final Random random;\n\n    private volatile boolean closed = false;\n\n    public ServerThread(RequestQueue queue) {\n        this.queue = queue;\n        random = new Random(System.currentTimeMillis());\n    }\n\n    @Override\n    public void run() {\n        while (!closed) {\n            Request request = queue.getRequest();\n            //get可能会返回null\n            if (null == request) {\n                System.out.println(\"Received the empty request.\");\n                break;\n            }\n            System.out.println(\"Server ->\" + request.getValue());\n            try {\n                Thread.sleep(random.nextInt(1000));\n            } catch (InterruptedException e) {\n                //打断后直接return\n                return;\n            }\n        }\n    }\n\n    public void close() {\n        this.closed = true;\n        this.interrupt();\n    }\n}\n```\n\n**Client**\n\n```java\npublic class ClientThread extends Thread {\n    private final RequestQueue queue;\n\n    private final Random random;\n\n    private final String sendValue;\n\n    public ClientThread(RequestQueue queue, String sendValue) {\n        this.queue = queue;\n        this.sendValue = sendValue;\n        random = new Random(System.currentTimeMillis());\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"Client -> request \" + sendValue);\n            //客户端发送请求\n            queue.putRequest(new Request(sendValue));\n            try {\n                Thread.sleep(random.nextInt(1000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class SuspensionClient {\n    public static void main(String[] args) throws InterruptedException {\n        final RequestQueue queue = new RequestQueue();\n        new ClientThread(queue, \"Shaw\").start();\n        ServerThread serverThread = new ServerThread(queue);\n        serverThread.start();\n        //serverThread.join(); join住了后面还咋close？？？\n        Thread.sleep(10000);\n        serverThread.close();\n    }\n}\n```\n\n\n\n## ThreadLocal\n\n线程局部变量，线程保险箱，以`Thread`作为`key`\n\n> This class provides `thread-local variables`. These variables differ from their normal counterparts in that each thread that accesses one (via its `get` or `set` method) has its own, independently initialized copy of the variable.\n\n模拟`ThreadLocal`\n\n```java\npublic class ThreadLocalSimulator<T> {\n    private final Map<Thread,T> threadMap=new HashMap<>();\n\n    public void set(T t){\n        Thread currentThread=Thread.currentThread();\n        synchronized (threadMap){\n            threadMap.put(currentThread,t);\n        }\n    }\n\n\n    public T get(){\n        Thread currentThread =Thread.currentThread();\n        if(threadMap.get(currentThread)==null){\n             threadMap.put(currentThread,initVal());\n        }\n        return threadMap.get(currentThread);\n    }\n\n    protected T initVal() {\n        return null;\n    }\n}\n```\n\n\n\n## Balking设计模式\n\n>核心思想：当不再适合或者没有必要进行这个操作时，就直接放弃进行这个操作而直接返回，不需要就算了\n\n```java\npublic class BalkingData {\n    private final String fileName;\n\n    private String content;\n\n    private boolean changed;\n\n    public BalkingData(String fileName, String content, boolean changed) {\n        this.fileName = fileName;\n        this.content = content;\n        this.changed = changed;\n    }\n\n    public synchronized void change(String newContent) {\n        this.content = newContent;\n        this.changed = true;\n    }\n\n    public synchronized void save() throws IOException {\n        if (!changed) {\n            //顾客没有服务请求，那么放弃提供服务操作，直接返回。\n            return;\n        }\n        doSave();\n        this.changed = false;\n    }\n\n    private void doSave() throws IOException {\n        System.out.println(Thread.currentThread().getName() + \" call  do save content\");\n        try(Writer writer = new FileWriter(fileName, true)) {\n            writer.write(content);\n            writer.write(\"\\n\");\n            writer.flush();\n        }\n    }\n}\n```\n\n**CustomerThread**\n\n```java\npublic class CustomerThread extends Thread {\n\n    private final BalkingData balkingData;\n\n    private final Random random = new Random(System.currentTimeMillis());\n\n    public CustomerThread(BalkingData balkingData) {\n        super(\"Customer\");\n        this.balkingData = balkingData;\n    }\n\n    @Override\n    public void run() {\n        try {\n            balkingData.save();\n            for (int i = 0; i < 20; i++) {\n                balkingData.change(\"No.\" + i);\n                Thread.sleep(random.nextInt(1000));\n                balkingData.save();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**WaiterThread**\n\n```java\npublic class WaiterThread extends Thread {\n\n    private final BalkingData balkingData;\n\n    public WaiterThread(BalkingData balkingData) {\n        super(\"Waiter\");\n        this.balkingData = balkingData;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 200; i++) {\n            try {\n                balkingData.save();\n                Thread.sleep(1_000L);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## CountDown设计模式\n\n**CountDown**\n\n```java\npublic class CountDown {\n    private final int total;\n\n    //计数器\n    private int counter;\n\n    public CountDown(int total) {\n        this.total = total;\n    }\n\n    public void down(){\n        synchronized (this){\n            this.counter++;\n            this.notifyAll();\n        }\n    }\n\n    public void await() throws InterruptedException {\n        synchronized (this){\n            while (counter!=total){\n                this.wait();\n            }\n        }\n    }\n}\n```\n\n**测试**\n\n```java\npublic class JDKCountDown {\n\n    private static final Random random = new Random(System.currentTimeMillis());\n\n\n    public static void main(String[] args) throws InterruptedException {\n        //JDK的CountDown\n        //final CountDownLatch latch=new CountDownLatch(5);\n        final CountDown latch=new CountDown(5);\n\n        System.out.println(\"准备多线程处理任务\");\n        //the first phase\n        IntStream.range(0,5).forEach(i->{\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+\" is working\");\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                latch.down();\n            },String.valueOf(i)).start();\n        });\n        latch.await();\n        //the second phase\n        System.out.println(\"多线程任务全部结束，准备第二阶段任务\");\n        System.out.println(\"........\");\n        System.out.println(\"Finish\");\n    }\n}\n```\n\n## 单例模式\n\n### Double check\n\n```java\npublic class SingletonObjectPlus {\n    private static volatile  SingletonObjectPlus singletonObjectPlus =null;\n    public static SingletonObjectPlus getSingletonObject3(){\n    \tif(singletonObjectPlus==null){\n        \tsynchronized(SingletonObject.class){\n            \tif(singletonObjectPlus==null){\n                \tsingletonObjectPlus= new SingletonObjectPlus();\n            \t}\n        \t}\n    \t}\n     \treturn singletonObjectPlus;\n\t}\n}\n```\n\n> 这种方式在实例对象上要加上 `volatile`，避免实例对象没有初始化完成就返回\n\n### InstanceHolder\n\n```java\npublic class SingleGraceful {\n    private SingleGraceful(){\n\n    }\n    //private静态内部类\n    private static class InstanceHolder{\n        //只会被初始化一次\n        private final static SingleGraceful instance=new SingleGraceful();\n    }\n\n    public static SingleGraceful getInstance(){\n        return SingleGraceful.InstanceHolder.instance;\n    }\n}\n```\n\nJVM只会为static变量分配一次内存，也就是只会初始化一次，而内部类不会在其外部类被加载的同时被加载，所以这也是一种很简洁很优秀的单例\n\n### Enum\n\n```java\npublic class SingleGraceful2 {\n    private SingleGraceful2() {}\n    \n    private enum Singleton {\n        INSTANCE;\n        \n        private final SingleGraceful2 instance;\n\n        Singleton() {\n            instance = new SingleGraceful2();\n        }\n\n        public SingleGraceful2 getInstance() {\n            return instance;\n        }\n    }\n    public static SingleGraceful2 getInstance() {\n        return Singleton.INSTANCE.getInstance();\n    }\n}\n```\n\n- 枚举类构造函数是`private`类型的\n- 枚举类的域(field)(`INSTANCE`)其实是相应的enum类型(`Singleton`)的一个静态实例对象，所以只会被初始化一次，构造器也只会被调用一次\n- 枚举单例可以防止`反序列化` ，`反射`，`克隆`对单例的破坏，所以是一种极其优秀的单例实现。\n\n\n\n> 这里其实还有很多没有介绍出来，设计模式这些东西没有实际的场景去用确实难以体会到它的精髓，需要慢慢的积累经验才行。\n\n","tags":["多线程","设计模式"],"categories":["并发"]},{"title":"Java多线程基础","url":"/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/","content":"## 1.线程与进程区别\n\n每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。\n\n使用线程可以把占据时间长的程序中的任务放到后台去处理，程序的运行速度可能加快，在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。\n\n如果有大量的线程,会影响性能，因为操作系统需要在它们之间切换，更多的线程需要更多的内存空间，线程的中止需要考虑其对程序运行的影响。通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。\n\n总结:进程是所有线程的集合，每一个线程是进程中的一条执行路径。\n\n## 2.为什么要使用多线程？多线程应用场景？\n\n答:主要能体现到多线程提高程序效率。\n\n举例: 迅雷多线程下载、数据库连接池、分批发送短信等。\n\n## 3.线程创建方式\n\n### 继承Thread类重写run方法\n\n```java\nclass PlayGame extends Thread {\n\tpublic void run() {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tSystem.out.println(\"PlayGame\" + (i + 1));\n\t\t}\n\t}\n\t//void say() {}\n}\n\nclass ListenMusic extends Thread {\n\tpublic void run() {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tSystem.out.println(\"ListenMusic\" + (i + 1));//底层操作居然是用的StringBuilder\n\t\t}\n\t}\n}\n\npublic class ThreadDemo {\n\tpublic static void main(String[] args)\n\t{\n\t\tThread music = new ListenMusic();\n\t\tThread pg = new PlayGame();\n\t\tmusic.start(); //三个线程同时运行抢占资源\n\t\ttry {\n\t\t\tpg.start();\n\t\t\tfor (int i = 0; i < 50; i++) {\n\t\t\t\tSystem.out.println(\"    main方法:\" + (i + 1));\n\t\t\t}\n\t\t\tpg.start();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"出现了IllegalThreadStateException异常\");\t  //线程只能启动一次\n\t\t}\n\t}\n}\n\n```\n这种方法官方也不推荐使用因为Java是单继承的继承了Thread类之后就不能继承其他的类\n\n### 实现Runnable接口\n\n```java\nclass CreateRunnable implements Runnable {\n\n\t@Override\n\tpublic void run() {\n\t\tfor (inti = 0; i< 10; i++) {\n\t\t\tSystem.out.println(\"i:\" + i);\n\t\t}\n\t}\n\n}\n\npublic class ThreadDemo2 {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"-----多线程创建开始-----\");\n\t\t// 1.创建一个线程\n\t\tCreateRunnable createThread = new CreateRunnable();\n\t\t// 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法\n\t\tSystem.out.println(\"-----多线程创建启动-----\");\n\t\tThread thread = new Thread(createThread);\n\t\tthread.start();\n\t\tSystem.out.println(\"-----多线程创建结束-----\");\n\t}\n}\n\n```\n### 匿名内部类\n\n```java\npublic class InClass {\n\tpublic static void main(String[] args) {\n\t\t Thread thread = new Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor (int i = 0; i< 100; i++) {\n\t\t\t\t\t\tSystem.out.println(\"i:\" + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\tthread.start();\n\n\t\t //lambda表达式还是比较简洁\n\t\t new Thread(()-> {for (int i = 0; i <100; i++) {System.out.println(\"lambda:\" +i);}}).start();\n\t}\n}\n\n```\n线程创建方式不只这些还有很多，后面再介绍\n\n### Thread 类中的start() 和 run() 方法有什么区别？\n\n这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。`start()`方法被用来启动新创建的线程，而且`start()`内部native方法`start0()`调用了run()方法，这和直接调用`run()`方法的效果不一样。当你调用`run()`方法的时候，只会是在原来的线程中调用，没有新的线程启动，`start()`方法才会启动新线程\n\n## 4.Thread构造函数\n\n| **常用线程api方法**| |\n|:--|---|\n| start()| 启动线程|\n| currentThread()| 获取当前线程对象|\n| getID()| 获取当前线程ID   Thread-编号 该编号从0开始|\n| getName()| 获取当前线程名称|\n| sleep(long mill)| 休眠线程|\n| Stop（）| 停止线程,|\n| **常用线程构造函数** | |\n| Thread（）| 分配一个新的 Thread 对象|\n| Thread（String name）| 分配一个新的 Thread对象，具有指定的 name正如其名。|\n| Thread（Runnable r）| 分配一个新的 Thread对象|\n| Thread（Runable r, String name）| 分配一个新的 Thread对象，具有指定的 name正如其名。|\n| Thread(ThreadGroup group, Runnable target) | 分配一个新的 Thread对象，如果不传`ThreadGroup`默认加入当前线程的`ThreadGroup`中 |\n| Thread(ThreadGroup group, Runnable target, String name) | 分配一个新的 `Thread`对象，使其具有  `target`作为其运行对象，具有指定的 `name`作为其名称，属于  `group`引用的线程组。 |\n| Thread(ThreadGroup group, Runnable target, String name,  long stackSize) | 分配一个新的 `Thread`对象，以便它具有  `target`作为其运行对象，将指定的 `name`正如其名，以及属于该线程组由称作  `group` ，并具有指定的 *堆栈大小* |\n\n### Thread构造方法的一些细节\n\n直接上源码\n\n```java\nprivate void init(ThreadGroup g, Runnable target, String name,\n                  long stackSize, AccessControlContext acc,\n                  boolean inheritThreadLocals) {\n    if (name == null) {\n        throw new NullPointerException(\"name cannot be null\");\n    }\n\n    this.name = name;\n\n    Thread parent = currentThread();\n    SecurityManager security = System.getSecurityManager();\n    if (g == null) {\n        /* Determine if it's an applet or not */\n\n        /* If there is a security manager, ask the security manager\n               what to do. */\n        if (security != null) {\n            g = security.getThreadGroup();\n        }\n\n        /* If the security doesn't have a strong opinion of the matter\n               use the parent thread group. */\n        if (g == null) {\n            g = parent.getThreadGroup();\n        }\n    }\n\n    /* checkAccess regardless of whether or not threadgroup is\n           explicitly passed in. */\n    g.checkAccess();\n\n    /*\n         * Do we have the required permissions?\n         */\n    if (security != null) {\n        if (isCCLOverridden(getClass())) {\n            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n    }\n\n    g.addUnstarted();\n    this.group = g;\n    //这里继承了父类的一些属性\n    this.daemon = parent.isDaemon();\n    this.priority = parent.getPriority();\n\n    if (security == null || isCCLOverridden(parent.getClass()))\n        this.contextClassLoader = parent.getContextClassLoader();\n    else\n        this.contextClassLoader = parent.contextClassLoader;\n    this.inheritedAccessControlContext =\n        acc != null ? acc : AccessController.getContext();\n    //传入的Runnable接口\n    this.target = target;\n    setPriority(priority);\n    if (inheritThreadLocals && parent.inheritableThreadLocals != null)\n        this.inheritableThreadLocals =\n        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n    /* Stash the specified stack size in case the VM cares */\n    this.stackSize = stackSize;\n\n    /* Set thread ID */\n    tid = nextThreadID();\n}\n```\n\n① 创建的线程会继承父线程的一些属性，是否是守护线程 ，和优先级。\n\n②使用Thread(Runnable r)创建线程时`this.target = target`传入的`Runnable`接口在这里赋值然后会在`run方法`中被调用。\n\n③`stacksize`这个参数会影响`虚拟机栈`的大小，这个值越大能存放的`栈帧`就越多，可达到的递归深度越深，但是这个参数不一定有效，有的平台可能并没有效果，具体的`JVM`底层的知识等后面学到再来细化\n\n④一种奇怪的写法，这里只会执行重写`Thread`的`run`方法，这里从源码上可以看出来，传递`Runnable`接口其实是在Thread的run方法中调用了`target`的`run`方法，如果同时再`继承`Thread类，重写`run`方法，调用的就不再是Thread类的run方法，而是匿名Thread子类重写的run方法\n\n```java\nThread t = new Thread(() -> {\n    System.out.println(\"Runnable\");\n}) {\n    @Override\n    public void run() {\n        System.out.println(\"Thread\");\n    }\n};\n```\n\n④线程`tid`通过`threadSeqNumber`从0自增的来，main线程是第`10`个线程因为会有一些守护线程会在main启动前启动.\n\n## 5.守护线程\n\nJava中有两种线程，一种是用户线程，另一种是守护线程。\n\n用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止\n\n- 守护线程顾名思义当父线程结束时，守护线程也会被停止。\n- JVM只有在最后一个非守护线程结束后才会退出\n- 在线程start前`setDaemon(true)`方法设置为守护线程，否则就会报错\n- 父线程是守护线程，子线程默认是守护线程。\n\n```java\nclass Daemon implements Runnable {\n    public void run() {\n        for(int i=0;i<500;i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n    }\n}\n\npublic class DaemonDemo {\n    public static void main(String[]args) {\n        System.out.println(Thread.currentThread().getPriority());\n        Thread r1=new Thread(new Daemon(),\"后台线程\");     //设置该线程为后台线程\n        r1.setDaemon(true);                        //前台线程挂掉后，后台线程就会挂掉\n        for(int i=0;i<50;i++) {                   \n            System.out.println(\"main\"+i);\n            if(i==10) {\n                r1.start();\n            }\n        }\n        System.out.println(\"主线程执行完毕\");\n    }\n}\n```\n\n### 应用场景\n\n`心跳检测`，在通信过程中会需要判断对方是否在线，会需要创建一条线程去做这些事情，但是如果这样会导致`主线程停止工作`了，但是检测心跳的线程仍然在继续工作，JVM就无法停下来，显然这样时不合理的，这时就可以把检测心跳的线程设置为`守护线程`，这样当它主线程停止工作时它的守护线程也会随之停止。\n\n```java\n//心跳检测MOCK\npublic static void main(String[] args) throws InterruptedException {\n        Thread t = new Thread(() -> {\n            Thread inThread = new Thread(() -> {\n                while (true) {\n                    System.out.println(\"start heart check\");\n                    try {\n                        Thread.sleep(1_00);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            //将子线程设置为守护线程\n            inThread.setDaemon(true);\n            inThread.start();\n            try {\n                Thread.sleep(1_000);\n                System.err.println(\"Thread finish done...\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        t.start();\n        //主线程(main)-->t-->inThread\n    }\n```\n\n## 6.线程的状态\n\n线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。\n\n![mark](http://static.imlgw.top///20181226/WXPYz3SiidMT.png?imageslim)\n\n- 新建状态\n  当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码\n\n- 就绪状态\n  一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。\n  处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由`Java`运行时系统的线程调度程序(*thread scheduler*)来调度的。\n\n- 运行状态\n  当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.\n\n- 阻塞状态\n  线程运行过程中，可能由于各种原因进入阻塞状态:\n  1>线程通过调用sleep方法进入睡眠状态；\n  2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；\n  3>线程试图得到一个锁，而该锁正被其他线程持有；\n  4>线程在等待某个触发条件；\n\n- 死亡状态\n\n  有两个原因会导致线程死亡：\n\n  1) run方法正常退出而自然死亡，\n\n  2) 一个未捕获的异常终止了run方法而使线程猝死。 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用`isAlive`方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.\n\n## 7.join()方法\n\n### 源码解析\n\n```java\n public final synchronized void join(long millis) throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n        if (millis == 0) {\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {\n            while (isAlive()) {\n                long delay = millis - now;\n                if (delay <= 0) {\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n```\n\n①`thread.join()`没有参数会默认调用`join(0)`然后回轮询检查调用`join()`的线程也就是是`thread`线程是否`isAlive()`如果thread依然存活就回释放`当前线程`的CPU执行权，然后继续轮询，知道`thread`进入终止状态。\n\n②`join(long millis)` 参数的作用就是当前线程最多等待时间，限时等待，避免无止境的等待。\n\n③一个线程自己调用自己的`join`方法该线程就回一直`wait`下去因为他自己要一直等自己😄\n\n### 应用场景\n\n>  多线程同时采集数据，最后将统计的总时间等信息存到数据库中，如果不jion就无法统一结束的时间\n\n```java\npublic class ThreadJoin3 {\n    public static void main(String[] args) throws InterruptedException {\n        long l1 = System.currentTimeMillis();\n        Thread t0 = new Thread(new CaptureMachine(\"M0\", 1000));\n        Thread t1 = new Thread(new CaptureMachine(\"M1\", 2000));\n        Thread t2 = new Thread(new CaptureMachine(\"M2\", 4000));\n        t0.start();\n        t1.start();\n        t2.start();\n        //让主线程等待子线程结束然后统计最后总体结束的时间\n        t0.join();\n        t1.join();\n        t2.join();\n        long l = System.currentTimeMillis();\n        System.out.println(\"end save begin timestamp:\" + l1 + \"end timestamp\" + l);\n    }\n}\n\nclass CaptureMachine implements Runnable {\n    private String machineId;\n\n    private long spentTime;\n\n    public CaptureMachine(String machineId, long spentTime) {\n        this.machineId = machineId;\n        this.spentTime = spentTime;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(spentTime);\n            System.out.println(machineId + \" capture done\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 8.优先级\n\n现代操作系统基本采用时分的形式调度运行的线程，线程分配得到的时间片的多少决定了线程使用处理器资源的多少，也对应了线程优先级这个概念。在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。下面是Demo（基于1.8）中关于priority的一些量和方法。\n\n```java\npublic class ThreadSimpleAPI2 {\n    public static void main(String[] args) {\n        Thread t0 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                Optional.of(Thread.currentThread().getName() + \"-index\" + i).ifPresent(System.out::println);\n            }\n        });\n        t0.setPriority(Thread.MAX_PRIORITY);\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                Optional.of(Thread.currentThread().getName() + \"-index\" + i).ifPresent(System.out::println);\n            }\n        });\n        t1.setPriority(Thread.NORM_PRIORITY);\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                Optional.of(Thread.currentThread().getName() + \"-index\" + i).ifPresent(System.out::println);\n            }\n        });\n        t2.setPriority(Thread.MIN_PRIORITY);\n        t0.start();\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n## 9.Interrupt方法 \n\n### 看看源码\n\n```java\npublic void interrupt() {\n        if (this != Thread.currentThread())\n            checkAccess();\n\n        synchronized (blockerLock) {\n            Interruptible b = blocker;\n            if (b != null) {\n                interrupt0();           // Just to set the interrupt flag\n                b.interrupt(this);\n                return;\n            }\n        }\n        interrupt0();\n}\n```\n\n在知乎上看见一个好的回答：首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己`自行停止`。所以，`Thread.stop()` ,`Thread.suspend()`,`Thread.resume()`都已经被废弃了。而`Thread.interrupt()`的作用也不是中断线程，_而是通知线程该结束了_ 具体中断还是继续运行还是由被通知的线程自己处理。具体来说，当对一个线程调用`interrupt()`时\n\n①如果线程处于阻塞状态(sleep,wait,join等)，那么线程将~~立即退出被阻塞状态~~并抛出一个异常(2019.8.10 fix)\n\n> 这里其实是有点问题的，在有同步锁存在的情况下，并不一定会立即退出被阻塞的状态，即使抛出异常也要等到再次拿到锁之后才能抛出，同时也不是所有的阻塞操作都会响应中断信号，比如IO操作之类的都不会响应中断信号\n\n**验证Demo**\n\n```java\npublic class WaitNotify {\n\n    public static void main(String[] args) {\n\n        Object object = new Object();\n\n        Thread thread1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (object) {\n                    System.out.println(\"线程1 获取到监视器锁\");\n                    try {\n                        object.wait();\n                        System.out.println(\"线程1 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。\");\n                    } catch (InterruptedException e) {\n                        System.out.println(\"线程1 wait方法抛出了InterruptedException异常，即使是异常，我也是要获取到监视器锁了才会抛出\");\n                    }\n                }\n            }\n        }, \"线程1\");\n        thread1.start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (object) {\n                    System.out.println(\"线程2 拿到了监视器锁。为什么呢，因为线程1 在 wait 方法的时候会自动释放锁\");\n                    System.out.println(\"线程2 设置线程1 中断\");\n                    thread1.interrupt();\n                    System.out.println(\"线程2 执行完了 中断，先休息3秒再说。\");\n                    try {\n                        Thread.sleep(3000);\n                        System.out.println(\"线程2 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁\");\n                    } catch (InterruptedException e) {\n\n                    }\n                    System.out.println(\"线程2 休息够了，结束操作\");\n                }\n            }\n        }, \"线程2\").start();\n    }\n}\n```\n\n②如果线程处于正常活动状态，那么会将该线程的`中断标志位`设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响。\n\n③对已经结束的线程调用`interupt`没有任何效果\n\n上面只是简单的分析，其实情况还是很复杂的，后面再来总结\n\n**具体的小案例**\n\n```java\npublic class ThreadInterrup2 {\n    public static void main(String[] args) {\n        Thread main=Thread.currentThread();\n\n        Thread t=new Thread(()->{\n            while (true){\n\n            }\n        });\n        t.start();\n\t\n        Thread t2 = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //t.interrupt(); 这里打断的是t线程但是阻塞的是main线程所以打断不了，捕获不到异常\n            main.interrupt();\n            System.out.println(\"打断 main 线程\");\n        });\n        t2.start();\n\n        try {\n            //这里阻塞的是main线程\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n看懂这个小案例应该就理解interrupt了。\n\n### 如何优雅的结束线程\n\n**1. 使用“开关”**\n\n```java\npublic class ThreadCloseGraceful {\n    public static void main(String[] args) throws InterruptedException {\n        Worker worker=new Worker();\n        worker.start();\n        Thread.sleep(10000); //等待10s\n        worker.shutdown();\n    }\n}\n\nclass Worker extends Thread{\n    //优雅的停止线程-----开关\n    private volatile boolean start = true;\n\n    @Override\n    public void run() {\n        while (start){\n\n        }\n    }\n\n    public void shutdown(){\n        this.start=false;\n    }\n}\n```\n\n> 为了及时的感知到开关的变化 start需要声明为 volatile（后面讲Volatile的时候会说到）\n\n**2. 轮询中断标志位**\n\n```java\npublic class ThreadCloseGraceful2 {\n    public static void main(String[] args) throws InterruptedException {\n        Worker2 worker2 = new Worker2();\n        worker2.start();\n        Thread.sleep(5000);\n        worker2.interrupt();\n    }\n}\n\nclass Worker2 extends Thread{\n    //优雅的停止线程2-----打断\n    @Override\n    public void run() {\n        while (true){\n            /*try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                break; //return 会直接退出\n            }*/\n            //代码有可能在执行isInterrupted之前就Block了\n            if(isInterrupted()){\n                break;\n            }\n        }\n        //-----------\n    }\n}\n```\n\n**3. 利用守护线程**\n\n上面的代码已经提到了，有可能在轮询`开关` 或者 轮询`中断标志位`之前就堵塞了，这时也不能一直等该下去所以就需要强制结束线程的方法，`（当然不会是stop）` 这里就可以利用守护线程的特性去完成这件事\n\n```java\npublic class ThreadService {\n    private  Thread executeThread;\n\n    private  volatile  boolean finished=false;\n\n    public void execute(Runnable task){\n        executeThread =new Thread(()->{\n            //子线程\n            Thread t=new Thread(()->{\n                task.run();\n            });\n            t.setDaemon(true);\n            t.start();\n\n            try {\n                t.join(); //这里阻塞的是executeThread\n                finished=true;\n                //到这里说明executeThread已经不阻塞了,子线程已经执行完了，没有超时\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                System.out.println(\"TLE，executeThread execution was interrupted\");\n            }\n        });\n        executeThread.start();\n    }\n\n    public void shutdown(long mills){\n        long base=System.currentTimeMillis();\n        while (!finished){ //轮询检查标志位，看是否已经结束\n            if(System.currentTimeMillis()-base>=mills){\n                //超时了没有完成\n                System.out.println(\"TLE, will end it now\");\n                executeThread.interrupt(); //打断executeThread\n                break;\n            }\n            //没超时\n            try {\n                executeThread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                System.out.println(\"executeThread was interrupted when shutdown\");\n            }\n        }\n        //标志位复原\n        finished=false;\n    }\n}\n```\n\n将待执行的`task`传递到`ThreadService`中然后会创建一个`executeThread`的线程，在线程中创建一个子线程去执行`task`的`run`方法然后将子线程设置为`executeThread`的守护线程然后`join`阻塞`executeThread`线程，同时会调用`ThreadService`的`shutdown`方法传入一个最长等待时间然后`轮询标志位`检查是否结束，如果超时就会打断`executeThread`进而结束`executeThread`的子线程也就是`task`\n\n### Thread.interrupted()\n\n这个方法和`isInterrupt()`类似但是他会清除中断标志位为`false`方便之后的中断操作而且这个是`静态方法`，所以你用线程实例去调用这个方法没有任何意义，它这里是用来判断**当前执行线程**是否 `interrupt` ，并且设置中断标志位为`false`\n\n```html\n/**\n * Tests whether the current thread has been interrupted.  The\n * <i>interrupted status</i> of the thread is cleared by this method.  In\n * other words, if this method were to be called twice in succession, the\n * second call would return false (unless the current thread were\n * interrupted again, after the first call had cleared its interrupted\n * status and before the second call had examined it).\n *\n * <p>A thread interruption ignored because a thread was not alive\n * at the time of the interrupt will be reflected by this method\n * returning false.\n *\n * @return  <code>true</code> if the current thread has been interrupted;\n *          <code>false</code> otherwise.\n * @see #isInterrupted()\n * @revised 6.0\n */\n```\n\n同时在抛出`InterruptedException` 之后中断状态也会被自动清除为false\n\n> if any thread has interrupted the current thread. The <i>interrupted status</i> of the current thread is cleared when this exception is thrown.     ----Thread.sleep注释\n\n## 10.Yield方法\n\nThread.yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）\nyield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。\n结论：大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。\n\n## 11.Synchronized关键字 \n\n### 线程安全问题\n\n```java\npublic class TicketRunnable implements Runnable {\n    \n    private final static int MAX_NO = 500;\n\n    private int index = 1;\n\n    @Override\n    public void run() {\n        while (true) {\n                if (index > MAX_NO) {\n                    return;\n                }\n                try {\n                    Thread.sleep(5);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"第：\" + index++);\n        }\n    }\n}\n```\n\n用这个创建多个`Thread`然后运行\n\n> 二号窗口第：497\n> 三号窗口第：499\n> 一号窗口第：498\n> 一号窗口第：500\n> 二号窗口第：`502`\n> 三号窗口第：`501`\n\n可以看出打印出了501，502明显不对为什么会出现这种问题呢？其实仔细想想也很容易理解\n\n![mark](http://static.imlgw.top///20190326/zSGNeiCW2zc1.png?imageslim)\n\n当两个线程如图所示的情况，2号线程`index=500`然后`index++`然后 1号线程读取到`index`的值就会产生这个问题。\n\n### 同步代码块\n\n**解决线程安全问题**\n\n```java\npublic class TicketRunnable implements Runnable {\n\n    private final static int MAX_NO = 500;\n    \n    private int index = 1;\n\n    private final Object MONITOR = new Object();\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (MONITOR) {\n                //单线程\n                if (index > MAX_NO) {\n                    return;\n                }\n                try {\n                    Thread.sleep(5);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"第：\" + index++);\n            }\n        }\n    }\n}\n```\n\n利用`MONITOR`对象作为同步锁同步之后的部分就相当于单线程，`MONITOR`锁对象一般设置为`final`的避免在执行过程中对`MONITOR`对象进行改变而产生无法预料的后果\n\n### 同步方法\n\n```java\npublic class SynchronizeRunnable implements Runnable {\n\n    private final static int MAX_NO = 500;\n\n    private int index = 1;\n\n    @Override\n    public  void run() {\n        //this锁\n        while (true) {\n            if (ticket()) {\n                return;\n            }\n\n        }\n    }\n\n    private synchronized boolean ticket(){\n        //synchronized (this) {\n            //1.getFiled\n            if (index > MAX_NO) {\n                return true;\n            }\n            try {\n                Thread.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            // getFiled index\n            // index=index+1\n            // putFiled index\n            //同步代码块就是保护共享数据index, MAX_NO不是,他是只读数据\n            System.out.println(Thread.currentThread().getName() + \"第：\" + index++);\n            return false;\n       // }\n    }\n}\n```\n\n默认加的是`this`锁\n\n**证明this锁的存在**\n\n```java\npublic class SynchronizedThis {\n    public static void main(String[] args) {\n        ThisLock thisLock = new ThisLock();\n        Thread thread = new Thread(() -> thisLock.m1(), \"Thread0\");\n        thread.start();\n        Thread thread1 = new Thread(() -> thisLock.m2(), \"Thread1\");\n        thread1.start();\n        Thread thread2 = new Thread(() -> thisLock.m3(), \"Thread2\");\n        thread2.start();\n    }\n}\n\nclass ThisLock {\n\n    private final Object LOCK = new Object();\n\n    public synchronized void m1() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public synchronized void m2() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void m3() {\n        synchronized (LOCK) {\n            System.out.println(Thread.currentThread().getName());\n            try {\n                Thread.sleep(10_000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n运行上面的代码会发现`Thread0`和`Thread2`会先打印出来因为他们不是同一个锁不用等待对方，而`Thread1`会等待一段时间后才会执行因为它需要等待`Thread0`释放锁而这个锁只能是`this锁`\n\n**证明class锁的存在**\n\n```java\npublic class SynchronizedClass {\n    public static void main(String[] args) {\n        Thread thread0 = new Thread(() -> ClassLock.m1(), \"Thread0\");\n        thread0.start();\n        Thread thread1 = new Thread(() -> ClassLock.m2(), \"Thread1\");\n        thread1.start();\n        Thread thread2 = new Thread(() -> ClassLock.m3(), \"Thread2\");\n        thread2.start();\n    }\n}\n\nclass ClassLock {\n    static {\n        synchronized (ClassLock.class) {\n            System.out.println(\"static\" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(10_000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static synchronized void m1() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized void m2() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void m3() {\n        System.out.println(Thread.currentThread().getName());\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n运行上面的代码会发现最开始只有一个线程会去执行静态代码快，在静态代码快执行完之后`Thread2`会和另一个线程一起执行，说明一开始`Thread2`回和其中一个线程抢`Class锁`执行静态代码块（静态代码块只会执行一次）\n\n### 死锁\n\n> 一个线程可以持有多个锁，而这样就可能会导致`死锁`的产生\n\n**死锁示例**\n\n```java\npublic class Service1 {\n    private  final Object LOCK=new Object();\n\n    private Service2 service2;\n\n    public  void s1(){\n        synchronized (LOCK){\n            System.out.println(\"s1==============\");\n        }\n    }\n\n    public void s2(){\n        synchronized (LOCK){\n            System.out.println(\"s2==============\");\n            service2.m2();\n        }\n    }\n\n    public void setService2(Service2 service2) {\n        this.service2 = service2;\n    }\n}\n---------------------------------------------------\npublic class Service2 {\n    private Service1 service1;\n\n    public Service2(Service1 service1) {\n        this.service1 = service1;\n    }\n\n    private  final  Object LOCK=new Object();\n\n    public  void  m1(){\n        synchronized (LOCK){\n            System.out.println(\"m1\");\n            service1.s1();\n        }\n    }\n\n    public  void  m2(){\n        synchronized (LOCK){\n            System.out.println(\"m2\");\n        }\n    }\n}\n-------------------------------------------------\npublic class DeadLockTest {\n    public static void main(String[] args) {\n        Service1 service1=new Service1();\n        Service2 service2 =new Service2(service1);\n        service1.setService2(service2);\n\n        new Thread(()->{\n            while (true){\n                service2.m1();\n            }\n        }).start();\n\n        new Thread(()->{\n            while (true){\n                service1.s2();\n            }\n        }).start();\n    }\n}\n```\n\n执行上面代码就会发现在运行一段时间后两个线程都`阻塞`了，这就是`死锁`\n\n- `jps`&`jstack`  分析死锁\n\n![mark](http://static.imlgw.top///20190328/BG9eU9Rq8ae0.png?imageslim)\n\n两个线程都需要对方手上的的锁，陷入僵持状态，就会产生死锁，也可以使用`jconsole`图形化界面来分析\n\n## 12.线程间通讯\n\n在Java平台中，Object.wait()/notify() 等方法可用于实现线程的等待和通知，wait将当前线程暂停生命周期变为 **WAITING** ，而notify() 则可以唤醒一个被暂停的线程从而实现通知，一般来说wait() 代码模板类似下面\n\n```java\nsynchronized(someObj){\n    while(保护条件不成立){\n        //等待\n        someObj.wait();\n    }\n    //保护条件满足\n    doAction();\n}\n```\n\n而`notify()` 对应代码模板如下\n\n```java\nsynchronized(someObj){\n    //更新等待线程的保护条件设计的共享变量\n    updateSharedDate();\n    //唤醒其他线程\n    someObj,notify();\n}\n```\n\n### 生产者消费者模型\n\n**错误示例**\n\n```java\npublic class ProduceConsumerVersion1 {\n    public static void main(String[] args) {\n        ProduceConsumerVersion1 pc = new ProduceConsumerVersion1();\n        new Thread(() -> {\n            while (true) {\n                pc.produce();\n            }\n        }, \"Produce\").start();\n        new Thread(() -> {\n            while (true) {\n                pc.consumer();\n            }\n        }, \"Consumer\").start();\n    }\n\n    private int i = 0;\n\n    private final Object LOCK = new Object();\n\n    public void produce() {\n        synchronized (LOCK) {\n            System.out.println(\"Produce->\" + (i++));\n        }\n    }\n\n    public void consumer() {\n        synchronized (LOCK) {\n            System.out.println(\"Consumer->\" + (i));\n        }\n    }\n}\n```\n\n这种模型当生产者和消费者启动后会发现两个线程无法协作，生产者不断生产，消费者`不消费`或者`重复消费`\n\n**单生产者&单消费者**\n\n```java\npublic class ProduceConsumerVersion2 {\n    public static void main(String[] args) {\n        ProduceConsumerVersion2 pc = new ProduceConsumerVersion2();\n        Stream.of(\"Produce1\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n\n    private int i = 0;\n\n    private final Object LOCK = new Object();\n\n    private volatile boolean isProduced = false;\n\n    public void produce() {\n        synchronized (LOCK) {\n            if (isProduced) {\n                //已经生产了\n                try {\n                    LOCK.wait();//等待消费者唤醒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (++i));//produce\n            isProduced = true;\n            LOCK.notify();\n        }\n    }\n\n    public void consumer() {\n        synchronized (LOCK) {\n            if (!isProduced) {\n                try {\n                    LOCK.wait();//等待生产者唤醒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (i));//consumer\n            isProduced = false;\n            LOCK.notify();\n        }\n    }\n}\n```\n\n**wait()：** 当前线程`释放锁`进入该锁对象的`等待队列` \n\n> Causes the current thread to wait until another thread invokes the\n>\n> {@link java.lang.Object#notify()} method or the\n>\n> {@link java.lang.Object#notifyAll()} method for this object.\n>\n> In other words, this method behaves exactly as if it simply\n>\n> performs the call {@code `wait(0)`}.\n>\n> The current thread `must own this object's monitor.` The thread\n>\n> `releases` ownership of this monitor and waits until another thread\n>\n> notifies threads waiting on this object's monitor to wake up\n>\n> either through a call to the {@code notify} method or the\n>\n> {@code notifyAll} method. The thread then waits until it can\n>\n> re-obtain ownership of the monitor and resumes execution.\n\n**wait(long timeout)：**`wait()`的重载方法很容易想到是干啥的✔\n\n> Causes the current thread to wait until either another thread invokes the\n>\n> {@link java.lang.Object#notify()} method or the\n>\n> {@link java.lang.Object#notifyAll()} method for this object, or a\n>\n> `specified amount of time has elapsed.`\n>\n> The current thread must own this object's monitor.\n>\n> @throws  `IllegalArgumentException`  if the value of timeout is negative.\n\n**notify()：** 唤醒该`锁对象`的`等待队列`的线程，唤醒方法不同的虚拟机实现不同有的可能是`FCFS`有的可能是`SJF` 等等....所以唤醒的是那个线程是无法确定的\n\n> Wakes up a single thread that is `waiting on this object's`\n>\n> `monitor`. If any threads are waiting on this object, one of them\n>\n> is chosen to be awakened. `The choice is arbitrary and occurs at`\n>\n> `the discretion of the implementation`. A thread waits on an object's\n>\n> monitor by calling one of the {@code wait} methods.\n>\n> The awakened thread will not be able to proceed until the current\n>\n> thread `relinquishes` the lock on this object. The awakened thread will\n>\n> compete in the usual manner with any other threads that might be\n>\n> actively competing to synchronize on this object; for example, the\n>\n> awakened thread enjoys no reliable privilege or disadvantage in being\n>\n> the next thread to lock this object.\n\n生产者生产一个消费者消费一个，没毛病，但是上面的代码仅仅适用于`单生产者&消费者`对于多个生产者消费者就会有线程安全问题，具体问题如下\n\n**测试多消费者&生产者**\n\n沿用上面single p&c的代码，测试多消费者和生产者\n\n```java\n    public static void main(String[] args) {\n        ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();\n        Stream.of(\"Produce1\", \"Produce2\", \"Produce3\", \"Produce4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\", \"Consumer2\", \"Consumer3\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n```\n\n运行会发现程序进入`”死锁“`状态，用`jps&jstack`分析\n\n![mark](http://static.imlgw.top///20190328/pzXBY0ertEVV.png?imageslim)\n\n程序并没有发现死锁❎，这就是多生产者多消费者会产生的`假死`状态，实际上是所有的线程都进入了`wait()`状态都放弃了`CPU`的执行权\n\n**假死原因分析**\n\n```java\nProduce1-->1\tnotify C1 wait\nConsumer1-->1\tnotify P1 wait\nProduce1-->2    notify C2 wait\nConsumer2-->2   notify P2 wait\nProduce2-->3\tnotify P1 wait ---> Produce1-->wait\n```\n\n上面是其中一种情况，大致分析下：前两次生产消费都正常一个`消费者`唤醒一个`生产者`，前两次执行完之后`P1 C1 C2`都进入`wait`状态然后第三次生产的时候`P2`唤醒了一个不该唤醒的人😂 唤醒了`P1`然后`wait`了，`P1`醒来后发现已经生产了然后也`wait`去了，至此所有的线程全部进入`wait`状态就造成了假死。这个问题记得大一的时候还问过老师当时特别纠结为啥会死锁，现在看看其实也没啥，主要就是`notify`唤醒的线程是不确定的，是由`JVM`决定的每种`JDK`的实现也不太一样，无法保证消费者一定唤醒生产者，反之亦然。\n\n**多生产者&多消费者**\n\n```java\nimport java.util.stream.Stream;\npublic class ProduceConsumerVersion3 {\n    public static void main(String[] args) {\n        ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();\n        Stream.of(\"Produce1\", \"Produce2\", \"Produce3\", \"Produce4\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.produce();\n                }\n            }, n).start();\n        });\n        Stream.of(\"Consumer1\", \"Consumer2\", \"Consumer3\").forEach(n -> {\n            new Thread(() -> {\n                while (true) {\n                    pc.consumer();\n                }\n            }, n).start();\n        });\n    }\n\n    private int i = 0;\n\n    private final Object LOCK = new Object();\n\n    private volatile boolean isProduced = false;\n\n    public void produce() {\n        synchronized (LOCK) {\n            while (isProduced) {\n                //已经生产了\n                try {\n                    LOCK.wait(); //加入LOCK锁的wait队列\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (++i));//produce\n            isProduced = true;\n            LOCK.notifyAll();\n        }\n    }\n\n    public void consumer() {\n        synchronized (LOCK) {\n            while (!isProduced) {\n                try {\n                    LOCK.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName() + \"-->\" + (i));//consumer\n            isProduced = false;\n            LOCK.notifyAll();\n        }\n    }\n}\n```\n\n**notifyAll()：**唤醒当前锁对象等待队列上的`所有`线程\n\n> Wakes up `all threads` that are waiting on `this object's monitor`. A\n>\n> thread waits on an object's monitor by calling one of the\n>\n> {@code wait} methods.\n>\n> The awakened threads will not be able to proceed until the current\n>\n> thread relinquishes the lock on this object. The awakened threads\n>\n> will `compete in the usual manner` with any other threads that might\n>\n> be actively competing to synchronize on this object; for example,\n>\n> the awakened threads enjoy `no reliable privilege or disadvantage` in\n>\n> being the next thread to lock this object.\n\n① 为了解决上面的`假死`问题这里使用了`notifyAll()`来唤醒`等待队列`的线程，看名字就知道这个方法会唤醒所有的线程，那么上面的假死问题就自然解决了。\n\n② 还有一点不同的是这里判断生产状态时用的是`while`而不是`if`为什么不用`if`? 其实也很好理解如果有多个生产者或者消费者同时在`等待队列`中，然后其中一个抢到锁后执行，执行完生产后唤醒了所有等待的线程，假设唤醒的是`生产者`的话，因为是`if语句`控制的被唤醒的生产者抢到锁之后就直接顺着执行下去了，就直接去生产了，就会造成`重复的生产`当然用`else`语句貌似可以解决这个问题，但是那会影响效率（个人感觉），而且很别扭（被唤醒了直接退出？？？）. 所以这里用`while`来进行`二次检测`避免这种情况，这种while循环也被称为`自旋锁` 这一块后面的文章会再详细的讲。\n\n### 为什么wait和notify必须在同步方法或同步块中调用？ \n\n这是`阿里巴巴`的一道面试题\n\n① 首先从语法层面讲，如果不在同步方法和同步代码块中调用，也就是说没有加锁，自然就不用谈是不是`锁对象的持有者` ，就会报`IllegalMonitorStateException`.\n\n> @throws  `IllegalMonitorStateException`  if the current thread is not\n>\n> the owner of the object's monitor.\n\n②设想下如果不加锁可以直接调用，就会产生所谓的`竞态条件`，假设`wait()`,`notify()`,`notifyAll()`方法不需要加锁就能够被调用。此时消费者线程调用`wait()`正在进入状态变量的等待队列(译者注:可能还未进入)。在同一时刻，生产者线程调用`notify()`方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的`wait()`,`notify()`,`notifyAll()`方法必须在该对象的同步方法或同步代码块中被互斥地调用。\n\n> 计算的正确性取决于多个线程的交替执行时序时就会产生竞态条件\n\n### wait()后被唤醒会怎么样？\n\n上面说到被唤醒后会去抢锁，但是这里有人可能会有疑问，去抢锁会不会回到同步的起点去争抢锁，然后把wait前的逻辑再执行一遍？这里肯定事不会的，确实是要抢锁但是会有记录会继续顺着wait方法走下去。\n\n### notify和中断的一个很有意思的现象\n\n```java\npublic class NotifyInter {\n\n    volatile int a = 0;\n\n    public static void main(String[] args) {\n\n        Object object = new Object();\n\n        NotifyInter waitNotify = new NotifyInter();\n\n        Thread thread1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                synchronized (object) {\n                    System.out.println(\"线程1 获取到监视器锁\");\n                    try {\n                        object.wait();\n                        System.out.println(\"线程1 正常恢复啦。但是 isInterrupt = \"+ Thread.currentThread().isInterrupted());\n                    } catch (InterruptedException e) {\n                        System.out.println(\"线程1 wait方法抛出了InterruptedException异常\");\n                    }\n                }\n            }\n        }, \"线程1\");\n        thread1.start();\n\n        Thread thread2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                synchronized (object) {\n                    System.out.println(\"线程2 获取到监视器锁\");\n                    try {\n                        object.wait();\n                        System.out.println(\"线程2 正常恢复啦。\");\n                    } catch (InterruptedException e) {\n                        System.out.println(\"线程2 wait方法抛出了InterruptedException异常\");\n                    }\n                }\n            }\n        }, \"线程2\");\n        thread2.start();\n\n        // 这里让 thread1 和 thread2 先起来，然后再起后面的 thread3\n       try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n        }\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (object) {\n                    System.out.println(\"线程3 拿到了监视器锁。\");\n                    System.out.println(\"线程3 设置线程1中断\");\n                    thread1.interrupt(); // 1\n                    //waitNotify.a = 1; // 这行是为了禁止上下的两行中断和notify代码重排序\n                    System.out.println(\"线程3 调用notify\");\n                    object.notify(); //2\n                    System.out.println(\"线程3 调用完notify后，休息一会\");\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                    System.out.println(\"线程3 休息够了，结束同步代码块\");\n                }\n            }\n        }, \"线程3\").start();\n    }\n}\n```\n\n多执行几次可能就可能会发生如下情况，线程1被打断后居然正常的返回了！！！！线程2被阻塞住了\n\n```java\n线程1 获取到监视器锁\n线程2 获取到监视器锁\n线程3 拿到了监视器锁。\n线程3 设置线程1中断\n线程3 调用notify\n线程3 调用完notify后，休息一会\n线程3 休息够了，结束同步代码块\n线程1 正常恢复啦。但是 isInterrupt = true\n```\n\n其实这里主要问题就是 `notify()` 和`interrupt()` 执行顺序的问题\n\n- 如果先被打断，那么后续的notify会这个线程无效，依然会抛出异常，如果这是该锁实例上仍然有其他线程处于wait状态，那么这个notify会唤醒其中的一个，不能虚发，具体可以参考 [Java语言规范文档17.2.4](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4)\n\n  > The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption.\n  >\n  > If a thread is both notified and interrupted while waiting, it may either:\n  >\n  > - return normally from `wait`, while still having a pending interrupt (in other words, a call to `Thread.interrupted` would return true)\n  > - return from `wait` by throwing an `InterruptedException`\n  >\n  > The thread may not reset its interrupt status and return normally from the call to `wait`.\n  >\n  > Similarly, notifications cannot be lost due to interrupts. Assume that a set *s* of threads is in the wait set of an object *m*, and another thread performs a `notify` on *m*. Then either:\n  >\n  > - at least one thread in *s* must return normally from `wait`, or\n  > - all of the threads in *s* must exit `wait` by throwing `InterruptedException`\n  >\n  > Note that if a thread is both interrupted and woken via `notify`, and that thread returns from `wait` by throwing an `InterruptedException`, then some other thread in the wait set must be notified.\n\n- 如果先被notify()，那么线程会从wait中醒来，然后中断，设置中断标志位为 true，但不会在这个wait上抛出异常，而会影响后面的阻塞操作，具体可以看下面的Demo\n\n  ```java\n  public class NotifyInter {\n      volatile int a = 0;\n      public static void main(String[] args) {\n          Object object = new Object();\n          NotifyInter waitNotify = new NotifyInter();\n          Thread thread1 = new Thread(new Runnable() {\n              @Override\n              public void run() {\n                  synchronized (object) {\n                      System.out.println(\"线程1 获取到监视器锁\");\n                      try {\n                          object.wait();\n                          System.out.println(\"线程1 正常恢复啦。但是 isInterrupt = \"+ Thread.currentThread().isInterrupted());\n                      } catch (InterruptedException e) {\n                          System.out.println(\"线程1 wait方法抛出了InterruptedException异常\");\n                      }\n  \n                      try {\n                          TimeUnit.SECONDS.sleep(3);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                          System.out.println(\"在sleep中被中断\");\n                      }\n                  }\n              }\n          }, \"线程1\");\n          thread1.start();\n          // 这里让 thread1 和 thread2 先起来，然后再起后面的 thread3\n         try {\n              Thread.sleep(1000);\n          } catch (InterruptedException e) {\n          }\n  \n          new Thread(new Runnable() {\n              @Override\n              public void run() {\n                  synchronized (object) {\n                      System.out.println(\"线程3 拿到了监视器锁。\");\n                      System.out.println(\"线程3 设置线程1中断\");\n                      object.notify(); //2\n                      waitNotify.a = 1; // 这行是为了禁止上下的两行中断和notify代码重排序\n                      thread1.interrupt(); // 1\n                      System.out.println(\"线程3 调用notify\");\n                      System.out.println(\"线程3 调用完notify后，休息一会\");\n                      try {\n                          Thread.sleep(1000);\n                      } catch (InterruptedException e) {\n                      }\n                      System.out.println(\"线程3 休息够了，结束同步代码块\");\n                  }\n              }\n          }, \"线程3\").start();\n      }\n  }\n  ```\n\n### wait()和sleep()的区别\n\n这也是一道面试常问的题\n\n① 首先`sleep()`是线程Thread的静态方法，`wait()`是`Object`类的实例方法\n\n②`sleep()`不会释放锁对象，`wait()`会释放锁对象，这一点比较重要\n\n③ 承接第二点，`wait()`会释放锁，但是要是你没有锁呢？其实就是上面语法层面说到的，所以调用`wait()`必须要`持有`锁对象否则就会报`IllegalMonitorStateException`\n\n④`sleep()`不需要被唤醒`timeout`后会自动醒来，而`wait()`需要被其他线程唤醒（`wait(long time)`除外）\n\n### 线程通讯综合案例\n\n控制同一时间执行同一方法线程的数量\n\n```java\npublic class ControlThreadNum {\n\n    private static final LinkedList THREADS = new LinkedList<>();\n\n    private final static int MAX_THREAD = 5;\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        List<Thread> worker = new ArrayList();\n        //创建了十个线程，但是控制每次最多同时运行的只有5个\n        Arrays.asList(\"M1\", \"M2\", \"M3\", \"M4\", \"M5\", \"M6\", \"M7\", \"M8\", \"M9\", \"M10\").stream().map(ControlThreadNum::captureThread).forEach(t -> {\n            t.start();\n            worker.add(t);\n        });\n        //main线程等待worker的线程都执行完\n        worker.stream().forEach(thread -> {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        Optional.of(\"All capture is done\").ifPresent(System.out::println);\n        Optional.of(System.currentTimeMillis() - start).ifPresent(System.out::println);\n    }\n\n    private static Thread captureThread(String name) {\n        return new Thread(() -> {\n            Optional.of(\"Thread \" + Thread.currentThread().getName() + \"  is begin\").ifPresent(System.out::println);\n            synchronized (THREADS) {\n                while (THREADS.size() >= MAX_THREAD) {\n                    try {\n                        THREADS.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //THREADS 只是用来控制数量&锁 元素是什么并不重要\n                THREADS.addLast(1);\n            }\n            //到这里是并行\n            Optional.of(\"Thread \" + Thread.currentThread().getName() + \"  is running\").ifPresent(System.out::println);\n            try {\n                Thread.sleep(10000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            synchronized (THREADS) {\n                Optional.of(\"Thread \" + Thread.currentThread().getName() + \"  is end\").ifPresent(System.out::println);\n                THREADS.removeLast();\n                THREADS.notifyAll();\n            }\n        }, name);\n    }\n}\n```\n\n这里一开始一共创建了10个线程，但是执行的时候会控制`running`的个数小于5个，`runnning`线程个数用一个`LinkList`记录，若`size()>=5`就进入`wait`然后如果有线程`end`就会`notifyAll`唤醒进入等待状态的线程。\n\n```java\nThread M2  is begin\nThread M3  is begin\nThread M2  is running\nThread M1  is begin\nThread M1  is running\nThread M3  is running\nThread M4  is begin\nThread M4  is running\nThread M5  is begin\nThread M6  is begin\nThread M5  is running\nThread M7  is begin\nThread M8  is begin\nThread M9  is begin\nThread M10  is begin\nThread M3  is `end`\nThread M10  is running\nThread M5  is `end`\nThread M1  is `end`\nThread M2  is `end`\nThread M4  is `end`\nThread M6  is running\nThread M7  is running\nThread M9  is running\nThread M8  is running\nThread M10  is end\nThread M8  is end\nThread M9  is end\nThread M7  is end\nThread M6  is end\nAll capture is done\n20124\n```\n\n这样就是其实就是为了提高效率，线程并不是越多越好，线程创建太多，就会达到瓶颈，效率反而会降低，因为时间都消耗在了`线程切换`上了，当然这是在没有`线程池`的情况下，后面用`线程池`就不会这么麻烦了。\n\n### wait()/notify的开销及问题\n\n**过早唤醒** \n\n 比如生产者消费者问题中生产者生产后唤醒了生产者，其实就是过早唤醒了，过早唤醒使得那些本来无须被唤醒的等待线程也被唤醒了，从而造成资源浪费。这就好比你在人群里大喊一声“美女”，便会有许多自我感觉良好的女性回头一样——尽管你要喊的仅仅是其中某一个人，但大家却都以为你是在喊自己。过早唤醒问题可以利用JDK\n1.5引入的`java.util.concurrent.locks.Condition`接口来解决，后面的文章会讲到。\n\n**信号丢失**\n\n信号丢失（Missed Signal）问题。如果等待线程在执行`Object.wait()`前没有先判断保护条件是否已然成立，那么有可能出现这种情形——通知线程在该等待线程进人临界区之前就已经更新了相关共享变量，使得相应的保护条件成立并进行了通知，但是此时等待线程还没有被暂停，自然也就无所谓唤醒了。这就可能造成等待线程直接执行`Object.wait()`而被暂停的时候，该线程由于没有其他线程进行通知而一直处于等待状态。这种现象就相当于等待线程错过了一个本来“发送”给它的“信号”，因此被称为信号丢失（Missed Signal）。只要将对保护条件的判断和`Object.wait()`调用放在一个循环语句之中就可以避免上述场景的信号丢失。信号丢失的另外一个表现是在应该调用`Object.notifyAll()` 的地方却调用了`Object.notify()`。比如，对于使用同一个保护条件的多个等待线程，如果通知线程在侦测到这个保护条件成立后调用的是`Object.notify()`，那么这些等待线程最多只有一个线程能够被唤醒，甚至一个也没有被唤醒——被唤醒的线程是`Object.notify()`所属对象上使用其他保护条件的一个等待线程！也就是说，尽管通知线程在调用`Object.notify()`前可能考虑（判断）了某个特定的保护条件是否成立，但是`Object.notify()`本身在其唤醒线程时是不考虑任何保护条件的！这就可能使得通知线程执行`Object.notify()`进行的通知对于使用相应保护条件的等待线程来说丢失了。这种情形下，避免信号丢失的一个方法是在必要的时候使用`Object.notifyAll()`来通知。总的来说，信号丢失本质上是一种代码错误，而不是Java标准库API自身的问题。\n\n**欺骗性唤醒**\n\n由于莫名其妙的原因，线程有可能在没有调用过`notify()`和`notifyAll()`的情况下醒来。这就是所谓的假唤醒（spurious wakeups），无端端地醒过来了，然而此时可能保护条件并没有成立。这个问题的解决同样是讲 保护条件和wait放在临界区内同一个循环体内就可以了。\n\n**上下文切换**\n\n​\t首先，等待线程执行`Object.wait()`至少会导致该线程对相应对象内部锁的两次申请与释放。通知线程在执行`Object.notify()/notifyAll()`时需要持有相应对象的内部锁，因此`Object.notify()/notifyAll()`调用会导致一次锁的申请。而锁的申请与释放可能导致上下文切换。\n\n​\t其次，等待线程从被暂停到唤醒这个过程本身就会导致上下文切换。\n\n​\t再次，被唤醒的等待线程在继续运行时需要再次申请相应对象的内部锁，此时等待线程可能需要和相应对象的入口集中的其他线程以及其他新来的活跃线程（即申请相应的内部锁且处于RUNNABLE状态的线程）争用相应的内部锁，而这又可能导致上下文切换。\n最后，过早唤醒问题也会导致额外的上下文切换，这是因为被过早唤醒的线程仍然需要继续等待，即再次经历被暂停和唤醒的过程。\n\n[更多参考](http://ifeve.com/thread-signaling/)\n\n## 13.手写一个BooleanLock\n\n`Synchronized`的缺点其实很明显，当多个线程竞争锁的时候，当一个线程抢到锁后其他的线程只能傻傻的等着，这样会影响效率，所以这里可以自己简单手写一个限制等待时间的锁。\n\n### LOCK接口\n\n```java\npublic interface Lock {\n\n    class TimeOutException extends Exception {\n        public TimeOutException(String message) {\n            super(message);\n        }\n    }\n\n    void lock() throws InterruptedException;\n\n    void lock(long time) throws InterruptedException,TimeOutException;\n\n    void unLock() throws InterruptedException;\n\n    Collection<Thread> getBlockThread();\n}\n```\n\n定义了一个`TimeOutException`\n\n### BooleanLock实现类\n\n```java\npublic class BooleanLock implements Lock {\n\n    //false indicated free\n    private boolean initValue;\n    //加锁的线程\n    private Thread lockedThread;\n\n    private Collection<Thread> blockThreadCollection = new ArrayList<>();\n\n    public BooleanLock() {\n        this.initValue = false;\n    }\n\n    @Override\n    public synchronized void lock() throws InterruptedException {\n        while (initValue) {\n            blockThreadCollection.add(Thread.currentThread());\n            System.out.println(Thread.currentThread().getName() + \" is wait\");\n            this.wait();\n        }\n        blockThreadCollection.remove(Thread.currentThread());\n        this.initValue = true;\n        this.lockedThread = Thread.currentThread();\n    }\n\n    @Override\n    public synchronized void lock(long time) throws InterruptedException, TimeOutException {\n        if (time <= 0) lock();\n        long remainTime=time;\n        long endTime=System.currentTimeMillis()+time;\n        while (initValue){\n            if(remainTime<=0){\n                throw new TimeOutException(\"time is out\");\n            }\n            blockThreadCollection.add(Thread.currentThread());\n            this.wait(time);\n            remainTime=endTime-System.currentTimeMillis();\n        }\n        this.initValue=true;\n        this.lockedThread=Thread.currentThread();\n        blockThreadCollection.remove(Thread.currentThread());\n    }\n\n    @Override\n    public synchronized void unLock() {\n        //判断是不是加锁的线程\n        if (lockedThread == Thread.currentThread()) {\n            this.initValue = false;\n            this.notifyAll();\n            Optional.of(Thread.currentThread().getName() + \"  release the lock monitor\").ifPresent(System.out::println);\n        }\n    }\n\n    @Override\n    public Collection<Thread> getBlockThread() {\n        return Collections.unmodifiableCollection(blockThreadCollection);\n    }\n}\n```\n\n### 测试BooleanLock的效果\n\n```java\npublic class LockTest {\n    public static void main(String[] args) {\n        final BooleanLock booleanLock = new BooleanLock();\n        Stream.of(\"t0\", \"t1\", \"t2\").forEach(name -> {\n            new Thread(() -> {\n                try {\n                    booleanLock.lock(10);\n                    Optional.of(Thread.currentThread().getName() + \" get the lock\").ifPresent(System.out::println);\n                    doSomething();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (Lock.TimeOutException e) {\n                    System.out.println(Thread.currentThread().getName()+\" Time out\");\n                    e.printStackTrace();\n                } finally {\n                    booleanLock.unLock();\n                }\n            }, name).start();\n        });\n        //main线程释放锁，不应该，谁加的锁应该由谁去释放锁\n        //booleanLock.unLock();\n    }\n\n    private static void doSomething() {\n        Optional.of(Thread.currentThread().getName() + \" is working...\").ifPresent(System.out::println);\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n这里设置在抢不到锁的时候，只等待`10ms`，然后`doSomething`会`sleep`5000ms，所以只有一个线程可以抢到锁后面的都会超时 throw `TimeOutException`典型的`限时等待`模型\n\n```java\nt0 get the lock\nt0 is working...\n`base_thread_study.chaper10.Lock$TimeOutException: time is out`\n\tat base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:41)\n\tat base_thread_study.chaper10.LockTest.lambda$null$0(LockTest.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\n`base_thread_study.chaper10.Lock$TimeOutException: time is out`\n\tat base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:41)\n\tat base_thread_study.chaper10.LockTest.lambda$null$0(LockTest.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\nt2 Time out\nt1 Time out\nt0  release the lock monitor\n```\n\n## 14.给应用程序注入钩子Hook\n\n关于`Hook`是什么就不多介绍了，这里的钩子和`git`,`svn`里面的是一样的，类似的在使用`Tomcat`等服务的时候，在你关闭它之后它仍然会打印日志和释放一些资源，这就是`Hook`的一种，当然`Hook`有多种，这只是其中一种。\n\n```java\npublic class ExitCap{\n\tpublic static void main(String []arg){\n\tint i=0;\n\tRuntime.getRuntime().addShutdownHook(new Thread(()->{\n   \t    System.out.println(\"The test app will shutdown\");\n\t    notifyAndRelease();\n\t}));\n\twhile(true){\n\t\ttry{\n\t\tThread.sleep(1000);\n\t\tSystem.out.println(\"i am working\");\n\t\t}catch(Exception e){\n\t\t //donothing\n\t\t}\n\t\tif(i>10){\n\t\t   throw new RuntimeException();\n\t\t}\n\t\ti++;    \n\t}\n    }\n\n    public static void notifyAndRelease(){\n\tSystem.out.println(\"notify to admin\");\n    \t\n\ttry{\n\tThread.sleep(1000);\n\t}catch(Exception e){}\n\t\n\tSystem.out.println(\"release the resources(socker. file, connection.)\");\n\t\n\ttry{\n        Thread.sleep(1000);\n        }catch(Exception e){}\n\t\n\tSystem.out.println(\"release and notify done\");\n    }\n}\n\n```\n\n这里是在`Linux`上进行的测试，因为效果比较明显，顺便也熟悉下`Linux`的命令，可以看到上面的钩子就是通过`Runtime.getRuntime().addShutdownHook()`注入了一个`Thread`进去的，这样就会检测到程序的退出并触发`Hook`做一些释放资源之类的工作。\n\n```java\ni am working\ni am working\ni am working\ni am working\ni am working\ni am working\ni am working\ni am working\ni am working\ni am working\ni am working\nException in thread \"main\" java.lang.RuntimeException\n\tat base_thread_study.chaper10.ExitCap.main(ExitCap.java:18)\ni am working\n`The test app will shutdown`\n`notify to admin`\n`release the resources(socker. file, connection.)`\n`release and notify done`\n```\n\n上面是在正常情况下终止线程比如 `异常`，`ctrl C`或者 `kill pid`如果使用 `kill -9 pid`就不会触发钩子，强制停止，所以一般不建议用`kill -9`\n\n## 15.捕获线程的Runtime异常\n\n在Java多线程环境下，所有线程都不允许抛出未捕获的`checked exception`(比如sleep的InterruptException)，也就是各个线程必须自己把自己的`checked exception`处理掉，但是如果是`unchecked exception `呢？主要就是指`RuntimeException`此类异常抛出时该线程会`shutdown`但是其它线程不受影响也无法感知到这个异常，就像下面的例子\n\n```java\npublic class ThreadException {\n    public static void main(String[] args) {\n        Thread thread = null;\n        try {\n            thread=new Thread(()->{\n                int res=1/0;\n            });\n            thread.start();\n        }catch (Exception e){\n            System.out.println(\"捕获到异常\");\n        }\n    }\n}\n```\n\n控制台输出`main线程`并没有捕获到异常，其实这也是一种很好的理念，每个线程的事情应该由线程自己去处理不应该由其他线程去干扰，正如`stop/resume/suspend`这些方法被弃用的原因。但是这些异常如果不去处理可能会导致一些严重的后果，JDK1.5之后官方也提供了API去处理线程的异常。setDefaultUncaughtExceptionHandler()和setUncaughtExceptionHandler()前者是`Thread`的静态方法，用于给所有的线程设置默认的异常处理，后者是实例方法，针对每个线程会给每个线程加上一个异常处理器，如下Demo\n\n```java\npublic class ThreadException {\n    private static int A = 10;\n    private static int B = 0;\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n              int res = A / B;\n            }\n        );\n        //最好在start前设置异常处理器，放在后面可能会起不到作用。\n        thread.setUncaughtExceptionHandler((t, e) -> {\n            System.out.println(t.getName());\n            System.out.println(e);\n        });\n        thread.start();\n    }\n}\n```\n\n> `Thread-0`\n> `java.lang.ArithmeticException: / by zero`\n\n可以看到已经捕获到了这个异常，当线程遇到未捕获的异常而结束时会调用`UncaughtExceptionHandler` 处理一些\"后事\"和释放一些宝贵的资源，`setUncaughtExceptionHandler`建议放在线程start之前，不然可能起不到作用。\n\n## 16.ThreadGroup线程组\n\n### 获取线程组信息\n\n```java\npublic class ThreadGroupAPI {\n    public static void main(String[] args) {\n        ThreadGroup tgp = new ThreadGroup(\"TGP1\");\n        Thread t = new Thread(tgp, \"t0\") {\n            @Override\n            public void run() {\n                while (true) {\n                    try {\n                        System.out.println(getThreadGroup().getName());\n                        System.out.println(getThreadGroup().getParent());\n                        //可以访问，文档上说不行\n                        System.out.println(getThreadGroup().getParent().activeCount());\n                        Thread.sleep(10000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        };\n        t.start();\n\n        ThreadGroup tgp2 = new ThreadGroup(\"TGP2\");\n        Thread t1 = new Thread(tgp2, \"t0\") {\n            @Override\n            public void run() {\n                System.out.println(tgp.getName());\n                System.out.println(tgp.activeCount());\n                Thread[] threads=new Thread[tgp.activeCount()];\n                tgp.enumerate(threads);\n                //也可以访问\n                Arrays.asList(threads).forEach(System.out::println);\n            }\n        };\n        t1.start();\n        //System.out.println(tgp2.getName());\n        //System.out.println(tgp2.getParent().getName());\n    }\n}\n```\n\n文档上说的不能访问其他线程组的信息，这里测试的几个都可以，可能描述有点问题，`线程组`的创建类似于`线程`的创建，如果没有显示的指定线程组都会默认加到父线程的线程组中。\n\n### 打断线程组interrupt()\n\n> Interrupts all threads in this thread group.\n>\n> First, the <code>checkAccess</code> method of this thread group is\n>\n> called with no arguments; this may result in a security exception.\n>\n> This method then calls the <code>interrupt</code> method on all the\n>\n> threads in this thread group and in `all of its subgroups.`\n\n打断该线程组里面所有的线程，包括子线程组的线程。\n\n### 线程组setDaemon()\n\n和线程的`setDaemon`不一样。\n\n> Changes the daemon status of this thread group.\n>\n> First, the <code>checkAccess</code> method of this thread group is\n>\n> called with no arguments; this may result in a security exception.\n>\n> A daemon thread group is `automatically` `destroyed` when its last\n>\n> thread is stopped or its `last thread group is destroyed`.\n\n当最后一个线程执行完毕后自动销毁线程组，当然与其对应的也有手动销毁的方法`destroy()`这个方法如果线程没执行完毕就调用会抛`IllegalThreadStateException`，其他的方法详细可以参考文档。\n\n## 17.线程池\n\n### 为什么要使用线程池\n\n 创建和销毁线程开销大，利用好线程池可以避免cpu花费不必要的时间在这上面，从而专注于具体的任务:)\n\n基本的线程池包括下面几部分：\n\n①任务队列\n\n②拒绝策略(抛出异常，直接丢弃，阻塞，临时队列)\n\n③`init`(`min`)初始大小\n\n④`active`中间常态大小\n\n⑤`max`最大个数，超过就会加到任务队列中，任务队列也满就会执行拒绝策略\n\n> min<=active<=max\n\n### 手写线程池\n\n#### 临时队列\n\n```java\npublic class SimpleThreadPool {\n    //线程池大小\n    private final int size;\n    //默认大小\n    private final static int DEFAULT_SIZE = 10;\n\t//任务队列\n    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();\n\t//线程序号\n    private static volatile int seq = 0;\n\t//线程组\n    private final static ThreadGroup GROUP = new ThreadGroup(\"Pool_Group\");\n\t//线程前缀名\n    private final static String THREAD_PREFIX = \"SIMPLE_THREAD_POOL-\";\n\t//线程队列\n    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();\n\n    public SimpleThreadPool(int size) {\n        this.size = size;\n        init();\n    }\n\n    public SimpleThreadPool() {\n        this(DEFAULT_SIZE);\n    }\n\n    private void init() {\n        for (int i = 0; i < size; i++) {\n            createThreadQueue();\n        }\n    }\n\t\n    //暴露对外的接口，提交任务队列\n    public void submit(Runnable runnable) {\n        synchronized (TASK_QUEUE) {\n            TASK_QUEUE.addLast(runnable);\n            //唤醒线程池中的线程\n            TASK_QUEUE.notifyAll();\n        }\n    }\n\n    private void createThreadQueue() {\n        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));\n        thread.start();\n        THREAD_QUEUE.add(thread);\n    }\n\n    private enum ThreadState {\n        FREE, RUNNING, BLOCKED, DEAD\n    }\n\t\n    //包装的线程类\n    private static class MyThread extends Thread {\n        private volatile ThreadState threadState = ThreadState.FREE;\n\n        public ThreadState getThreadState() {\n            return this.threadState;\n        }\n\n        public MyThread(ThreadGroup group, String name) {\n            super(group, name);\n        }\n\n        @Override\n        public void run() {\n            OUTER:\n            while (this.threadState != ThreadState.DEAD) {\n                //当前线程没有dead\n                Runnable runnable;\n                synchronized (TASK_QUEUE) {\n                    while (TASK_QUEUE.isEmpty()) {\n                        //任务队列为空，全员wait\n                        try {\n                            this.threadState = ThreadState.BLOCKED;\n                            TASK_QUEUE.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(\"break\");\n                            break OUTER;\n                        }\n                    }\n                    runnable = TASK_QUEUE.removeFirst();\n                }\n                //这里应该并行\n                Optional.of(runnable).ifPresent(t -> {\n                    this.threadState = ThreadState.RUNNING;\n                    t.run();\n                    this.threadState = ThreadState.FREE;\n                });\n            }\n        }\n\n        public void close() {\n            this.threadState = ThreadState.DEAD;\n        }\n    }\n}\n```\n\n最开始实现的时候`synchronized`的范围太大，将具体的执行`run`的过程也同步了起来，这明显是有问题的，只需要同步共享变量就可以了，同步了后面的代码那就跟单线程一样了。\n\n#### 关闭线程池&拒绝策略\n\n```java\npublic class SimpleThreadPool {\n    //线程池大小\n    private final int size;\n\t//任务队列大小\n    private final int queueSize;\n\t//默认线程池大小\n    private final static int DEFAULT_SIZE = 10;\n\t//线程池中线程编号\n    private static volatile int seq = 0;\n\t//默认任务队列的大小\n    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;\n\t//线程组\n    private final static ThreadGroup GROUP = new ThreadGroup(\"Pool_Group\");\n\t//线程名前缀\n    private final static String THREAD_PREFIX = \"SIMPLE_THREAD_POOL-\";\n\t//任务队列\n    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();\n\t//线程队列\n    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();\n\t//拒绝策略\n    private final DiscardPolicy discardPolicy;\n\t//线程次是否销毁\n    private volatile boolean destroy = false;\n\t//默认的拒绝策略（抛异常）\n    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {\n        throw new DiscardException(\"Discard this Task!!!!(Default Policy)\");\n    };\n    public SimpleThreadPool(int size, int queueSize, DiscardPolicy discardPolicy) {\n        this.size = size;\n        this.queueSize = queueSize;\n        this.discardPolicy = discardPolicy;\n        init();\n    }\n\n    public SimpleThreadPool() {\n        this(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);\n    }\n\n    private void init() {\n        for (int i = 0; i < size; i++) {\n            createThreadQueue();\n        }\n    }\n\n    public void submit(Runnable runnable) {\n        if (destroy) {\n            throw new IllegalStateException(\"The Pool is shutdown , you can't submit now ! !\");\n        }\n        synchronized (TASK_QUEUE) {\n            if (TASK_QUEUE.size() > queueSize) {\n                discardPolicy.discard();\n            }\n            TASK_QUEUE.addLast(runnable);\n            //唤醒线程池中的线程\n            TASK_QUEUE.notifyAll();\n        }\n    }\n\n    public void shutdown() throws InterruptedException {\n        //判断任务队列是否为空\n        while (!TASK_QUEUE.isEmpty()) {\n            Thread.sleep(50);\n        }\n        int initVal = THREAD_QUEUE.size();\n        while (initVal > 0) {\n            for (MyThread thread : THREAD_QUEUE) {\n                if (thread.getThreadState() == ThreadState.BLOCKED) {\n                    thread.close();\n                    thread.interrupt();\n                    initVal--;\n                } else {\n                    Thread.sleep(10);\n                }\n            }\n        }\n        this.destroy = true;\n        System.out.println(\"My Thread pool is shutdown\");\n    }\n\n    public boolean isDestroy() {\n        return this.destroy;\n    }\n\n    private void createThreadQueue() {\n        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));\n        thread.start();\n        THREAD_QUEUE.add(thread);\n    }\n\n\n    private enum ThreadState {\n        FREE, RUNNING, BLOCKED, DEAD\n    }\n\n    public static class DiscardException extends RuntimeException {\n        public DiscardException(String message) {\n            super(message);\n        }\n    }\n\n    @FunctionalInterface\n    public interface DiscardPolicy {\n        void discard() throws DiscardException;\n    }\n\n    private static class MyThread extends Thread {\n        private volatile ThreadState threadState = ThreadState.FREE;\n\n        public ThreadState getThreadState() {\n            return this.threadState;\n        }\n\n        public MyThread(ThreadGroup group, String name) {\n            super(group, name);\n        }\n\n        @Override\n        public void run() {\n            OUTER:\n            while (this.threadState != ThreadState.DEAD) {\n                Runnable runnable;\n                synchronized (TASK_QUEUE) {\n                    while (TASK_QUEUE.isEmpty()) {\n                        try {\n                            this.threadState = ThreadState.BLOCKED;\n                            TASK_QUEUE.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(Thread.currentThread().getName() + \" is dead\");\n                            break OUTER;\n                        }\n                    }\n                    runnable = TASK_QUEUE.removeFirst();\n                }\n                Optional.of(runnable).ifPresent(t -> {\n                    this.threadState = ThreadState.RUNNING;\n                    t.run();\n                    this.threadState = ThreadState.FREE;\n                });\n            }\n        }\n\n        private void close() {\n            this.threadState = ThreadState.DEAD;\n        }\n    }\n}\n\n```\n\n- `shutdown`方法实现\n\n①先轮询任务队列是否为空，不为空就会让`当前线程`等待`线程队列`的线程执行完所有任务。\n\n②当任务队列为空时，遍历`线程队列`，然后打断`BLOCK`的线程并且设置为`DEAD`状态跳出循环，因为`任务队列`为空`线程队列`里面的线程都会在`TASK_QUEUE`上面`BLOCK`住，但是也存在特殊情况，可能某个线程刚拿到最后一个任务，这种情况我们可以稍微等一下，等它`BLOCK`，毕竟这是个`lg(N)-lg(N2)`的方法\n\n③设置`destory`状态为true，然后在`submit`的时候会根据这个变量来判断是否已经销毁，如果已经销毁就会抛出一个`RunntimeException`\n\n- `拒绝策略`实现\n\n这里实现了一个·默认的拒绝策略，抛出异常，在submit的时候判断任务队列是不是满的，如果满了就直接抛异常，这里如果用这种方式拒绝，一但出现异常`当前线程`就会`直接结束`可能就无法关闭连接池。\n\n#### 自动扩容&闲时回收\n\n```java\npublic class SimpleThreadPool extends Thread {\n    //线程池大小\n    private int size;\n    //线程大小变化值\n    private int min;\n    private int active;\n    private int max;\n    //默认值\n    private final static int MIN = 4;\n    private final static int ACTIVE = 8;\n    private final static int MAX = 12;\n    //任务队列大小\n    private final int queueSize;\n\n    public int getMin() {\n        return min;\n    }\n\n    public int getActive() {\n        return active;\n    }\n\n    public int getMax() {\n        return max;\n    }\n\n    //线程池中线程编号\n    private static volatile int seq = 0;\n    //默认任务队列的大小\n    private final static int DEFAULT_TASK_QUEUE_SIZE = 2000;\n\n    //线程组\n    private final static ThreadGroup GROUP = new ThreadGroup(\"Pool_Group\");\n    //线程名前缀\n    private final static String THREAD_PREFIX = \"SIMPLE_THREAD_POOL-\";\n    //任务队列\n    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();\n    //线程队列\n    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();\n    //拒绝策略\n    private final DiscardPolicy discardPolicy;\n    //线程池是否销毁\n    private volatile boolean destroy = false;\n    //默认的拒绝策略（抛异常）\n    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {\n        throw new DiscardException(\"Discard this Task!!!!(Default Policy)\");\n    };\n\n    public SimpleThreadPool(int min, int active, int max, int queueSize, DiscardPolicy discardPolicy) {\n        this.queueSize = queueSize;\n        this.discardPolicy = discardPolicy;\n        this.min = min;\n        this.active = active;\n        this.max = max;\n        init();\n    }\n\n    public SimpleThreadPool() {\n        this(MIN, ACTIVE, MAX, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);\n    }\n\n    //线程池的线程，维护整个线程\n    @Override\n    public void run() {\n        while (!destroy) {\n            System.err.printf(\"Pool#min:%d,active:%d,max:%d,currentSize:%d,taskRemain:%d\\n\",\n                    this.min, this.active, this.max, this.size, TASK_QUEUE.size());\n            try {\n                Thread.sleep(5000);\n                if (TASK_QUEUE.size() > active && size < active) {\n                    for (int i = size; i < active; i++) {\n                        createThreadQueue();\n                    }\n                    System.out.println(\"increment to active success\");\n                    this.size = active;\n                } else if (TASK_QUEUE.size() > max && size < MAX) {\n                    for (int i = size; i < max; i++) {\n                        createThreadQueue();\n                    }\n                    System.out.println(\"increment to max success\");\n                    this.size = max;\n                }\n                if (TASK_QUEUE.isEmpty() && size > active) {\n                    System.out.println(\"==================reduce=================\");\n                    //防止并发修改，在shutdown的时候reduce\n                    synchronized (THREAD_QUEUE) {\n                        int release = size - active;\n                        //Itertor可以在遍历的过程中remove\n                        for (Iterator<MyThread> it = THREAD_QUEUE.iterator(); it.hasNext(); ) {\n                            if (release <= 0)\n                                break;\n                            MyThread mt = it.next();\n                            //如果该线程在工作就不要打断它\n                            if(mt.getThreadState()==ThreadState.RUNNING){\n                                continue;\n                            }\n                            mt.close();\n                            mt.interrupt();\n                            it.remove();\n                            release--;\n                        }\n                        this.size = active;\n                    }\n\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void init() {\n        /*    for (int i = 0; i < size; i++) {\n            createThreadQueue();\n        }*/\n        for (int i = 0; i < this.min; i++) {\n            createThreadQueue();\n        }\n        this.size = min;\n        this.start();\n    }\n\n    public void submit(Runnable runnable) {\n        if (destroy) {\n            throw new IllegalStateException(\"The Pool is shutdown , you can't submit now ! !\");\n        }\n        synchronized (TASK_QUEUE) {\n            if (TASK_QUEUE.size() > queueSize) {\n                discardPolicy.discard();\n            }\n            TASK_QUEUE.addLast(runnable);\n            //唤醒线程池中的线程\n            TASK_QUEUE.notifyAll();\n        }\n    }\n\n    public void shutdown() throws InterruptedException {\n        while (!TASK_QUEUE.isEmpty()) {\n            Thread.sleep(50);\n        }\n        int initVal = THREAD_QUEUE.size();\n        synchronized (THREAD_QUEUE) {\n            while (initVal > 0) {\n                for (MyThread thread : THREAD_QUEUE) {\n                    if (thread.getThreadState() == ThreadState.BLOCKED) {\n                        //设置为DEAD状态\n                        thread.close();\n                        thread.interrupt();\n                        initVal--;\n                    } else {\n                        Thread.sleep(10);\n                    }\n                }\n            }\n        }\n        this.destroy = true;\n        System.out.println(\"My Thread pool is shutdown\");\n    }\n\n    public boolean isDestroy() {\n        return this.destroy;\n    }\n\n    private void createThreadQueue() {\n        MyThread thread = new MyThread(GROUP, THREAD_PREFIX + (seq++));\n        thread.start();\n        THREAD_QUEUE.add(thread);\n    }\n\n\n    private enum ThreadState {\n        FREE, RUNNING, BLOCKED, DEAD\n    }\n\n    public static class DiscardException extends RuntimeException {\n        public DiscardException(String message) {\n            super(message);\n        }\n    }\n\n    @FunctionalInterface\n    public interface DiscardPolicy {\n        void discard() throws DiscardException;\n    }\n\n    private static class MyThread extends Thread {\n        private volatile ThreadState threadState = ThreadState.FREE;\n\n        public ThreadState getThreadState() {\n            return this.threadState;\n        }\n\n        public MyThread(ThreadGroup group, String name) {\n            super(group, name);\n        }\n\n        @Override\n        public void run() {\n            OUTER:\n            while (this.threadState != ThreadState.DEAD) {\n                Runnable runnable;\n                synchronized (TASK_QUEUE) {\n                    while (TASK_QUEUE.isEmpty()) {\n                        try {\n                            this.threadState = ThreadState.BLOCKED;\n                            TASK_QUEUE.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(Thread.currentThread().getName() + \" is dead\");\n                            break OUTER;\n                        }\n                    }\n                    runnable = TASK_QUEUE.removeFirst();\n                }\n                Optional.of(runnable).ifPresent(t -> {\n                    this.threadState = ThreadState.RUNNING;\n                    t.run();\n                    this.threadState = ThreadState.FREE;\n                });\n            }\n        }\n\n        private void close() {\n            this.threadState = ThreadState.DEAD;\n        }\n    }\n}\n```\n\n相比上面固定的size这个版本\n\n① 增加了三个字段用于动态的扩容，因为需要管理这些线程，所以将整个线程池也继承了`Thread`并实现了run方法，主要就是判断`TASK_QUEUE.size() > active && size < active`当前任务队列任务多于`active`并且当前线程队列线程数小于`active`，就可以扩容到active，max同理\n\n②`TASK_QUEUE.isEmpty() && size > active` 闲时回收，任务队列没有任务，但是线程队列线程还很多，浪费了资源，所以需要`reduce`一些空闲的线程。这里有两个小细节，1.在reduce和shutdown的时候需要同步`线程队列`不然在`reduce`的时候`shutdown`会产生`并发修改异常`（一个在遍历，一个在remove）。\n\n### 测试线程池\n\n```java\npublic class ThreadPoolTest {\n    public static void main(String[] args) throws InterruptedException {\n        SimpleThreadPool threadPool= new SimpleThreadPool();\n        IntStream.rangeClosed(0, 40)\n                .forEach(i -> {\n                    threadPool.submit(() -> {\n                        System.out.println(\"The task \" + i + \"  runnable by thread \" + Thread.currentThread().getName() + \" start\");\n                        try {\n                            Thread.sleep(5000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"The task \" + i + \"  runnable by thread \" + Thread.currentThread().getName() + \" end\");\n                    });\n                    System.out.println(\"submit \" + i);\n                });\n        threadPool.shutdown();\n    }\n}\n```\n\n## 参考资料\n\n- 《Java多线程编程实战指南》 \n- [并发编程网](http://ifeve.com)\n- [Java语言规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4)\n\n","tags":["多线程","并发编程"],"categories":["并发"]},{"title":"LeetCode链表","url":"/2019/02/27/leetcode-lian-biao/","content":"\n> 链表专题是最开始学算法的时候写的，很多代码都写得很烂，目前正在慢慢的重写，u1s1链表的题还是很考验细心的，稍不注意就连错了\n\n##  [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers)\n\n给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。\n 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n\n输出：7 -> 0 -> 8\n\n原因：342 + 465 = 807\n\n**解法一**\n\n```java\n//比较推荐的写法，简洁一点，在lc上提交区别不大\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyNode=new ListNode(-1);\n    ListNode temp=dummyNode;\n    dummyNode.next=temp;\n    int carry=0;\n    while(l1!=null || l2!=null){\n        int sum= (l1!=null?l1.val:0) + (l2!=null?l2.val:0)+ carry;\n        temp.next=new ListNode(sum%10);\n        temp=temp.next;\n        carry=sum/10;\n        l1=l1!=null?l1.next:null;\n        l2=l2!=null?l2.next:null;\n    }\n    if(carry!=0) temp.next=new ListNode(1);\n    return dummyNode.next;\n}\n```\n~~很久之前写的代码了，代码很乱，用0补齐短的那个然后对应相加注意进位就行了~~\n\n2020.3.22 把之前的代码删了，一年前的代码，写的太丑了\n\n**解法二**\n\n2020.3.22 新增了一个解法，有点偏，没啥意思，不过熟悉下链表还是可以\n\n```java\n//这个解法有点偏了,为了不new节点直接在原链表上修改的\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=l1;\n    int carry=0;\n    ListNode last=l1;\n    while(l1!=null && l2!=null){\n        int sum= l1.val + l2.val+ carry;\n        l1.val=sum%10;\n        carry=sum/10;\n        last=l1;\n        l1=l1.next;\n        l2=l2.next;\n    }\n    while(l1!=null && carry!=0){\n        int sum = l1.val + carry;\n        l1.val=sum%10;\n        carry=sum/10;\n        last=l1;\n        l1=l1.next;\n    }\n    if(l2!=null){\n        last.next=l2;\n        while(l2!=null && carry!=0){\n            int sum = l2.val + carry;\n            l2.val=sum%10;\n            carry=sum/10;\n            last=l2;\n            l2=l2.next;\n        }\n    }\n    if(carry!=0) last.next=new ListNode(1);\n    return dummyNode.next;\n}\n```\n## [445. 两数相加Ⅱ](https://leetcode-cn.com/problems/add-two-numbers-ii)\n\n给定两个**非空**链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n进阶:\n如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。\n\n输入: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\n\n输出: 7 -> 8 -> 0 -> 7\n\n```java\npublic static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    BigInteger b1 = new BigInteger(list2num(l1));\n    BigInteger b2 = new BigInteger(list2num(l2));\n    String resStr=b1.add(b2).toString();\n    //再变成字符串存到连表里面\n    ListNode res=new ListNode(1);\n    ListNode real=res;\n    for (int i=0;i<resStr.length();i++) {\n        real.next=new ListNode(Integer.valueOf(resStr.charAt(i)-48));\n        real=real.next;\n    }\n    return res.next;\n}\npublic static String  list2num(ListNode l){\n    String num=\"\";\n    while(l!=null){\n        num=num+l.val;\n        l=l.next;\n    }\n    return num;\n}\n```\n这两题方法很多，下面那题实际上是上面那一题反过来的，但是题目要求不改变链表所以可以利用栈来反转，然后就跟上面的类似了，然后这里我偷了个懒用的`BigInteger`搞的速度也还行 77%beat。\n\n**解法二**\n\n（update: 2020.4.14）上面的解法笔试这样写倒是无所谓，面试这样写肯定是不行的，咱还是得规规矩矩的写\n\n```java\npublic  ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    //用数组的话不知道有多长,需要多遍历两遍\n    Deque<Integer> stack1=new ArrayDeque<>();\n    Deque<Integer> stack2=new ArrayDeque<>();\n    ListNode res=new ListNode(-1);\n    while(l1!=null){\n        stack1.push(l1.val);\n        l1=l1.next;\n    }\n    while(l2!=null){\n        stack2.push(l2.val);\n        l2=l2.next;\n    }\n    int carry=0;\n    while(!stack1.isEmpty() || !stack2.isEmpty() || carry>0){\n        int temp=(stack1.isEmpty()?0:stack1.pop())+(stack2.isEmpty()?0:stack2.pop())+carry;\n        //头插法\n        ListNode next=res.next;\n        ListNode newNode=new ListNode(temp%10);\n        res.next=newNode;\n        newNode.next=next;\n        carry=temp/10;\n    }\n    return res.next;\n}\n```\n\n最后的头插法还是挺好的，我开始还想着翻转一下的，我看见评论区有人用递归写，我试了下，还是算了，太麻烦了，还没上面的简洁，写一大坨初始化，然后再递归，代码一点都不简洁，没啥意义\n\n## [876. 链表的中间节点](https://leetcode-cn.com/problems/middle-of-the-linked-list)\n\n```java\npublic static ListNode middleNode(ListNode head) {\n        if(head==null||head.next==null)return head;\n        ListNode fast=head;\n        ListNode slow=head;\n        // 1 2 3 4 5 6 7\n        while(fast!=null&&fast.next!=null){\n            fast=fast.next.next;\n            slow=slow.next;\n        }\n        return slow;\n}\n```\n> `快慢指针`，很常见很经典的做法后面很多题会用到这个。\n\n## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)\n反转一个单链表。\n\n**解法一**\n\n```java\n//递归\npublic static ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    ListNode newHead = reverseList(head.next);\n    //从后往前\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n}\n```\n**解法二**\n\n```java\n//三指针迭代\npublic static ListNode reverseList2(ListNode head) {\n    if(head==null)return head;\n    ListNode pre=head;\n    ListNode cur=head.next;\n    ListNode temp;\n    while(cur!=null){\n        temp=cur.next;\n        cur.next=pre;\n        pre=cur;\n        cur=temp;\n    }\n    head.next=null;\n    return pre;\n}\n```\n## [92. 反转链表Ⅱ](https://leetcode-cn.com/problems/reverse-linked-list-ii)\n反转从位置 _m_ 到 _n_ 的链表。请使用一趟扫描完成反转。\n\n**解法一**\n\n```java\npublic static ListNode reverseBetween(ListNode head, int m, int n) {\n    if(m==n) return head;\n    //用来遍历\n    ListNode pre=head;\n    ListNode mid=head.next;\n    ListNode rear=null;\n    //在遍历的中间连接这个表 时间复杂厚度O(N)\n    //所以需要先保存 m前的节点用于后面到n的时候连接n和前面的部分 preM\n    //还要保存m节点，在后面遍历到n的时候将M节点和后面的部分连接\n    //中间段的前后节点 \n    ListNode preM =null;\n    ListNode valM=head;\n    //ListNode nNext=null;\n    int count =1;\n    while(count <=n-1){\n        //count的位置实际上是指的pre的位置因为只有pre是从head开始走的\n        //尾指针后移\n        rear=mid.next;\n        if(count==m-1){\n            //保存M点前面的节点和M节点\n            preM=pre;\n            valM=mid;\n            //System.out.println(\"preM :\"+preM.val);\n        }\n        if(count==n-1){\n            //连接n后面节点的值\n            valM.next=rear;\n            //在这里判断下m前有没有元素\n            if(m==1){\n                head=mid;\n            } else{\n                preM.next=mid;\n            }\n        }\n        if(count >= m && count <=n-1){\n            //只有mid的位置大于m小于等于n才会将节点next域反转\n            mid.next=pre;\n        }\n        //其他两个指针也向后移动\n        pre=mid;\n        mid=rear;\n        count++;\n    }\n    return head;\n}\n```\n代码写的比较烂但是思路还是比较清晰，只扫描了一遍链表 2ms beat 100%，但是创建的指针有点多，抠边界要细心。\n\n**解法二**\n\n被本来是像把上面的解法删掉的，想了一下还是留着，提醒下自己，上面的解法不够通用，属于一次性的解法，细节也很多，当初可能是追求在一个循环内写完，所以可能写的比较难看\n\n```go\nfunc reverseBetween2(head *ListNode, m int, n int) *ListNode {\n    dummyNode := &ListNode{\n        Val:  -1,\n        Next: head,\n    }\n    mpre := dummyNode //m节点前的节点\n    for i := m; i > 1; i-- {\n        mpre = mpre.Next\n    }\n    pre := mpre\n    cur := mpre.Next\n    //  2   4\n    //1 2 3 4 5\n    for i := m; i <= n; i++ {\n        next := cur.Next\n        cur.Next = pre\n        pre = cur\n        cur = next\n    }\n    mpre.Next.Next = cur //2.next=5\n    mpre.Next = pre      //1.next=4\n    return dummyNode.Next\n}\n```\n\n这个解法实际上就是普通一个翻转，然后处理翻转部分的头尾节点连接，但是代码比上面的简洁多了\n\n**解法三**\n\n头插法的应用，将翻转部分节点用头插法插入pre后，也挺不错\n\n```go\n//头插法\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\n    dummyNode := &ListNode{\n        Val:  -1,\n        Next: head,\n    }\n    mpre := dummyNode //m节点前的节点\n    for i := m; i > 1; i-- {\n        mpre = mpre.Next\n    }\n    cur := mpre.Next\n    //1 |2 3 4| 5\n    for i := m; i < n; i++ {\n        //除非m=n=len不然next肯定不为空,但是这种情况已经被循环的条件过滤了\n        next := cur.Next\n        cur.Next = next.Next\n        next.Next = mpre.Next\n        mpre.Next = next\n    }\n    return dummyNode.Next\n}\n```\n\n## [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)\n\nGiven a (singly) linked list with head node `root`, write a function to split the linked list into `k` consecutive linked list \"parts\".\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.\n\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n\nReturn a List of ListNode's representing the linked list parts that are formed.\n\nExamples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]\n\n**Example 1:**\n\n```java\nInput: \nroot = [1, 2, 3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe input and each element of the output are ListNodes, not arrays.\nFor example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but it's string representation as a ListNode is [].\n```\n\n**Example 2:**\n\n```java\nInput: \nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\nOutput: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n```\n\n**Note:**\n\nThe length of `root` will be in the range `[0, 1000]`.\n\nEach value of a node in the input will be an integer in the range `[0, 999]`.\n\n`k` will be an integer in the range `[1, 50]`.\n\n**解法一**\n\n```java\npublic static ListNode[] splitListToParts(ListNode root, int k) {\n    //先要获取下链表的长度\n    ListNode temp=root;\n    ListNode next=root;\n    ListNode [] result=new ListNode[k];\n    int count=0;\n    while(temp!=null){\n        temp=temp.next;\n        count++;\n    }\n    temp=root;\n    //任意两部分差距不能大于1，大的在前，小的在后面\n    //其实就是对count进行分配\n    //注意: 有null的情况一定是 k>count 直接按 1 切分就完事了\n    //k<count的情况只要在 count/k 的前几个元素上加上 count/k 的余数就行了\n    int size=count/k;\n    int num=count%k;\n    result[0]=root;\n    int index=1;\n    if(k<=count){\n        for (int i=1;temp!=null && index < k;i++){\n            next=temp.next;\n            if(i<=(size+1)*num && i%(size+1)==0){\n                //前几个res的分割点\n                result[index++]=next;\n                //切断\n                temp.next=null;\n            } else if(i>(size+1)*num && (i-num)%size==0){\n                result[index++]=next;\n                temp.next=null;\n            }\n            temp=next;\n        }\n    } else{\n        //剩下的情况就是后面要补null的情况\n        // 这里两种情况应该是可以合并的，但是k>count num>0 懒得去抠边界\n        for (int i=1;i<k;i++){\n            if(temp==null){\n                //这个if其实没必要\n                result[i]=null;\n            } else{\n                next=temp.next;\n                result[i]=next;\n                temp.next=null;\n                temp=next;\n            }\n        }\n    }\n    return result;\n}\n```\n3ms beat 89% 这题也比较简单主要是边界要抠好\n\n## [86. 分隔(割)链表](https://leetcode-cn.com/problems/partition-list)\n给定一个链表和一个特定值`x`，对链表进行分隔，使得所有小于`x`的节点都在大于或等于`x`的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n**输入:** head = 1->4->3->2->5->2, _x_ = 3\n\n**输出:** 1->2->2->4->3->5\n\n**解法一**\n\n```java\npublic ListNode partition(ListNode head, int x) {\n    //先在头部加一个dummy节点统一操作\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    //分割点\n    ListNode pre=cutNode=dummyNode;\n    ListNode cur=head;\n    int cut=0;\n    while(cur!=null){\n        if(cur.val>=x&&cut==0){\n            //只会执行一次在找到第一个val>=x的节点的时候---保存分割点\n            cutNode=pre;\n            cut=1;\n        } else if(cur.val<x && cut==1){\n            //找到分割点后 遍历到val<x的节点的情况---将cur连接到cutNode的后面 处理好cur相邻的两个节点\n            //先处理好cur相邻的节点\n            pre.next=cur.next;\n            //连接cutNode\n            cur.next=cutNode.next;\n            cutNode.next=cur;\n            //cutNode后移\n            cutNode=cur;\n        }\n        pre=cur;\n        cur=cur.next;\n    }\n    return dummyNode.next\n}\n```\n这题也挺简单和上面的那题名字一样是在整理这篇博客的时候现场做的(2019.2.27)前后大概半个小时orz。。。比较菜，但是这个我没有在本地跑直接在LeetCode上提交的然后就过了 1ms beat84% 感觉思路比较清晰就没有本地跑，提交记录上最快的居然是用了额外空间new了两个链表然后连起来的。。。醉了可能是测试用例太少了。\n\n\n## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)\n编写一个程序，找到两个单链表相交的起始节点。\n如下面的两个链表：\n![mark](http://static.imlgw.top///20190303/NVEXndTcF1R6.png?imageslim)\n\n在节点 c1 开始相交。\n\n**示例 1：**\n\n![mark](http://static.imlgw.top///20190303/ymln2djUVieT.png?imageslim)\n\n**输入**: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n**输出**: Reference of the node with value = 8\n**输入解释**:相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n**示例 2：**\n\n![mark](http://static.imlgw.top///20190303/2F7qqhkUIWog.png?imageslim)\n**输入**:intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n**输出**:Reference of the node with value = 2\n**输入解释**:相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n**示例 3：**\n\n![mark](http://static.imlgw.top///20190303/hKSAelGSE1TY.png?imageslim)\n\n**输入**:intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n**输出**:null\n**输入解释**:从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n**解释**:这两个链表不相交，因此返回 null。\n\n**注意：**\n\n*   如果两个链表没有交点，返回 `null`.\n*   在返回结果后，两个链表仍须保持原有的结构。\n*   可假定整个链表结构中没有循环。\n*   程序尽量满足 O(_n_) 时间复杂度，且仅用 O(_1_) 内存。\n\n**解法一：**\n\n```java\npublic static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode pA=headA;\n    ListNode pB=headB;\n    //计算两个链表长度然后计算差距然后向后对齐\n    int lenA=0;\n    int lenB=0;\n    while(pA!=null){\n        pA=pA.next;\n        lenA++;\n    }\n    while(pB!=null){\n        pB=pB.next;\n        lenB++;\n    }\n    int dis=lenB>lenA?lenB-lenA:lenA-lenB;\n    if(lenB>lenA){\n        while(dis-->0){\n            headB=headB.next;\n        }\n    } else{\n        while(dis-->0){\n            headA=headA.next;\n        }\n    }\n    //不相等就一直向后移\n    while(headA!=headB){\n        //如果有一条为空说明没有交点\n        if(headA.next==null){\n            return null;\n        }\n        headA=headA.next;\n        headB=headB.next;\n    }\n    return headA;\n}\n```\n这种方法比较直接直接计算两个链表的长度然后计算差值然后将长的那个移动到对应的位置让`两条链表尾对齐`然后一起向后移动\n**解法二：**\n\n```java\n//方法二 \npublic static ListNode getIntersectionNode2(ListNode headA, ListNode headB) {\n    //当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，向后对齐，方法还是很巧妙的。\n    ListNode pA=headA;\n    ListNode pB=headB;\n    if(headB==null || headA==null)\n                 return null;\n    //while(pA!=null && pB!=null ){\n    while(pA!=pB){\n        //要保证两个==null的时候都只能执行一次不然如果没有交点就会死循环\n        //改变while的条件\n        //改变pA，pB跳转的条件\n        //这样就可以保证最后没交点的时候 第二遍循环pA和pB最后会同时等于null会有出口不会死循环\n        pA=pA==null?headB:pA.next;\n        pB=pB==null?headA:pB.next;\n    }\n    return pA;\n}\n```\n>  同时遍历两个链表，当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，使之尾对齐，方法还是很巧妙的，代码也比较简洁。\n\n\n## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list)\n请判断一个链表是否为回文链表。\n\n**示例 1:**\n\n**输入:** 1->2\n**输出:** false\n\n**示例 2:**\n\n**输入:** 1->2->2->1\n**输出:** true\n\n**进阶：**\n你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n\n```java\npublic boolean isPalindrome(ListNode head) {\n    if(head==null || head.next==null){\n        return true;\n    }\n    // 利用快慢指针找到中点\n    ListNode fast = head;\n    ListNode slow = head;\n    while (fast.next != null) {\n        fast = fast.next.next == null ? fast.next : fast.next.next;\n        slow = slow.next;\n    }\n    // 如果是偶数节点，slow就是偏右的那个 奇数就是正中间的 奇数在正中间不用管\n    // fast是尾节点 1 1 1 1 1 1\n    resverList(slow);\n    //slow.next==null\n    // check\n    while (fast != null && head != null) {\n        if (fast.val != head.val) {\n            return false;\n        }\n        fast = fast.next;\n        head = head.next;\n    }\n    return true;\n\n}\n\npublic static void resverList(ListNode node) {\n    ListNode cur = node;\n    ListNode pre = null;\n    ListNode next = node;\n    while (cur != null) {\n        next = next.next;\n        cur.next = pre;\n        pre = cur;\n        cur = next;\n    }\n}\n```\n这题就用到了上面的翻转链表的方法，不过这里只翻转了一半，翻转了后半段然后从两边到中间逐个节点对比\n\n\n## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。\n\n现有一个链表 -- head = [4,5,1,9]，它可以表示为:\n\n![mark](http://static.imlgw.top///20190303/9MUvMzlcAN0G.png?imageslim)\n\n**示例 1:**\n\n**输入:** head = [4,5,1,9], node = 5\n**输出:** [4,1,9]\n**解释:** 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n**示例 2:**\n\n**输入:** head = [4,5,1,9], node = 1\n**输出:** [4,5,9]\n**解释:** 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n**说明:**\n\n*   链表至少包含两个节点。\n*   链表中所有节点的值都是唯一的。\n*   给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n*   不要从你的函数中返回任何结果。\n\n**二货做法**\n\n```java\npublic  static void deleteNodelow(ListNode node) {\n    //思路就是和node后面的元素一直交换，就像冒泡排序一样\n    ListNode next;\n    ListNode temp=new ListNode(0);\n    ListNode pre=temp;\n    while(node.next!=null){\n        next=node.next;\n        if(node.next.next==null){\n            pre=node;\n        }\n        //先保存最后一个节点前的节点\n        //交换当前节点和后一个节点\n        temp.val=node.val;\n        node.val=next.val;\n        next.val=temp.val;\n        node=next;\n    }\n    pre.next=null;\n}\n```\n首先想到的愚蠢的做法,怎么这么蠢？？？？\n\n**正确做法**\n\n```java\n  public  static void deleteNode(ListNode node) {\n        node.val=node.next.val;\n        node.next=node.next.next;\n  }\n```\n\n## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)\n删除链表中等于给定值 val 的所有节点。\n\n**示例:**\n\n**输入:** 1->2->6->3->4->5->6, _**val**_ = 6\n**输出:** 1->2->3->4->5\n\n**解法一：**\n双指针 + 虚拟头节点\n\n```java\n public static ListNode removeElements(ListNode head, int val) {\n        if (head == null) return null;\n        ListNode dummyHead = new ListNode(0);\n        //再头接待你之前加了新的节点\n        dummyHead.next = head;\n        ListNode pre = dummyHead, cur = head;\n        while (cur != null) {\n            if (cur.val == val) {\n                pre.next = cur.next;\n            } else {\n                //不是相等的值就向后移动\n                pre = cur;\n            }\n            cur = cur.next;\n        }\n        return dummyHead.next;\n    }\n```\n**解法二：**\n\n递归方法比较简洁\n\n```java\n//递归\npublic static ListNode removeElements2(ListNode head, int val){\n    if (head == null)\n       return null;\n    //将下一个元素放进递归如果是==val的就会把下一个的下一个元素返回连接到当前元素\n    head.next = removeElements2(head.next, val);\n    return head.val == val ? head.next : head;\n}\n```\n\n## [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n说明：\n给定的 n 保证是有效的。\n进阶：\n你能尝试使用一趟扫描实现吗？\n\n**解法一**\n\n```java\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    if(head==null&&head.next==null) return null;\n    //双指针 主要是头和尾的删除需要抠一下边界\n    //  -1 | 1 2 3 4 5 6\n    ListNode fast=head;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode slow=dummyNode;\n    //加了哑节点，直接先加1\n    int count=1;\n    while(fast!=null){\n        fast=fast.next;\n        slow=count<n?slow:slow.next;\n        count++;\n        if(fast.next==null){\n            //slow到达需要删除的位置的前一个\n            slow.next=slow.next.next;\n            return dummyNode.next;\n        }\n    }\n    return dummyNode.next;\n}\n```\n看了评论才知道咋一遍循环，主要就是控制slow指针走`length-n`步，让快指针先走n步，然后快慢一起走，快指针到头时慢指针就到`length-n`的位置了，这题也可以用List保存每个节点让然后把待删除的节点的前一个拿出来操作，遍历两遍的方法比较简单就不写了，感觉这种方法比较好 , 这题的OJ case比较少所以没什么可比性 , 前几个都是跑了两遍的，我把最快的拷过来跑的比我还慢。。。。然后我又提交了一次 beat 90%.......\n\n\n## [82. 删除排序链表中的重复元素Ⅱ](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)\n给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中**没有重复出现**的数字。\n\n**示例 1:**\n\n输入: 1->2->3->3->4->4->5\n输出: 1->2->5\n\n**示例 2:**\n\n输入: 1->1->1->2->3\n输出: 2->3\n\n**解法一**\n\n乍一看跟上面那一题一样？这题是排序链表上面那题是无序的，而且这题不给定元素\n\n```java\npublic  static ListNode deleteDuplicates(ListNode head) {\n    if(head==null)return null;\n    //首先想到的思路是3指针，然后遍历的过程中后面的指针遇到==val的情况就让后面的指针一直后移走到！=val\n    //先添加个哑节点\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode cur=head;\n    ListNode next=head.next;\n    ListNode pre=dummyNode;\n    while(next!=null){\n        while(next.val==cur.val){\n            next=next.next;\n            if(next==null){\n                pre.next=null;\n                return dummyNode.next;\n            }\n            if(next.val!=cur.val){\n                pre.next=next;\n                //cur跟上\n                cur=next;\n                break;\n            }\n        }\n        //关键就是pre移动这里有坑 不能直接将pre移到cur,因为会有连续的连续存在\n        pre=cur.next!=null&&cur.val==cur.next.val?pre:cur;\n        cur=next;\n        next=next.next;\n    }\n    return dummyNode.next;\n}\n```\n整体来说还是挺简单的只跑了一趟 1ms beta98%，评论里面大都只用了两个指针我用了三个这样感觉比较清晰\n怎么好理解怎么来。貌似最快的是一个递归的，递归写起来确实玄学还要多练练啊\n\n**解法二**\n\n2020.4.2重写了一个递归的，感觉良好\n\n```java\npublic ListNode deleteDuplicates(ListNode head) {\n    if(head==null || head.next==null) return head;\n    if(head.val==head.next.val){\n        while(head!=null && head.next!=null && head.val==head.next.val){\n            head=head.next;\n        }\n        return deleteDuplicates(head.next); //去重\n    }\n    head.next=deleteDuplicates(head.next);\n    return head;\n}\n```\n## [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)\n\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n**示例 1:**\n\n```java\n输入: 1->1->2\n输出: 1->2\n```\n\n\n**示例 2:**\n\n```java\n输入: 1->1->2->3->3\n输出: 1->2->3\n```\n\n**解法一**\n\n老题新写\n\n```java\n//递归\npublic ListNode deleteDuplicates(ListNode head) {\n    if(head==null || head.next==null) return head;\n    ListNode node=deleteDuplicates(head.next);\n    if(head.val==node.val) {\n        head.next=node.next;\n    }\n    return head;\n}\n```\n**解法二**\n\n```java\n//迭代\npublic ListNode deleteDuplicates(ListNode head) {\n    ListNode temp = head;\n    while (temp != null){\n        if (temp.next == null){\n            break;\n        }\n        if (temp.next.val == temp.val){\n            temp.next = temp.next.next;\n        }else {\n            temp = temp.next;\n        }\n\n    }\n    return head;\n}\n```\n\n## [面试题 02.01\\. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)\n\n编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。\n\n**示例1:**\n\n```java\n 输入：[1, 2, 3, 3, 2, 1]\n 输出：[1, 2, 3]\n```\n\n**示例2:**\n\n```java\n 输入：[1, 1, 1, 1, 2]\n 输出：[1, 2]\n```\n\n**提示：**\n\n1.  链表长度在[0, 20000]范围内。\n2.  链表元素在[0, 20000]范围内。\n\n**进阶：**\n\n如果不得使用临时缓冲区，该怎么解决？\n\n**解法一**\n\n无序链表，和前面不太一样，开个20000的数组判断是否重复就行了\n```golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeDuplicateNodes(head *ListNode) *ListNode {\n    var set = make([]bool,20001)\n    var dummyNode = &ListNode{Next:head}\n    var pre = dummyNode\n    for head!=nil{\n        if !set[head.Val]{\n            set[head.Val]=true\n            pre=head\n        }else{\n            pre.Next=head.Next\n        }\n        head=head.Next\n    }\n    return dummyNode.Next\n}\n```\n> 这个进阶或许应该称之为退阶。。。进阶的应该只能暴力O(N^2)而且这个数据量肯定会T，排序的话并没有合适的排序方法\n\n## [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)\n\n给定一个单链表 _L_：L0→L1→…→Ln-1→Ln \n将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n**示例 1:**\n\n给定链表 1->2->3->4, 重新排列为 1->4->2->3.\n\n**示例 2:**\n\n给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.\n\n> 这题和上面的回文链表有点类似，都是快慢指针不过这题稍微复杂点\n\n**解法一**\n\n```java\npublic static void reorderList(ListNode head) {\n    if(head==null){\n        return;\n    }\n    ListNode right = head;\n    ListNode slow = head;\n    // 1 1 1 1 1 1 1\n    while (right.next != null) {\n        right = right.next.next != null ? right.next.next : right.next;\n        slow = slow.next;\n    }\n    // 从slow开始翻转\n    res(slow);\n    //左半部分\n    ListNode left = head;\n    //下一个节点\n    ListNode rnext = right;\n    ListNode lnext = left;\n    // 1 2 3 4 5 6 7 8 \n    // 1 8 2 7 3 6 4 5\n    while (right != null && left != null) {\n        // 要保存right的下一个节点 , left也需要,不然无法导航到下一个节点\n        lnext = lnext.next;\n        rnext = rnext.next;\n        // 偶数个数节点,如果遍历到right链表的最后一个节点\n        // 偶数的话right链表会短一点 最后连接的时候\n        // left: 1->2->3->4->5 right: 8->7->6->5   \n        // 像这样会将5加到left的4和5之间,但是明显只有一个5这样添加就是有问题的\n        if(right.next==null){\n            //所以这里吧lnext赋值为null,后面就不会重复连接5这个节点\n            lnext=null;\n        }\n        //奇数个数的时候这样连接没问题\n        // 1 2 3 4 5 \n        // 9 8 7 6 5\n        //5.next=5\n        left.next = right;\n        //如果奇数个数到最后这一步 right和left是同一个节点都为值是5的节点\n        //所以这里下面的直接覆盖了上面的\n        //5.next=null\n        right.next = lnext;\n        left = lnext;\n        right = rnext;\n    }\n}\n\n//反转\npublic static void res(ListNode node) {\n    ListNode pre = null;\n    ListNode cur = node;\n    ListNode nex = node;\n    while (cur != null) {\n        nex = nex.next;\n        cur.next = pre;\n        pre = cur;\n        cur = nex;\n    }\n}\n```\n\n也是之前的代码了，写的比较烂，但是思路还是比较清晰的，边界需要注意，速度还行 4ms  77% 。\n\n\n## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n**示例：**\n\n```java\n输入： 1->2->4, 1->3->4\n输出： 1->1->2->3->4->4\n```\n\n**解法一**\n\n常规迭代的做法\n\n```java\n public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode temp=new ListNode(0);\n        ListNode res=temp;\n        while(l1!=null&&l2!=null){\n            if(l2.val<l1.val){\n                temp.next=l2;\n                l2=l2.next;\n                temp=temp.next;\n            }else{\n                temp.next=l1;\n                l1=l1.next;\n                temp=temp.next;\n            }\n        }\n        temp.next=l1==null?l2:l1;\n        return res.next;\n}\n```\n归并分治的思想，期末考试的一道题\n\n**解法二**\n\n递归的做法\n\n```java\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummyNode=new ListNode(-1);\n    mergeTwoLists(l1,l2,dummyNode);\n    return dummyNode.next;\n}\n\npublic void mergeTwoLists(ListNode l1, ListNode l2,ListNode res) {\n    if(l1==null){\n        res.next=l2;\n        return;\n    }\n\n    if(l2==null){\n        res.next=l1;\n        return;\n    }\n\n    if(l1.val>l2.val){\n        res.next=l2;\n        mergeTwoLists(l1,l2.next,res.next);\n    }else{\n        res.next=l1;\n        mergeTwoLists(l1.next,l2,res.next);\n    }\n}\n```\n\n上面是我一开始自己写的，一点也不递归\n\n```java\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    if(l1==null) return l2;\n    if(l2==null) return l1;\n    ListNode dummyNode=new ListNode(-1);\n    if(l1.val<l2.val){\n        l1.next=mergeTwoLists(l1.next,l2);\n        return l1;\n    }else{\n        l2.next=mergeTwoLists(l1,l2.next);\n        return l2;\n    }\n}\n```\n\n这种看着就很简洁\n\n---\n## [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n**示例:**\n\n```java\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n```\n\n**解法一：**\n\n```java\npublic ListNode mergeKLists(ListNode[] lists) {\n    if(lists.length==0)return null;\n    ListNode temp=lists[0];\n    for (int i=0;i<lists.length-1;i++){\n        temp=merge2List(temp,lists[i+1]);\n    }\n    return temp;\n}\n\npublic static ListNode merge2List(ListNode headA,ListNode headB){\n    ListNode dummyNode=new ListNode(-1);\n    ListNode res=dummyNode;\n    ListNode tempA=headA;\n    ListNode tempB=headB;\n    while(tempB!=null&&tempA!=null){\n        if(tempB.val>tempA.val){\n            res.next=tempA;\n            tempA=tempA.next;\n        } else{\n            res.next=tempB;\n            tempB=tempB.next;\n        }\n        res=res.next;\n    }\n    res.next=tempA==null?tempB:tempA;\n    return dummyNode.next;\n}\n```\n最先想到的方法，和前面的二路归并一样，把前两个归并的结果和后面的继续归并。速度太慢了200ms左右.....时间复杂度是`O(N^2)`.\n**解法二：**\n\n```java\npublic ListNode mergeKLists2(ListNode[] lists) {\n    if(lists.length==0)return null;\n    return divide(lists,0,lists.length-1);\n}\n\npublic static ListNode divide(ListNode[] lists,int left,int right){\n    if(left>=right)return lists[left];\n    int mid=left+((right-left)>>1);\n    ListNode l = divide(lists,left,mid);\n    ListNode r = divide(lists,mid+1,right);\n    return merge2List(l,r);\n}\n\npublic static ListNode merge2List(ListNode headA,ListNode headB){\n    if(headA==null)return headB;\n    if(headB==null)return headA;\n    ListNode dummyNode=new ListNode(-1);\n    ListNode res=dummyNode;\n    ListNode tempA=headA;\n    ListNode tempB=headB;\n    while(tempB!=null&&tempA!=null){\n        if(tempB.val>tempA.val){\n            res.next=tempA;\n            tempA=tempA.next;\n        } else{\n            res.next=tempB;\n            tempB=tempB.next;\n        }\n        res=res.next;\n    }\n    res.next=tempA==null?tempB:tempA;\n    return dummyNode.next;\n}\n```\n看起来很眼熟？没错就是归并排序的思路，利用分治的思想，先归并左边，再归并右边，然后merge左右的结果，时间复杂度为`O(NlogK)` (递归树深度为logK，归并每一层时间复杂度都是N)， 10ms左右，N是所有链表的元素个数，K是链表个数。而且因为是链表空间复杂度也不高。另外这题也可以改成非递归的方式如下:\n```java\npublic ListNode mergeKLists3(ListNode [] lists){\n    if (lists.length == 0) {\n        return null;\n    }\n    int k = lists.length;\n    while (k > 1) {\n        for (int i = 0; i < k / 2; i++) {\n            //两两合并将结果保存在前半部分的节点中然后缩小一半的范围\n            lists[i] = merge2Lists(lists[i], lists[i + (k + 1) / 2]);\n        }\n        //缩小一半的范围\n        k = (k + 1) / 2;\n    }\n    return lists[0];\n}\n```\n**解法三：**\n\n```java\n//小根堆的方法\npublic ListNode mergeKLists4(ListNode[] lists) {\n    //利用一个按节点值最小次序排列的优先队列, 每次取最小的节点加入返回链表中\n    if(lists.length < 1) return null;\n    Queue<ListNode> pq = new PriorityQueue<>((a, b) -> (a.val - b.val));\n    ListNode head = new ListNode(0);\n    ListNode cur = head;\n    for (ListNode p : lists){\n        if(p != null)\n        pq.offer(p);\n    }\n    while(!pq.isEmpty()) {\n        cur.next = pq.poll();\n        cur = cur.next;\n        if(cur.next != null)\n        //讲当前节点后一个节点加入队列\n        pq.offer(cur.next);\n    }\n    return head.next;\n}\n```\n\n利用了小根堆，Java里面有小根堆可以直接用，思路就是每次把每条链表的头元素都放进小根堆里面然后找出最小的加到新链表中然后，最小的那个节点的链表向后移再加到小根堆里面，方法还是相当简洁的。但是用了90ms左右比较慢，时间复杂度`O(NlogK)`和上面是一样的，每次调整时间复杂度都是`logK`，需要调整`N`次(K为链表数量，N为所有链表的元素个数)，空间复杂度是 `O(K)`\n\n## [355. 设计推特](https://leetcode-cn.com/problems/design-twitter/)\n\n设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：\n\n1. **postTweet(userId, tweetId):** 创建一条新的推文\n2. **getNewsFeed(userId):** 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。\n3. **follow(followerId, followeeId):** 关注一个用户\n4. **unfollow(followerId, followeeId):** 取消关注一个用户\n\n**实例**\n\n```java\nTwitter twitter = new Twitter();\n\n// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).\ntwitter.postTweet(1, 5);\n\n// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.\ntwitter.getNewsFeed(1);\n\n// 用户1关注了用户2.\ntwitter.follow(1, 2);\n\n// 用户2发送了一个新推文 (推文id = 6).\ntwitter.postTweet(2, 6);\n\n// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -> [6, 5].\n// 推文id6应当在推文id5之前，因为它是在5之后发送的.\ntwitter.getNewsFeed(1);\n\n// 用户1取消关注了用户2.\ntwitter.unfollow(1, 2);\n\n// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.\n// 因为用户1已经不再关注用户2.\ntwitter.getNewsFeed(1);\n```\n\n**解法一**\n\n其实核心就是一个k路链表的归并，这里直接用的优先级队列，然后用java8的新特性简化了代码\n\n```java\nclass Twitter {\n    //全局时间戳\n    private  int timeStamp=0;\n    //Tweet是有序链表,按照时间戳来排序\n    private  Map<Integer,Tweet> userTweetMap=new HashMap<>();\n    //followMap\n    private  Map<Integer,Set<Integer>> userFollowMap=new HashMap<>();;\n\n    public Twitter() {}\n\n    public void postTweet(int userId, int tweetId) {\n        Tweet oldHead=userTweetMap.get(userId);\n        userTweetMap.compute(userId,(k,v)->new Tweet(tweetId,++timeStamp)).next=oldHead;\n    }\n\n    public List<Integer> getNewsFeed(int userId) {\n        PriorityQueue<Tweet> pq=new PriorityQueue<>((t1,t2)->t2.time-t1.time);\n        List<Integer> feed=new ArrayList<>();\n        follow(userId,userId);\n        userFollowMap.get(userId).forEach(followerId->Optional.ofNullable(userTweetMap.get(followerId)).ifPresent(tw->pq.offer(tw)));\n        int count=0;\n        while(!pq.isEmpty() && count<10){\n            Tweet tw=pq.poll();\n            feed.add(tw.twId);\n            if(tw.next!=null){\n                pq.offer(tw.next);\n            }\n            count++;\n        }\n        return feed;\n    }\n\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\n    public void follow(int followerId, int followeeId) {\n        userFollowMap.computeIfAbsent(followerId,k->new HashSet<>()).add(followeeId);\n    }\n\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\n    public void unfollow(int followerId, int followeeId) {\n        Optional.ofNullable(userFollowMap.get(followerId)).ifPresent(set->set.remove(followeeId));\n    }\n}\n\nclass Tweet{\n    int twId;\n    int time;\n    Tweet next;\n    public Tweet(int twId,int time){\n        this.twId=twId;\n        this.time=time;\n    }\n}\n```\n\n## [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list)\n\n您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。\n\n扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。\n\n**示例:**\n\n输入:\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL\n\n输出:\n1-2-3-7-8-11-12-9-10-4-5-6-NULL\n\n**说明:**\n\n给出以下多级双向链表:\n\n![mark](http://static.imlgw.top///20190303/DqC2qKF5h63V.png?imageslim)\n\n我们应该返回如下所示的扁平双向链表:\n\n![mark](http://static.imlgw.top///20190303/qOSn0TLmMuCt.png?imageslim)\n\n**解法一：**\n\n```java\n/*\n        这种解法思路还是比较清晰的\n        每次有子链的时候就直接把子链遍历到尾 然后添加到链表中形成新主链 把子链的入口节点child指定为null\n        然后主链继续向后遍历所以整个遍历的次数就是整个链表元素的个数 O(M)\n*/\npublic static Node flatten1(Node head) {\n    if(head==null || head.next==null&&head.child==null){\n        return head;\n    }\n    Node cur=head;\n    Node nNext;\n    Node child;\n    while(cur!=null){\n        if(cur.child!=null){\n            //有子链表\n            child=cur.child;\n            //子链表的表头\n            nNext=cur.next;\n            //主链的下一节点\n            //连接子链表\n            cur.next=child;\n            //主链的下一节点为子链表头\n            child.prev=cur;\n            //子链表的前驱节点\n            //已经拼接到主链，孩子链置为空 （这步还很关键我开始一直忘设置为null）\n            cur.child=null;\n            if(nNext==null){\n                //遍历到主链最后一个了\n                //所以没有下一个节点，后面的步骤不用继续但是也不能Break 因为最后一个节点有可能还有子链表\n                continue;\n            }\n            while(child.next!=null){\n                //找到新主链的下一节点 (子链的最后一个)\n                child=child.next;\n            }\n            //连接以前的主链\n            child.next=nNext;\n            nNext.prev=child;\n        }\n        //主链表向后移动\n        cur=cur.next;\n    }\n    return head;\n}\n```\n**解法二：**\n\n```java\n    //标准的DFS\n    public static Node flatten2(Node node) {\n       if(node==null){\n            return node;\n        }\n        Node head = node;\n        while (head!=null){\n            //我感觉这样会快一些\n             Node next = head.next;\n            if(head.child!=null){\n                next = head.next;\n                //子链表扁平化 返回头节点\n                Node nextLayer = flatten2(head.child);//子链表的头节点\n                //连接子链表头和主链\n                head.next = nextLayer;\n                nextLayer.prev = head;\n                //然后子链表置为null\n                head.child = null;\n                //遍历到子链表的结尾\n                while (nextLayer.next!=null){\n                    nextLayer = nextLayer.next;\n                }\n                //连接子链表的尾部\n                nextLayer.next = next;\n                if(next!=null){\n                    next.prev = nextLayer;\n                }\n            }\n            //这里就直接跳过子链表 之前的是head=head.next; 但是因为之前的子链表已经加到主链表中所以会浪费一些时间（子链表肯定是已经扁平化的肯定都没有子链表）\n            head = next;\n        }\n        return node;\n    }\n```\n\n两种方法都是看的评论里面的第二种我稍微改了下，直接跳过子链表效率会高很多，不过这题case也比较少看不出差异。\n\n---\n## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle)\n\n给定一个链表，判断链表中是否有环。\n\n为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。\n\n**示例 1：**\n\n```c\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n![mark](http://static.imlgw.top///20190303/H2wmyaG9uoiz.png?imageslim)\n\n**示例 2：**\n```c\n输入： head = [1,2], pos = 0\n输出： true\n解释： 链表中有一个环，其尾部连接到第一个节点。\n\n```\n![mark](http://static.imlgw.top///20190303/UqIc2XWwtxbo.png?imageslim)\n\n**示例 3：**\n\n```c\n输入： head = [1], pos = -1\n输出： false\n解释： 链表中没有环。\n\n```\n![mark](http://static.imlgw.top///20190303/dAg8QrxqJJga.png?imageslim)\n\n**进阶：**\n\n你能用O(1)（即，常量）内存解决此问题吗？\n\n**解法一**\n\n有一点需要注意的是只有一个节点的情况应该是不考虑的直接 false\n```java\npublic static Boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null)\n                  return false;\n    //快慢指针 相遇的时候快指针回到头部step改为1 再次相遇的时候就是环的pos\n    //这题只是判断有没有环所以只要相遇就有环\n    ListNode slow=head;\n    ListNode fast=head.next;\n    while(slow!=fast){\n        //有环是不会走到尽头的\n        if(fast.next==null || fast.next.next==null){\n            return false;\n        }\n        fast=fast.next.next;\n        slow=slow.next;\n    }\n    return true;\n}\n```\n\n## [141. 环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。\n\n为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。\n\n**说明：** 不允许修改给定的链表。 ps:上题的基础上返回入环的第一个节点\n\n```golang\n//UPDATE：2020.9.7 实行重写所有链表题的计划\n// A-->B-->C-->D   B为入环点，D为相遇点，相遇时slow = AD, fast = AD+DB+BD\n// fast = 2*slow ==> AD = DB + BD ==> AB+BD = DB+BD ==> AB = DB\nfunc detectCycle(head *ListNode) *ListNode {\n    var fast, slow = head, head\n    for fast!=nil && fast.Next!=nil {\n        fast = fast.Next.Next\n        slow = slow.Next\n        if fast == nil { //无环\n            return nil\n        }\n        if fast == slow { //有环，next一定不为null\n            for head!=fast {\n                head = head.Next\n                fast = fast.Next\n            }\n            return head\n        }\n    }\n    return nil\n}\n```\n> 这种解法还是挺有意思的`快慢指针`，快指针一次走两步慢指针一次走一步在环上相遇的时候快指针回到头节点步数调整为1，再>次相遇的>时候（这里有可能重合，当头节点就是入环节点的时候）就是入环节点。\n> 原理 :\n> A---->B---->C      分别为`头节点`，`入环节点`，`第一次相遇的节点`\n> 分析第一次相遇时快慢指针走过的路径可得\n> AB+BC+CB+BC=2(AB+BC)  快指针走过的路程肯定是慢指针的两倍\n> 化简最后就得到AB=CB 所以他们`再次相遇`就是入环的节点\n\n---\n## [61.旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n给定一个链表，旋转链表，将链表每个节点向右移动  k个位置，其中 k是非负数。\n\n**示例 1:**\n\n```java\n输入: 1->2->3->4->5->NULL, k = 2\n输出: 4->5->1->2->3->NULL\n解释:\n向右旋转 1 步: 5->1->2->3->4->NULL\n向右旋转 2 步: 4->5->1->2->3->NULL\n```\n\n**示例 2:**\n\n```java\n输入: 0->1->2->NULL, k = 4\n输出: 2->0->1->NULL\n解释:\n向右旋转 1 步: 2->0->1->NULL\n向右旋转 2 步: 1->2->0->NULL\n向右旋转 3 步: 0->1->2->NULL\n向右旋转 4 步: 2->0->1->NULL\n```\n\n**解法一**\n\n\n```java\npublic static ListNode rotateRight(ListNode head, int k) {\n    if(head==null||head.next==null){\n        return head;\n    }\n    //先获取下链表的长度，顺便记录tail的值\n    ListNode temp=head;\n    ListNode tail=head;\n    int length=0;\n    while(temp!=null){\n        length++;\n        if(temp.next==null){\n            tail=temp;\n            break;\n        }\n        temp=temp.next;\n    }\n    //将K化简\n    k=k%length;\n    if(k==0) return head;\n    temp=head;\n    int count=0;\n    //然后再遍历一遍链表在 length-k 的地方断开\n    while(temp!=null){\n        if(count==(length-k-1)){\n            tail.next=head;\n            head=temp.next;\n            temp.next=null;\n            return head;\n        }\n        count++;\n        temp=temp.next;\n    }\n    return head;\n}\n```\n虽然难度是mid，但是感觉这题还是比较简单，我看见有一种比较好点的方法是在第一遍循环完之后将链表转换为`双向链表`然后再移动还是比较有意思的\n\n## [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n\n请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。\n\n**示例 1:**\n\n输入: `1->2->3->4->5->NULL`\n输出: `1->3->5->2->4->NULL`\n\n**示例 2:**\n\n输入: `2->1->3->5->6->4->7->NULL`\n输出: `2->3->6->7->1->5->4->NULL`\n\n**说明:**\n\n应当保持奇数节点和偶数节点的相对顺序。\n链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。\n\n**解法一**\n\n```java\n//奇偶链表\npublic static ListNode oddEvenList(ListNode head) {\n    if(head==null||head.next==null||head.next.next==null)return head;\n    // 1 2 3 4 5 6 7\n    // 1 2 3 4 5 6\n    ListNode pOdd=head;\n    ListNode pEven=head.next;\n    ListNode temp=pEven;\n    while(pEven!=null&&pEven.next!=null){\n        pOdd.next=pEven.next;\n        //奇数先走\n        pOdd=pOdd.next;\n        pEven.next=pOdd.next;\n        pEven=pEven.next;\n    }\n    pOdd.next=temp;\n    return head;\n}\n```\n很像踩石头过河的游戏，一道很简单的mid，不知道为啥一开始抠了半天的边界。。。果然\n> 还是不熟悉啊。Add oil ! ! !\n\n\n## [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list)\n\n插入排序的动画演示如上篇文章。\n每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。\n插入排序算法：\n插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n重复直到所有输入数据插入完为止。\n\n**示例 1：**\n\n```java\n输入: 4->2->1->3\n输出: 1->2->3->4\n```\n\n**示例 2：**\n\n```java\n输入: -1->5->3->4->0\n输出: -1->0->3->4->5\n```\n\n**解法一**\n\n```java\n//beat 50%\npublic static  ListNode insertionSortList(ListNode head) {\n    if(head==null||head.next==null)return head;\n    //哑节点\n    ListNode dummyNode=new ListNode(Integer.MIN_VALUE);\n    System.out.println(dummyNode.val);\n    dummyNode.next=head;\n    ListNode tempNode=head;\n    //外循环内的指针\n    ListNode loopVariable=head.next;\n    ListNode loopPre=head;\n    //内循环的指针\n    ListNode tempPre=dummyNode;\n    while(loopVariable!=null){\n        //头插法\n        for (tempNode=dummyNode;tempNode!=loopVariable;tempNode=tempNode.next){\n            if(tempNode.val>loopVariable.val){\n                //System.out.println(loopVariable.val);\n                //printList(dummyNode.next);\n                //先处理好loopVariable的前后节点\n                loopPre.next=loopVariable.next;\n                //再处理tempNode前后的节点\n                loopVariable.next=tempNode;\n                tempPre.next=loopVariable;\n                //loopVariable 归位\n                loopVariable=loopPre;\n                break;\n            }\n            tempPre=tempNode;\n        }\n        loopPre=loopVariable;\n        loopVariable=loopVariable.next;\n    }\n    return dummyNode.next;\n}\n```\n上面的是我开始自己写的，但是提交后发现速度有点慢40ms 50%左右 然后我有点不信把比较靠前的拷了一个 10ms😂前几名10ms以内的都是用的方法不是插入....\n在研究别人10ms的代码时突然意识到了问题所在 我在进行插入的时候没有判断就时没有关心是不是应该进行插入操作，对于数组的插入排序是不用关心这个问题的，因为是反向遍历的 而这里是链表只能正向的遍历如果不判断就会浪费很多时间\n\n```java\n// 16ms  beat  70% 开始少写了一个if判断\npublic static  ListNode insertionSortList(ListNode head) {\n    if(head==null||head.next==null)return head;\n    //哑节点\n    ListNode dummyNode=new ListNode(Integer.MIN_VALUE);\n    System.out.println(dummyNode.val);\n    dummyNode.next=head;\n    ListNode tempNode=head;\n    //外循环内的指针\n    ListNode loopVariable=head.next;\n    ListNode loopPre=head;\n    //内循环的指针\n    ListNode tempPre=dummyNode;\n    while(loopVariable!=null){\n        //头插法\n        if(loopVariable.val<loopPre.val){\n            for (tempNode=dummyNode;tempNode!=loopVariable;tempNode=tempNode.next){\n                if(tempNode.val>loopVariable.val){\n                    //System.out.println(loopVariable.val);\n                    //printList(dummyNode.next);\n                    //先处理好loopVariable的前后节点\n                    loopPre.next=loopVariable.next;\n                    //再处理tempNode前后的节点\n                    loopVariable.next=tempNode;\n                    tempPre.next=loopVariable;\n                    //loopVariable 归位\n                    loopVariable=loopPre;\n                    break;\n                }\n                tempPre=tempNode;\n            }\n        }\n        loopPre=loopVariable;\n        loopVariable=loopVariable.next;\n    }\n    return dummyNode.next;\n}\n```\n这题整体思路就是按照插入排序的思路来的，值得注意的就是链表只能正向遍历，而且需要考虑保存的节点有两个，插入位置的前一个，以及待插入的前一个(头插法)。\n\n## [148. 排序链表](https://leetcode-cn.com/problems/sort-list)\n\n在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n\n**示例 1:**\n\n输入: 4->2->1->3\n输出: 1->2->3->4\n示例 2:\n\n输入: -1->5->3->4->0\n输出: -1->0->3->4->5\n\n>上面那题时间复杂度明显是O(n2)最坏，这题要求是O(nlogn)和常数空间上面的插入肯定不适合了\n\n**解法一**\n\n```java\n//归并排法\npublic static  ListNode sortList(ListNode head) {\n    if(head==null||head.next==null)return null;\n    return mergeSort(head);\n}\n\npublic static ListNode mergeSort(ListNode head){\n    if(head.next==null){\n        return head;\n    }\n    ListNode fast=head;\n    ListNode slow=head;\n    ListNode pre=head;\n    while(fast!=null&&fast.next!=null){\n        pre=slow;\n        fast=fast.next.next;\n        slow=slow.next;\n    }\n    pre.next=null;\n    //这里要注意断开两条链表不然后面不方便找中点\n    ListNode left = mergeSort(head);\n    //归并左边\n    ListNode right = mergeSort(slow);\n    //归并右边\n    return merge2list(left,right);\n    //返回 左右两条链表归并结果\n}\n\npublic static ListNode merge2list(ListNode headA,ListNode headB){\n    if(headA==null)return headB;\n    if(headB==null)return headA;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=headA;\n    ListNode temp=dummyNode;\n    while(headA!=null&&headB!=null){\n        if(headA.val>headB.val){\n            temp.next=headB;\n            headB=headB.next;\n        } else{\n            temp.next=headA;\n            headA=headA.next;\n        }\n        temp=temp.next;\n    }\n    temp.next=headA==null?headB:headA;\n    return dummyNode.next;\n}\n```\n\n4ms 85%  标准的`归并操作`分治的思想，但是我还是扣了好长时间，最后还是看了别人的代码才知道，其实一开始就想到了`快慢指针找中点`但是感觉时间复杂度可能会变得更高就没那样做。。。还是太菜了时间复杂度都不会分析。。。这里有一个小地方就是找到中点之后要记得断开中点和后面链表的连接，这样会方便后面归并，不然就需要传递一个边界的指针那样又会有很多问题（没错我开始就是这么做的😭）\n\n下面这种是后来又写的`经典快排`，400ms，12% 我都怀疑我到底写了个啥？后来把插入拿来试了下884+ms然后又看了一遍才相信我写的是快排。\n\n```java\n//我自己写的快排\npublic static ListNode sortList4(ListNode head){\n    if(head==null||head.next==null)return head;\n    sortList(head,null);\n    return head;\n}\n\n//快排实现\npublic static void sortList(ListNode head,ListNode tail) {\n    if(tail==head){\n        return;\n    }\n    //确定枢纽元素\n    ListNode base=partion(head,tail);\n    sortList(head,base);\n    sortList(base.next,tail);\n}\n\n//看了下别人的博客也学到了一种快排的新思路\n//慢指针左边都是小于base枢纽元素的，快指针和慢指针中间都是大于等于base枢纽元素的\n//慢指针后面的都是未知区域\npublic static ListNode partion(ListNode head,ListNode tail){\n    ListNode base=head;\n    ListNode fast=head.next;\n    ListNode slow=head;\n    // 3  1  3  2  5  -1 0\n    //    s  f\n    while(fast!=tail){\n        if(fast.val<=base.val){\n            //交换两个节点的值\n            swap(fast,slow.next);\n            slow=slow.next;\n        }\n        fast=fast.next;\n    }\n    //归位\n    swap(head,slow);\n    //应该可以试试返回区间\n    return slow;\n}\n\npublic static void swap(ListNode a,ListNode b){\n    int temp=a.val;\n    a.val=b.val;\n    b.val=temp;\n}\n```\n\n> 实际上快排确实不适合链表（下面光速打脸）因为毕竟不是数组可以从两边开始遍历，链表每次都需要遍历整个链表才能划分好基准位置。\n\n看了下前几的代码发现了这个，`非标准的三向切分的快排`，为啥说是非标准呢？看下面代码就知道了，我给加了注释\n\n```java\npublic static ListNode sortList3(ListNode head) {\n    ListNode node = new ListNode(0);\n    node.next = head;\n    sort(node, null);\n    return node.next;\n}\n\nprivate  static void sort(ListNode from, ListNode to) {\n    if (from == null || from == to || from.next == to || from.next.next == to)return;\n    int v = from.next.val;\n    //基准元素\n    ListNode mid = from;\n    //切分点指针\n    ListNode equal = from.next;\n    //等于区域右边界\n    ListNode node = from.next;\n    //遍历用的指针\n    while (node.next != to) {\n        //node不到头  左开右开区间（from,to）\n        if (node.next.val < v) {\n            //小于基准位置元素\n            //保存当前节点的下一个元素，用于插入节点\n            //小于基准元素的节点\n            ListNode currentNext = node.next.next;\n            //保存切分点的下一个元素，作用同上\n            ListNode midNext = mid.next;\n            //交换node.next和mid\n            //纸上画一下就了解了\n            mid.next = node.next;\n            node.next.next = midNext;\n            node.next = currentNext;\n            //切分点后移\n            mid = mid.next;\n        } else if (node.next.val == v) {\n            //node的下一个等于基准元素\n            //3 1 2 3 4 5 6\n            if (equal == node) {\n                //等于区域和node.next==val相邻了，直接跳过\n                equal = node.next;\n                node = node.next;\n            } else {\n                //将node.next插入equal后面\n                //然后equal向后移动\n                //和上面的类似\n                ListNode nodeNext = node.next.next;\n                ListNode equalNext = equal.next;\n                equal.next = node.next;\n                node.next.next = equalNext;\n                node.next = nodeNext;\n                equal = equal.next;\n            }\n        } else {\n            //大于直接跳过\n            node = node.next;\n        }\n    }\n    // [mid.next---equal] 为等于val的节点\n    sort(from, mid.next);\n    sort(equal, to);\n}\n```\n\n整体思路就是一共有三个指针，`mid`(切分点)  `equal`(等于区) `node`(遍历指针) node从from遍历到to，注意这里是`左开右开区间` 就是说头from和尾to都取不到，然后将小与base的节点插入到mid的后面，然后mid后移，等于区插入到equal的后面，最后形成的就是`[mid.next---equal]` 为等于val的节点，然后对子区域递归就ok了，这个用时 `4ms` 。。。。。。还要继续加油啊！！！\n\n\n## [138.复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer)\n\n给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。\n\n要求返回这个链表的深拷贝。 \n\n**示例：**\n\n![mark](http://static.imlgw.top///20190308/tR8e3eu2yqaq.png?imageslim)\n\n```c\n输入：\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1}`\n解释：\n节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。\n节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。\n```\n**提示：**\n\n你必须返回给定头的拷贝作为对克隆列表的引用。\n\n**解法一** \n\n利用Map保存原链表和复制链表的对应关系\n\n```java\npublic static Node copyRandomList(Node head) {\n    Map<Node,Node> copNode =new HashMap<>();\n    Node temp=head;\n    while(temp!=null){\n        //建立对应关系\n        copNode.put(temp,new Node(temp.val,null,null));\n        temp=temp.next;\n    }\n    //再循环一次复制next和Radom节点\n    temp=head;\n    while(temp!=null){\n        copNode.get(temp).next=copNode.get(temp.next);\n        copNode.get(temp).random=copNode.get(temp.random);\n        temp=temp.next;\n    }\n    return copNode.get(head);\n}\n```\n第一个循环利用Map将原链表和拷贝链表形成对应关系，第二个循环就是直接给拷贝链表的next域和random域赋值。\n\n**解法二**\n\n奥义 影分身\n\n```java\npublic static Node copyRandomList2(Node head) {\n    if(head==null)return head;\n    Node temp=head;\n    //链表  奥义 - 影分身\n    while(temp!=null){\n        //这里直接将next域传入构造器完成和后面元素的连接\n        temp.next=new Node(temp.val,temp.next,null);\n        temp=temp.next.next;\n    }\n    temp=head;\n    //连接random域\n    while(temp!=null){\n        if(temp.random!=null){\n            temp.next.random=temp.random.next;\n        }\n        temp=temp.next.next;\n    }\n    temp=head;\n    // 分离\n    Node newHead=head.next;\n    Node next=null;\n    while(temp!=null){ //=将每个元素的next指向下一个的下一个\n        next=temp.next;\n        if(next!=null){\n            temp.next=next.next;\n        }\n        temp=next;\n    }\n    return newHead;\n}\n```\n为啥要叫影分身？因为帅...这种方法比上面的要快一点可能是创建hashMap比较耗时间，其实分析这两种方法其实都是先把链表拷贝了一份，然后通过对应关系来连接拷贝链表的next和random域，map是通过键值对的方式对应拷贝链表，这样可以方便的通过原链表找到拷贝链表的random. 然后上面这种方法也是一样，在原链表每个节点后面copy一个节点，然后根据前一个节点的random来找拷贝节点的random(前一个节点的random的next) 主要就是找到一个对应关系.\n\n> tips: 这题OJ上的0ms是有问题的，这题本意肯定也不是这个\n>\n> \n>\n> ![mark](http://static.imlgw.top///20190308/p1GPgJVYaURp.png?imageslim)\n\n最开始能通过主要是OJ后台只判断了val的值，可以看出现在题目已经改了。现在肯定是跑不过的，可能是判断了random是不是new出来的(我试了下看了下返回这个)\n输入\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1}`\n输出\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":`\n\n`{\"$id\":\"3\",\"next\":null,\"random\":null,\"val\":2},\"val\":2},`\n\n`\"random\":{\"$id\":\"4\",\"next\":null,\"random\":null,\"val\":2},\"val\":1}`\n预期结果\n`{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1}`\n\n**解法三**\n\n重写了一遍，题目改了一点\n\n```java\npublic Node copyRandomList(Node head) {\n    if(head==null) return null;\n    Node temp=head;\n    while(temp!=null){\n        Node next=temp.next;\n        Node newNode=new Node(temp.val);\n        temp.next=newNode;\n        newNode.next=next;\n        temp=next;\n    }\n    temp=head;\n    //重写的时候想把random连接和分离一起做\n    //然后就错了。。。\n    //这里next域的变化就会导致后面random域的变化，最后结果就错了\n    while(temp!=null){\n        Node next=temp.next.next;\n        if(temp.random!=null){\n            temp.next.random=temp.random.next;\n        }\n        temp=next;\n    }\n    Node newHead=head.next;\n    temp=head;\n    //将每个元素的next域指向下一个的下一个就行了\n    while(temp!=null){\n        Node next=temp.next;\n        if(next!=null){\n            temp.next=next.next;\n        }\n        temp=next;\n    }\n    return newHead;\n}\n```\n\n## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n**示例:**\n\n给定 1->2->3->4, 你应该返回 2->1->4->3.\n\n**解法一**\n\n```java\npublic ListNode swapPairs(ListNode head) {\n    if(head==null||head.next==null)return head;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode nex=head.next;\n    ListNode cur=head;\n    ListNode pre=dummyNode;\n    // -1|1 2 3 4\n    while(nex!=null){\n        pre.next=nex;\n        cur.next=nex.next;\n        nex.next=cur;\n        pre=cur;\n        if(cur.next==null){\n            return dummyNode.next;\n        }\n        cur=cur.next;\n        nex=cur.next;\n    }\n    return dummyNode.next;\n}\n```\n其实跟反转链表是一样的，三个指针分别记录前 中 后三个节点然后逆序，只不过步长不一样，这里step为2，一次走两步， 我上面的代码可能写的有些乱，思路还是一样的\n\n**解法二**\n\n```java\n//递归版本\npublic ListNode swapPairs(ListNode head) {\n    if(head==null||head.next==null){\n        return head;\n    }\n    ListNode next=head.next;\n    head.next=swapPairs(next.next);\n    next.next=head;\n    return next;\n}\n```\n递归是真的简洁，我最开始写反转链表的递归就是这么写的😂\n\n\n## [25.K个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。\n\n**示例 :**\n\n```java\n给定这个链表：1->2->3->4->5\n当 k = 2 时，应当返回: 2->1->4->3->5\n当 k = 3 时，应当返回: 3->2->1->4->5\n```\n\n**说明 :**\n\n- 你的算法只能使用常数的额外空间。\n- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n**解法一**\n\n```java\n//非递归，理一下思路： 记录每次翻转前后的节点 然后翻转返回头 将每 K 个元素当成一个整体\npublic static ListNode reverseKGroup(ListNode head,int k) {\n    if(head==null||head.next==null)return head;\n    ListNode dummyNode=new ListNode(-1);\n    dummyNode.next=head;\n    ListNode pre=dummyNode;\n    ListNode cur=head;\n    ListNode next=head;\n    ListNode temp;\n    while(next!=null){\n        //temp 保存 cur 方便后面连接  K+1位置的元素\n        temp=cur;\n        //k 个一组翻转\n        int step=k;\n        while(step>0 && next!=null){\n            //next走到 K+1 位置节点\n            next=next.next;\n            step--;\n            //小细节 k>链表长度时应该直接返回（我认为）等下提交了看看\n            //所以直接应该直接返回 (掉了k的值判断 因为有可能刚好有k个元素)\n            if(next==null&& step!=0){\n                return dummyNode.next;\n            }\n        }\n        //翻转 cur--next.prev 返回头节点\n        //连接 反转后的头节点\n        pre.next=reverse(cur,k);\n        temp.next=next;\n        //pre temp向后移动\n        pre=temp;\n        cur=next;\n    }\n    return dummyNode.next;\n}\n\n// -1| 1 2 3 | 4 5 6 | 7 8\n//翻转链表并返回子链表\npublic static ListNode reverse(ListNode node,int k){\n    ListNode pre=null;\n    ListNode cur=node;\n    ListNode next=node;\n    while(k>0&&next!=null){\n        next=next.next;\n        cur.next=pre;\n        pre=cur;\n        cur=next;\n        k--;\n    }\n    //返回反转后的头节点\n    System.out.println(\"头\"+pre.val);\n    return pre;\n}\n```\n\n7ms 74% 也是我第一道做出来的困难题，[上一道困难题超时了](http://imlgw.top/2018/10/31/%E4%B8%80%E9%81%93LeetCode%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/)\n\n这题虽然说是困难题但是其实也不难，感觉就mid左右的水平，确实比上一题要复杂一点，但是只要思路理清楚其实也挺简单的，下面是我用OneNote画的一张图片。\n\n4个指针分别对应 K 链表的 前一个(pre)  K链表的头节点(cur) 没有翻转前的K链表的头节点and**翻转后的尾节点(temp)**   K链表的后一个节点(next)。然后其实就简单了，写一个翻转链表的函数然后返回头节点(也可以多加一个指针指向**翻转前的头节点**)，然后就简单了，next指针一次走K步，走到 K+1 位置 同时也是**下一次K链表的头节点**，而temp则为下一次K链表的pre...然后循环这个过程就行了，其实写成递归会很简洁，但是我是真的不会写递归，太菜了Orz\n\n![mark](http://static.imlgw.top///20190312/jl7moiy7PbjH.png?imageslim)\n\n**解法二**\n\n2020.2.23 时隔多年现在回头重新写了一个递归的写法，还是比较简洁的\n\n```java\n//时隔一年,回头自己写了一个递归的解法\npublic ListNode reverseKGroup(ListNode head, int k) {\n    if(head==null || k==1) return head;\n    int sum=0;\n    ListNode temp=head;\n    //预先计算链表的长度\n    while(temp!=null){\n        temp=temp.next;\n        sum++;\n    }\n    return reverse(head,k,sum);\n}\n\npublic ListNode reverse(ListNode head, int k,int remain) {\n    if(remain<k) return head; //ramain不足k个return \n    if(head==null) return head;\n    //正常的翻转操作\n    ListNode cur=head,pre=null,last=head;\n    int count=k;\n    while(count-- >0){\n        last=cur.next;\n        cur.next=pre;\n        pre=cur;\n        cur=last;\n    }\n    //下一次从last开始翻转,remain-k\n    head.next=reverse(last,k,remain-k);\n    return pre;\n}\n```\n**解法三**\n\n这题递归明显是不太符合要求的，空间复杂度不是常数的，如果有要求还是要写下面的解法\n\n```go\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    dummyNode := &ListNode{\n        Next: head,\n        Val:  -1,\n    }\n    pre := dummyNode\n    cur := head\n    //-1 | 1 2 3 4 5\n    for cur != nil {\n        for i := 0; i < k-1 && cur != nil; i++ {\n            cur = cur.Next\n        }\n        if cur == nil { //不足k个\n            break\n        }\n        next := cur.Next\n        cur.Next = nil \n        start := pre.Next\n        pre.Next = reverse(start)\n        start.Next = next\n        //这里要注意pre=start\n        pre = start\n        cur = next\n    }\n    return dummyNode.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var pre *ListNode\n    var cur = head\n    for cur != nil {\n        next := cur.Next\n        cur.Next = pre\n        pre = cur\n        cur = next\n    }\n    return pre\n}\n```\n隔一段时间就会重新写一遍，写肯定写的出来，就是要想清楚，最好搞个case在上面，一边模拟一边写\n> 做链表的题就是得细心啊，容易把自己绕进去，上面的解法就是看了题解才写出来的\n\n## [817. 链表组件](https://leetcode-cn.com/problems/linked-list-components)\n\n给定一个链表（链表结点包含一个整型值）的头结点 head。\n同时给定列表 G，该列表是上述链表中整型值的一个子集。\n返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。\n\n**示例 1：**\n\n```java\n输入: \nhead: 0->1->2->3\nG = [0, 1, 3]\n输出: 2\n解释: \n链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。\n```\n\n**示例 2：**\n\n```java\n输入: \nhead: 0->1->2->3->4\nG = [0, 3, 1, 4]\n输出: 2\n解释: \n链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。\n```\n\n**注意:**\n\n- 如果 N 是给定链表 head 的长度，1 <= N <= 10000。\n- 链表中每个结点的值所在范围为 [0, N - 1]。\n- 1 <= G.length <= 10000\n- G 是链表中所有结点的值的一个子集.\n\n**解法一**\n\n```java\npublic int numComponents(ListNode head, int[] G) {\n    if(head==null||head.next==null) return head;\n    ListNode temp=head;\n    int res=0;\n    while(temp!=null){\n        if(isInG(temp.val,G)){\n            while(temp!=null&&isInG(temp.val,G)){\n                temp=temp.next;\n            }\n            res++;\n            if(temp==null){\n                return res;\n            }\n        }\n        temp=temp.next;\n    }\n    return res;\n}\n\npublic static Boolean isInG(int val,int[] G){\n    for (int i=0;i<G.length;i++){\n        if(G[i]==val){\n            return true;\n        }\n    }\n    return false;\n}\n```\n首先想到的方法 91ms 19%..... 有点慢了，然后我稍微改了下。\n\n```java\npublic int numComponents2(ListNode head, int[] G) {\n    ListNode temp=head;\n    int res=0;\n    Boolean [] isInG=new Boolean[10000];\n    int j=0;\n    while(temp!=null){\n        for (int i=0;i<G.length;i++){\n            if(G[i]==temp.val){\n                isInG[j]=true;\n                break;\n            }\n        }\n        j++;\n        temp=temp.next;\n    }\n    temp=head;\n    for (int i=0;temp!=null;temp=temp.next,i++){\n        if(isInG[i]){\n            while(temp!=null&&isInG[i]){\n                temp=temp.next;\n                i++;\n            }\n            res++;\n            if(temp==null){\n                return res;\n            }\n        }\n    }\n    return res;\n}\n```\n   用了一个数组保存了每个位置的状态速度跟前面的差不多。。。主要问题就是那个数组的创建，这种创建方式用连续的下标来对应连续的链表的每个元素，每次都要遍历G才知道当前位置是不是在G中。\n\n   其实可以直接把当前节点的val作为数组的下标这样既有了对应关系也不用遍历G.可以说是很优秀了，但是实际上这样做是有前提条件的那就是链表中的元素值应该`没有负数`，还是题做少了啊 Orz。\n\n```java\npublic int numComponents3(ListNode head, int[] G) {\n    ListNode temp=head;\n    int res=0;\n    Boolean [] isInG=new Boolean[10000];\n    int j=0;\n    //换一种方式 以node.val作为数组的下标\n    for (int i:G){\n        isInG[i]=true;\n    }\n    while(temp!=null){\n        if(isInG[temp.val]){\n            while(temp!=null&&isInG[temp.val]){\n                temp=temp.next;\n            }\n            res++;\n            if(temp==null){\n                return res;\n            }\n        }\n        temp = temp.next;\n    }\n    return res;\n}\n```\n\n## [1019. 链表中的下一个更大节点](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/)\n\n给出一个以头节点 `head` 作为第一个节点的链表。链表中的节点分别编号为：`node_1, node_2, node_3, ...` 。\n\n每个节点都可能有下一个更大值（next larger **value**）：对于 `node_i`，如果其 `next_larger(node_i)` 是 `node_j.val`，那么就有 `j > i` 且  `node_j.val > node_i.val`，而 `j` 是可能的选项中最小的那个。如果不存在这样的 `j`，那么下一个更大值为 `0` 。\n\n返回整数答案数组 `answer`，其中 `answer[i] = next_larger(node_{i+1})` 。\n\n**注意：** 在下面的示例中，诸如 `[2,1,5]` 这样的**输入**（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。\n\n**示例 1：**\n\n```java\n输入：[2,1,5]\n输出：[5,5,0]\n```\n\n**示例 2：**\n\n```java\n输入：[2,7,4,3,5]\n输出：[7,0,5,5,0]\n```\n\n**示例 3：**\n\n```java\n输入：[1,7,5,1,9,2,5,1]\n输出：[7,9,9,9,0,5,0,0]\n```\n\n**提示：**\n\n1. 对于链表中的每个节点，`1 <= node.val <= 10^9`\n2. 给定列表的长度在 `[0, 10000]` 范围内\n\n**解法一**\n\n```java\npublic static int[] nextLargerNodes(ListNode head) {\n    //list里面存元素\n    ArrayList<Integer> A = new ArrayList<>();\n    for (ListNode node = head; node != null; node = node.next)\n                A.add(node.val);\n    int[] res = new int[A.size()];\n    //栈里面存索引\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 0; i < A.size(); ++i) {\n        while (!stack.isEmpty() && A.get(stack.peek()) < A.get(i))\n             res[stack.pop()] = A.get(i);\n        stack.push(i);\n    }\n    return res;\n}\n```\n\n新题，磨了好长时间，没做出来。。。真是菜啊 Orz，70ms，因为跑两遍。下面这个`14ms`可以说是相当快了，但，时间可能耗费在建立栈和list上了，看了下提交上的前几个都是用的数组，用数组模拟的栈。\n\n```java\n//和上面的方法差不多,但这个更快，上面那个跑了两遍\npublic static int[] nextLargerNodes3(ListNode head) {\n    int[] stack = new int[10000];\n    int[] res = new int[10000];\n    //temp是链表的副本，相当于上面的list\n    int[] temp = new int[10000];\n    //top 栈顶\n    int top = -1, i = 0;\n    ListNode node = head;\n    while (node != null) {\n        while (top != -1 && temp[stack[top]] < node.val){\n            //后一个大于当前节点, 栈不为空\n            //pop出比它小的元素并赋值res，重新生成单调栈\n            res[stack[top--]] = node.val;\n        }\n        stack[++top] = i;\n        temp[i++] = node.val;\n        node = node.next;\n    }\n    return Arrays.copyOf(res, i);\n}\n```\n\n思路就是利用`单调栈`，栈里面存的索引对应的元素都是单调递减的，遇到不递减的就会一直pop()直到再次单调递减。这样很容易就找到了每个元素的下一个最大元素了。\n\n19.7.21 重新做了一遍这道题，第一遍还是没想出来，还是看了之前的代码\n\n```java\npublic static int[] nextLargerNodes5(ListNode head) {\n        List<Integer> list=new ArrayList<>();\n        ListNode temp=head;\n        while(temp!=null){\n            list.add(temp.val);\n            temp=temp.next;\n        }\n        int [] stack=new int[10000];\n        int stackIndex=-1;\n        int [] res=new int[10000];\n        for (int i=0;i<list.size();i++) {\n            while(stackIndex!=-1 && list.get(i)>list.get(stack[stackIndex])){\n                res[stack[stackIndex--]]=list.get(i);\n            }\n            //维护一个递减的栈\n            stack[++stackIndex]=i;\n        }\n        return  Arrays.copyOf(res, list.size());\n}\n```\n\n相比上面的方法一，采用了数组模拟队列(数据范围已经给定了)，30ms，80% 。仔细看看代码发现其实第一个循环完全没有必要，可以一边遍历一边存进去。\n\n**一次遍历**\n\n```java\npublic static int[] nextLargerNodes6(ListNode head) {\n    List<Integer> list=new ArrayList<>();\n    ListNode temp=head;\n    int [] stack=new int[10000];\n    int stackIndex=-1;\n    int [] res=new int[10000];\n\n    for (int i=0;temp!=null;i++) {\n        list.add(temp.val);\n        while(stackIndex!=-1 && list.get(i)>list.get(stack[stackIndex])){\n            res[stack[stackIndex--]]=list.get(i);\n        }\n        //维护一个递减的栈\n        stack[++stackIndex]=i;\n        temp=temp.next;\n    }\n    return  Arrays.copyOf(res, list.size());\n}\n```\n\n优化后发现比之前还慢了。。。\n\n**数组模拟链表**\n\n```java\n public static int[] nextLargerNodes7(ListNode head) {\n        int [] list=new int[10000];\n        ListNode temp=head;\n        int [] stack=new int[10000];\n        int stackIndex=-1;\n        int [] res=new int[10000];\n\n        int i;\n        for ( i=0;temp!=null;i++) {\n            list[i]=temp.val;\n            while(stackIndex!=-1 && list[i]>list[stack[stackIndex]]){\n                res[stack[stackIndex--]]=list[i];\n            }\n            //维护一个递减的栈\n            stack[++stackIndex]=i;\n            temp=temp.next;\n        }\n        return  Arrays.copyOf(res, i);\n  }\n```\n\n这次提交了几次直接 8ms 100%了。。。\n\n","tags":["LeetCode","链表"],"categories":["算法"]},{"title":"常见的排序算法总结","url":"/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/","content":"\n## 常见排序算法总结\n关于排序的部分一直想总结下一直没时间，现在来总结下吧。gif图来自微信上的文章 (**五分钟学算法**的公众号，挺不错干货挺多的)，原理性的东西就不讲了，图讲的比我好。如果还是不懂可以看看《算法》里面的轨迹图，那个也很直观 \n\n### 冒泡排序 \n\n  ![weixin](http://static.imlgw.top/f02ace7b7fb9b810274e683c2be54a02_640_wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1.gif)\n\n```java\n//冒泡排序\nprivate static void MaoPaoSort(int []nums){\n    for (int i=nums.length-1;i>=0;i--){\n        for (int j=0;j<i;j++){\n            if(nums[j]>nums[j+1]){\n                swap(nums,j,j+1);\n            }\n        }\n    }\n}\n```\n### 选择排序\n\n![weixin](http://static.imlgw.top/640.gif)\n\n```java\n//选择排序\nprivate static void SelectSort(int []nums){\n    for (int i=0;i<nums.length;i++){\n        int min=nums[i];\n        for (int j=i+1;j<nums.length;j++){\n            if(nums[j]<min){\n                min=nums[j];\n                swap(nums,j,i);\n            }\n        }\n    }\n}\n```\n\n### 直接插入排序\n\n![weixin](http://static.imlgw.top/640%20%281%29.gif)\n\n```java\n//直接插入排序\nprivate static void InsertSort(int []nums){\n    for (int i=1;i<nums.length;i++){\n        for (int j=i;j>0&&nums[j]<nums[j-1];j--){\n            swap(nums,j,j-1);\n        }\n    }\n}\n```\n\n### 归并排序\n\n![weixin](http://static.imlgw.top/640%20%282%29.gif)\n\n#### 图上面的是递归版本的归并，实现如下\n\n```java\n//归并排序\nprivate static void MergerSort(int []nums){\n    help=new int[nums.length];\n    MergerSort(nums,0,nums.length-1);\n}\n\nprivate static void MergerSort(int []nums,int left,int right){\n    if(left>=right){\n        return;\n    }\n    //不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用merger2的方式(也不好，应该保证辅助数组只初始化一次)\n    //help=new int[nums.length];\n    int mid=left+((right-left)>>1);\n    MergerSort(nums,left,mid);\n    MergerSort(nums,mid+1,right);\n    merger(nums,left,mid,right);\n}\n\n//辅助数组\nprivate static int []help;\n\n//归并操作\nprivate static void merger(int []nums ,int left,int mid,int right){\n    int i=left,j=mid+1;\n    //其实没区别空间复杂度，都是O(N) 后面这个会更加耗费时间\n    //int []help=new int[right-left+1];\n    for (int k=left;k<=right;k++){\n        //一边的到达尽头,先判断两个边界,不然就要想下面那样写\n        if(i>mid){\n            help[k]=nums[j++];\n        } else if(j>right){\n            help[k]=nums[i++];\n        } else if(nums[i]>nums[j]){\n            help[k]=nums[j++];\n        } else{\n            //相等的时候左边先进栈保证稳定性\n            help[k]=nums[i++];\n        }\n        /*// 2 \n            if( i<=mid &&j<=right && nums[i]>nums[j]){\n                help[k]=nums[j++];\n            }else if( i<=mid &&j<=right && nums[i]<=nums[j]){\n                //相等的时候左边先进栈保证稳定性\n                help[k]=nums[i++];\n            }else if(i>mid){\n                help[k]=nums[j++];\n            }else if(j>right){ \n                help[k]=nums[i++];\n            }*/\n    }\n    //复制\n    for (int k=left;k<=right;k++){\n        nums[k]=help[k];\n    }\n\n    /*while (p1 <= m && p2 <= r) {\n            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];\n        }\n        while (p1 <= m) {\n            help[i++] = arr[p1++];\n        }\n        while (p2 <= r) {\n            help[i++] = arr[p2++];\n        }\n        for (i = 0; i < help.length; i++) {\n            arr[l + i] = help[i];\n        }*/\n}\n```\n\n#### 非递归版本\n\n```java\n//归并排序（非递归，方向不一样，时间复杂度一样都为O(NlogN)\nprivate static void MergerSortNoRecurse(int []nums){\n    help=new int[nums.length];\n    //控制合并的长度 \n    for (int sz=1;sz<nums.length;sz*=2){\n        //控制合并的向后移动\n        for (int i=0;i<nums.length-sz;i+=2*sz){\n            int r=i+2*sz-1<nums.length-1?i+2*sz-1:nums.length-1;\n            merger(nums,i,i+sz-1,r);\n        }\n    }\n}\n```\n\n### 三向切分的快排(荷兰国旗问题)\n\n![weixin](http://static.imlgw.top/640%20%283%29.gif)\n\n```java\n//快排 (不具有稳定性或者难以实现)\nprivate static void QuickSort(int []nums,int l,int r){\n    if(l>r){\n        return;\n    }\n    //随机一个数和r交换 ---随机快排\n    swap(nums, l + (int) (Math.random() * (r - l + 1)), r);\n    int []index=partition2(nums,l,r);\n    QuickSort(nums,l,index[0]-1);\n    QuickSort(nums,index[1]+1,r);\n}\n\npublic static int partition1(int []nums ,int l,int r){\n    int base = l;\n    //双指针\n    int lo = l, hi = r;\n    //这种partition的实现细节有点不好理解\n    //这种partition不能随机基准元素。。。。\n    //参照了左神的代码发现其实可以在partition之前随机一个变量和lo交换，也有同样的效果也消除了输入的影响\n    while (lo < hi) {\n        //必须先从右往左,主要是为了归位的时候不出现问题\n        //比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是lo和一个比lo大的数然而比lo大的数应该放在右边\n        //反之如果选的是hi为基准就要先从左往右\n        // 7  0  1  2    10  11  22\n        while (nums[hi] >= nums[base] && lo < hi) {\n            hi--;\n        }\n        while (nums[lo] <= nums[base] && lo < hi) {\n            lo++;\n        }\n        if (lo < hi) {\n            swap(nums, lo, hi);\n        }\n    }\n    //归位 lo==hi\n    swap(nums, hi, base);\n    return lo;\n}\n\n//荷兰国旗优化的快排\npublic static int[] partition2(int []arr ,int l,int r){\n    // 7  0  1  2    10  11  22        \n    //小于区为空\n    int less=l-1;\n    //l ----> more 为待定区\n    int more=r;\n    while(l<more){\n        if(arr[l]<arr[r]){\n            swap(arr,++less,l++);\n        } else if(arr[l]>arr[r]){\n            //大于基准时 , 大于区扩大(大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能l++)\n            swap(arr,--more,l);\n        } else{\n            l++;\n        }\n    }\n    //和大于区间的第一个交换 保证归位正确,如果选取的是以最左边为基准元素 这里就应该和less交换\n    //到这里  [less+1,more-1]之间都是等于 基准元素 arr【r】 的\n    swap(arr,more,r);\n    //到这  [less+1,more]之间都是等于 基准元素 arr【r】 的\n    return new int[]{less+1,more};\n}\n```\n\n### 堆排序\n\n![weixin](http://static.imlgw.top/640%20%284%29.gif)\n\n```java\n//堆排序\nprivate static void HeapSort(int []nums){\n    if(nums.length<2){\n        return;\n    }\n    //构建大根堆\n    for (int i=0; i<nums.length; i++) {\n        heapInsert(nums,i);\n    }\n    //交换堆顶和最后一个节点\n    int size= nums.length;\n    swap(nums,size-1,0);\n    size--;\n    while(size>1){\n        //调整\n        heapIfy(nums,0,size);\n        //每次都和最后一个孩子节点交换，然后size--\n        swap(nums,--size,0);\n    }\n}\n\n//向上爬\nprivate static void heapInsert(int []nums, int index){\n    //迭代比较当前节点和父节点的值的大小\n    while(nums[index]>nums[(index-1)/2]){\n        swap(nums,index,(index-1)/2);\n        index=(index-1)/2;\n    }\n}\n\n//向下爬\n//index位置的值变小后继续调整为大根堆\nprivate static void heapIfy(int []nums,int index,int size){\n    //左孩子\n    int left=index*2+1;\n    //节点有左孩子\n    while(left<size){\n        //判断是否有右孩子.....\n        //左右孩子里的最大值 有右孩子且右孩子大于左孩子\n        int largest=left+1<size && nums[left]<nums[left+1] ?left+1:left;\n        largest=nums[largest]>nums[index]?largest:index;\n        //最大值等于自己\n        if(largest==index){\n            break;\n        }\n        //交换大孩子节点和自己\n        swap(nums,largest,index);\n        //设置大孩子的index和左孩子\n        index=largest;\n        left=index*2+1;\n    }\n}\n```\n\n### 堆排序更优的做法\n\n上面的做法并不是最优的堆排序\n\n```java\npublic static void heapSort(int []nums){\n    int last=nums.length-1;\n    //N构建大根堆\n    //从倒数第二层开始\n    for (int i=nums.length/2-1 ;i>=0;i--){\n        heapIfy(nums,i,last);\n    }\n    //printArray(nums);\n    while(last>=1){\n        swap(nums,0,last--);\n        heapIfy(nums,0,last);\n    }\n}\n\n//i 大根堆调整\npublic static void heapIfy(int[] nums,int i,int last){\n    //判断有没有子节点（左孩子）\n    int left=i*2+1;\n    while(left<=last){\n        int right=left+1;\n        //左右节点最大值\n        int larger=right<=last && nums[right] > nums[left]?right:left;\n        if(nums[larger]>nums[i]){\n            swap(nums,larger,i);\n            i=larger;\n            left=larger*2+1;\n        } else{\n            break;\n        }\n    }\n}\n\npublic static  void  swap(int []nums,int a,int b){\n    int temp=nums[a];\n    nums[a]=nums[b];\n    nums[b]=temp;\n}\n```\n\n对比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的`insert`方式时间复杂度是`O(NlogN)`，其实仔细想想，这两种方式是完全相反的，insert的方式，最后一层每个元素最坏都可能调整`logN`次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的`heapIfy`方式最后一层都只需要调整`1`次，而根节点需要调整`logN`次，而根节点**只有一个**时间复杂度就会大大降低，最终的时间复杂度就是O(N)，[具体推算过程可以看这些回答](https://www.zhihu.com/question/20729324) \n\n**手推过程**\n\n![img](http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim)\n\n最后推得到得复杂度是小于`O(2N)`，也就是`O(N)`的时间复杂度，如果不是刷`leetCode` 看到了类似的题可能会一直被那样去写😂\n\n**再回首**\n\n时隔多年，又回头写了一个，写了大概半个小时左右，边写边回忆，感觉这个写法比上面好一点点，所以记录一下\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int[] nums=new int[N];\n        for(int i=0;i<N;i++)nums[i]=sc.nextInt();\n        heapSort(nums);\n        for(int i=0;i<N;i++)System.out.print(nums[i]+\" \");\n    }\n\n    public static void heapSort(int[] nums){\n        //求左右孩子\n        //       0 \n        //   1       2\n        // 3   4   5   6 \n        //7                 7/2=3  4/2=1 8/2=4\n        //O(N)构建堆\n        for(int i=nums.length/2;i>=0;i--){ //从2/n开始down构建二叉树,不一定要精确,多一两个无所谓\n            down(nums,i,nums.length);\n        }\n\n        int index=0,tail=nums.length;\n        //堆排,将堆头放到尾部\n        while(tail>0){\n            swap(nums,index,--tail);\n            down(nums,index,tail);\n        }\n    }\n\n    public static void down(int[] nums,int index,int size){\n        //求左右孩子\n        //      0 \n        //  1       2\n        //3   4   5   6\n        while(index*2+1 < size){ //还有孩子\n            int left=index*2+1,right=left+1;\n            //左右子树中的较大\n            int largeIndex = right<size && nums[left]<nums[right] ? right:left;\n            if(nums[index] >= nums[largeIndex]){\n                return;\n            }\n            swap(nums,index,largeIndex);\n            index=largeIndex;\n        }\n    }\n\n    public static void swap(int[] nums,int a,int b){\n        int temp=nums[a];\n        nums[a]=nums[b];\n        nums[b]=temp;\n    }\n}\n```\n\n\n\n### 希尔排序\n\n实际上写排序就是基于插入排序的，在它之上进行了数学上的优化。\n\n![image](http://static.imlgw.top/640%20%285%29.gif)\n\t实际上从逆序对的角度来看，基于比较的排序就是为了消除逆序对的个数，而诸如冒泡选择每次都只是交换相邻的两个元素，每次交换最多只减少一个逆序对，而希尔排序扩大了这个间距，就增大了减少逆序对的可能。不过要研究他的时间复杂度就是数学上的研究的问题了，至于每次间距都减半这个也是根据大样本测试下这种递增序列性能会更好 O(∩_∩)O\n\n```java\n//插入排序的改进\nprivate static void ShellSort(int [] nums){\n    int h=nums.length>>1;\n    while(h>0){\n        for (int i=h;i<nums.length;i++){\n            //实际上是增大了插入排序的间隙，最后还是对进行一次插入排序,不过那个时候的数据已经是高度有序了\n            for (int j=i;j-h>=0&&nums[j]<nums[j-h];j-=h) {\n                swap(nums,j,j-h);\n            }\n        }\n        h=h>>1;\n    }\n}\n```\n\n---\n### BUG\n排个序还能排出Bug？对的没错就是排出了Bug🤣 看看我最开始写的交换函数\n\n```java\nprivate static void swap(int []nums,int a,int b){\n    nums[a]=nums[a]^nums[b];\n    nums[b]=nums[a]^nums[b];\n    nums[a]=nums[a]^nums[b];\n}\n```\n为了抖这个机灵付出了惨痛的代价，之前用 >> 拿来当除2操作的时候就忽略了`优先级`的问题。。。那这里的机灵有什么问题呢？一个数异或同一个数两次就还原没毛病啊？But如果交换的两个数是同一个元素比如上面在数组中 a==b时 nums[a]异或了3次自己相当于`nums[a]^nums[a]^nums[a]^nums[a]=0^0=0`，最后就会出问题,其实开始前面的排序都没有出现问题，主要是后面的快排时发现了这个Bug因为快排为了避免数据分布的影响随机选取基准值，可能随机的是最后一个，而且快排的partition过程中也会有时也会自己和自己交换，最开始的第一步就是自己和直接交换，让小于区扩大。所以这个方法仅仅只能用来抖一抖机灵，没啥实际意义，以后还是要老老实实写，不然咋死的都不知道😁\n\n>  未完待续......还有一类非基于比较的排序 桶排序之类的等后面再来总结加上去.\n\n### 对数器\n直接拿的左神的对数器😄，所有排序都是经过对数器测试的。 *talk is cheap show me the code*\n\n\n```java\nimport java.util.Arrays;\nimport java.util.Random;\npublic class Sorts{\n    public static void main(String[] args) {\n        /*int []nums={1,0,-1,-22,213,4,535,-112,99999};\n        //ShellSort(nums);\n        //MaoPaoSort(nums);\n        //SelectSort(nums);\n        //MergerSort(nums,0,nums.length-1);\n        QuickSort(nums,0,nums.length-1);\n        printArray(nums);*/\n        int testTime = 10000;\n        int maxSize = 10000;\n        int maxValue = 100;\n        Boolean succeed = true;\n        for (int i = 0; i < testTime; i++) {\n            int[] arr1 = generateRandomArray(maxSize, maxValue);\n            int[] arr2 = copyArray(arr1);\n            long time=System.currentTimeMillis();\n            //冒泡\n            //MaoPaoSort(arr1);\n            //选择\n            //SelectSort(arr1);\n            //插入\n            //InsertSort(arr1);\n            //归并\n            //MergerSort(arr1);\n            //非递归归并\n            //MergerSortNoRecurse(arr1);\n            //希尔\n            //ShellSort(arr1);\n            //快排\n            //QuickSort(arr1,0,arr1.length-1);\n            //堆排序\n            HeapSort(arr1);\n            long time2=System.currentTimeMillis();\n            if(i==0){\n                System.out.println(time2-time);\n            }\n            //系统排序\n            comparator(arr2);\n            if(i==0){\n                System.out.println(System.currentTimeMillis()-time2);\n            }\n            if (!isEqual(arr1, arr2)) {\n                succeed = false;\n                printArray(arr1);\n                printArray(arr2);\n                break;\n            }\n        }\n        System.out.println(succeed ? \"Nice!\" : \"Fucking fucked!\");\n    }\n    //初级排序算法\n    //************************************************************************\n    //冒泡排序\n    private static void MaoPaoSort(int []nums){\n        for (int i=nums.length-1;i>=0;i--){\n            for (int j=0;j<i;j++){\n                if(nums[j]>nums[j+1]){\n                    swap(nums,j,j+1);\n                }\n            }\n        }\n    }\n    //************************************************************************\n    //选择排序\n    private static void SelectSort(int []nums){\n        for (int i=0;i<nums.length;i++){\n            int min=nums[i];\n            for (int j=i+1;j<nums.length;j++){\n                if(nums[j]<min){\n                    min=nums[j];\n                    swap(nums,j,i);\n                }\n            }\n        }\n    }\n    //************************************************************************\n    //直接插入排序\n    private static void InsertSort(int []nums){\n        for (int i=1;i<nums.length;i++){\n            for (int j=i;j>0&&nums[j]<nums[j-1];j--){\n                swap(nums,j,j-1);\n            }\n        }\n    }\n    //************************************************************************\n    //插入排序的改进\n    private static void ShellSort(int [] nums){\n        int h=nums.length>>1;\n        while(h>0){\n            for (int i=h;i<nums.length;i++){\n                //实际上是增大了插入排序的间隙，最后还是对进行一次插入排序,不过那个时候的数据已经是高度有序了\n                for (int j=i;j-h>=0&&nums[j]<nums[j-h];j-=h) {\n                    swap(nums,j,j-h);\n                }\n            }\n            h=h>>1;\n        }\n    }\n    //************************************************************************\n    //归并排序\n    private static void MergerSort(int []nums){\n        help=new int[nums.length];\n        MergerSort(nums,0,nums.length-1);\n    }\n    private static void MergerSort(int []nums,int left,int right){\n        if(left>=right){\n            return;\n        }\n        //不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用merger2的方式(也不好，应该保证辅助数组只初始化一次)\n        //help=new int[nums.length];\n        int mid=left+((right-left)>>1);\n        MergerSort(nums,left,mid);\n        MergerSort(nums,mid+1,right);\n        merger(nums,left,mid,right);\n    }\n    //辅助数组\n    private static int []help;\n    //归并操作\n    private static void merger(int []nums ,int left,int mid,int right){\n        int i=left,j=mid+1;\n        //其实没区别空间复杂度，都是O(N) 后面这个会更加耗费时间\n        //int []help=new int[right-left+1];\n        for (int k=left;k<=right;k++){\n            //一边的到达尽头,先判断两个边界,不然就要想下面那样写\n            if(i>mid){\n                help[k]=nums[j++];\n            } else if(j>right){\n                help[k]=nums[i++];\n            } else if(nums[i]>nums[j]){\n                help[k]=nums[j++];\n            } else{\n                //相等的时候左边先进栈保证稳定性\n                help[k]=nums[i++];\n            }\n            /*// 2 \n            if( i<=mid &&j<=right && nums[i]>nums[j]){\n                help[k]=nums[j++];\n            }else if( i<=mid &&j<=right && nums[i]<=nums[j]){\n                //相等的时候左边先进栈保证稳定性\n                help[k]=nums[i++];\n            }else if(i>mid){\n                help[k]=nums[j++];\n            }else if(j>right){ \n                help[k]=nums[i++];\n            }*/\n        }\n        //复制\n        for (int k=left;k<=right;k++){\n            nums[k]=help[k];\n        }\n        //asddsdasdasdasd\n        /*while (p1 <= m && p2 <= r) {\n            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];\n        }\n        while (p1 <= m) {\n            help[i++] = arr[p1++];\n        }\n        while (p2 <= r) {\n            help[i++] = arr[p2++];\n        }\n        for (i = 0; i < help.length; i++) {\n            arr[l + i] = help[i];\n        }*/\n    }\n    //归并排序（非递归，方向不一样，时间复杂度一样都为O(NlogN)\n    private static void MergerSortNoRecurse(int []nums){\n        help=new int[nums.length];\n        //控制合并的长度 \n        for (int sz=1;sz<nums.length;sz*=2){\n            //控制合并的向后移动\n            for (int i=0;i<nums.length-sz;i+=2*sz){\n                int r=i+2*sz-1<nums.length-1?i+2*sz-1:nums.length-1;\n                merger(nums,i,i+sz-1,r);\n            }\n        }\n    }\n    //************************************************************************\n    //快排 (不具有稳定性或者难以实现)\n    private static void QuickSort(int []nums,int l,int r){\n        if(l>r){\n            return;\n        }\n        //随机一个数和r交换 ---随机快排\n        swap(nums, l + (int) (Math.random() * (r - l + 1)), r);\n        int []index=partition2(nums,l,r);\n        QuickSort(nums,l,index[0]-1);\n        QuickSort(nums,index[1]+1,r);\n    }\n    public static int partition1(int []nums ,int l,int r){\n        int base = l;\n        //双指针\n        int lo = l, hi = r;\n        //这种partition的实现细节有点不好理解\n        //这种partition不能随机基准元素。。。。\n        //参照了左神的代码发现其实可以在partition之前随机一个变量和lo交换，也有同样的效果也消除了输入的影响\n        while (lo < hi) {\n            //必须先从右往左,主要是为了归位的时候不出现问题\n            //比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是lo和一个比lo大的数然而比lo大的数应该放在右边\n            //反之如果选的是hi为基准就要先从左往右\n            // 7  0  1  2    10  11  22\n            while (nums[hi] >= nums[base] && lo < hi) {\n                hi--;\n            }\n            while (nums[lo] <= nums[base] && lo < hi) {\n                lo++;\n            }\n            if (lo < hi) {\n                swap(nums, lo, hi);\n            }\n        }\n        //归位 lo==hi\n        swap(nums, hi, base);\n        return lo;\n    }\n    //荷兰国旗优化的快排\n    public static int[] partition2(int []arr ,int l,int r){\n        // 7  0  1  2    10  11  22        \n        //小于区为空\n        int less=l-1;\n        //l ----> more 为待定区\n        int more=r;\n        while(l<more){\n            if(arr[l]<arr[r]){\n                swap(arr,++less,l++);\n            } else if(arr[l]>arr[r]){\n                //大于基准时 , 大于区扩大(大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能l++)\n                swap(arr,--more,l);\n            } else{\n                l++;\n            }\n        }\n        //和大于区间的第一个交换 保证归位正确,如果选取的是以最左边为基准元素 这里就应该和less交换\n        //到这里  [less+1,more-1]之间都是等于 基准元素 arr【r】 的\n        swap(arr,more,r);\n        //到这  [less+1,more]之间都是等于 基准元素 arr【r】 的\n        return new int[]{less+1,more};\n    }\n    //************************************************************************\n    //堆排序\n    private static void HeapSort(int []nums){\n        if(nums.length<2){\n            return;\n        }\n        //构建大根堆\n        for (int i=0; i<nums.length; i++) {\n            heapInsert(nums,i);\n        }\n        //交换堆顶和最后一个节点\n        int size= nums.length;\n        swap(nums,size-1,0);\n        size--;\n        while(size>1){\n            //调整\n            heapIfy(nums,0,size);\n            //每次都和最后一个孩子节点交换，然后size--\n            swap(nums,--size,0);\n        }\n    }\n    //向上爬\n    private static void heapInsert(int []nums, int index){\n        //迭代比较当前节点和父节点的值的大小\n        while(nums[index]>nums[(index-1)/2]){\n            swap(nums,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n    //向下爬\n    //index位置的值变小后继续调整为大根堆\n    private static void heapIfy(int []nums,int index,int size){\n        //左孩子\n        int left=index*2+1;\n        //节点有左孩子\n        while(left<size){\n            //判断是否有右孩子.....\n            //左右孩子里的最大值 有右孩子且右孩子大于左孩子\n            int largest=left+1<size && nums[left]<nums[left+1] ?left+1:left;\n            largest=nums[largest]>nums[index]?largest:index;\n            //最大值等于自己\n            if(largest==index){\n                break;\n            }\n            //交换大孩子节点和自己\n            swap(nums,largest,index);\n            //设置大孩子的index和左孩子\n            index=largest;\n            left=index*2+1;\n        }\n    }\n    //************************************************************************\n    private static void swap(int []nums,int a,int b){\n        //不知道为啥快排交换的时候这样写会出现很多0\n        //查询知道，当a==b时自己和直接交换，a异或自己4次后a==0.....\n        nums[a]=nums[a]^nums[b];\n        nums[b]=nums[a]^nums[b];\n        nums[a]=nums[a]^nums[b];\n        /*int temp=nums[a];\n        nums[a]=nums[b];\n        nums[b]=temp;*/\n    }\n    // for test  对数器\n    public static void comparator(int[] arr) {\n        Arrays.sort(arr);\n    }\n    // for test\n    public static int[] generateRandomArray(int maxSize, int maxValue) {\n        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());\n        }\n        return arr;\n    }\n    // for test\n    public static int[] copyArray(int[] arr) {\n        if (arr == null) {\n            return null;\n        }\n        int[] res = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n    // for test\n    public static Boolean isEqual(int[] arr1, int[] arr2) {\n        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {\n            return false;\n        }\n        if (arr1 == null && arr2 == null) {\n            return true;\n        }\n        if (arr1.length != arr2.length) {\n            return false;\n        }\n        for (int i = 0; i < arr1.length; i++) {\n            if (arr1[i] != arr2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // for test\n    public static void printArray(int[] arr) {\n        if (arr == null) {\n            return;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n\n\n​\t\t\n\n\n","tags":["数据结构","排序"],"categories":["算法"]},{"title":"NodeJS模仿Express封装路由","url":"/2018/12/03/nodejs-mo-fang-express-feng-zhuang-lu-you/","content":"\n## NodeJS模仿Express封装路由\n\n_最近才开始学NodeJs也不知道为啥就突然对这个很感兴趣,(可能Java写烦了😄)，感觉用这个开发还是挺快的，而且性能也很好，借此也了解下函数式编程的特点和异步编程的思想。_\n\n- ### 没封装前\n  原生的就差不多是这样的。\n\n```java\n\t/* \n\t    Node.js 未封装 1.0\n\t*/\n\tconst http = require(\"http\");\n\tconst fs = require(\"fs\");\n\tconst path = require(\"path\");\n\tconst querystring = require(\"querystring\"); //json转换\n\tconst scores = require(\"./StudentScore.json\");\n\tconst template = require(\"art-template\");\n\thttp.createServer((req, resp) => {\n\t    if (req.url.startsWith(\"/query\") && req.method == 'GET') {\n\t        //这里可以采用模板为了和下面的对比一下\n\t        fs.readFile(path.join(__dirname, \"querypage.html\"), (err, content) => {\n\t            if (err) {\n\t                resp.writeHead(500, {\n\t                    'Content-Type': 'text/plain;charset=utf8'\n\t                });\n\t                resp.end('服务器错误');\n\t            }\n\t            resp.end(content);\n\t        });\n\t    } else\n\t    if (req.url.startsWith(\"/scores\")) {\n\t        let pdata = '';\n\t        //事件绑定\n\t        //获取数据（id）\n\t        req.on('data', (ck) => {\n\t            pdata += ck;\n\t        });\n\t        //在这里返回\n\t        req.on('end', () => {\n\t            let obj = querystring.parse(pdata); //将参数 的字符串转换成 对象\n\t            let result = scores[obj.stunum];\n\t            let content = template(path.join(__dirname, \"scores.art\"), result);\n\t            resp.end(content);\n\t        });\n\t    }\n\t}).listen(9999, () => {\n\t    console.log('Server is runing on 9999');\n\t});\n```\n\n- Express的方式\n通过const app=express(); 获得一个app的对象后面就通过这个来操作\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/D~KS%28D1%5B%5DUS5TBZPO7KTJ88.png)\n- 手动封装\n\n```java\n\tvar url = require('url');\n\t\n\t//封装方法改变res  绑定res.send()\n\tfunction changeRes(res) {\n\t\n\t    res.send = function(data) {\n\t\n\t        res.writeHead(200, {\n\t            \"Content-Type\": \"text/html;charset=utf-8\"\n\t        });\n\t\n\t        res.end(data);\n\t    }\n\t}\n\t\n\t//定义暴露的模块  return 里面定义的模块\n\tvar Server = function() {\n\t\n\t\n\t    var G = this; /*全局变量*/\n\t\n\t    //处理get和post请求\n\t    this._get = {};\n\t\n\t    this._post = {};\n\t\n\t\n\t\n\t    var app = function(req, res) {\n\t\n\t\n\t        changeRes(res);\n\t\n\t        //获取路由\n\t        var pathname = url.parse(req.url).pathname;\n\t        if (!pathname.endsWith('/')) {\n\t            pathname = pathname + '/';\n\t        }\n\t\n\t        //获取请求的方式 get  post\n\t        var method = req.method.toLowerCase();\n\t\n\t\n\t        if (G['_' + method][pathname]) {\n\t\n\t            if (method == 'post') { /*执行post请求*/\n\t\n\t                var postStr = '';\n\t                req.on('data', function(chunk) {\n\t\n\t                    postStr += chunk;\n\t                })\n\t                req.on('end', function(err, chunk) {\n\t                    //添加请求属性\n\t                    req.myBody = postStr; /*表示拿到post的值*/\n\t                    /*执行方法*/\n\t                    G['_' + method][pathname](req, res);\n\t                })\n\t            } else { /*执行get请求*/\n\t                G['_' + method][pathname](req, res); /*执行方法*/\n\t            }\n\t        } else {\n\t            res.end('no router');\n\t        }\n\t    }\n\t\n\t    //下面的都是为了做注册的操作\n\t    app.get = function(string, callback) {\n\t        if (!string.endsWith('/')) {\n\t            string = string + '/';\n\t        }\n\t        if (!string.startsWith('/')) {\n\t            string = '/' + string;\n\t\n\t        }\n\t\n\t        //    /login/\n\t        G._get[string] = callback;\n\t\n\t    }\n\t\n\t    app.post = function(string, callback) {\n\t        if (!string.endsWith('/')) {\n\t            string = string + '/';\n\t        }\n\t        if (!string.startsWith('/')) {\n\t            string = '/' + string;\n\t\n\t        }\n\t        //    /login/\n\t        G._post[string] = callback;\n\t\n\t        //G._post['dologin']=function(req,res){\n\t        //\n\t        //}\n\t    }\n\t\n\t    return app;\n\t\n\t}\n\t\n\tmodule.exports = Server();\n```\n\n- 封装后\n```java\n\tconst http = require(\"http\");\n\tconst url = require(\"url\");\n\t//引入自定义的路由模块\n\tconst myApp = require(\"./model/express-route.js\");\n\t\n\t//使用自定义的模块\n\thttp.createServer(myApp).listen(9999, () => {\n\t    console.log('Running 9999');\n\t});\n\t\n\tmyApp.get(\"/express\", (req, resp) => {\n\t    resp.send(\"模仿Express封装路由\");\n\t    console.log(req);\n\t});\n\tmyApp.post(\"/postExpress\", (req, resp) => {\n\t    resp.send(\"模仿Express封装路由\");\n\t    console.log(req.myBody);\n\t});\n```\n\n---\n通过这个体会下Express的封装\n\n\n\n\n\n","tags":["NodeJS","ES6","JavaScript"],"categories":["Web"]},{"title":"Java爬虫实战(一) ：爬取斗图社所有gif","url":"/2018/11/30/java-pa-chong-shi-zhan/","content":"## Java爬虫实战(一) ：爬取斗图社所有gif\n最近开始玩爬虫 , 还是挺有意思的 , 虽然写爬虫一般都是用Python比较方便，但是也没有必要为了写爬虫再学一门语言 ,虽然也挺简单，但是还是对Java比较习惯，后面可能会学Python但是目前还是先用java写着玩玩。\n\n**目标** \n[斗图社 ]( https://doutushe.com/)  上所有的图片。\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/%408Q0%601FQB2A2E4D%5D9M8%40VW8.png)\n\n**技术选择**\nJsoup，最开始看见这个我看成了Jsonp。。。我寻思着不是解决跨域的那个么?还能搞爬虫?这么牛掰的么😄\n关于Jsoup网上也有很多文档 [参考资料](http://www.open-open.com/jsoup/) \n还有一些其他的技术比如 httpclient+Xpath 还有htmlunit 还有 selenium 等等，等以后学了后再来秀一秀 😁\n\n---\n\n其实我写的第一个爬虫是copy的别人的博客上的，不过它爬取的是京东的，我爬的是淘宝的\n我也只是想参考下他的结构，但是我感觉他的有些类没什么实际意义。。然后我就直接自己写了。\n结构如下：\n\n- boot ：爬虫的入口\n- dao  ：dao\n- handle ：封装的处理查询结果集的类（这里没用）\n- model ：爬取的数据的模型\n- parse  ： 解析html的类\n- util     ： Jsoup工具类和dao的工具类和DB模板类\n\n首先建立数据模型DoutuModel\n\n```java\npublic class DoutuModel {\n\t    private Long id;\n\t    private String topic;\n\t    private String imgUrl;\n\t    private String title;\n\t\n\t    //数据库id自增\n\t    public DoutuModel(String topic, String imgUrl, String title) {\n\t        this.topic = topic;\n\t        this.imgUrl = imgUrl;\n\t        this.title = title;\n\t    }\n\t\n\t    public String getTopic() {\n\t        return topic;\n\t    }\n\t\n\t    public void setTopic(String topic) {\n\t        this.topic = topic;\n\t    }\n\t\n\t    public String getTitle() {\n\t        return title;\n\t    }\n\t\n\t    public void setTitle(String title) {\n\t        this.title = title;\n\t    }\n\t\n\t    public String getImgUrl() {\n\t        return imgUrl;\n\t    }\n\t\n\t    public void setImgUrl(String imgUrl) {\n\t        this.imgUrl = imgUrl;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public void setId(Long id) {\n\t        this.id = id;\n\t    }\n}\t\n```\n\n**主要记录下parse类**\n\n``` java\npublic static List<DoutuModel> getData2(String url) throws Exception {\n\t        //获取的数据，存放在集合中\n\t        List<DoutuModel> data = new ArrayList();\n\t        //采用Jsoup解析\n\t        //String url=\"https://doutushe.com/portal/article/index/id/5gK\";\n\t        String preurl = \"https://doutushe.com\";\n\t        //取到当前页的document\n\t        //取到内容页的所有图片\n\t        int page = 1;\n\t        while (true) {\n\t            Document doc = JsoupUtils.getHtmlDocument(url);\n\t            Elements imgList = doc.select(\"div[class=col-xs-12 col-sm-8 col-lg-9]\").select(\"img.lazy\");\n\t            String topic = doc.select(\"blockquote>p\").text();\n\t            for (Element imgelement : imgList) {\n\t                //异步的坏处体现出来了,这个明显是懒加载,要找就找数据源,直接获取src获取不到\n\t                //String imgUrl= imgelement.attr(\"src\");\n\t                String imgUrl = imgelement.attr(\"data-original\");\n\t                String title = imgelement.attr(\"title\");\n\t                data.add(new DoutuModel(topic, imgUrl, title));\n\t                //System.out.println(topic + \":\" + imgUrl + \":\" + title);\n\t            }\n\t            Elements pageUrls = doc.select(\"ul.pager\").select(\"a\");\n\t            //爬一页休息1秒\n\t            if (page % 10 == 0) {\n\t                Thread.sleep(1000);\n\t                System.out.println(\"第\" + (page/10) + \"页采集完 , 暂停-------\");\n\t            }\n\t            //最后一页也有两个按钮。。。看来要多观察页面\n\t            /*if (pageUrls.size() < 2) {\n\t                //说明到最后一页了\n\t                break;\n\t            }*/\n\t            url = preurl + pageUrls.get(1).attr(\"href\");\n\t            if (!url.matches(preurl + \"/portal/article/index/id/[a-zA-Z0-9_]*\")) {\n\t                break;\n\t            }\n\t            page++;\n\t        }\n\t        //返回数据\n\t        return data;\n}\n```\n其实一开始写的一个版本是从主页面爬的先获取每一页的链接，再获取每一页的主题的链接，再获取每个主题下的图片链接，一个三重for循环，速度确实比较慢。。。\n\n后来发现每一页都有下一页的链接。。。然后就可以直接从页面上爬，两个循环就可以了，但是一开始我判断边界的时候用的是在下面的链接的数量小于2但是一开始爬了好长时间结果报错了。。  然后我去看了下最后一页发现也有两个链接后面一个是全部的链接。。 。\n\n ![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/AT5%7BUKZN%24M%5B59V%5B1OU0S%5B7N.png)\n而且和上面的css是一样的但是和前面的每一页的链接的后缀不一样，所以就直接用正则表达式匹配url的后缀是否匹配\nRegex ：https://doutushe.com/portal/article/index/id/[a-zA-Z0-9_]*  后面的就是直接匹配任意视频\n而最后一页的全部链接是 ： https://doutushe.com/portal/index/index 所以就匹配不上直接break\n\n**爬图片的小细节** , 一开始没注意，他这个图片是懒加载的，也就是随着页面用js加载的， 直接src获取肯定获取不到的，因为jsoup是不支持异步的，用js操作的东西肯定爬不到。所以只能通过 data-orginal 获取。\n\ngithub  [仓库地址](https://github.com/imlgw/javaSpiders)\n\n---\n\n**结果**\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/X%28%7B%60H6YKH2LIW%24%25F2K4U53M.jpg)\n4243张图片，后面可以自己写个脚本把图片全部下载到本地或者用迅雷之类的下载工具。\n\n---\n后面会尝试下更多爬虫技术像 htmlunit这种支持异步的或者 selenium 这种直接操作浏览器的工具\n\n\n\n","tags":["爬虫","Java","misc"],"categories":["爬虫"]},{"title":"Spring-Security遇到的小问题","url":"/2018/11/26/springsecurity-pei-zhi-de-ji-ge-xiao-wen-ti/","content":"## Spring Security 配置 intercept-url 的小问题\n\n文档： http://www.fengfly.com/document/springsecurity3/core-web-filters.html\n\n```java\n<bean id=\"filterInvocationInterceptor\"\n     class=\"org.springframework.security.intercept.web.FilterSecurityInterceptor\">\n  <property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n  <property name=\"accessDecisionManager\" ref=\"accessDecisionManager\"/>\n  <property name=\"runAsManager\" ref=\"runAsManager\"/>\n  <property name=\"securityMetadataSource\">\n    <security:filter-security-metadata-source path-type=\"regex\">\n      <security:intercept-url pattern=\"\\A/secure/super/.*\\Z\" access=\"ROLE_WE_DONT_HAVE\"/>\n      <security:intercept-url pattern=\"\\A/secure/.*\\\" access=\"ROLE_SUPERVISOR,ROLE_TELLER\"/>\n    </security:filter-security-metadata-source>\n  </property>\n</bean>        \n```\n\n模式总是根据他们定义的顺序进行执行。因此很重要的是，把更确定的模式定义到列表的上面。 这会反映在你上面的例子中，更确定的/secure/super/模式放在没那么确定的 /secure/模式的上面。如果它们被反转了。/secure/会一直\n 被匹配，/secure/super/就永远也不会执行。\n\n----\n\n```java\n<http use-expressions=\"false\" entry-point-ref=\"casProcessingFilterEntryPoint\">\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_USER\"/>\n        <!--经过SpringSecurity的环境上下文，偶然发现一个小坑-->\n        <intercept-url pattern=\"/cart/*.do\" access=\"IS_AUTHENTICATED_ANONYMOUSLY\"/>\n        <csrf disabled=\"true\"/>\n        <!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前  ，after表示放在指定的位置之后  -->\n        <custom-filter ref=\"casAuthenticationFilter\"  position=\"CAS_FILTER\" />\n        <custom-filter ref=\"requestSingleLogoutFilter\" before=\"LOGOUT_FILTER\"/>\n        <custom-filter ref=\"singleLogoutFilter\" before=\"CAS_FILTER\"/>\n    </http>\n```\n一个小问题，就是大范围在前面会覆盖后面的小范围所以像我上面那么写/cart/*.do 就不会执行相当于没写，起不到作用。","tags":["Bug","Spring"],"categories":["踩坑记录"]},{"title":"CAS单点登陆系统Demo","url":"/2018/11/17/cas-dan-dian-deng-lu-xi-tong-ru-men/","content":"##  单点登陆系统 --CAS\n- 关于CAS的介绍网上都有。这里主要记录如何使用，如何配置和集成一些框架。\n- CAS架构图\n![OSS](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/CAS.PNG)\nCAS 的 SSO 实现方式可简化理解为： 1 个 Cookie 和 N 个 Session 。 CAS Server 创建 cookie，在所有应用认证时使用，各应用通过创建各自的 Session 来标识用户是否已登录。\n用 户在一个应用验证通过后，以后用户在同一浏览器里访问此应用时，客户端应用中的过滤器会在 session 里读取到用户信息，所以就不会去 CAS Server 认证。如果在此浏览器里访问别的 web 应用时，客户端应用中的过滤器在 session 里读取不到用户信息，就会去 CAS Server 的 login 接口认证，但这时CAS Server 会读取到浏览器传来的 cookie （ TGC ），所以 CAS Server 不会要求用户去登录页面登录，只是会根据 service 参数生成一个 Ticket ，然后再和 web 应用做一个验 证 ticket 的交互而已。\n\n### 1. 配置CAS服务端\n从上面的架构图也可以大概知道CAS运作的方式,首先配置好CAS的Server端，直接将CAS的war包拷到tomcat的webapp目录下然后启动tomcat自动解压就可以了，这里我设置的tomcat的端口是8888，地址栏输入localhost:8888/cas能看到CAS的登陆界面说明部署成功\n*  去除https\n\tCAS默认使用的是HTTPS协议，如果使用HTTPS协议需要SSL安全证书（需向特定的机构申请和购买） 。如果对安全要求不高或是在开发测试阶段，可使用HTTP协议。我们这里讲解通过修改配置，让CAS使用HTTP协议。\n\n\t* 修改cas的WEB-INF/deployerConfigContext.xml找到下面的配置\n<bean class=\"org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler\"\np:httpClient-ref=\"httpClient\"/>\n这里需要增加参数p:requireSecure=\"false\"，requireSecure属性意思为是否需要安全验证，即HTTPS，false为不采用\n   * 修改cas的/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml\n找到下面配置\n    <bean id=\"ticketGrantingTicketCookieGenerator\" class=\"org.jasig.cas.web.support.CookieRetrievingCookieGenerator\"\n      p:cookieSecure=\"true\"\n      p:cookieMaxAge=\"-1\"\n      p:cookieName=\"CASTGC\"\n      p:cookiePath=\"/cas\" />\n   * 参数p:cookieSecure=\"true\"，同理为HTTPS验证相关，TRUE为采用HTTPS验证，FALSE为不采用https验证。\n参数p:cookieMaxAge=\"-1\"，是COOKIE的最大生命周期，-1为无生命周期，即只在当前打开的窗口有效，关闭或重新打开其它窗口，仍会要求验证。可以根据需要修改为大于0的数字，比如3600等，意思是在3600秒内，打开任意窗口，都不需要验证。\n\t\t\n\t\t我们这里将cookieSecure改为false , cookieMaxAge 改为3600\n\n   * 修改cas的WEB-INF/spring-configuration/warnCookieGenerator.xml\n\t\t<bean id=\"warnCookieGenerator\" class=\"org.jasig.cas.web.support.CookieRetrievingCookieGenerator\"\n\t\tp:cookieSecure=\"true\"\n\t\tp:cookieMaxAge=\"-1\"\n\t\tp:cookieName=\"CASPRIVACY\"\n\t\tp:cookiePath=\"/cas\" />\n我们这里将cookieSecure改为false , cookieMaxAge 改为3600\n- 配置数据源\n   - cas有默认的密码但是实际中肯定是要从数据库中查的，所以我们需要配置下数据源\n   - 修改cas服务端中web-inf下deployerConfigContext.xml ，添加如下配置\n\t\t```java\n\t\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" \n\t\t p:driverClass=\"com.mysql.jdbc.Driver\"\n\t\t p:jdbcUrl=\"jdbc:mysql://127.0.0.1:3306/pinyougoudb?characterEncoding=utf8\"\n\t\t p:user=\"root\"\n\t\t p:password=\"123456\" />\n\t\t<bean id=\"passwordEncoder\"\n\t\tclass=\"org.jasig.cas.authentication.handler.DefaultPasswordEncoder\" \n\t\t c:encodingAlgorithm=\"MD5\"\n\t\t p:characterEncoding=\"UTF-8\" />\n\t\t<bean id=\"dbAuthHandler\" \n\t\t class=\"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler\"\n\t\t p:dataSource-ref=\"dataSource\"\n\t\t p:sql=\"select password from tb_user where username = ?\"\n\t\t p:passwordEncoder-ref=\"passwordEncoder\"/>\n\t\t```\n  - 然后在配置文件开始部分找到如下配置\n\t\n\t```java\n\t <bean id=\"authenticationManager\" class=\"org.jasig.cas.authentication.PolicyBasedAuthenticationManager\">\n\t        <constructor-arg>\n\t            <map>               \n\t                <entry key-ref=\"proxyAuthenticationHandler\" value-ref=\"proxyPrincipalResolver\" />\n\t                <entry key-ref=\"primaryAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" />\n\t            </map>\n\t        </constructor-arg>      \n\t        <property name=\"authenticationPolicy\">\n\t            <bean class=\"org.jasig.cas.authentication.AnyAuthenticationPolicy\" />\n\t        </property>\n\t</bean>\n\t```\n\t其中 <entry key-ref=\"primaryAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" />一句是使用固定的用户名和密码，我们在下面可以看到这两个bean ,如果我们使用数据库认证用户名和密码，需要将这句注释掉。\n\t添加下面这一句配置\n\t<entry key-ref=\"dbAuthHandler\" value-ref=\"primaryPrincipalResolver\"/>\n  - 将三个jar包加入到cas的lib目录下\n   ![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/casjar.PNG)\n\t第一个和第三个大家应该很熟悉了，中间的那个是cas对jdbc的支持包\n\t\n\n\n\n---\n### 2. 普通的web项目集成CAS\n 普通的web项目也就是没有使用Spring之类的框架而采用web.xml配置的普通项目\n* 2.1 为了方便我这里采用maven配置，先添加相应的依赖\n\t\t\n```java\n        <!-- cas -->\n        <dependency>\n            <groupId>org.jasig.cas.client</groupId>\n            <artifactId>cas-client-core</artifactId>\n            <version>3.3.3</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>servlet-api</artifactId>\n            <version>2.5</version>\n            <scope>provided</scope>\n        </dependency>\n```\n一个是cas客户端的核心包，一个是servlet的包，因为后面会写一些jsp\n然后添加tomcat插件我设置的端口为9002\n* 2.2 因为是普通的web项目所以配置的方式主要是通过web.xml来配置，直接上配置\n\n\t```java\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n\t         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n\t         version=\"2.5\">\n\t    <!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置 -->\n\t    <listener>\n\t        <listener-class>org.jasig.cas.client.session.SingleSignOutHttpSessionListener</listener-class>\n\t    </listener>\n\t    <!-- 该过滤器用于实现单点登出功能，可选配置。 -->\n\t    <filter>\n\t        <filter-name>CAS Single Sign Out Filter</filter-name>\n\t        <filter-class>org.jasig.cas.client.session.SingleSignOutFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS Single Sign Out Filter</filter-name>\n\t        <url-pattern>/* </url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器负责用户的认证工作，必须启用它 -->\n\t    <filter>\n\t        <filter-name>CASFilter</filter-name>\n\t        <filter-class>org.jasig.cas.client.authentication.AuthenticationFilter</filter-class>\n\t        <init-param>\n\t            <param-name>casServerLoginUrl</param-name>\n\t            <param-value>http://localhost:8888/cas/login</param-value>\n\t            <!--这里的server是服务端的IP -->\n\t        </init-param>\n\t        <init-param>\n\t            <param-name>serverName</param-name>\n\t            <param-value>http://localhost:9002</param-value>\n\t        </init-param>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CASFilter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器负责对Ticket的校验工作，必须启用它 -->\n\t    <filter>\n\t        <filter-name>CAS Validation Filter</filter-name>\n\t        <filter-class>org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter</filter-class>\n\t        <init-param>\n\t            <param-name>casServerUrlPrefix</param-name>\n\t            <param-value>http://localhost:8888/cas</param-value>\n\t        </init-param>\n\t        <init-param>\n\t            <param-name>serverName</param-name>\n\t            <param-value>http://localhost:9002</param-value>\n\t        </init-param>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS Validation Filter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器负责实现HttpServletRequest请求的包裹， 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 -->\n\t    <filter>\n\t        <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name>\n\t        <filter-class>\n\t            org.jasig.cas.client.util.*\n\t        </filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t    <!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 -->\n\t    <filter>\n\t        <filter-name>CAS Assertion Thread Local Filter</filter-name>\n\t        <filter-class>org.jasig.cas.client.util.AssertionThreadLocalFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>CAS Assertion Thread Local Filter</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t</web-app>\n\n\t```\n\n  * 用户认证过滤器(必选)**AuthenticationFilter**在上面的配置中需要两个参数一个是casServerLoginUrl顾名思义就是CASserver登陆的地址，比如我的是http://localhost:8888/cas/login ，第二个参数是**serverName** ,因为登陆成功后还是要返回你当前的应用所以需要将你当前的应用的地址传递给CASserver比如我的当前应用 http://localhost:9002/\n  * Ticket的校验过滤器(必选)**Cas20ProxyReceivingTicketValidationFilter** 与上面的过滤器类似也需要那两个参数，\t\t\t\t\t\t\t  配置了这两个过滤器CAS就能正常运行了\n  * 单点登出过滤器 **SingleSignOutFilter**，顾名思义就是用于单点登出  \n  * 另外还有两个过滤器都是为了获取登陆名配置的过滤器，配置一个就行。    \n#\n* 2.3 编写index.jsp(tomcat默认打开的页面)\n\t\n\t```java\n\t<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"\n\t         pageEncoding=\"utf-8\"%>\n\t<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n\t<html>\n\t<head>\n\t    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n\t    <title>一品优购</title>\n\t</head>\n\t<body>\n\t 采用web.xml配置的普通的web模块\n\t<%=request.getRemoteUser()%>\n\t <a href=\"http://localhost:8888/cas/logout?service=http://www.imlgw.top\">退出登录</a>>\n\t</body>\n\t</html>\n\t\n\t```\n\t 如果想让cas退出后跳转到指定的页面而不是CAS默认的页面也需要修改配置\n\t 修改cas系统的配置文件cas-servlet.xml\n\t <bean id=\"logoutAction\" class=\"org.jasig.cas.web.flow.LogoutAction\"\n\t p:servicesManager-ref=\"servicesManager\"\n\t p:followServiceRedirects=\"${cas.logout.followServiceRedirects:true}\"/>\n\t将cas.logout.followServiceRedirects改为true后，可以在退出时跳转页面到目标页面\n   然后就可以启动cas和你的应用来测试了。\n* 2.4 服务端界面改造\n   上面测试成功，但是真实的情况肯定不会用cas默认的那个页面做登陆需要改成你自己的登陆界面，然后你当前应用的登陆页面就没用了。\n  \n\t```java\n\t<!DOCTYPE >\n\t<%@ page pageEncoding=\"UTF-8\" %>\n\t<%@ page contentType=\"text/html; charset=UTF-8\" %>\n\t<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n\t<%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %>\n\t<%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %>\n\t<%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %>\n\t<html>\n\t\t<head>\n\t\t\t<meta charset=\"UTF-8\" />\n\t\t\t<title>Login</title>\n\t\t\t<link rel=\"stylesheet\" type=\"text/css\" href='bs/css/bootstrap.min.css' />\n\t\t\t<script type=\"text/javascript\" src=\"js/jquery.min.js\"></script>\n\t\t\t<script type=\"text/javascript\" src=\"bs/js/bootstrap.min.js\"></script>\n\t\t\t<style>\n\t\t\t\timg {\n\t\t\t\t\theight: 200px;\n\t\t\t\t\tborder-radius: 200px;\n\t\t\t\t}\n\t\t\t\t.panel-title{\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t\t.login {\n\t\t\t\t\twidth: 500px;\n\t\t\t\t\theight: 400px;\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: 20%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\tmargin-left: -250px;\n\t\t\t\t}\n\t\t\t\t.sub{\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\n\t\t\t</style>\n\t\t</head>\n\t\n\t\t<body>\n\t\t\t<div class=\"panel panel-primary login\">\n\t\t\t\t<div class=\"panel-heading\">\n\t\t\t\t\t<div class=\"panel-title\">\n\t\t\t\t\t\t<img src=\"images/login.jpg\" />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"panel-body\">\n\t\t\t\t\t<!--自定义的登陆界面修改 1 -->\n\t\t\t\t\t<form:form method=\"post\" id=\"fm1\" commandName=\"${commandName}\" htmlEscape=\"true\" class=\"sui-form\">\n\t\t\t\t\t\n\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t\t\t\t<span class=\"input-group-addon\" id=\"basic-addon1\"><span class=\"glyphicon glyphicon-user\"></span></span>\n\t\t\t\t\t\t\t\t<!--自定义的登陆界面修改 2 -->\n\t\t\t\t\t\t\t\t<form:input  class=\"form-control\" aria-describedby=\"basic-addon1\" placeholder=\"Username\"  id=\"username\" size=\"25\" tabindex=\"1\" accesskey=\"${userNameAccessKey}\" path=\"username\" autocomplete=\"off\" htmlEscape=\"true\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t\t\t\t<span class=\"input-group-addon\" id=\"basic-addon1\"><span class=\"glyphicon glyphicon-lock\"></span></span>\n\t\t\t\t\t\t\t\t<!--自定义的登陆界面修改 3 -->\n\t\t\t\t\t\t\t\t<form:password class=\"form-control\" placeholder=\"password\" aria-describedby=\"basic-addon1\" id=\"password\" size=\"25\" tabindex=\"2\" path=\"password\"  accesskey=\"${passwordAccessKey}\" htmlEscape=\"true\" autocomplete=\"off\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"form-group sub\">\n\t\t\t\t\t\t\t<!--自定义的登陆界面修改 4 登陆框 -->\n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"lt\" value=\"${loginTicket}\" />\n\t     \t \t\t\t\t<input type=\"hidden\" name=\"execution\" value=\"${flowExecutionKey}\" />\n\t      \t\t\t\t\t<input type=\"hidden\" name=\"_eventId\" value=\"submit\" />\n\t      \t\t\t\t\t<input class=\"btn btn-primary btn-lg\" name=\"submit\" accesskey=\"l\" value=\"登陆\" type=\"submit\" />\n\t      \t\t\t\t\t<!--自定义的登陆界面修改 4 错误提示框 -->\n\t      \t\t\t\t\t<form:errors path=\"*\" id=\"msg\" cssClass=\"errors\" element=\"div\" htmlEscape=\"false\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</form:form>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\n\t\t</body>\n\t\n\t</html>\n\t```\n\t可以直接将登陆的页面拷过来然后加上指令再根据cas的登陆页面稍加修改就可以了\n\n---\n### 3. Spring项目集成CAS和Spring-security\n* pom依赖\n\t\n\t```java\n\t<properties>\n\t        <spring.version>4.2.0.RELEASE</spring.version>\n\t    </properties>\n\t    <dependencies>\n\t        <!-- Spring -->\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-context</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-beans</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-webmvc</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-jdbc</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-aspects</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-jms</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework</groupId>\n\t            <artifactId>spring-context-support</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <!--spring-security-->\n\t        <dependency>\n\t            <groupId>org.springframework.security</groupId>\n\t            <artifactId>spring-security-web</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>org.springframework.security</groupId>\n\t            <artifactId>spring-security-config</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <dependency>\n\t            <groupId>javax.servlet</groupId>\n\t            <artifactId>javax.servlet-api</artifactId>\n\t            <version>3.1.0</version>\n\t            <scope>provided</scope>\n\t        </dependency>\n\t        <!--集成包-->\n\t        <dependency>\n\t            <groupId>org.springframework.security</groupId>\n\t            <artifactId>spring-security-cas</artifactId>\n\t            <version>${spring.version}</version>\n\t        </dependency>\n\t        <!--cas-->\n\t        <dependency>\n\t            <groupId>org.jasig.cas.client</groupId>\n\t            <artifactId>cas-client-core</artifactId>\n\t            <version>3.3.3</version>\n\t            <exclusions>\n\t                <exclusion>\n\t                    <groupId>org.slf4j</groupId>\n\t                    <artifactId>log4j-over-slf4j</artifactId>\n\t                </exclusion>\n\t            </exclusions>\n\t        </dependency>\n\t    </dependencies>\n\t```\n\t添加tomcat插件指定端口为9001\n* web.xml配置\n```java\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n\t         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n\t         version=\"2.5\">\n\t\n\t    <context-param>\n\t        <param-name>contextConfigLocation</param-name>\n\t        <param-value>classpath:spring/spring-*.xml</param-value>\n\t    </context-param>\n\t    <listener>\n\t        <listener-class>\n\t            org.springframework.web.context.ContextLoaderListener\n\t        </listener-class>\n\t    </listener>\n\t\n\t    <filter>\n\t        <filter-name>springSecurityFilterChain</filter-name>\n\t        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>springSecurityFilterChain</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t\n\t</web-app>\n```\n主要配置Spring容器和Spring-security的过滤器\n- spring-security.xml配置\n  其实就是把之前配置在web.xml里面的过滤器采用Spring的方式配置出来\n\n``` java\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\n\t             xmlns:beans=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t             xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\t\t\t\t\thttp://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\">\n\t\n\t    <http pattern=\"/out.html\" security=\"none\"></http>\n\t    <!--   entry-point-ref  入口点引用 因为登陆交给cas或者其他的登陆系统,就不会在本系统做登陆需要指定登陆点-->\n\t    <http use-expressions=\"false\" entry-point-ref=\"casProcessingFilterEntryPoint\">\n\t        <intercept-url pattern=\"/**\" access=\"ROLE_USER\"/>\n\t        <csrf disabled=\"true\"/>\n\t        <!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前  ，after表示放在指定的位置之后  -->\n\t        <custom-filter ref=\"casAuthenticationFilter\"  position=\"CAS_FILTER\" />\n\t        <custom-filter ref=\"requestSingleLogoutFilter\" before=\"LOGOUT_FILTER\"/>\n\t        <custom-filter ref=\"singleLogoutFilter\" before=\"CAS_FILTER\"/>\n\t    </http>\n\t\n\t    <!-- CAS入口点 开始 -->\n\t    <beans:bean id=\"casProcessingFilterEntryPoint\" class=\"org.springframework.security.cas.web.CasAuthenticationEntryPoint\">\n\t        <!-- 单点登录服务器登录URL -->\n\t        <beans:property name=\"loginUrl\" value=\"http://localhost:8888/cas/login\"/>\n\t        <beans:property name=\"serviceProperties\" ref=\"serviceProperties\"/>\n\t    </beans:bean>\n\t\n\t    <beans:bean id=\"serviceProperties\" class=\"org.springframework.security.cas.ServiceProperties\">\n\t        <!--service 配置自身工程的根地址+/login/cas   -->\n\t        <beans:property name=\"service\" value=\"http://localhost:9001/login/cas\"/>\n\t    </beans:bean>\n\t    <!-- CAS入口点 结束 -->\n\t    <!-- 认证过滤器 开始 -->\n\t    <beans:bean id=\"casAuthenticationFilter\" class=\"org.springframework.security.cas.web.CasAuthenticationFilter\">\n\t        <beans:property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n\t    </beans:bean>\n\t    <!-- 认证管理器 -->\n\t    <authentication-manager alias=\"authenticationManager\">\n\t        <authentication-provider  ref=\"casAuthenticationProvider\">\n\t        </authentication-provider>\n\t    </authentication-manager>\n\t    <!-- 认证提供者 -->\n\t    <beans:bean id=\"casAuthenticationProvider\"     class=\"org.springframework.security.cas.authentication.CasAuthenticationProvider\">\n\t        <beans:property name=\"authenticationUserDetailsService\">\n\t            <beans:bean class=\"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper\">\n\t                <beans:constructor-arg ref=\"userDetailsService\" />\n\t            </beans:bean>\n\t        </beans:property>\n\t        <beans:property name=\"serviceProperties\" ref=\"serviceProperties\"/>\n\t        <!-- ticketValidator 为票据验证器 -->\n\t        <beans:property name=\"ticketValidator\">\n\t            <beans:bean class=\"org.jasig.cas.client.validation.Cas20ServiceTicketValidator\">\n\t                <beans:constructor-arg index=\"0\" value=\"http://localhost:8888/cas\"/>\n\t            </beans:bean>\n\t        </beans:property>\n\t        <beans:property name=\"key\" value=\"an_id_for_this_auth_provider_only\"/>\n\t    </beans:bean>\n\t    <!-- 认证类 -->\n\t    <beans:bean id=\"userDetailsService\" class=\"top.imlgw.demo.UserDetailServiceImpl\"/>\n\t\n\t    <!-- 认证过滤器 结束 -->\n\t\n\t\n\t    <!-- 单点登出  开始  -->\n\t    <beans:bean id=\"singleLogoutFilter\" class=\"org.jasig.cas.client.session.SingleSignOutFilter\"/>\n\t    <!--关联两个地址，相当于封装了前面的地址-->\n\t    <beans:bean id=\"requestSingleLogoutFilter\" class=\"org.springframework.security.web.authentication.logout.LogoutFilter\">\n\t        <beans:constructor-arg value=\"http://localhost:8888/cas/logout?service=http://localhost:9001/out.html\"/>\n\t        <beans:constructor-arg>\n\t            <beans:bean class=\"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler\"/>\n\t        </beans:constructor-arg>\n\t        <beans:property name=\"filterProcessesUrl\" value=\"/logout/cas\"/>\n\t    </beans:bean>\n\t    <!-- 单点登出  结束 -->\n\t\n\t</beans:beans>\n```\n\n- userDetailsService编写\n  这是一个认证类是属于Spring-security的，如果不使用CAS那么这个类就是用来验证密码是否正确是否放行的。但是整合了CAS后就不用在里面做认证了，只是为了返回后面的角色集合。\n\n\t```java\n\tpackage top.imlgw.demo;\n\timport org.springframework.security.core.GrantedAuthority;\n\timport org.springframework.security.core.authority.SimpleGrantedAuthority;\n\timport org.springframework.security.core.userdetails.User;\n\timport org.springframework.security.core.userdetails.UserDetails;\n\timport org.springframework.security.core.userdetails.UserDetailsService;\n\timport org.springframework.security.core.userdetails.UsernameNotFoundException;\n\timport java.util.ArrayList;\n\timport java.util.List;\n\t\n\tpublic class UserDetailServiceImpl implements UserDetailsService {\n\t    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t        System.out.println(\"经过认证类\");\n\t        List<GrantedAuthority> authorities=new ArrayList();\n\t        //最开始把这里的role写错了，然后cas登陆成功后也一直被403 forbid，因为SpringSecurity认证没通过，一直没放行\n\t        authorities.add(new SimpleGrantedAuthority(\"ROLE_USER\"));\n\t        //不通过本项目做登陆 所以密码无所谓，在执行这个方法的时候就已经登陆成功了\n\t        return new User(username,\"\",authorities);\n\t    }\n\t}\n\t\n\t```\n\n---\n### 4. 测试\n启动搭建好的两个服务器，和casServer，然后测试在一个应用登陆后另一个能否进入index页面 .....\n\n---\nSpringBoot集成CAS和Spring-security的后面再补充，因为SpringBoot还不太熟悉。","tags":["CAS","SSO"],"categories":["Web"]},{"title":"一道LeetCode引发的惨案","url":"/2018/10/31/yi-dao-leetcode-yin-fa-de-can-an/","content":"## 一道LeetCode搜索题引发的惨案\n ### 1.先上 [题目](https://leetcode-cn.com/problems/word-ladder/) \n给定两个单词（_beginWord _和 _endWord_）和一个字典，找到从 _beginWord_ 到 _endWord_ 的最短转换序列的长度。转换需遵循如下规则：\n\n1.  每次转换只能改变一个字母。\n2.  转换过程中的中间单词必须是字典中的单词。\n [原题链接](https://leetcode-cn.com/problems/word-ladder/) \n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/3V6EQ77R_%28%292SCR%248R%5B%245F7.png)其实这题明显是BFS(广搜) 题目类型也说了是广搜，但是我不信邪写了DFS(毕竟代码比较好写)，然后惨案就发生了。\n\n```java\n   // 标记数组\n\t// 默认都是0\n\tprivate static int[] mark;\n\n\tpublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n\t\t// 不存在\n\t\tmark = new int[wordList.size() + 1];\n\t\tif (!wordList.contains(endWord)) {\n\t\t\treturn 0;\n\t\t}\n\t\t// dfs开始\n\t\tdfs(beginWord, endWord, wordList);\n\t\t// 无法转换\n\t\tif (min == Integer.MAX_VALUE) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn min + 1;\n\t}\n\n\tint min = Integer.MAX_VALUE;\n\n\t// dfs\n\tprivate void dfs(String beginWord, String endWord, List<String> wordList) {\n\t\t//当相等的时候\n\t\tif (beginWord.equals(endWord)) {\n\t\t\tint step = 0;\n\t\t\tfor (int i = 0; i < mark.length; i++) {\n\t\t\t\tif (mark[i] == 1) {\n\t\t\t\t\tstep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//更新最小值\n\t\t\tmin = step < min ? step : min;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < wordList.size(); i++) {\n\t\t\tif (mark[i] == 0 && cmp(beginWord, wordList.get(i))) {\n\t\t\t\tmark[i] = 1;\n\t\t\t\tdfs(wordList.get(i), endWord, wordList);\n\t\t\t\tmark[i] = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// 写一个函数判段是否只变化了一个字母\n\tprivate boolean cmp(String s1, String s2) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (s1.charAt(i) != s2.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count == 1;\n\t}\n```\n结果直接TLE了，后来想了想DFS每次都会**尝试**所有情况，而给的例子后面的数据量也比较大，而且这题是要统计最短路径，要全部递归完才能确定最小值，我把数据拿来自己测试跑了好长时间都没跑出来，而BFS没有递归只是会耗费的空间会比较大。从这里也可以总结出来DFS跟适合判断是否存在是否可达之类的问题，BFS更适合做找最短最小之类的问题。上BFS代码\n\n```java\n// 标记数组\n\t// 默认都是0\n\tprivate static int[] mark;\n\t// 模拟队列\n\tclass Que {\n\t\tString word;\n\t\tint step;\n\t}\n\t//BFS\n\tpublic int ladderLengthBFS(String beginWord, String endWord, List<String> wordList){\n        // 不存在\n\t\tmark = new int[wordList.size() + 1];\n\t\tif (!wordList.contains(endWord)) {\n\t\t\treturn 0;\n\t\t}\n\t\t// BFS\n\t\tint head = 0, tail = 0;\n\t\t// 初始化队列\n\t\tQue[] que = new Que[wordList.size() + 1];\n\t\t// 循环促使话述祖\n\t\tfor (int i = 0; i < que.length; i++) {\n\t\t\tque[i] = new Que();\n\t\t}\n\t\tque[tail].word = beginWord;\n\t\tque[tail].word = beginWord;\n\t\tque[tail].step = 1;\n\t\ttail++;\n\t\tint flag=0;\n\t\twhile (head < tail) {\n\t\t\t// 遍历字典\n\t\t\tfor (int i = 0; i < wordList.size(); i++) {\n\t\t\t\tif (mark[i] == 0 && cmp(wordList.get(i), que[head].word)) {\n\t\t\t\t\tque[tail].word = wordList.get(i);\n\t\t\t\t\t//这里是从head开始的，所以应该是head的步数+1\n\t\t\t\t\tque[tail].step=que[head].step+1;\n\t\t\t\t\t// 标记为已经走过\n\t\t\t\t\tmark[i] = 1;\n\t\t\t\t   if (que[tail].word.equals(endWord)) {\n\t\t\t\t\t//到这里说明已经到终点了，而且是最短的，之后的最多就是相等\n\t\t\t\t\t//跳出循环\n                       flag=1;\n                       break;\n\t\t\t    \t}\n                    tail++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n            if(flag==1){\n                break;\n            }\n\t\t\t// 每次检查完一个单词就将其出队列\n\t\t\thead++;\n\t\t}\n\t\treturn que[tail].step;\n    }\n\n\t// 写一个函数判段没吃是否只变化了一个字母\n\tprivate boolean cmp(String s1, String s2) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (s1.charAt(i) != s2.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count == 1;\n\t}\n```\n\nPS：刚刚修改了下代码，我也佩服自己BFS都还没搞清楚就直接上了代码，然后结果居然还是对的，之前在if判断队尾元素是不是和endWord相等后还维护了一个最小值min，后来想了想不对，最后一个和endWord相等的元素已经进栈了，已经是最短的了，后面的即使可以转换到也最多只能和当前的相等了。 如果只是为了统计最小值就可以直接break了。那如果不仅仅要统计最小值还要记录路径要怎么搞？\n### 2. [加强版](https://leetcode-cn.com/problems/word-ladder-ii/) 单词接龙 2\n是一道困难等级的题，需要在上面的基础上找出所有的最短的路径。\n\n```java\n// 内部类\n\tclass Que {\n\t\tString word;\n\t\tint step;\n\t\tQue prev;\n\t\tpublic String toString(){\n\t\t\treturn (word + \":\" + step);\n\t\t}\t\t \n\t}\n\n\t//返回值\n\tprivate  List<List<String>> res=new ArrayList<>();\n\n\t\n\t//BFS\n\tpublic List<List<String>> ladderLengthBFS(String beginWord, String endWord, List<String> wordList){\n        //返回值\n\t\t//List<List<String>> res=new ArrayList<>();\n\t\t\n        // 不存在\n\t\tmark = new int[wordList.size() + 1];\n\t\tif (!wordList.contains(endWord)) {\n\t\t\treturn res;\n\t\t}\n\t\t// BFS\n\t\tint head = 0, tail = 0;\n\t\t// 初始化队列\n\t\tQue[] que = new Que[wordList.size() + 1];\n\t\t// 循环促使话述祖\n\t\tfor (int i = 0; i < que.length; i++) {\n\t\t\tque[i] = new Que();\n\t\t}\n\t\t//先把第一个单词放进去\n\t\tque[tail].word = beginWord;\n\t\tque[tail].word = beginWord;\n\t\tque[tail].step = 1;\n\t\ttail++;\n\t\tList<Que> quelist=new ArrayList<>();\n\t\twhile (head < tail) {\n\t\t\t// 遍历字典\n\t\t\tfor (int i = 0; i < wordList.size(); i++) {\n\t\t\t\tif (mark[i] == 0 && cmp(wordList.get(i), que[head].word)) {\n\t\t\t\t\tque[tail].word = wordList.get(i);\n\t\t\t\t\t//这里是从head开始的，所以应该是head的步数+1\n\t\t\t\t\tque[tail].step=que[head].step+1;\n\t\t\t\t\t//que[head].next=que[tail];\n\t\t\t\t\t// 标记为已经走过\n\t\t\t\t\tmark[i] = 1;\n\t\t\t\t   if (que[tail].word.equals(endWord)) {\t\n\t\t\t\t   \t\t//记录最小值\n\t\t\t\t   \t\tmin=que[tail].step;\n\t\t\t\t   \t\t//到这里队列后面就不用再插入元素了\n\n\t\t\t\t   \t\t//2.把之前走过的路在下一个head\n\n\t\t\t\t   \t\t//将队列变成list\n\t\t\t\t   \t\tfor(int j=0;j<=tail;j++){\n\t\t\t\t   \t\t\tquelist.add(que[j]);\n\t\t\t\t   \t\t}\n\t\t\t\t   \t\tmarkDfs= new int[wordList.size() + 1]; \n\t\t\t\t   \t\t// 1. 用DFS试一下\n\t\t\t\t   \t\tdfsBfs(que[0],endWord,quelist);\n\t\t\t    \t}\n                    tail++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 每次检查完一个单词就将其出队列\n\t\t\thead++;\n\t\t}\n\t\treturn res;\n    }\n\n\n    private void dfsBfs(Que beginWord,String endWord,List<Que> ques){\n    \tint step = 0;\n\t\tfor (int i = 0; i < markDfs.length; i++) {\n\t\t\t\tif (markDfs[i] == 1) {\n\t\t\t\t\tstep++;\n\t\t\t\t}\n\t\t}\n\t\tif(step>=min) return;\n\t\tif(step+1==min&&endWord.equals(beginWord.word)){\n\t\t\tList<String> list=new ArrayList<>();\n\t\t\tStack<String> stack=new Stack<>();\n\t\t\tSystem.out.println(beginWord.word+\":\"+step);\n\t\t\tQue temp=beginWord;\n\t\t\t\t//找到一条\n\t\t\t\tfor(int i=0;i<min;i++){\n\t\t\t\t\tstack.push(temp.word);\n\t\t\t\t\tSystem.out.print(temp.word+\"<--\");\n\t\t\t\t\ttemp=temp.prev;\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\tfor(int i=0;i<min;i++){\n\t\t\t\t\tlist.add(stack.pop());\n\t\t\t\t}\n\t\t\t\tres.add(list);\n\t\t\t\tSystem.out.println(res);\n\t\t\treturn;\n\t\t}\n\n\t\t\n\t\tfor (int i = 0; i < ques.size(); i++) {\n\t\t\tif (markDfs[i] == 0 && cmp(beginWord.word,ques.get(i).word)){\n\t\t\t\tmarkDfs[i] = 1;\n\t\t\t\t//连接两个节点\n\t\t\t\t//beginWord.next=ques.get(i);\n\t\t\t\tques.get(i).prev=beginWord;\n\t\t\t\tdfsBfs(ques.get(i), endWord, ques);\n\t\t\t\tmarkDfs[i] = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n    }\n\n\t// private int step = 0;\n\tint min = Integer.MAX_VALUE;\n\n\t// 写一个函数判段没吃是否只变化了一个字母\n\tprivate boolean cmp(String s1, String s2) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (s1.charAt(i) != s2.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count == 1;\n\t}\n```\n整体上在Que上增加了一个prev的指针，遍历路径，一开始是用的BFS不过我想的太简单了，我只是把最后一个节点出队列然后再BFS，后来发现不行(居然还跑过了24个测试案例)，实际上这题我还是没有做出来，但是上面的方法应该是没问题的就是会TLE😭，大概思路就是先BFS缩短DFS需要遍历的字典然后控制每次递归的身体不能超过BFS的到的最短路径\n![img9](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/blog.PNG)一开始只能跑几个数据的，优化下能跑几十个的，但是还是太慢了，毕竟是一道难题等以后学了相关的东西再来试试看能不能做出来吧.\n\n---\n算法，学着挺有意思，就是头有点凉。","tags":["数据结构","算法","搜索"],"categories":["算法"]},{"title":"你有FreeBug么? --->Spring-solr","url":"/2018/10/05/solr-ni-you-freebug-me/","content":"## FreeBug ? 哎呦，不错喔。\n 昨天从上午10点开始一直到晚上 11：58才把那几个Bug给解决了，前两个Bug确实蛮奇怪的，特别是第一个Bug ,最后一个Bug....纯属智障。把这几个Bug记录下┗|｀O′|┛ \n### ***Bug1***:\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/9642SBM2%60QFX4AMO1C%5D~A%5BM.png)\n意思是没找到TbItemMapper的select方法还有这个类的其他方法。\n估计是xml文件没有加载到classes路径下，之前一直好好的然后昨天突然抽风了，百度了下叫我把xml文件随便的改动下在里面加个空格换行之类的，然后就好了。。。。\n### ***Bug2***:\n![img9](https://p4.cdn.img9.top/ipfs/Qmcg5dscbhYgod9vdN2SHaxywdaCPVgY28jX4imd53TH6J?4.png)\n看着这些个Bug真的是一脸懵，写main方法执行就一点问题没有，首先是一波百度，说是jar包冲突了主要是HttpClient的冲突，然后我就尝试了下idea的maven依赖视图\n![img9](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/DJQYP%604SGOCL_VP%28LGN%7B_TN.png )\n然后发现dubbo和spring-data-solr都有httpclient包和httpcore而且版本不一致，然后果断的把dubbo里面的httpclient和httpcore给exclusion了，不看不知道，整个项目的maven依赖好乱，有好多依赖冲突，不过没影响使用我就没有去改，怕再改出什么问题。你以为改完之后bug就结束了？\n### ***Bug3***:\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/%60Z3GBQ~K%29%7D%60DX%60P%60Q%257%25%7B%25S.png)在controller层疯狂报错，service层一点问题没有![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/NLKUXAM~LPOZ7K%60%28%29D52%40VD.png)可以，又一个FreeBug，在纠结了几个小时后看了一眼代码发现\n![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/L20FMBQ%28XNRQV6Y6%24ITFEYA.png)原来这里写掉了东西，返回了一个solr的结果集也没有实现序列化返回出去了前台也根本就解析不了难怪会再前台报错。。。\n\n\nps: 之前一直用的img9.top的无限图床，前几天突然崩溃了博客的图片都失效了，之前也有一个送的阿里云的oss的包所以就想拿那个当图床，这篇文章里面的图片也都是在oss上的，img9虽然也还可以但是是个去中心化的图床不好管理确实难搞，等有时间就用java写一个自动化的图床工具玩玩。","tags":["Bug","Solr","Spring"],"categories":["踩坑记录"]},{"title":"可以获取最小值的栈","url":"/2018/09/27/ke-yi-huo-qu-zui-xiao-zhi-de-zhan/","content":"## 如何实现可以获取最小值的栈？\n这个问题是很久之前在微信公众号上看见的一个问题，突然想起来就来操作一下。\n开发环境   : sublime+MinGW\n先附上我自己实现的栈的结构\n\n```java\n//定义链栈的节点的结构体 \ntypedef struct  StackNode\n{\n\tint data;\n\tstruct StackNode *next;\n}StackNode,*LinkStackPtr;\n\n//链栈的结构体\ntypedef struct LinkStack\n{\n\t//栈顶\n\tLinkStackPtr top;\n\t//总数量\n\tint count;\n}LinkStack;\n\n//初始化栈\nLinkStack *init(){\n\tLinkStack *stack=(LinkStack*)malloc(sizeof(LinkStack));\n\tif (stack==NULL)\n\t{\n\t\tprintf(\"动态开辟空间失败\");\n\t}else\n\t\t//初始化空栈\n\t\tstack->top=NULL;\n\t\tstack->count=0;\n\t\treturn stack;\n}\n\n//创建节点\nLinkStackPtr  creatNode(){\n\tLinkStackPtr stack;\n\t//开辟空间\n\tstack =(LinkStackPtr)malloc(sizeof(StackNode));\n\tif(stack==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tscanf(\"%d\",&(stack->data));\n\tstack->next=NULL;\n\treturn stack;\n}\n\n//压栈\nvoid push(LinkStack * s){\n\t//创建节点\n\tLinkStackPtr newStack= creatNode();\n\t//保存当前的节点\n\tLinkStackPtr currentTopStack=s->top;\n\t//栈顶变为刚进栈的元素\n\ts->top=newStack;\n\t//连接\n\tnewStack->next=currentTopStack;\n\t//数目加一\n\ts->count++;\n}\n\n//弹栈\nvoid pop(LinkStack *s){\n\t//将栈顶弹出\n\tLinkStackPtr topStack=s->top;\n\ts->top=topStack->next;\n\ts->count--;\n\tfree(topStack);\n}\n```\n\n\n### **Solution 1**：\n在进栈的时候用一个变量保存当前的最小值每次进栈就会和最小值比较如果比最小值要小就会更新这个变量的值，出栈的时候比较麻烦，如果最小值被弹出去了就需要遍历整个栈来获取最小值。\n- Implement：\n\n\n```java\ntypedef struct  StackNode\n{\n\tint data;\n\tstruct StackNode *next;\n}StackNode,*LinkStackPtr;\n\n//链栈的结构体\ntypedef struct LinkStack\n{\n\t//栈顶\n\tLinkStackPtr top;\n\t//总数量\n\tint count;\n\t//最小值\n\tint min;\n}LinkStack;\n\n//进栈\nvoid push(LinkStack * s){\n\t//创建节点\n\tLinkStackPtr newStack= creatNode();\n\t//**********************************\n\tif(s->count==0){\n\t\ts->min=newStack->data;\t\n\t}else if(s->min>newStack->data){\n\t\ts->min=newStack->data;\n\t}\n\t//*********************************\n\t//保存当前的节点\n\tLinkStackPtr currentTopStack=s->top;\n\t//栈顶变为刚进栈的元素\n\ts->top=newStack;\n\t//连接\n\tnewStack->next=currentTopStack;\n\t//数目加一\n\ts->count++;\n}\n\n//弹栈\nvoid pop(LinkStack *s){\n\t//将栈顶弹出\n\tLinkStackPtr topStack=s->top;\n\t//从第二个开始比较\n\tLinkStackPtr stackNode=topStack->next;\n\t//弹出去的那个节点的数据\n\tint min=topStack->data;\n\ts->top=topStack->next;\n\ts->count--;\n\tfree(topStack);\n\t//如果弹出的是最小值就需要从当前栈顶遍历数组获取最小值\n\tif(min==s->min){\n\t\tmin=stackNode->data;\n\t  do{\n\t  \tif(min>stackNode->data){\n\t  \t\tmin=stackNode->data;\n\t  \t}\n\t\tstackNode=stackNode->next;\n\t   }while(stackNode!=NULL);\t\n\t}\n\ts->min=min;\n}\n```\n这种方法进栈时间复杂度为O(1),但是出栈时间复杂度为O(n).显然不是很优雅。\n\n### **Solution 2**：\n空间换时间利用一个辅助栈，辅助栈里面存放最小值，辅助栈进栈时判断进栈的元素和当前栈顶的元素大小跟小就可以进栈。所以最小值就是辅助栈的栈顶元素，出栈时如果出栈的元素是最小值节点那辅助栈也同时弹栈 再取栈顶元素。\n- Implement：\n\n```java\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//定义链栈的节点的结构体 \ntypedef struct  StackNode\n{\n\tint data;\n\tstruct StackNode *next;\n}StackNode,*LinkStackPtr;\n\n//链栈的结构体\ntypedef struct LinkStack\n{\n\t//栈顶\n\tLinkStackPtr top;\n\t//总数量\n\tint count;\n\t//辅助栈\n\tstruct LinkStack *mins;\n}LinkStack;\n\n//初始化栈\nLinkStack *init(){\n\tLinkStack *stack=(LinkStack*)malloc(sizeof(LinkStack));\n\tif (stack==NULL)\n\t{\n\t\tprintf(\"动态开辟空间失败\");\n\t}else\n\t\t//初始化空栈\n\t\tstack->top=NULL;\n\t\tstack->count=0;\n\t\treturn stack;\n}\n\n//创建节点\nLinkStackPtr  creatNode(){\n\tLinkStackPtr stack;\n\t//开辟空间\n\tstack =(LinkStackPtr)malloc(sizeof(StackNode));\n\tif(stack==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tscanf(\"%d\",&(stack->data));\n\tstack->next=NULL;\n\treturn stack;\n}\n\n//进栈\nvoid push(LinkStack * s){\n\t//创建节点\n\tLinkStackPtr newStack= creatNode();\n\t//保存当前的节点\n\tLinkStackPtr currentTopStack=s->top;\n\n\t//开辟空间 用于添加到辅助栈中，之前直接操作newStack，指针地址导致后面辅助栈和主栈混合到了一起，，，，\n\tLinkStackPtr minStackNode =(LinkStackPtr)malloc(sizeof(StackNode));\n\tif(minStackNode==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tminStackNode->data=newStack->data;\n\tminStackNode->next=NULL;\n\n\t//栈顶变为刚进栈的元素\n\ts->top=newStack;\n\t//辅助栈\n\tLinkStack *mins=s->mins;\n\t//保存辅助栈当前栈顶\n\tLinkStackPtr  currentMinsTop=mins->top;\n\tif(s->count==0){\n\t   mins->top=newStack;\n\t   newStack->next=NULL;\n    }else\n    \t//如果进栈的元素比当前辅助栈的栈顶小\n    \t//相等的要进栈\n    \tif(newStack->data<=mins->top->data){\n    \t\tmins->top=minStackNode;\n    \t\t//连接\n    \t\tmins->top->next=currentMinsTop;\n    \t\tmins->count++;\n    \t}\n\t//连接\n\ts->top->next=currentTopStack;\n\t//数目加一\n\ts->count++;\n}\n\n//弹栈\nvoid pop(LinkStack *s){\n\t//将栈顶弹出\n\tLinkStackPtr topStack=s->top;\n    //辅助栈\n\tLinkStack * mins=s->mins;\n\t//保存辅助栈栈顶元素便于销毁\n\tLinkStackPtr minsTopStack=mins->top;\n\ts->top=topStack->next;\n\ts->count--;\n\t//弹出的元素是最小值\n\tif (topStack->data==mins->top->data)\n\t{\n\t\t//辅助栈同时弹栈\n\t\tmins->top=minsTopStack->next;\n\t\tmins->count--;\n\t\tfree(minsTopStack);\n\t}\n\tfree(topStack);\n}\n\n//遍历栈（栈顶到栈底）\nvoid printStack(LinkStack *stack){\n\t//当前栈顶\n\tLinkStackPtr stackNode=stack->top;\n\tdo{\n\t\tprintf(\"%d\\n\",stackNode->data);\n\t\tstackNode=stackNode->next;\n\t}while(stackNode!=NULL);\n}\n\nint main(int argc, char const *argv[])\n{\n\t//申明并初始化栈结构\n\tLinkStack *stack=init();\n\t//初始化这个链栈的辅助（C语言学的不好原谅这些很奇怪的操作）\n\tstack->mins=init();\n\tpush(stack);\n\tpush(stack);\n\tpush(stack);\n\tpush(stack);\n\tprintf(\"*******进栈******\\n\");\n\tprintStack(stack);\n\tprintf(\"*********辅助栈*******\\n\");\n\tprintStack(stack->mins);\n\tprintf(\"*******最小值******\\n\");\n\tprintf(\"%d\\n\", stack->mins->top->data);\n\tpop(stack);\n\tprintf(\"*******出栈******\\n\");\n\tprintStack(stack);\n\tprintf(\"*******最小值******\\n\");\n\tprintf(\"%d\\n\", stack->mins->top->data);\n\tprintf(\"*********辅助栈*******\\n\");\n\tprintStack(stack->mins);\n\treturn 0;\n}\n```\n明显这个方法进栈出栈时间复杂度都是O(1)，空间复杂度相对会高一点，其实空间复杂度还可以优化，可以在辅助栈里面存索引，这样进栈时会避免存入相同的最小值，如  2 1 1 1 1 1 存到辅助栈就是  2 1 1 1 1 1 后面的1都是重复的，如果存索引就是 0 1 进栈时跟之前一样,出栈时判断索引是否和辅助栈存的索引一致，不一致就不动。这里因为这个是个链栈 ,要根据索引取值并不方便所以就不实现了.\n\n这里我把代码全部贴上来了，C语言确实学的不怎么样，所以里面会有一些奇怪的操作，这个算法本身很简单但是用C语言一实现就会有一堆问题，昨天进栈的时候一个指针把辅助栈和主栈搞混了一直有bug, 今天早上上课才想起来，毕竟C语言写的少hahahaha,  所以后面我打算以后会同时用C语言和Java都实现一遍。\n\n\n\n","tags":["数据结构","算法"],"categories":["算法"]},{"title":"Spring-Redis遇到的bug","url":"/2018/09/24/spring-redis-yu-dao-de-bug/","content":"\n##   两个小bug记录一下\n1.  Spring-data-redis和jedis整合的版本问题报错如下：\n```java\n严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisTemplate' defined in URL [jar:file:/E:/repository/com/pyg/pyg-common/0.0.1-SNAPSHOT/pyg-common-0.0.1-SNAPSHOT.jar!/spring/applicationContext-redis.xml]: Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1578)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\nat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:305)\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301)\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772)\nat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:834)\nat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:537)\nat org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:446)\nat org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:328)\nat org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:107)\nat org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4939)\nat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5434)\nat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\nat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V\nat org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.<init>(JdkSerializationRedisSerializer.java:53)\nat org.springframework.data.redis.core.RedisTemplate.afterPropertiesSet(RedisTemplate.java:117)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1637)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1574)\n... 21 more\n```\n\n 报错原因：Spring-data-reids 和 jedis的版本冲突（应该也和Spring的版本有关系,别人跟我一样的包都可以运行）。\n我测试成功的版本：\n<jedis.version>2.6.2</jedis.version>\n<spring.version>4.2.0.RELEASE</spring.version>\n<spring-data-redis.version>1.4.2.RELEASE</spring.version>\n\n2. Spring加载配置文件的问题\n因为同时配置了MySql和Redis的配置文件而且不是同一个工程所以不是同时初始化然后出现了以下的问题。\n同个模块中如果出现多个context:property-placeholder ，location properties文件后， 运行时出现Could not resolve placeholder 'key' in string value${key}。原因是在加载第一个context:property-placeholder时 会扫描所有的bean，而有的bean里面出现第二个 context:property-placeholder引入的properties的占位符${key}， 此时还没有加载第二个property-placeholder，所以解析不了${key}。\n解决办法一，可以将通过模块的多个property-placeholder合并为一个，将初始化放在一起。\n方法二，添加ignore-unresolvable=\"true \"，这样可以在加载第一个property-placeholder时出现解析不了的占位符进行忽略掉\n\nps：目前的计划是先把品优购这个项目做完，然后搞一搞微信小程序之类的开发，然后开始着手研究源码，对Spring的源码非常好奇有种特别想了解她的欲望hahahahahaha....  看源码肯定会涉及到设计模式也顺便学一学，再就是数据结构和算法，这学期也正在学也不用着急跟着老师的进度再加自己的自学补充，这个东西也不是说今天学完了就会了的东西，大二上学期主要的打算就是这个了，还有就是不能挂科！！！！,再往后就是打算学下安卓和安卓逆向，不过暂时只是个打算😄。再往后就是大三了，还没打算到那个时候，想想还真快，不知不觉就一年过去了。Come on , add oil ! ! ! @imlgw\n\n","tags":["Redis","Bug","Spring"],"categories":["踩坑记录"]},{"title":"KMP算法及优化","url":"/2018/09/06/kmp-suan-fa-ji-you-hua/","content":"## KMP算法及优化\n> 后面有时间再来重写一下，kmp还是挺重要的\n\nKMP算法是一种改进的[字符串匹配](https://baike.so.com/doc/9018958-9348545.html)算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特--莫里斯--普拉特操作(简称KMP算法)。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。\n 开发环境   : sublime+MinGW \n\n- 暴力匹配法\n\n```c\n//暴力匹配   \nint BruteForce(String S, String T,int begin){ \n\tint i=begin,j=0;\n\twhile(i<S.length&&j<T.length){\n\t\tif(S.str[i]==T.str[j]){\n\t\t\tj++;\n\t\t\ti++;\n\t\t}else{\n\t\t\t//母串的当前位置+1向后移动\n\t\t\ti=i-j+1;\n\t\t\t//子串从0开始\n\t\t\tj=0;\n\t\t}\n\t}\n\tif (i<s(S.length-T.length))\n\t\treturn i-j-begin;\n\treturn -1;  //没找到\n}\n```\n暴力匹配比较简单粗暴，就是一个个的比对如果不对母串就回溯直到配成功。\n这个算法无疑时间复杂度较高，最糟糕情况为 O(m*n);而这个算法的缺陷就在于每次母串的不必要的回溯，于是KMP算法出现了\n- KMP算法\n\n```c\nvoid getNext(String S,int next[]){\n\t//自己和自己匹配其实和kmp是一个道理\n\tint i=1,j=0;\n\t//和标准的KMP不台一样,标准的KMP是从1开始的其实原理也一样，这样更习惯\n\tnext[0]=-1;\n\tnext[1]=0;\n\t//循环 n-2 次\n\twhile(i<S.length-1){\n\t\tif(S.str[i]==S.str[j]){\n\t\t\t++j;\n\t\t\t++i;\n\t\t\tnext[i]=j;\n\t\t}else if(j==0){\n\t\t\t//如果和前缀第一个字符就不等，i后移下一个位置的next为0\n\t\t\t++i;\n\t\t\tnext[i]=0;\n\t\t}else\n\t\t    //j回退到之前的位置\n\t\t\tj=next[j];\n\t}\n} \n\n//返回第一次出现的位置\nint KMP(String S,String T,int begin){\n\tint i=begin,j=0;\n\tint next[100];\n\tgetNext(T,next);\n\twhile(i<S.length&&j<T.length){\n\t\tif(S.str[i]==T.str[j]){\n\t\t\t++i;\n\t\t\t++j;\n\t\t}else if(j==0){\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t j=next[j];\n\t\t}\n\t}\n\tif (i<s(S.length-T.length))\n\t\treturn i-j-begin;\n\treturn -1;   //没找到\n}\n```\n这个算法的原理其实很好理解 ,母串不回溯，如果不相等字串就会跳到对应的位置继续比对\n # a b a b c\n # a b c\n比如上面这种，c和a不相等 ，如果是暴力匹配那母串就会回溯到第二个字符b的位置继续比对，但是这并没有意义，因为子串的字符都不相等，正确的做法肯定是直接将字串右滑，或者说将子串回溯，回溯到a的位置，然后计较母串的第三个字符和子串的第一个字符...... 分析一下可以看出来这个算法最坏时间复杂度为O(n+m)\n那么问题来了回溯的位置如何确定？这也是这个算法的关键之处。要得到一个对应每个位置的next数组储存当失配时回溯的位置，这个数组的确定只和子串本身的结构有关其代表的时最长的公共前后缀的长度，关于next数组的求法就不说了，人眼基本上一眼就能看出来。\n- next数组编程实现\n\n```c\nvoid getNext(String S,int next[]){\n\t//自己和自己匹配其实和kmp是一个道理\n\tint i=1,j=0;\n\t//和标准的KMP不台一样,标准的KMP是从1开始的其实原理也一样，这样更习惯\n\tnext[0]=-1;\n\tnext[1]=0;\n\t//循环 n-2 次\n\twhile(i<S.length-1){\n\t\tif(S.str[i]==S.str[j]){\n\t\t\t++j;\n\t\t\t++i;\n\t\t\tnext[i]=j;\n\t\t}else if(j==0){\n\t\t\t//如果和前缀第一个字符就不等，i后移下一个位置的next为0\n\t\t\t++i;\n\t\t\tnext[i]=0;\n\t\t}else\n\t\t    //j回退到之前的位置\n\t\t\tj=next[j];\n\t}\n} \n```\n一开始看到这个我是比较懵的怎么这么短？仔细看了下这几行代码前面的其实都还好理解,相当于自己和自己匹配\n# ！！！关键是后面的不相等的情况\n这里我也纠结了小半天随后在网上看到了一个图讲解这个的瞬间就开朗了这里就直接搬过来了（对[原文](https://blog.csdn.net/qq_30974369/article/details/74276186)加了一点自己的直观理解并另外加上了参考《大话数据结构》里面的对于KMP算法的优化）\n#  a b  a  c  f  g a  b a b h\n![image](https://p1.cdn.img9.top/ipfs/QmQLpe9fWukFT9is6XnAmmAyBdTCVYSeV6oj7mn5yGVsy8?1.png)\n# **a b  a**  c  f  g **a  b a** *b*  h\n红色的是当前匹配上的最长的前后缀，蓝色为当前匹配位置，也就是*i* 的位置 与上面对应的就是b 的位置了\n![image2](https://p3.cdn.img9.top/ipfs/QmaFp1PaEY5Ednc4wUdLatsuJ7e4fibKv7jXwroGGb8rXN?3.png)\n# **a b  a**  *c*  f  g **a  b  a** *b*  h\n绿色为当前匹配到的最长前缀的后一位也就是 *j*  的位置 对应 c 的位置\n显然c b不相等  如果不相等那就不能继续往后找了 那像 aba 这么长的公共前后缀就用不了了，也就是你的next数组会变小，前后缀相似度会减小。\n![image3](https://p1.cdn.img9.top/ipfs/QmURa6y33pwvpWjoBZ6eSiyZzraBd9QPWSBF13gq2xdPnT?1.png)\n![image4](https://p2.cdn.img9.top/ipfs/QmVfW9VQ2JYhNigxskotFVRtgAYcEhksBBEKzSztKn3p9b?2.png)\n# **a**  *b*  **a**  c  f  g  **a**  b  **a** b  h\n如图四块灰色区域完全相等，关键步骤 j=next[j];之前的j在绿色区域 现在的 j 回溯到了紫色区域 也就是对应b的位置\n![image5](https://p1.cdn.img9.top/ipfs/QmYo2cscPKdCL9tGGn2frfrn6p4WuGXuma6W6yQSEw4bdx?1.png)\n相信到这里应该就看明白了,四块区域相等，如果蓝色部分和紫色相等是不是就又有了公共的前后缀了呢？那如果不同就会继续递推。\n- KMP优化\n  什么？这么吊的算法还可以优化？的确，KMP还可以优化，这里直接拿《大话数据结构》里面的例子来说明 (ps : 这里大话数据结构和KMP原始的是一样的，也就是next是从1开始的，我是从0开始的)     \n![image6](https://p0.cdn.img9.top/ipfs/QmSum26wHswwEgRmR79oM75o8afbAMCy2ZMQcremrXpfka?0.png)    \n  - next优化\n\n```c\nvoid getNexval(String S,int next[]){\n\t//自己和自己匹配其实和kmp是一个道理\n\tint i=1,j=0;\n\t//和标准的KMP不台一样,标准的KMP是从1开始的其实原理也一样，这样更习惯\n\tnext[0]=-1;\n\tnext[1]=0;\n\t//循环n-2次\n\twhile(i<S.length-1){\n\t\tif(S.str[i]==S.str[j]){\n\t\t\t++j;\n\t\t\t++i;\n\t\t\t//下一对对应的位置（也就是正在求next值的位置）\n\t\t\tif(S.str[j]==S.str[i]){\n\t\t\t\t//这一步实际上是跳过了重复的部分 如果和这个位置的next值的字符相同就可以将这个位置的next字符设置为next位置字符的next值\n\t\t\t\tnext[i]=next[j];\n\t\t\t}else\n\t\t\tnext[i]=j;\n\t\t}else if(j==0){\n\t\t\t//如果和前缀第一个字符就不等，i后移下一个位置的next为0\n\t\t\t++i;\n\t\t\tnext[i]=0;\n\t\t}else\n\t\t    //j回退到之前的位置\n\t\t\tj=next[j];\n\t}\n} \n```\n其实优化的理由就是在进行和子串匹配的时候如果失配，在子串回溯时回溯到的那个值和当前的值相同那么我们可以直接回溯到 那个回溯值的回溯值，可能有点绕但是仔细想想就明白了。\n # **a b a b a a a b a**\n这个字符串的next应该是 next=[-1,0,0,1,2,3,1,1,2] \nnextval=[-1,0,0,0,0,3,1,0,0] （这里有一个小问题，那就是前两位是不用考虑的，永远是-1 0，所以如果按照上面的说法可能会认为第三个是-1，其实不是的具体的可以看代码，如果时官方的那种从1开始就没有这种顾虑）。\n拿这个实际的来说 ,  **a b a b a a a b a**当比对到该子串最后一个a时 不相等 ，按照之前的方法回溯，回溯到index=2的a位置，发现这货也是a那肯定也不相等，然后又回溯回溯到第一个a，这中间不就多回溯了一次么？为什么不一次到位呢？所以我们直接判断将要回溯的值和当前值是不是相等，相等就把将要回溯的值的回溯值赋给当前值。\n\n\n\n","tags":["数据结构","算法"],"categories":["算法"]},{"title":"双向循环链表","url":"/2018/08/18/shuang-xiang-xun-huan-lian-biao-c-shi-xian/","content":"## C实现的双向循环链表\n很久没有用C了，都忘了，昨天下午又复习了一下然后实现了这个双向循环链表，后面每种数据结构都会在这里实现记录下来。\n开发环境   : sublime+MinGW \n```java\n#include <stdio.h>\n#include <stdlib.h>\n//定义结构体\ntypedef struct Node\n{\n\tint data;\n\tstruct Node *perv;\n\tstruct Node *next;\n}Node;\n\nint length;\n\n//初始化节点\nNode* createNode(){\n\tNode * node;\n\t//开辟空间\n\tnode =(Node*)malloc(sizeof(Node));\n\tif(node==NULL){\n\t\tprintf(\"动态开辟空间失败\");\n\t}\n\tscanf(\"%d\",&(node->data));\n\tnode->perv=NULL;\n\tnode->next=NULL;\n\treturn node;\n}\n\n//初始化链表 \nNode* createList(int n)\n{\n    Node *tail,*p,*head;\n    //初始化头结点 (这个节点只是个标志，标志链表的头并不存储数据,只是为了操作的统一性)\n    head=(Node*)malloc(sizeof(Node));\n    int i;\n    if(n >= 1)   //结点的个数 >= 1 的时候\n    {\n        p = createNode();\n        head->next = p;\n        p->perv=head;\n        tail = p;\n    }\n    for(i = 2;i <= n;i++)    //生成第一个结点以后的结点，并建立双向链表的关系 \n    {\n        p = createNode();\n        tail->next = p;\n        p->perv = tail;\n        //尾指针后移\n        tail = p;\n    }\n    //连接头尾\n    head->perv=tail;\n    tail->next=head;\n    //链表的长度\n    length = n;\n    if(n >= 1)\n        return (head);\n    else\n        return 0;    \n} \n\n\n//在头尾插入节点   （实际上这两个方法都可以通过下面的insAnywhere完成，主要为了效率,如果是尾结点插入getEle()时间复杂度过高）\n//insAnywhere(head,0);\nvoid insHead(Node* head){\n\tNode *p=createNode();\n\tNode *q;\n\t//保存第一个节点\n\tq=head->next;\n\t//连接头结点\n\thead->next=p;\n\tp->perv=head;\n\t//连接之前的第一个节点\n\tp->next=q;\n\tq->perv=p;\n\t++length;\n}\n\n//insAnywhere(head,length);\nvoid insTail(Node* head){\n\tNode *p=createNode();\n\t//先保存下之前的尾指针\n\tNode *tail=head->perv;\n\t//连接头尾\n\thead->perv=p;\n\tp->next=head;\n\t//连接之前的尾指针\n\ttail->next=p;\n\tp->perv=tail;\n\t++length;\n}\n\n//取得某一位置的节点  时间复杂度为 O(n)\nNode * getEle(Node* head,int n){\n\t//将第一个节点赋值给p\n\tNode *p=head;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tp=p->next;\n\t}\n\treturn p;\n}\n\n//获取链表的长度\nint getLength(){\n\treturn length;\n}\n\n//任意位置插入，因为设置了头节点所以插入的操作具有一致性\nvoid insAnywhere(Node *head,int n){\n\tNode *newNode=createNode();\n\t//取得对应位置的值\n\tNode *currentNode=getEle(head,n);\n\t//保存当前位置的下一个\n\tNode *nextNode;\n\t//保存下一个节点\n\tnextNode=currentNode->next;\n\t//连接当前结点\n\tcurrentNode->next=newNode;\n\tnewNode->perv=currentNode;\n\t//连接之前的下一个节点\n\tnewNode->next=nextNode;\n\tnextNode->perv=newNode;\n\t++length;\n}\n\n//任意位置的删除\nvoid delNode(Node *head,int n){\n\tNode *delNode=getEle(head,n);\n\t/*printf(\"%d\\n\", delNode->data);\n\tprintf(\"--------------\\n\");*/\n\t//先保存当前节点的后一节点\n\tNode *nextNode=delNode->next;\n\t//将后一个节点接在当前节点的前一个的后面\n\tdelNode->perv->next=nextNode;\n\tnextNode->perv=delNode->perv;\n\t//free这个节点\n\tfree(delNode);\n}\n\n//遍历链表\nvoid printlnAll(Node *head){\n\tNode *p=head->next;\n   do{\n   \t  printf(\"%d\\n\", p->data);\n   \t  p=p->next;\n   }while(p!=head);\n\t// while(p->next!=head){\n\t// \tprintf(\"%d\\n\", p->data);\n\t// \t//指针后移\n\t// \tp=p->next;\n\t// }\n}\n\n\nint main(int argc, char const *argv[])\n{\n\n\tNode* createList(int n);\n\tNode* createNode();\n\n\tNode *head=createList(3);\n\tprintf(\"遍历链表\\n\");\n\tprintlnAll(head);\n\t\n\tinsHead(head);\n\t//insAnywhere(head,0);\n\tprintf(\"在头插入节点后\\n\");\n\tprintlnAll(head);\n\n\tinsTail(head);    //下面的也可以但是效率比较低\n\t//insAnywhere(head,getLength());\n\tprintf(\"在尾插入节点后\\n\");\n\tprintlnAll(head);\n\n\t//在第一个元素后面插入元素\n\tprintf(\"---------在第一个元素后面插入元素-----\\n\");\n\tinsAnywhere(head,1);\n\tprintlnAll(head);\n\n\t//删除最后面的节点\n\tprintf(\"---------删除最后面的节点-------\\n\");\n\tdelNode(head,6);\n\tprintlnAll(head);\n\n\t//删除第一个后面的节点\n\tprintf(\"-------删除第一个后面的节点---------\\n\");\n\tdelNode(head,2);\n\t//printf(\"%d\\n\", head->next->data);\n\tprintlnAll(head);\n\treturn 0;\n}\n```\n- 线性表\n![image](http://p0.cdn.img9.top/ipfs/QmUS62kkfTx4trGRmMukDCFuJNxrKDR2P2DdoERRqf1pcr?0.png)\n这里面的链式存储结构里面的 *静态链表* 挺有意思的，不用指针实现链式结构。\n线性表的这两种结构实际上是后面其他数据结构的基础，顺序储存结构和链式储存结构也各有优劣。\n![image](http://p1.cdn.img9.top/ipfs/QmUWbnXLv86uwuCrWkp2ft6fax7TgZ1kryaCPKrWTGidsy?1.PNG)\n\n注：代码中的String是我自定义的。\n\n```java\ntypedef struct{\n\t//长度\n\tint length;\n\t//内容\n\tchar *str;\n\t//最大值\n\tint maxLength;\n}String;\n\nvoid init(String *s,int max,char * string){\n\tint i;\n\ts->maxLength=max;\n\ts->length=strlen(string);\n\t//开辟空间\n\ts->str=(char*)malloc(sizeof(char)*max);\n\t//赋值\n\tfor(i=0;i<s->length;i++){\n\t\ts->str[i]=string[i];\n\t}\n}\n\n```\n\n","tags":["数据结构","算法"],"categories":["算法"]},{"title":"Hexo添加其他的评论系统","url":"/2018/07/01/hexo-tian-jia-ping-lun-xi-tong/","content":"\n## 最近换了一个Hexo的主题，也就是现在的这款，但是支持的评论系统两个已经关了，还有一个会被墙。所以就自己来加了一个\n\n### 首先注册并登录LiveRe\n登陆注册过程就不多说了\n   选择city版的安装，会得到一段代码 \n### 在个人博客中加入LiveRe代码\n\n首先去如路径：hexo_bolg/themes/your-theme/layout/_partial/post下创建livere.ejs代码。livere.ejs的内容就是上一步中获取的代码：\n\n```\n<!-- 来必力City版安装代码 -->\n<div id=\"lv-container\" data-id=\"city\" data-uid=\"MTAyMC8zMzM5MC85OTQ2\">\n    <script type=\"text/javascript\">\n   (function(d, s) {\n       var j, e = d.getElementsByTagName(s)[0];\n\n       if (typeof LivereTower === 'function') { return; }\n\n       j = d.createElement(s);\n       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';\n       j.async = true;\n\n       e.parentNode.insertBefore(j, e);\n   })(document, 'script');\n    </script>\n<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>\n</div>\n<!-- City版安装代码已完成 -->\n```\n\n然后修改路径：hexo_bolg/themes/your-theme/layout/_partial下的article.ejs文件，在`<% if (!index && post.comments){ %>` 代码块下添加如下代码：\n\n```\n<% if (!index){ %>\n  <% if (post.comments){ %>\n  <%- partial('post/livere') %>\n  <% } else { %>\n    <div class=\"lv-container\"></div>\n  <% } %>\n<% } %>\n```\n![](http://p0.cdn.img9.top/ipfs/QmWwSjQj5zqz5mAgEtYjgTBRXRqBapvZMaEzArt8xRqQm2?0.jpg)\n\n~~此时LiveRe已经添加OK了，重新部署你的博客然后刷新页面就可以看到博客中添加好了LiveRe评论~~\n换了 Valine\n\n\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"Nmap学习","url":"/2018/06/17/nmap-xue-xi/","content":"\n## Nmap简介\n   Nmap是一个开源免费的网络发现和安全审计工具 ， 全称是NetWork  Mapper , 采用c++语言编写。纯命令行界面，Nmap官方提供了一个Zenmap的图形界面。\n\n- 关于端口\n\t·\t默认情况下，Namp会扫描1000个最有可能开放的TCP端口\n·   open：开放\n·   closed：关闭\n·   filtered：被屏蔽\n·   unfiltered：没有屏蔽还需要确认\n·   open | filtered : 开放或者屏蔽\n·   close | filtered : 关闭或屏蔽\n# 使用\n - 主机扫描\n 1. nmap  192.168.1.100 直接扫描，会扫描常用前1000个端口 扫描我的宿主机\n2. nmap -F 192.168.1.100  快速扫描，会扫描常用的前100个端口\n3. -v  显示扫描过程\nroot@kali:~# nmap -v -F  192.168.1.100\nStarting Nmap 7.70 ( https://nmap.org ) at 2018-06-17 00:55 EDT\nInitiating Ping Scan at 00:55\nScanning 192.168.1.100 [4 ports]\nCompleted Ping Scan at 00:55, 0.05s elapsed (1 total hosts)\nInitiating Parallel DNS resolution of 1 host. at 00:55\nCompleted Parallel DNS resolution of 1 host. at 00:55, 0.01s elapsed\nInitiating SYN Stealth Scan at 00:55\nScanning 192.168.1.100 [100 ports]\nDiscovered open port 135/tcp on 192.168.1.100\nDiscovered open port 139/tcp on 192.168.1.100\nDiscovered open port 445/tcp on 192.168.1.100\nDiscovered open port 3306/tcp on 192.168.1.100\nDiscovered open port 443/tcp on 192.168.1.100\nIncreasing send delay for 192.168.1.100 from 0 to 5 due to 43 out of 142 dropped probes since last increase.\nCompleted SYN Stealth Scan at 00:55, 7.68s elapsed (100 total ports)\nNmap scan report for 192.168.1.100\nHost is up (1.8s latency).\nNot shown: 94 closed ports\nPORT     STATE    SERVICE\n135/tcp  open     msrpc\n139/tcp  open     netbios-ssn\n443/tcp  open     https\n445/tcp  open     microsoft-ds\n514/tcp  filtered shell\n3306/tcp open     mysql\nRead data files from: /usr/bin/../share/nmap\nNmap done: 1 IP address (1 host up) scanned in 7.88 seconds\nRaw packets sent: 166 (7.280KB) | Rcvd: 163 (6.688KB)\n4. -sV  返回端口对应的服务信息（好慢）\n5. -O  返回对应服务的系统信息\n- 主机发现\n\t我们可以通过namp来嗅探整个局域网，扫描出局域网中在线的主机，通过ICMP ECHO扫描出在线的主机 （ping的底层原理） \n  1. nmap -sS 192.168.1.100 隐蔽扫描 -sS ，也就是SYN扫描，只管发送数据包\n  2. 查看存活主机\nnmap -sP 192.168.239.* 或者 192.168.239.0/24\n  3. 扫描主机的所有端口\nnmap -p 1-65535 192.168.239.133\n  4. 扫描主机的操作系统\nnmap -O 192.168.239.133\n  5. 查看主机个服务的版本详细信息\nnmap -sV 192.168.239.133\n- 常见的Nmap扫描类型参数\n -sT :TCP connect扫描 ，类似Metasploit中的tcp扫描\n -sS : TCP SYN扫描，类似于Metasploit 中的syn扫描模块\n -sF/-sX/-sN : 这些扫描通过发送一些特殊的标志位以避开设备或软件的监测\n -sP :通过发送ICMP echo 请求探测主机是否存货原理同Ping.\n -sU :探测主机开放了那些UDP端口。\n -sA : TCP ACK 扫描，类似与Metasploit里的ack扫描模块\n - 常见的Nmap扫描选项\n-Pn : 在扫描之前不发送ICMP echo请求测试目标是否活跃\n-O ：启用对于TCP/IP 协议栈的特征扫描以获取远程主机的操作系统\n-F ：快速扫描\n-p ：端口范围\n\n","tags":["Kali","Nmap"],"categories":["渗透"]},{"title":"Redis集群搭建","url":"/2018/05/27/redis-ji-qun-da-jian/","content":"# Redis集群搭建\n# 一、Redis简介\n\n### 1．关于关系型数据库和nosql数据库\n   关系型数据库是基于关系表的数据库，最终会将数据持久化到[磁盘]()上，而nosql数据  库是基于特殊的结构，并将数据存储到[内存]()的数据库。从性能上而言，nosql数据库  要优于关系型数据库，从安全性上而言关系型数据库要优于nosql数据库，所以在实  际开发中一个项目中nosql和关系型数据库会一起使用，达到性能和安全性的双保证\n### 2 . Redis的安装\n这里关于Redis的安装不想多说，实际生产中都是将Reids安装在Linux上的，这里主要是说集群的搭建。\n### 3. Redis的使用\n   我也是第一次接触Redis，使用其实也没什么说的 [菜鸟教程](http://www.runoob.com/redis/redis-tutorial.html)上都有，挺简单的。\n### 3. 集群的搭建\nRedis要做集群必须要有至少三个节点否则他的投票机制无法运行\n必须要有超过半数的节点都认为某一台Redis机器挂掉了才会认为集群挂掉了\n![Redis](http://p3.cdn.img9.top/ipfs/QmX5E7BViadysS6bZLs7Eeu1VSkvCHEEcUrkSVgWBjwNCx?3.png)\n\n这里再看看Redis集群的架构图![Redis](http://p3.cdn.img9.top/ipfs/QmZ6PpYPozPHppvXGRBMY5LgnrsjAqDaT2s1NoUCT8EFuD?3.png)\n架构细节:\n\n(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.\n\n(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.\n\n(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可\n\n(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->value\nRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点，所以Redis节点最多也就16384个节点最少3个节点。\n- 开始搭建\n 这里搭建的是有3个节点的最小的集群为保证集群的高可用每个节点都有一台备份机一共需要6台服务器，就需要开6个虚拟机这里其实做测试没那个必要，搭建一个伪分布式的就可以了，在一台虚拟机上搭建6个Redis实例\n- 集群搭建环境\n1、使用ruby脚本搭建集群。需要ruby的运行环境。\n安装ruby\nyum install ruby\nyum install rubygems\n(我虚拟机yum的时候一直报错无法解析，然后加了DNS后报404很奇怪 然后yum makecache后就好了)\n2、安装ruby脚本运行使用的包[redis-3.0.0.gem](https://pan.baidu.com/s/1bW6EUyeEevR5h1cT-g51mQ)。\n gem install redis-3.0.0.gem\n这个脚本在你Redis源代码的src目录下redis-trib.rb这个脚本\n 3、创建6个Redis实例\n直接copy5份编译后的Redis文件然后改下端口 把redis.conf(在Redis源代码下copy过来)里 cluster-enabled yes前注释去掉\n 3 、启动6个Redis这里可以写一个shell\n```java\ncd redis01\n./redis-server redis.conf\ncd ..\ncd redis02\n./redis-server redis.conf\ncd ..\ncd redis03\n./redis-server redis.conf\ncd ..\ncd redis04\n./redis-server redis.conf\ncd ..\ncd redis05\n./redis-server redis.conf\ncd ..\ncd redis06\n./redis-server redis.conf\ncd ..\n```\n4、用Ruby搭建集群 只需要这条命令集群就搭建完毕了\n./redis-trib.rb create --replicas 1 192.168.25.3:7001 192.168.25.3:7002 192.168.25.3:7003 192.168.25.3:7004 192.168.25.3:7005 192.168.25.3:7006\n补 ：这里的ip不要写127.0.0.1 不然连接集群的时候就会报Too many Cluster redirections?错误 亲测。。。我不是写的127.0.0.1我是因为后来虚拟机ip变了然后\nreplicas后面参数1代表每个节点会有一台备份机所以后面的ip和端口号必须是偶数\n### 4. 集群的使用\n    redis01/redis-cli -p 7002 -c \n后面的c代表连接的是集群 如果不加c就是单机的 如果存入数据的槽位不对应就会报错当然这是在命令行下的使用，windows下也有一些Redis的客户端。这里主要讲用Java代码连接Redis这就要用到Jedis了跟JDBC那一套差不多 这里直接讲在淘淘中实际是怎么用的吧\n这里有两个版本集群版和单机版 平常测试就用单机版所以可以先写一个接口，抽取一些常用的方法\n\n```java\npackage redis;\npublic interface JedisClient {\n\n\tString set(String key, String value);\n\tString get(String key);\n\tBoolean exists(String key);\n\tLong expire(String key, int seconds);\n\tLong ttl(String key);\n\tLong incr(String key);\n\tLong hset(String key, String field, String value);\n\tString hget(String key, String field);\n\tLong hdel(String key, String... field);\n}\n\n```\n然后写各自的实现类\n- 单机版\n\n```java\npackage redis;\nimport lombok.Getter;\nimport lombok.Setter;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n@Getter@Setter\npublic class JedisClientPool implements JedisClient {\n\t\n\tprivate JedisPool jedisPool;\n\n\t@Override\n\tpublic String set(String key, String value) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tString result = jedis.set(key, value);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String get(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tString result = jedis.get(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Boolean exists(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tBoolean result = jedis.exists(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long expire(String key, int seconds) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.expire(key, seconds);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long ttl(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.ttl(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long incr(String key) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.incr(key);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long hset(String key, String field, String value) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.hset(key, field, value);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String hget(String key, String field) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tString result = jedis.hget(key, field);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Long hdel(String key, String... field) {\n\t\tJedis jedis = jedisPool.getResource();\n\t\tLong result = jedis.hdel(key, field);\n\t\tjedis.close();\n\t\treturn result;\n\t}\n\n}\n\n```\n- 集群版\n\n```java\npackage redis;\nimport lombok.Getter;\nimport lombok.Setter;\nimport redis.clients.jedis.JedisCluster;\n\n@Getter@Setter\npublic class JedisClientCluster implements JedisClient {\n\t\n\tprivate JedisCluster jedisCluster;\n\n\t@Override\n\tpublic String set(String key, String value) {\n\t\treturn jedisCluster.set(key, value);\n\t}\n\n\t@Override\n\tpublic String get(String key) {\n\t\treturn jedisCluster.get(key);\n\t}\n\n\t@Override\n\tpublic Boolean exists(String key) {\n\t\treturn jedisCluster.exists(key);\n\t}\n\n\t@Override\n\tpublic Long expire(String key, int seconds) {\n\t\treturn jedisCluster.expire(key, seconds);\n\t}\n\n\t@Override\n\tpublic Long ttl(String key) {\n\t\treturn jedisCluster.ttl(key);\n\t}\n\n\t@Override\n\tpublic Long incr(String key) {\n\t\treturn jedisCluster.incr(key);\n\t}\n\n\t@Override\n\tpublic Long hset(String key, String field, String value) {\n\t\treturn jedisCluster.hset(key, field, value);\n\t}\n\n\t@Override\n\tpublic String hget(String key, String field) {\n\t\treturn jedisCluster.hget(key, field);\n\t}\n\n\t@Override\n\tpublic Long hdel(String key, String... field) {\n\t\treturn jedisCluster.hdel(key, field);\n\t}\n\n}\n\n```\n- 使用\n   使用的时候就可以写个bean然后在需要的时候就可以直接注入了\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txmlns:tx=\"http://www.springframework.org/schema/tx\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:mybatis-spring=\"http://mybatis.org/schema/mybatis-spring\"\n\txsi:schemaLocation=\"http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\n\t\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd\">\n\t<!--单机版-->\n    <!-- \t<bean id=\"jedisClientPool\" class=\"redis.JedisClientPool\">\n\t\t<property name=\"jedisPool\" ref=\"jedisPool\" />\n\t</bean>\n\t<bean id=\"jedisPool\" class=\"redis.clients.jedis.JedisPool\">\n\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t<constructor-arg name=\"port\" value=\"6379\"/>\n\t</bean> -->\n\t<!--集群版-->\n\t<bean id=\"jedisClientCluster\" class=\"redis.JedisClientCluster\">\n\t\t<property name=\"jedisCluster\" ref=\"jedisCluster\"/>\t\t\n\t</bean>\n\t\n\t<bean id=\"jedisCluster\" class=\"redis.clients.jedis.JedisCluster\">\n\t\t<constructor-arg name=\"nodes\">\n\t\t\t<set>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7001\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7002\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7003\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7004\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7005\"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class=\"redis.clients.jedis.HostAndPort\">\n\t\t\t\t\t<constructor-arg name=\"host\" value=\"192.168.25.4\"/>\n\t\t\t\t\t<constructor-arg name=\"port\" value=\"7006\"/>\n\t\t\t\t</bean>\n\t\t\t</set>\n\t\t</constructor-arg>\t\t\t\n\t</bean>\n</beans>\n```\n这里在集群的时候遇到了问题就是我上面提到的ip的问题不要写127.0.0.1要写实际的内网ip以后如果ip变了就只能重新来一次了，那个命令我试了下执行第二次，报错说我那个节点不为空，**也许**把数据清空了就可以了。\n- 测试\n```java\n\t@Test\n\tpublic void testRedis() {\n\t\t//初始化Spring容器\n\t\tApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext-redis.xml\");\n\t\t//从容器中获取jedisClient对象 (单机版) \n\t\tJedisClient jedisClient=applicationContext.getBean(JedisClient.class);\n\t\tjedisClient.set(\"testRedis\", \"Hello World\");\n\t\tSystem.out.println(jedisClient.get(\"testRedis\"));\n\t}\n```\n\n","tags":["淘淘商城","Redis","集群搭建"],"categories":["Web"]},{"title":"Mybatis逆向工程对text的特殊处理","url":"/2018/05/23/mybatis-ni-xiang-gong-cheng-dui-text-de-te-shu-chu-li/","content":"# Mybatis对Mysql中text类型的特殊处理\n- 昨天晚上在做cms的crud的时候遇到的问题，编辑的时候不回显内容，然后f12看了下响应的json里面content也为null，然后去service里面把那个pojo加了toString把几条数据直接打印出来 因为用了分页然后打印出来的也并不是数据\n\n（下次再来探究分页插件） 然后注释掉在打印发现还是没有然后我试了下单独查询，根据主键查询查出来的居然用有！！！这就很奇怪了。。。我当时就以为是byexample的mapper有问题 哈哈哈~~ 其实还是自己框架学的不好的问题\n\n```java\npublic EasyUIJsonResult listContent(long categoryId,int page,int rows) {\n\t\tEasyUIJsonResult result=new EasyUIJsonResult();\n\t\t\n\t\t//测试过程中发现PageHelper的一些问题 等下再来研究\n\t\t//PageHelper.startPage(page, rows);\n\t\tTbContentExample example =new TbContentExample();\n\t\texample.createCriteria().andCategoryIdEqualTo(categoryId);\n\t\tList<TbContent> contents = dao.selectByExample(example);\n\t\tPageInfo<TbContent> info=new PageInfo<>(contents);\n\t\n\t\t//加上PageHelper后这里打印出来的就不是contents对象了就是Page对象\n\t\t//而且查出来的数据里面content为null (数据库中有 猜想可能是逆向工程有问题);\n\t\tSystem.out.println(contents);\n\t\t\n\t\t//测试下单独查询 主键查询没问题 取的到content\n\t\tSystem.out.println(dao.selectByPrimaryKey((long)42));\n\t\t\n\t\t//单独测试下只查一个    也没有\n\t\tTbContentExample example2 =new TbContentExample();\n\t\tCriteria criteria2 = example2.createCriteria();\n\t\tcriteria2.andCategoryIdEqualTo((long)90);\n\t\tSystem.out.println(dao.selectByExample(example2 ));\n\t\t\n\t\tresult.setTotal(info.getTotal());\n\t\tresult.setRows(contents);\n\t\treturn result;\n\t}\n```\n- 然后就面向百度了一波，还真就查到了遇到跟我一样的问题[同道中人](https://ask.csdn.net/questions/205320)\nselectByExampleWithBLOBs用这个方法就可以了 看名字就知道更这个有关哈哈哈\n然后就愉快的解决了![image](http://p1.cdn.img9.top/ipfs/QmVhiMUQoFbiHc8BJxFtSzCUxVrZffnj9vYD7yM5YmCjGL?1.png)\n- 不仅仅是select update也有这个方法\n```java\npublic interface TbContentMapper {\n    int countByExample(TbContentExample example);\n\n    int deleteByExample(TbContentExample example);\n\n    int deleteByPrimaryKey(Long id);\n\n    int insert(TbContent record);\n\n    int insertSelective(TbContent record);\n\n    List<TbContent> selectByExampleWithBLOBs(TbContentExample example);\n\n    List<TbContent> selectByExample(TbContentExample example);\n\n    TbContent selectByPrimaryKey(Long id);\n\n    int updateByExampleSelective(@Param(\"record\") TbContent record, @Param(\"example\") TbContentExample example);\n\n    int updateByExampleWithBLOBs(@Param(\"record\") TbContent record, @Param(\"example\") TbContentExample example);\n\n    int updateByExample(@Param(\"record\") TbContent record, @Param(\"example\") TbContentExample example);\n\n    int updateByPrimaryKeySelective(TbContent record);\n\n    int updateByPrimaryKeyWithBLOBs(TbContent record);\n\n    int updateByPrimaryKey(TbContent record);\n}\n```\n","tags":["技术","框架"],"categories":["Web"]},{"title":"SpringMVC - 处理静态资源 (转)","url":"/2018/05/21/springmvc-chu-li-jing-tai-zi-yuan/","content":"## **【1】第一种示例与解决办法**\n\n将DispatcherServlet请求映射设置为 / ，将会拦截所有的请求。不能访问静态资源。\n\n**解决办法：**\n\n在SpringMVC的配置文件中配置如下标签解决\n\n```java\n<mvc:default-servlet-handler/>\n```\n\n其XSD文档说明如下:\n\n\n```java\n/*配置一个handler通过转发请求到servlet容器的默认servlet来处理静态资源*/\nConfigures a handler for serving static resources by forwarding to the Servlet container's default Servlet.\n\n/*使用该handler将会允许DispatcherServlet 的url-pattern为'/';同时使用servlet容器的默认servlet处理静态资源*/\nUse of this handler allows using a \"/\" mapping with the DispatcherServlet \nwhile still utilizing the Servlet container to serve static resources. \n\n/*该handler将会转发所有请求到默认servlet*/\nThis handler will forward all requests to the default Servlet. \n\n/*因此将该handler的执行顺序放到所有请求处理的最后是非常重要的！！！*/\nTherefore it is important that it remains last in the order of all other URL HandlerMappings. \n\n/*使用<mvc:annotation-driven/>标签或者设置HandlerMapping instance的order来确保DefaultServletHttpRequestHandler的order最大。*/\nThat will be the case if you use the \"annotation-driven\" element \nor alternatively if you are setting up your customized HandlerMapping instance \nbe sure to set its \"order\" property to a value lower than \nthat of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE.\n```\n\n![image](https://img-blog.csdn.net/20170914152551033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**解释如下：**\n\n`<mvc:default-servlet-handler/>`将在SpringMVC的上下文中定义一个DefaultServletHttpRequestHandler来处理静态资源(其实就是将请求转发给默认的servlet)。\n\n一般WEB服务器默认的servlet的名称为default。若所使用的WEB服务器默认的Servlet名称不是default，则需要通过default-servlet-name 属性指定！\n\n![image](https://img-blog.csdn.net/20170224143539025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n* * *\n\n**不同服务器下默认servlet名字对应如下：**\n\n```java\nTomcat, Jetty, JBoss, and GlassFish  默认 Servlet的名字 -- \"default\"\nGoogle App Engine 默认 Servlet的名字 -- \"_ah_default\"\nResin 默认 Servlet的名字 -- \"resin-file\"\nWebLogic 默认 Servlet的名字  -- \"FileServlet\"\nWebSphere  默认 Servlet的名字 -- \"SimpleFileServlet\"\n```\n\n![这里写图片描述](https://img-blog.csdn.net/20170914154653746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n* * *\n\n**【Tips：】**\n\n使用上述配置，你会发现正常的Controller跳转失效了！\n\nXSD说明最后一段话如下：\n\n```java\n/*使用<mvc:annotation-driven/>标签或者设置HandlerMapping instance的order来确保DefaultServletHttpRequestHandler的order最大。*/\nThat will be the case if you use the \"annotation-driven\" element \nor alternatively if you are setting up your customized HandlerMapping instance \nbe sure to set its \"order\" property to a value lower than \nthat of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE.\n```\n\n也就是说，要么配置`<mvc:annotation-driven />`标签，要么手动注册请求映射处理bean于xml中，并设置order属性值，以其实现框架中处理请求映射的bean的order值小于DefaultServletHttpRequestHandler的order属性值！！！\n\n常用的解决方式为配置`<mvc:annotation-driven />`标签，详情点击查看[请求映射失效](http://blog.csdn.net/j080624/article/details/66969987)。\n\n点击查看[controller映射失效](http://blog.csdn.net/J080624/article/details/66969987)\n\n* * *\n\n## **【2】第二种示例与解决办法**\n\n解决静态资源的思路是，在SpringMVC.xml中，拦截设置为”*.do”，而不是”/”。\n\n这样就不会拦截静态资源的请求。\n\n需要注意的是，如果项目中用到了shiro或者其他权限框架。那么需要注意你的shiro.xml配置，示例如下：\n\n```java\n  <bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n        <!-- Shiro的核心安全接口,这个属性是必须的 -->\n        <property name=\"securityManager\" ref=\"securityManager\"/>\n        <!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 -->\n        <property name=\"loginUrl\" value=\"/login\"/>\n\n        <!-- Shiro连接约束配置,即过滤链的定义 -->\n        <property name=\"filterChainDefinitions\">\n            <value>\n                <!-- /** = anon所有url都可以匿名访问 -->\n                <!-- 对静态资源设置匿名访问 -->\n                /images/** = anon\n                /js/** = anon\n                /styles/** = anon\n                <!-- 验证码，可匿名访问 -->\n                /validateCode = anon  <!--验证码-->\n                /doLogin = anon\n\n                <!-- /** = authc 所有url都必须认证通过才可以访问 -->\n                /**=authc\n                <!--请求logout，shrio擦除sssion-->\n                /logout=logout\n            </value>\n        </property>\n    </bean>\n```\n\n需要注意的是虽然SpringMVC拦截的是.do，但是由于使用了shiro(或者你的其他权限框架)，那么未登录情况下是不能直接访问除shiro配置文件里面允许匿名访问的路径之外的静态资源文件。\n\n举个例子，你把静态资源文件放在了项目根目录，但是参考上面配置文件，显然不在匿名访问路径列表之内，所以会提示你先登录，登录之后才可访问项目根目录的静态资源文件。\n\n*   未登录前访问项目根目录下1.jpg , 跳到登录页面：\n\n![image](https://img-blog.csdn.net/20170518094647021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n*   登录后访问项目根目录下1.jpg :\n\n![image](https://img-blog.csdn.net/20170518094717006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n另外，建议最好参考shiro配置文件，比如1.jpg放到images文件夹下，那么不用登录就可以直接访问。\n\n![image](https://img-blog.csdn.net/20170518094833869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n* * *\n\n## **【3】第三种示例与解决办法**\n\n**通过配置，避免静态资源被拦截，示例如下：**\n\n```java\n <!-- 静态资源访问（不拦截此目录下的东西的访问） -->\n    <mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\n    <mvc:resources location=\"/css/\" mapping=\"/css/**\"/>\n    <mvc:resources location=\"/images/\" mapping=\"/images/**\"/>\n    <mvc:resources location=\"/bootstrap/\" mapping=\"/bootstrap/**\"/>\n```\n\n该标签的xsd说明文档如下：\n\n```\n/*配置handler为静态资源，如images，js和CSS文件并进行缓存头优化，以便在Web浏览器中高效加载。*/\nConfigures a handler for serving static resources such as \nimages, js, and, css files with cache headers optimized for efficient loading in a web browser. \n/*允许为任何可以通过spring处理的路径资源提供服务*/\nAllows resources to be served out of any path that is reachable via Spring's Resource handling.\n```\n\n注册的handler如下：\n\n```java\norg.springframework.web.servlet.resource.ResourceHttpRequestHandler\n```\n\n**即，该标签注册ResourceHttpRequestHandler为静态资源的访问提供服务。**\n\n该handler的javadoc如下所示：\n\n```java\n{@code HttpRequestHandler} that serves static resources in an optimized way according to the guidelines of Page Speed, YSlow, etc.\n\n * <p>The {@linkplain #setLocations \"locations\"} property takes a list of Spring\n * {@link Resource} locations from which static resources are allowed to\n * be served by this handler. Resources could be served from a classpath location,\n * e.g. \"classpath:/META-INF/public-web-resources/\", allowing convenient packaging\n * and serving of resources such as .js, .css, and others in jar files.\n```\n\n* * *\n\n## **【4】第四种示例与解决办法**\n\n确切说这里只解决不通过controller而直接访问jsp的问题。\n\n`<mvc:view-controller/>`直接访问view-name对应的jsp\n\n*   jsp路径依据视图解析器配置。\n\n```java\n    <!-- mvc:view-controller可使其直接访问路径 -->  \n    <mvc:view-controller path=\"/i18n\" view-name=\"i18n\"/>\n\n    <mvc:view-controller path=\"/i18n2\" view-name=\"i18n2\"/>\n```\n","tags":["技术","Spring","转载"],"categories":["Web"]},{"title":"Spring请求参数获取的几种方式（转）","url":"/2018/05/17/spring-qing-qiu-can-shu-huo-qu/","content":"# [springmvc请求参数获取的几种方法](http://www.cnblogs.com/xiaoxi/p/5695783.html)\n**1、直接把表单的参数写在Controller相应的方法的形参中，适用于get方式提交，不适用于post方式提交。**\n\n```java \n    /** * 1.直接把表单的参数写在Controller相应的方法的形参中\n      * @param username\n     * @param password\n     * @return\n     */ @RequestMapping(\"/addUser1\") public String addUser1(String username,String password) {\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```\nurl形式：[http://localhost/SSMDemo/demo/addUser1?username=lixiaoxi&password=111111](http://localhost/SSMDemo/demo/addUser1?username=lixiaoxi&password=111111) 提交的参数需要和Controller方法中的入参名称一致。\n\n**2、通过HttpServletRequest接收，post方式和get方式都可以。**\n\n```java\n   /** 2、通过HttpServletRequest接收\n    * @param request\n     * @return\n     */ @RequestMapping(\"/addUser2\") public String addUser2(HttpServletRequest request) {\n        String username=request.getParameter(\"username\");\n        String password=request.getParameter(\"password\");\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```\n\n**3、通过一个bean来接收,post方式和get方式都可以。**\n(1)建立一个和表单中参数对应的bean\n\n```java\npackage demo.model; public class UserModel { private String username; private String password; public String getUsername() { return username;\n    } public void setUsername(String username) { this.username = username;\n    } public String getPassword() { return password;\n    } public void setPassword(String password) { this.password = password;\n    }\n\n}\n```\n\n(2)用这个bean来封装接收的参数\n\n\n\n```java\n /** * 3、通过一个bean来接收\n      * @param user\n     * @return\n     */ @RequestMapping(\"/addUser3\") public String addUser3(UserModel user) {\n        System.out.println(\"username is:\"+user.getUsername());\n        System.out.println(\"password is:\"+user.getPassword()); return \"demo/index\";\n    }\n```\n**4、通过@PathVariable获取路径中的参数**\n\n```java\n/*** 4、通过@PathVariable获取路径中的参数\n      * @param username\n     * @param password\n     * @return\n     */ @RequestMapping(value=\"/addUser4/{username}/{password}\",method=RequestMethod.GET) public String addUser4(@PathVariable String username,@PathVariable String password) {\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```\n例如，访问[http://localhost/SSMDemo/demo/addUser4/lixiaoxi/111111](http://localhost/SSMDemo/demo/addUser4/lixiaoxi/111111) 路径时，则自动将URL中模板变量{username}和{password}绑定到通过@PathVariable注解的同名参数上，即入参后username=lixiaoxi、password=111111。\n**5、使用@ModelAttribute注解获取POST请求的FORM表单数据**\nJsp表单如下：\n```java\n<form action =\"<%=request.getContextPath()%>/demo/addUser5\" method=\"post\"> 用户名:&nbsp;<input type=\"text\" name=\"username\"/><br/> 密&nbsp;&nbsp;码:&nbsp;<input type=\"password\" name=\"password\"/><br/>\n     <input type=\"submit\" value=\"提交\"/> \n     <input type=\"reset\" value=\"重置\"/> \n</form> \n```\nJava Controller如下：\n\n```java \n/** * 5、使用@ModelAttribute注解获取POST请求的FORM表单数据\n     * @param user\n     * @return\n     */ @RequestMapping(value=\"/addUser5\",method=RequestMethod.POST) public String addUser5(@ModelAttribute(\"user\") UserModel user) {\n        System.out.println(\"username is:\"+user.getUsername());\n        System.out.println(\"password is:\"+user.getPassword()); return \"demo/index\";\n    } \n```\n\n \n\n**6、用注解@RequestParam绑定请求参数到方法入参**\n当请求参数username不存在时会有异常发生,可以通过设置属性required=false解决,例如: @RequestParam(value=\"username\", required=false)\n\n```java \n/** * 6、用注解@RequestParam绑定请求参数到方法入参\n      * @param username\n     * @param password\n     * @return\n     */ @RequestMapping(value=\"/addUser6\",method=RequestMethod.GET) public String addUser6(@RequestParam(\"username\") String username,@RequestParam(\"password\") String password) {\n        System.out.println(\"username is:\"+username);\n        System.out.println(\"password is:\"+password); return \"demo/index\";\n    }\n```","tags":["Spring","转载"],"categories":["Web"]},{"title":"FastDFS学习","url":"/2018/05/16/fastdfs/","content":"# FastDFS学习笔记\n- FastDFS简介\n\tFastDFS服务端有两个角色：跟踪器（tracker）和存储[节点](https://baike.baidu.com/item/%E8%8A%82%E7%82%B9)（storage）。跟踪器主要做调度工作，在访问上起负载均衡的作用。\n存储节点存储文件，完成文件管理的所有功能：就是这样的存储、同步和提供存取接口，FastDFS同时对文件的metadata进行管理。所谓文件的meta data就是文件的相关属性，以键值对（key value）方式表示，如：width=1024，其中的key为width，value为1024。文件metadata是[文件属性](https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7)列表，可以包含多个键值对。\n跟踪器和存储节点都可以由一台或多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。\n为了支持大容量，存储[节点](https://baike.baidu.com/item/%E8%8A%82%E7%82%B9)（服务器）采用了分卷（或分组）的组织方式。[存储系统](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F)由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台[存储服务器](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8)组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了[冗余备份](https://baike.baidu.com/item/%E5%86%97%E4%BD%99%E5%A4%87%E4%BB%BD)和负载均衡的作用。\n在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。\n当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了[存储系统](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F)的容量。\nFastDFS中的文件标识分为两个部分：卷名和文件名，二者缺一不可。\n- 大胆分析\n这里在淘淘的后台上传图片的时候用到了,确实好用也是c语言开发的 搭配*Nginx*贼方便,确实佩服那些搞**C**的大佬，上面的说法不够直白文字总是苍白的(￣▽￣)~*让我来强行解释一波![image](http://p1.so.qhmsg.com/bdr/_240_/t0183119f547ca0bbc6.png)\n上面说到了**FastDFS**主要有两个节点\n 1. 储存节点Storage  \n顾名思义就是用来储存文件的服务器这个图中的是比较复杂的情况这里有一个stroage 群里又分了很多组每个组里又有很多服务器（这里的服务器里面储存的文件是一样的 会自动同步 方便加机器）\n  2. 监控节点Tracker \n这个就跟[zookeper](http://www.so.com/link?m=a0NGOfhwBC5nSFnUTBxpX2uhRysff5w5UsQFEqgCBRrJbwZpybFckcSRdwhuJdbgSApcIIqhL0gq5D6eIbBJ5pN22O2Z0k6ENTFGSjrRpsgETp2Dl)作用有点像先上图\n![image](http://p0.cdn.img9.top/ipfs/QmZynH9DgJJbePkn35LjhRTc6xyyWL64jNT6QU6jyBnrXE?0.png\n)\n这个是上传的过程可以看到客户端要上传图片都是通过Tracker的而储存节点也会定时向Tracker发送状态的信息监控Storage的状态\n`可以看出上面Client在上传图片成功后Storage返回了一个file_id然后客户端就会储存这个id那客户端是如何通过这个id访问到这个图片的呢？ ---没错就是Nginx 用Nginx来处理这些静态资源再好不过了`\n- 使用\n 说了这么多来实际用用看吧  \n   1. 首先我们要在虚拟机上安装FastDFS并配置Nginx这个过程比较复杂也不是我们重点关心的问题是运维应该关心的问题这里有一个搭建好的最简单的[FastDFS服务器](https://pan.baidu.com/s/1u5FLtQu71CueAJwq63ji6A)开机就可以直接用服务都是开机自启动的  \n  2. 然后我们要有客户端这里FastDFS作者已经写好了JAVA的客户端我们直接拿来用就好了[fastdfs_client的jar包](https://pan.baidu.com/s/1KY5BKUr6f1PlCRR7hyhRSA)\n  3. 开始使用吧  \n\n``` java\n@Test\n\tpublic void testUpload() throws Exception {\n\n\t\t//1、加载配置文件，配置文件中的内容就是tracker服务的地址。\n\t\t//配置文件内容：tracker_server=192.168.25.133:22122\n\t\tClientGlobal.init(\"D:\\\\JavaDemo\\\\taoshop-web\\\\src\\\\main\\\\resources\\\\conf\\\\client.conf\");\n\t\t//2、创建一个TrackerClient对象。直接new一个。\n\t\tTrackerClient trackerClient =new TrackerClient();\n\t\t//3、使用TrackerClient对象创建连接，获得一个TrackerServer对象。\n\t\tTrackerServer trackerServer = trackerClient.getConnection();\n\t\t//4、创建一个StorageServer的引用，值为null\n\t\tStorageServer storageServer =null;\n\t\t//5、创建一个StorageClient对象，需要两个参数TrackerServer对象、StorageServer的引用\n\t\tStorageClient storageCilent =new StorageClient(trackerServer,storageServer);\n\t\t//6、使用StorageCilent上传文件\n\t\tString[] strings = storageCilent.upload_file(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\image\\\\222.jpg\",\"jpg\", null);\n\t\tfor (String string : strings) {\n\t\t\tSystem.out.println(string);\n\t\t}\n```\n这里最后也就是为了的到StorageServer对象 我们可以写个工具类方便我们上传，将得到的file信息直接放在虚拟机ip/后面\n![image](http://p3.so.qhimgs1.com/bdr/_240_/t0151a407cda74a2153.png)成功访问到了这张图片！还是很方便的。\n- 在淘淘商城中的运用\n   在淘淘中主要是用在后台的图片上传上的 这里用的是ssm的组合SpringMVC上传图片首先要有commons.io和fileupload的jar包还有配置多媒体解析器\n在这里我也遇到了一个小问题 他在这里用的是*KingEditor* 上传图片时要求返回的格式是\n```  java\n  //成功时\n  { \n        \"error\" : 0,\n        \"url\" : \"http://www.example.com/path/to/file.ext\"\n}\n//失败时\n{\n        \"error\" : 1,\n        \"message\" : \"错误信息\"\n}\n```\n我直接返回的一个map然后前台解析不出来出现了问题后来用fastJson把map转成json后就好了但是其实传还是传到了图片服务器上去了\n\n- 在做这个的时候还遇到了一些奇怪的问题就是如果修改代码后马上重新启动项目会报错clean一下就好了。","tags":["入门","FastDFS","淘淘商城"],"categories":["运维"]},{"title":"Nginx学习","url":"/2018/05/13/nginx-xue-xi/","content":"# Nginx学习笔记\n- Nginx简介\n  _Nginx_ (engine x) 是一个高性能的[HTTP](https://baike.so.com/doc/5366073-5601774.html)和[反向代理](https://baike.so.com/doc/5345781-5581226.html)服务器，也是一个IMAP/POP3/SMTP[服务器](https://baike.so.com/doc/4487696-4696885.html)。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点(俄文:Рамблер)开发的，第一个公开版本0.1.0发布于2004年10月4日。\n其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。\nNginx是一款[轻量级](https://baike.so.com/doc/585215-619452.html)的[Web](https://baike.so.com/doc/4230501-4432285.html) 服务器/[反向代理](https://baike.so.com/doc/5345781-5581226.html)服务器及[电子邮件](https://baike.so.com/doc/928072-980969.html)(IMAP/POP3)代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，[并发](https://baike.so.com/doc/6916691-7138566.html)能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有:百度、京东、[新浪](https://baike.so.com/doc/2204905-2333035.html)、网易、[腾讯](https://baike.so.com/doc/1038695-1098608.html)、淘宝等。\n\t\n- Nginx主要作用\n1. (Http服务器)处理静态文件\n![image](http://p0.cdn.img9.top/ipfs/QmdiKx1JUr7y9TabUQNNqu5dP8AwdsHSHe9QMwa487rsaS?0.png)\n像这样配置的话当访问 *localhost:80* 时就会访问到相对当前路径下的 html文件夹下的index.html 或者index.htm\n2. 反向代理\n    **反向代理** 也是nginx用的最多的地方，既然有反向代理那就肯定有 **正向代理** 先来理解下正向代理![image](https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/zhidao/pic/item/a2cc7cd98d1001e96d753f76b10e7bec54e79779.jpg)\n正向代理其实就是代理上网，**客户端**发送请求到代理服务器然后代理服务器转交请求给**目标服务器**目标服务器响应给代理服务器代理服务器再响应给**客户端**也就起到了代理的作用\n那反向代理是什么呢？\n![image](https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/zhidao/pic/item/a8014c086e061d95f3f21c4172f40ad162d9ca17.jpg)\n正向代理针对的是**客户端**而反向代理正对的是**服务端**\n当用户发送一个请求给ServerB然后ServerB判断用户是什么请求\n是请求Server1就转发给Server1... 在生产中前端用一个Nginx处理用户的请求再分发到不同的后端服务器。\n**配置**\n```java\nupstream sina{\n\tserver 192.168.125.3:8080;\n    }\n    server {\n        listen       80;\n        server_name  www.sina.com.cn;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            proxy_pass   http://sina;\n            index  index.html index.htm;\n        }\n\n    }\n\n     upstream sohu{\n\tserver 192.168.125.3:8081;\n    }\n    server {\n        listen       80;\n        server_name  www.sohu.com;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n\t\t\t#交给谁代理\n            proxy_pass   http://sohu;\n            index  index.html index.htm;\n        }\n\n    }\n```\n\n像这样配置客户端访问通过一个公网ip入口先到达Nginx然后转发给对应的服务器当用户访问*www.sohu.com*时就会转发给http://sohu 这个就是上面的upstream sohu{...} 交给它处理\n3. 负载均衡和容错\n\t负载均衡就是在反向代理的中间加上的 就是在upstream 里面加一个server，最简单的负载均衡就是轮询一人一次刷新就换(*默认的就是轮询*) 当然你也可以根据服务器性能配置权重权重越大访问到的机会越大\n\n```java\nupstream sina{\n\tserver 192.168.125.3:8080;\n\t#weigth是权重\n\tserver 192.168.25.148:8082 weight=2;\n    }\n    server {\n        listen       80;\n        server_name  www.sina.com.cn;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            proxy_pass   http://sina;\n            index  index.html index.htm;\n         }\n       }\n```\n由于Nginx是我们网站的入口如果Nginx挂掉后面的服务就都失效了这时候就可以加备用Nginx服务器用 keepalive+Nginx实现主备![image](http://p0.cdn.img9.top/ipfs/Qmc3nC82Xsh1QANbUfAdDGUmTL2KJ2bQzoYzge7VHvRRWu?0.png)\n","tags":["Nginx"],"categories":["Web"]},{"title":"Hexo第一篇博客","url":"/2018/05/10/hexo-de-di-yi-pian-bo-ke/","content":"第一篇Hexo博客\n=====\n- 才开始接触*markdown*不太熟悉，不过感觉还是很有意思的 😂  \n\n![image](http://p4.cdn.img9.top/ipfs/QmcPovxCWmXZdSB7GYz1RJUp1twhrnHEeZMDnidv4S5kvB?4.jpg\n)\n- 本来是想把这个博客放到我的阿里云上的，但是感觉日常写写博客也够了，移过去可以自己写写后台但感觉有点麻烦，等到以后有时间了再来折腾，日常用用这个静态的就够了 用了cdn加速访问速度还可以😉\n- 其实之前自己也自己做了一个博客 前台后台都是自己写的 前端不太熟悉用的bs，后台是ssm的 本来想上线的 但是感觉太丑了了而且后台的代码也还有问题😂放张图对比下\n![image](http://p1.cdn.img9.top/ipfs/Qmc73XD1sHrvpEM2Wn8DMSXZcvRGjSW2x7GJPuzhjJa68c?1.jpg\n) 就这个画风 响应式也被我禁用了 实在是响应的太诡异了 再看看*material* \n `Hexo的一款主题` \n![image](http://p1.cdn.img9.top/ipfs/QmcghHet9V1iE2CXxYnUh9VbwQq6STX3ZpsZqs6ruy657h?1.png)\n\n---\n ![mark](http://static.imlgw.top///20190127/0ddQkCXFDNyh.png?imageslim) 第2个主题\n\n---\n\n目前的是第三个\n\n- 认认真真的写博客了。","tags":["入门","Hexo","体验"],"categories":["Hexo"]}]