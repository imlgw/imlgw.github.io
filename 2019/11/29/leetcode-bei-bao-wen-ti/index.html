<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>LeetCode背包问题 | iMlGw0</title><meta name="description" content="LeetCode背包问题"><meta name="keywords" content="LeetCode,背包"><meta name="author" content="imlgw"><meta name="copyright" content="imlgw"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/jedi-solid.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LeetCode背包问题"><meta name="twitter:description" content="LeetCode背包问题"><meta name="twitter:image" content="http://static.imlgw.top/blog/20191117/lAgAEVtKwR4j.jpg?imageslim"><meta property="og:type" content="article"><meta property="og:title" content="LeetCode背包问题"><meta property="og:url" content="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/"><meta property="og:site_name" content="iMlGw0"><meta property="og:description" content="LeetCode背包问题"><meta property="og:image" content="http://static.imlgw.top/blog/20191117/lAgAEVtKwR4j.jpg?imageslim"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/"><link rel="prev" title="堆和优先队列" href="http://imlgw.top/2019/12/01/dui-he-you-xian-dui-lie/"><link rel="next" title="Map映射" href="http://imlgw.top/2019/11/25/map-ying-she/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?93be601f1b40364d8cd640d751012180";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"imlgw.top","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">iMlGw0</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/board/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> LeetCode</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://imlgw.top/2019/02/27/leetcode-lian-biao/"><i class="fa-fw fa fa-tags"></i><span> 链表</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/05/04/leetcode-shu-zu/"><i class="fa-fw fa fa-tags"></i><span> 数组</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/"><i class="fa-fw fa fa-tags"></i><span> 栈&amp;队列</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 二分查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/"><i class="fa-fw fa fa-tags"></i><span> 二叉树</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/"><i class="fa-fw fa fa-tags"></i><span> 滑动窗口</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/"><i class="fa-fw fa fa-tags"></i><span> 动态规划</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/"><i class="fa-fw fa fa-tags"></i><span> 背包问题</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/10/leetcode-hui-su/"><i class="fa-fw fa fa-tags"></i><span> 回溯</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-address-book"></i><span> 大佬们</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://static.imlgw.top/blog/20191125/NtrimWLEnNSI.png?imageslim" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">58</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">58</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/board/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> LeetCode</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://imlgw.top/2019/02/27/leetcode-lian-biao/"><i class="fa-fw fa fa-tags"></i><span> 链表</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/05/04/leetcode-shu-zu/"><i class="fa-fw fa fa-tags"></i><span> 数组</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/"><i class="fa-fw fa fa-tags"></i><span> 栈&amp;队列</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 二分查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/"><i class="fa-fw fa fa-tags"></i><span> 二叉树</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/"><i class="fa-fw fa fa-tags"></i><span> 滑动窗口</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/"><i class="fa-fw fa fa-tags"></i><span> 动态规划</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/"><i class="fa-fw fa fa-tags"></i><span> 背包问题</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/10/leetcode-hui-su/"><i class="fa-fw fa fa-tags"></i><span> 回溯</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-address-book"></i><span> 大佬们</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#92-背包问题（lintCode）"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">92.背包问题（lintCode）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#416-分割等和子集"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">416. 分割等和子集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#322-零钱兑换"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">322. 零钱兑换</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#518-零钱兑换-II"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">518. 零钱兑换 II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#377-组合总和-Ⅳ"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">377. 组合总和 Ⅳ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#494-目标和"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">494. 目标和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#474-一和零"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">474. 一和零</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#139-单词拆分"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">139. 单词拆分</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1255-得分最高的单词集合"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">1255. 得分最高的单词集合</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#92-背包问题（lintCode）"><span class="toc-number">1.</span> <span class="toc-text">92.背包问题（lintCode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-分割等和子集"><span class="toc-number">2.</span> <span class="toc-text">416. 分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-零钱兑换"><span class="toc-number">3.</span> <span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#518-零钱兑换-II"><span class="toc-number">4.</span> <span class="toc-text">518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#377-组合总和-Ⅳ"><span class="toc-number">5.</span> <span class="toc-text">377. 组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#494-目标和"><span class="toc-number">6.</span> <span class="toc-text">494. 目标和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#474-一和零"><span class="toc-number">7.</span> <span class="toc-text">474. 一和零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-单词拆分"><span class="toc-number">8.</span> <span class="toc-text">139. 单词拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1255-得分最高的单词集合"><span class="toc-number">9.</span> <span class="toc-text">1255. 得分最高的单词集合</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://static.imlgw.top/blog/20191117/lAgAEVtKwR4j.jpg?imageslim)"><div id="post-info"><div id="post-title"><div class="posttitle">LeetCode背包问题</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-11-29<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2019-12-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">209</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 1 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><blockquote>
<p>从<a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/">动态规划专题</a> 中抽取出来的</p>
</blockquote>
<h2 id="92-背包问题（lintCode）"><a href="#92-背包问题（lintCode）" class="headerlink" title="92.背包问题（lintCode）"></a><a href="https://www.lintcode.com/problem/backpack/description" target="_blank" rel="noopener">92.背包问题（lintCode）</a></h2><p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p>
<ul>
<li>你不可以将物品进行切割</li>
</ul>
<p><strong>样例</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">样例 <span class="number">1</span>:</span><br><span class="line">	输入:  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>], backpack size=<span class="number">10</span></span><br><span class="line">	输出:  <span class="number">9</span></span><br><span class="line">样例 <span class="number">2</span>:</span><br><span class="line">	输入:  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], backpack size=<span class="number">12</span></span><br><span class="line">	输出:  <span class="number">12</span></span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>挑战</strong></p>
<ul>
<li><p>O(n x m) time and O(m) memory.</p>
</li>
<li><p>O(n x m) memory is also acceptable if you do not know how to optimize memory.</p>
</li>
</ul>
<p><strong>解法一</strong></p>
<p>记忆化递归，对于每个元素，有两种选择，装或者不装🤣 （不知道为啥这么经典的题目LeetCode上居然没有</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//用Integer[][],空间会超空间。。。lintCode好严格</span></span><br><span class="line"><span class="keyword">int</span> [][] cache=<span class="keyword">null</span>;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack2</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    cache=<span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<a.length;i++) {< span><br><span class="line">        Arrays.fill(cache[i],-<span class="number">1</span>);   </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="keyword">null</span> || A.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> putPack(m,A,A.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将A[index,A.len-1]范围内的元素装进大小为m的背包的最大收益</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">putPack</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="comment">//index==0的时候不应该返回=0代表第一个,是可以装的</span></span><br><span class="line">    <span class="comment">//对于m也是一样, 这种边界思考一下m就等于0，或者就只有一个元素，index就等于0这种特例就可以</span></span><br><span class="line">    <span class="comment">//只要这种特例是正确的那么整个递归就是正确的,并不需要去思考整个递归的结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (index<<span class="number">0</span> || m<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index][m]!=-<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][m];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//不装index位置的元素</span></span><br><span class="line">    <span class="keyword">int</span> res=putPack(m,A,index-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (A[index]<=m) {</span><br><span class="line">        <span class="comment">//说明可以装下index位置的元素，所以我们将index位置的元素装进去试试看</span></span><br><span class="line">        <span class="comment">//然后求出剩下的空间还最多能装多少，最后求是装index收益大还是不装index收益大</span></span><br><span class="line">        res=Math.max(res,A[index]+putPack(m-A[index],A,index-<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    cache[index][m]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></a.length;i++)></span></pre></td></tr></tbody></table></figure></div>

<p>暴力递归的时间复杂度将会是<code>O((2^N)*N)</code></p>
<p>其实整个递归的思路是很清晰明白的，对于每个元素，有两种情况，这也是之所以称之为0-1背包的原因</p>
<ul>
<li>不选的话，背包的容量不变，改变为问题<code>putPack(m,A,index-1)</code></li>
<li>选的话，背包的容量变小，改变为问题<code>putPack(m-A[index],A,index-1)+A[index]</code></li>
</ul>
<p>到底选还是不选，取决于两种方案哪一种更好，我们要求的，就是这个最好的方案，知道了这样的递推关系后我们就可以很容易的写出递归方程，这里在递归的过程中有可能会产生重叠的子问题（其实这里我还纠结了好一会儿，我一直感觉没有重叠的子问题，后来画一下递归树就明白了，只是重叠的不明显），所以我们可以通过缓存每次计算的结果来进行记忆化递归，整体的时间复杂度应该是<code>O(2^N)</code>，空间<code>O(M*N)</code>显然不是我们想要的结果</p>
<blockquote>
<p>这里一开始我是想用<code>Integer[][]</code>的数组，然后就不用赋初始值，判断不为null就行，结果空间溢出了。。。lintCode好严格，换成<code>int[][]</code>然后赋个初始值就过了</p>
</blockquote>
<p><strong>解法二</strong></p>
<p>动态规划解法，在讲解之前，我们用一个二维表来分析下整个递推的过程</p>
<p>物品列表（样例1），因为这题价值就是重量，所以w和v是一样的</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>w</td>
<td>3</td>
<td>4</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td>v</td>
<td>3</td>
<td>4</td>
<td>8</td>
<td>5</td>
</tr>
</tbody></table>
<p>DpTable（样例1）</p>
<table>
<thead>
<tr>
<th align="center">index\m</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td align="center">1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td align="center">2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td align="center">3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>9</td>
</tr>
</tbody></table>
<p>一行一行的看，从左到右，<code>dp[index][m]</code>代表 <strong>背包总容量不超过m的情况下，考虑装入<code>[0,index]</code>中的元素能获得最大收益</strong>，比如<code>dp[1][7]</code>代表的就是背包总容量不超过7的情况下，考虑装入<code>[0,1]</code> 范围内的元素所能获得的最大收益，人脑思考结果自然是7了，下面我们分析下如果dp推出这个结果</p>
<p>前面我们已经分析过0-1背包的递归过程，每个元素面临两个选择，这里也一样</p>
<p><code>dp[1][7]</code>如果我们选择不装入当前index位置的元素的话，那么最大收益就是<code>dp[0][7]=3</code>这一点应该没啥疑问</p>
<p>如果我们考虑装入当前index位置的元素的话，m肯定会减小，那么所获得的最大收益就应该是<code>A[index]+dp[0][7-4]=7</code> </p>
<blockquote>
<p>注意这里当前index的值都是依赖于上一层<code>index-1</code>的计算结果的，也就是依赖于上一次<code>m,[0,index-1]</code>最大值的结果，所以我们需要手动的初始化第一层的值）</p>
</blockquote>
<p>最后我们得到的核心状态方程就是下面这样的</p>
<p><code>dp[index][m]=max(dp[index-1][m],A[index]+dp[index-1][j-A[index]])</code></p>
<p>然后我们根据这个很容易就可以写出dp的解法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//二维动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="keyword">null</span> || A.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[A.length][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<a.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=m;j++) {</span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">0</span>) {<span class="comment">//初始化第一列</span></span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) {<span class="comment">//初始化第一行</span></span><br><span class="line">                dp[i][j]=j-A[i]>=<span class="number">0</span>?A[i]:<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (i><span class="number">0</span>) {</span><br><span class="line">                dp[i][j]=j-A[i]>=<span class="number">0</span>?Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-A[i]]+A[i]):dp[i-<span class="number">1</span>][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[A.length-<span class="number">1</span>][m];</span><br><span class="line">}</span><br></a.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<p>当然我们肯定是不满足于这种二维的dp的，所以我们还得优化下空间，这里每一层都只依赖于上一层的结果，所以我么很容易就可以改成一维的，当然这里还有个小坑，如果直接按照上面的代码来改的话就是错的，我们先看看正确的改法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack4</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="keyword">null</span> || A.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<a.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=m;j>=<span class="number">0</span>;j--) {<span class="comment">//从右向左，避免覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">0</span>) {<span class="comment">//初始化第一列</span></span><br><span class="line">                dp[j]=<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) {<span class="comment">//初始化第一行</span></span><br><span class="line">                dp[j]= j-A[i]>=<span class="number">0</span>?A[i]:<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[j]=j-A[i]>=<span class="number">0</span>?Math.max(dp[j],dp[j-A[i]]+A[i]):dp[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">}</span><br></a.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<p>可以看到，我们的内层循环不再是从左往右，而是从右往左，这样的好处就是避免了<code>dp[j-A[i]]</code>已经被<code>当前层前面的元素</code>覆盖的尴尬情况，结合上面的表推一下就知道了</p>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>注意:</strong></p>
<ol>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ol>
<p><strong>示例 1:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>].</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>示例 2:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>解法一</strong></p>
<p>现在递归写起来已经有点感觉了，类似的题基本上都能写出记忆化递归的方法来</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归37ms 44%,开始慢是因为stream的原因</span></span><br><span class="line">Boolean[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//int sum=Arrays.stream(nums).sum();</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e:nums) sum+=e; <span class="comment">//求和</span></span><br><span class="line">    cache=<span class="keyword">new</span> Boolean[nums.length][sum+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">2</span>!=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> partition(nums,<span class="number">0</span>,<span class="number">0</span>,sum/<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试添加[0,index]位置的元素,看能否使得half=sum (这里其实应该直接在sum上减,看能不能减为0)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> half,<span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==nums.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index][half]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][half];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (half==sum) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    cache[index][half]=partition(nums,index+<span class="number">1</span>,half,sum) || </span><br><span class="line">        (half<sum&&partition(nums,index+<span class="number">1</sum&&partition(nums,index+<span></span>,half+nums[index],sum));<br><span class="line">    <span class="keyword">return</span> cache[index][half];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>解法二</strong></p>
<p>动态规划，依然是典型的背包问题，可以理解为用nums中的元素，填满sum/2容量大小的背包，递推公式</p>
<p> <code>dp[i][j] =dp[i-1][j] || dp[i-1][j-nums[i]]</code>  选当前元素和不选当前元素，有一个能填满就ok</p>
<p><code>dp[i][j]</code> 含义为：考虑<code>[0,i]</code> 范围内的元素，能否恰好装满 <code>j</code>大小的容器</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//二维dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//int sum=Arrays.stream(nums).sum(); 用stream好慢</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e:nums) sum+=e; <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">2</span>!=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> half=sum/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//dp[i][j]的含义是从[0,i]中选取元素,能否刚好填满j</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length][half+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=half;j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j]= nums[<span class="number">0</span>]==j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=half;j++) {</span><br><span class="line">            dp[i][j]= j>=nums[i]?dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i]]:dp[i-<span class="number">1</span>][j];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果在某个位置（每行最后一个）已经刚好填满了就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i][half]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][half];</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<p>空间上的优化</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e:nums) sum+=e; <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">2</span>!=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> half=sum/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//dp[j]的含义是从[0,i]中选取元素,能否刚好填满j</span></span><br><span class="line">    <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[half+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=half;j++) {</span><br><span class="line">        dp[j]= nums[<span class="number">0</span>]==j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=half;j>=nums[i];j--) {</span><br><span class="line">            <span class="comment">//dp[i][j]= j>=nums[i]?dp[i-1][j] || dp[i-1][j-nums[i]]:dp[i-1][j];</span></span><br><span class="line">            dp[j]=dp[j]||dp[j-nums[i]];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (dp[half]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[half];</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例 1:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>示例 2:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>说明:</strong><br>你可以认为每种硬币的数量是无限的</p>
<p><strong>解法一</strong></p>
<p>其实就是dfs，我最开始就是写的dfs只不过时间复杂度太高，没做记忆化，这里其实一开始做了记忆化也一直没跑过，一直超时，最后给的case是6249 好像也不算很大吧，然后我后来把<code>fill</code> 填充数组删了，用Integer就跑过了。。。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归AC 50%左右</span></span><br><span class="line"><span class="keyword">private</span> Integer[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange2</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount)</span></span>{</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//Arrays.fill(cache,-1); 这里fill直接tle了。。。。</span></span><br><span class="line">    <span class="keyword">return</span> takeCoins(coins,amount);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">takeCoins</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[amount]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[amount];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//int t1=coins(coins,amount,index+1);</span></span><br><span class="line">    <span class="keyword">int</span> res=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (amount<coins[i]) <span class="keyword">continue</coins[i])></span>;</coins.length;i++)></span><br><span class="line">        <span class="keyword">int</span> sub=takeCoins(coins,amount-coins[i]);</span><br><span class="line">        <span class="keyword">if</span> (sub!=-<span class="number">1</span>) {</span><br><span class="line">            res=Math.min(sub+<span class="number">1</span>,res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cache[amount]= res==Integer.MAX_VALUE?-<span class="number">1</span>:res;</span><br><span class="line">    <span class="keyword">return</span> cache[amount];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>解法二</strong></p>
<p>动态规划，二维dp，注意这里其实和前面的背包问题就有区别了，这里实际上就是个<code>无限背包</code>问题，因为这里的硬币是无限的，每个面值的硬币都可以重复的选取</p>
<p><strong>DpTable</strong></p>
<table>
<thead>
<tr>
<th>Coin / Amount</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>0（1）</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td>1（2）</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td><code>3</code></td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>2（5）</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>状态定义</strong></p>
<p>这里<code>dp[i][j]</code> 的含义为：<strong>考虑<code>[0，i]</code> 范围内的元素，能凑成 <code>j</code> 所需的最少硬币数</strong>，和之前的01背包问题状态定义没什么区别</p>
<p><strong>状态方程</strong></p>
<p>首先明确一点，这里我们对第<code>coins[i]</code>个硬币有两种选择 </p>
<ol>
<li>不拿 </li>
<li>拿，拿1~k个(k为硬币个数的限制，这里没有限制，所以是无穷大)</li>
</ol>
<p>进而我们可以的到状态转移的方程：</p>
<p><code>f[i][j] = min(f[i-1][j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)</code></p>
<p>但是这个方程有很多计算是重复的</p>
<p><code>f[i][j-c]=min(f[i-1][j-c], f[i-1][j-2*c]+1, ..., f[i-1][j-k*c]+k-1)</code></p>
<p>两者合并得到</p>
<p><code>f[i][j] = min(f[i-1]f[j], f[i][j-c]+1)</code>  有了状态方程，代码就好写了</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange4</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[coins.length][amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j]=j%coins[<span class="number">0</span>]==<span class="number">0</span>?j/coins[<span class="number">0</span>]:Integer.MAX_VALUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">            <span class="keyword">if</span> (j<coins[i] || dp[i][j-coins[i]]="=Integer.MAX_VALUE)" {< span><br><span class="line">                <span class="comment">//放不下</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                dp[i][j]=Math.min(dp[i][j-coins[i]]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[coins.length-<span class="number">1</span>][amount]!=Integer.MAX_VALUE?dp[coins.length-<span class="number">1</span>][amount]:-<span class="number">1</span>;</span><br><span class="line">}</span><br></coins[i]></span></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div>

<p><strong>空间优化</strong></p>
<p>感觉一维的解释起来会更加清晰易懂 <code>f(11)=1 + min(f(10),f(9),f(6))</code> 这个里面就具有最优子结构，而且一看就明白了</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//填充初始值为Integer.MAX_VALUE,代表不可达</span></span><br><span class="line">    Arrays.fill(dp,Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//除了dp[0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="comment">//注意这里不能逆序！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=coins[i];j<=amount;j++) {</span><br><span class="line">            <span class="keyword">if</span> (dp[j-coins[i]]!=Integer.MAX_VALUE) {</span><br><span class="line">                dp[j]=Math.min(dp[j-coins[i]]+<span class="number">1</span>,dp[j]);   </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==Integer.MAX_VALUE?-<span class="number">1</span>:dp[amount];</span><br><span class="line">}</span><br></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个</p>
<p><strong>示例 1:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>示例 2:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">3</span>, coins = [<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 只用面额<span class="number">2</span>的硬币不能凑成总金额<span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>示例 3:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">10</span>, coins = [<span class="number">10</span>] </span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>注意:</strong></p>
<p>你可以假设：</p>
<ul>
<li>0 <= amount (总金额) <= 5000</li>
<li>1 <= coin (硬币面额) <= 5000</li>
<li>硬币种类不超过 500 种</li>
<li>结果符合 32 位符号整数</li>
</ul>
<p><strong>解法一</strong></p>
<p>求方案数，不考虑顺序</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (coins==<span class="keyword">null</span> || coins.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> amount==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[coins.length][amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) {</span><br><span class="line">                dp[<span class="number">0</span>][j]=j%coins[i]==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) {</span><br><span class="line">                dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                  dp[i][j]= j>=coins[i]?dp[i-<span class="number">1</span>][j]+dp[i][j-coins[i]]:dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//dp[i][j]= j>=coins[i]?dp[i-1][j]+dp[i-1][j-coins[i]]:dp[i-1][j];</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[coins.length-<span class="number">1</span>][amount];</span><br><span class="line">}</span><br></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<p><strong>空间优化</strong></p>
<p><code>f(5)=f(4)+f(3)+f(0)</code> 突然感觉写二维的有点多余。。。这种子结构要清晰的多</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//直接理解一维dp还是不太容易,但是知道递推公式后先写个二维dp再改为一维就很容易</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这种方式相当于对dpTable从左向右,一行行的递推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">            <span class="comment">//dp[j]+= dp[j-coins[i]]:0;</span></span><br><span class="line">            dp[j]=j-coins[i]>=<span class="number">0</span>?dp[j]+dp[j-coins[i]]:dp[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* 交换一下内外顺序就变成了另一个问题的解</span></span><br><span class="line"><span class="comment">    for (int j=0;j<=amount;j++) {</span></span><br><span class="line"><span class="comment">        for (int i=0;i<coins.length;i++) {< span></coins.length;i++)></span><br><span class="line"><span class="comment">            dp[j]+= j-coins[i]>=0?dp[j-coins[i]]:0;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">}</span><br></span></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<p><strong>解法二</strong></p>
<p>记忆化递归，基本上dp能过得，记忆化递归一定能过，相比之下，我觉得记忆化递归会好写一些</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (coins==<span class="keyword">null</span> || coins.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> amount==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[coins.length][amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> takeCoins(amount,coins,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Integer[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[index,coins.length] 中凑成amount的方案数，考虑顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">takeCoins</span><span class="params">(<span class="keyword">int</span> amount,<span class="keyword">int</span>[] coins,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (index>=coins.length || amount<<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index][amount]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][amount];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (amount==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[index][amount]=takeCoins(amount-coins[index],coins,index)+takeCoins(amount,coins,index+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a></h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p><strong>示例:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">target = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line"></span><br><span class="line">因此输出为 <span class="number">7</span>。</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>进阶：</strong><br>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？</p>
<p><strong>解法一</strong></p>
<p>记忆化递归，没啥好说的</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归 1ms 100%</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[target+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> combination(nums,target);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Integer[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (cache[target]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[target];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (target-nums[i]>=<span class="number">0</span>) {</span><br><span class="line">            res+=combination(nums,target-nums[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[target]=res;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div>
<p><strong>解法二</strong></p>
<p>动态规划，乍一看好像和上面一题一样，实际上并不一样，这里是考虑顺序的，最优子结构也是</p>
<p><code>f(5)=f(4)+f(3)+f(0)</code> 这样的</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//一维dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<=target;i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<nums.length;j++) {< span><br><span class="line">            dp[i]+= i>=nums[j]?dp[i-nums[j]]:<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">}</span><br></nums.length;j++)></span></pre></td></tr></tbody></table></figure></div>

<p>这里还是要存个疑啊，没搞明白啊，为啥交换个顺序就不一样了呢？一个是按行打表，一个是按列打表？？？还是递归好写。。。</p>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a></h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p><strong>示例 1:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">一共有<span class="number">5</span>种方法让最终目标和为<span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>注意:</strong></p>
<ul>
<li>数组非空，且长度不会超过20。</li>
<li>初始的数组的和不会超过1000。</li>
<li>保证返回的最终结果能被32位整数存下</li>
</ul>
<p><strong>解法一</strong></p>
<p>后面的题都优先写记忆化递归了，动态规划确实有点难顶</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap<integer,integer> cache=new HashMap<></integer,integer></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span> || S><span class="number">1000</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)sum+=n;</span><br><span class="line">    <span class="keyword">if</span>(S>sum)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相当于平移了一下,从[-sum,sum] --> [0,2*sum]</span></span><br><span class="line">    cache=<span class="keyword">new</span> Integer[nums.length][<span class="number">2</span>*sum+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findTarget(nums,S,<span class="number">0</span>,<span class="number">2</span>*sum+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTarget</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> S,<span class="keyword">int</span> index,<span class="keyword">int</span> max)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (S==<span class="number">0</span> && index ==nums.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index>=nums.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(S <<span class="number">0</span>  && cache[index][S+max]!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> cache[index][S+max];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (S>=<span class="number">0</span> && cache[index][S]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][S];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> temp=findTarget(nums,S-nums[index],index+<span class="number">1</span>,max)+findTarget(nums,S+nums[index],index+<span class="number">1</span>,max);</span><br><span class="line">    <span class="keyword">if</span> (S<<span class="number">0</span>) {</span><br><span class="line">        cache[index][S+max]=temp;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        cache[index][S]=temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>  temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>这题还是挺有意思的，因为里面是有负数的，直接记忆化是不行的，需要转换一下，这里我是直接将cache数组扩大，同时保证不会有覆盖，所以直接扩大为 2sum就ok，这样整个S的范围就从<code>[-sum,+sum]</code> 变为 <code>[0,2sum]</code> 从而可以缓存所有的递归结果，其实也可以使用两个数组一个存正数，一个存负数，然后只需要符号取反就ok了，只不过占用的空间会大一点</p>
<h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a></h2><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p>
<p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p>
<p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p>
<p><strong>注意:</strong></p>
<ul>
<li>给定 0 和 1 的数量都不会超过 100。</li>
<li>给定字符串数组的长度不会超过 600。</li>
</ul>
<p><strong>示例 1:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: Array = {<span class="string">"10"</span>, <span class="string">"0001"</span>, <span class="string">"111001"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>}, m = <span class="number">5</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释: 总共 <span class="number">4</span> 个字符串可以通过 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 拼出，即 <span class="string">"10"</span>,<span class="string">"0001"</span>,<span class="string">"1"</span>,<span class="string">"0"</span> 。</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>示例 2:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: Array = {<span class="string">"10"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>}, m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 你可以拼出 <span class="string">"10"</span>，但之后就没有剩余数字了。更好的选择是拼出 <span class="string">"0"</span> 和 <span class="string">"1"</span> 。</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>解法一</strong></p>
<p>其实这是一个多重背包问题，一个物品有多个权值</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer [][][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[m+<span class="number">1</span>][n+<span class="number">1</span>][strs.length];</span><br><span class="line">    <span class="keyword">return</span> findMax(strs,m,n,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//m:0 n:1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index>=strs.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[m][n][index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[m][n][index];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] oz=count(strs[index]);</span><br><span class="line">    <span class="keyword">if</span> (oz[<span class="number">1</span>]<=n && oz[<span class="number">0</span>]<=m) {</span><br><span class="line">        <span class="keyword">return</span> cache[m][n][index]=Math.max(<span class="number">1</span>+findMax(strs,m-oz[<span class="number">0</span>],n-oz[<span class="number">1</span>],index+<span class="number">1</span>),findMax(strs,m,n,index+<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[m][n][index]=findMax(strs,m,n,index+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] count(String str){</span><br><span class="line">    <span class="keyword">int</span> one=<span class="number">0</span>,zero=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] s=str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c:s) {</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="string">'1'</span>) {</span><br><span class="line">            one++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            zero++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{zero,one};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"leetcode"</span>, wordDict = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">"leetcode"</span> 可以被拆分成 <span class="string">"leet code"</span>。</span><br></pre></td></tr></tbody></table></figure></div>


<p><strong>示例 2：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"applepenapple"</span>, wordDict = [<span class="string">"apple"</span>, <span class="string">"pen"</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">"applepenapple"</span> 可以被拆分成 <span class="string">"apple pen apple"</span>。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></tbody></table></figure></div>


<p><strong>示例 3：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"catsandog"</span>, wordDict = [<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>解法一</strong></p>
<p>记忆化递归，值得注意的点就是递归的终止条件</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归</span></span><br><span class="line">Boolean[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List<string> wordDict)</string></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    cache=<span class="keyword">new</span> Boolean[s.length()];</span><br><span class="line">    HashSet<string> set=<span class="keyword">new</span> HashSet<>(wordDict);</string></span><br><span class="line">    <span class="keyword">return</span> dfs(s,set,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断【index,s.len】中的字符是否能拆分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, HashSet<string> dict,<span class="keyword">int</span> index)</string></span> </span>{</span><br><span class="line">    <span class="comment">//终止条件一开始写的false....</span></span><br><span class="line">    <span class="comment">//这里的终止条件还是有点迷惑的,这里index只有在字典中存在当前元素的时候才会向后移动</span></span><br><span class="line">    <span class="comment">//所以当index移动到s==length的时候就说明前面的单词都匹配上了</span></span><br><span class="line">    <span class="keyword">if</span> (index==s.length()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index+<span class="number">1</span>;i<=s.length();i++) {</span><br><span class="line">        <span class="comment">//System.out.println(s.substring(index,i));</span></span><br><span class="line">        <span class="comment">//这里下一次dfs的index也要注意</span></span><br><span class="line">        <span class="keyword">if</span> (dict.contains(s.substring(index,i)) && dfs(s,dict,i)){</span><br><span class="line">            <span class="keyword">return</span> cache[index]=<span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[index]=<span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>解法二</strong></p>
<p>看了官方的解有BFS，然后也实现了一下</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//BFS,需要一个visit保证不会重复访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List<string> wordDict)</string></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    HashSet<string> dict=<span class="keyword">new</span> HashSet<>(wordDict);</string></span><br><span class="line">    <span class="comment">//queue中存index</span></span><br><span class="line">    LinkedList<integer> queue=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">    queue.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> index=queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (!visit[index]) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=index+<span class="number">1</span>;i<=s.length();i++) {</span><br><span class="line">                <span class="keyword">if</span>(dict.contains(s.substring(index,i))){</span><br><span class="line">                    <span class="keyword">if</span> (i==s.length()) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            visit[index]=<span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>一开始没想到用visit数组，感觉index是递增的好像没什么重复的元素，但是其实是有的，不用visit会超时</p>
<h2 id="1255-得分最高的单词集合"><a href="#1255-得分最高的单词集合" class="headerlink" title="1255. 得分最高的单词集合"></a><a href="https://leetcode-cn.com/problems/maximum-score-words-formed-by-letters/" target="_blank" rel="noopener">1255. 得分最高的单词集合</a></h2><p>你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。</p>
<p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。</p>
<p>单词拼写游戏的规则概述如下：</p>
<ul>
<li>玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。</li>
<li>可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。</li>
<li>单词表 words 中每个单词只能计分（使用）一次。</li>
<li>根据字母得分情况表score，字母 ‘a’, ‘b’, ‘c’, … , ‘z’ 对应的得分分别为 score[0], score[1], …, score[25]。</li>
<li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和</li>
</ul>
<p><strong>示例 1：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"dad"</span>,<span class="string">"good"</span>], letters = [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"d"</span>,<span class="string">"d"</span>,<span class="string">"g"</span>,<span class="string">"o"</span>,<span class="string">"o"</span>], score = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">23</span></span><br><span class="line">解释：</span><br><span class="line">字母得分为  a=<span class="number">1</span>, c=<span class="number">9</span>, d=<span class="number">5</span>, g=<span class="number">3</span>, o=<span class="number">2</span></span><br><span class="line">使用给定的字母表 letters，我们可以拼写单词 <span class="string">"dad"</span> (<span class="number">5</span>+<span class="number">1</span>+<span class="number">5</span>)和 <span class="string">"good"</span> (<span class="number">3</span>+<span class="number">2</span>+<span class="number">2</span>+<span class="number">5</span>)，得分为 <span class="number">23</span> 。</span><br><span class="line">而单词 <span class="string">"dad"</span> 和 <span class="string">"dog"</span> 只能得到 <span class="number">21</span> 分。</span><br></pre></td></tr></tbody></table></figure></div>


<p><strong>示例 2：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">"xxxz"</span>,<span class="string">"ax"</span>,<span class="string">"bx"</span>,<span class="string">"cx"</span>], letters = [<span class="string">"z"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"x"</span>,<span class="string">"x"</span>,<span class="string">"x"</span>], score = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">27</span></span><br><span class="line">解释：</span><br><span class="line">字母得分为  a=<span class="number">4</span>, b=<span class="number">4</span>, c=<span class="number">4</span>, x=<span class="number">5</span>, z=<span class="number">10</span></span><br><span class="line">使用给定的字母表 letters，我们可以组成单词 <span class="string">"ax"</span> (<span class="number">4</span>+<span class="number">5</span>)， <span class="string">"bx"</span> (<span class="number">4</span>+<span class="number">5</span>) 和 <span class="string">"cx"</span> (<span class="number">4</span>+<span class="number">5</span>) ，总得分为 <span class="number">27</span> 。</span><br><span class="line">单词 <span class="string">"xxxz"</span> 的得分仅为 <span class="number">25</span> 。</span><br></pre></td></tr></tbody></table></figure></div>


<p><strong>示例 3：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">"leetcode"</span>], letters = [<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"t"</span>,<span class="string">"c"</span>,<span class="string">"o"</span>,<span class="string">"d"</span>], score = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">字母 <span class="string">"e"</span> 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 <= words.length <= 14</code></li>
<li><code>1 <= words[i].length <= 15</code></li>
<li><code>1 <= letters.length <= 100</code></li>
<li><code>letters[i].length == 1</code></li>
<li><code>score.length == 26</code></li>
<li><code>0 <= score[i] <= 10</code></li>
<li><code>words[i] 和 letters[i]</code>只包含小写的英文字母</li>
</ul>
<p><strong>解法一</strong></p>
<p>看着题目就知道这题不简单😂，11.10的周赛最后一题，1ms，用01背包的思路做的，很多地方其实还没处理好</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreWords</span><span class="params">(String[] words, <span class="keyword">char</span>[] letters, <span class="keyword">int</span>[] score)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] les=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<letters.length;i++) {< span><br><span class="line">        les[letters[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxScoreWords(words,letters,score,<span class="number">0</span>,les);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreWords</span><span class="params">(String[] words, <span class="keyword">char</span>[] letters, <span class="keyword">int</span>[] score,<span class="keyword">int</span> index,<span class="keyword">int</span>[] les)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==words.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=maxScoreWords(words,letters,score,index+<span class="number">1</span>,les);</span><br><span class="line">    String word=words[index];</span><br><span class="line">    <span class="keyword">if</span> (hasWord(les,word)) {</span><br><span class="line">        <span class="keyword">int</span>[] bak=<span class="keyword">new</span> <span class="keyword">int</span>[les.length];</span><br><span class="line">        System.arraycopy(les,<span class="number">0</span>,bak,<span class="number">0</span>,les.length);</span><br><span class="line">        res=Math.max(res,getScore(bak,word,score)+maxScoreWords(words,letters,score,index+<span class="number">1</span>,bak));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWord</span><span class="params">(<span class="keyword">int</span>[] les,String word)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[] bak=<span class="keyword">new</span> <span class="keyword">int</span>[les.length];</span><br><span class="line">    System.arraycopy(les,<span class="number">0</span>,bak,<span class="number">0</span>,les.length);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:word.toCharArray()){</span><br><span class="line">        <span class="keyword">if</span> (bak[c-<span class="string">'a'</span>]!=<span class="number">0</span>) {</span><br><span class="line">            bak[c-<span class="string">'a'</span>]--;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count==word.length();</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span>[] les,String word,<span class="keyword">int</span>[] score)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> sc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c:word.toCharArray()) {</span><br><span class="line">        les[c-<span class="string">'a'</span>]--;</span><br><span class="line">        sc+=score[c-<span class="string">'a'</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sc;</span><br><span class="line">}</span><br></letters.length;i++)></span></pre></td></tr></tbody></table></figure></div></body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">imlgw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/">http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://imlgw.top">iMlGw0</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode    </a><a class="post-meta__tags" href="/tags/%E8%83%8C%E5%8C%85/">背包    </a></div><div class="post_share"><div class="social-share" data-image="http://static.imlgw.top/blog/20191117/lAgAEVtKwR4j.jpg?imageslim" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.png" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/01/dui-he-you-xian-dui-lie/"><img class="prev_cover lazyload" data-src="http://static.imlgw.top/image/featureimages/2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>堆和优先队列</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/25/map-ying-she/"><img class="next_cover lazyload" data-src="http://static.imlgw.top/blog/20191125/CdEsM2h5DuSX.png?imageslim" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Map映射</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/16/lrucache/" title="LRU队列实现"><img class="relatedPosts_cover lazyload"data-src="http://static.imlgw.top/image/featureimages/8.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-23</div><div class="relatedPosts_title">LRU队列实现</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/06/leetcode-er-fen-cha-zhao/" title="LeetCode二分查找"><img class="relatedPosts_cover lazyload"data-src="http://static.imlgw.top/5.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-23</div><div class="relatedPosts_title">LeetCode二分查找</div></div></a></div><div class="relatedPosts_item"><a href="/2019/09/15/leetcode-cha-zhao/" title="LeetCode查找"><img class="relatedPosts_cover lazyload"data-src="http://static.imlgw.top/blog/20190915/vqTRbmP6PbOo.jpg?imageslim"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-23</div><div class="relatedPosts_title">LeetCode查找</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'MkcXmeDvktRNBDBrVqb9KYPH-MdYXbMMI',
  appKey:'swDnb5a9u9Ksp2Rwkdm7Qulh',
  placeholder:'留下邮箱才能收到及时收到回复~~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(http://static.imlgw.top/blog/20191117/lAgAEVtKwR4j.jpg?imageslim)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By imlgw</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://beian.miit.gov.cn/publish/query/indexFirst.action" target="_blank" rel="noopener"><span>鄂ICP备18011208号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="undefined" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body></html>