
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="LeetCode," />
  

  
    <meta name="description" content="大悲无泪，大悟无言，大笑无声。" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/img/cat.ico">
  
  <title>LeetCode栈&amp;队列 [ iMlGw0 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">iMlGw0</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">分类</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">归档</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">标签</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="LC" class="pure-menu-link">LC</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/05/04/leetcode-shu-zu/" style="color:#202020;" class="pure-menu-link">数组</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/" style="color:#202020;" class="pure-menu-link">链表</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/" style="color:#202020;" class="pure-menu-link">栈&amp;队列</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/" style="color:#202020;" class="pure-menu-link">查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/" style="color:#202020;" class="pure-menu-link">滑动窗口</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/" style="color:#202020;" class="pure-menu-link">动态规划</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/" style="color:#202020;" class="pure-menu-link">二分查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/" style="color:#202020;" class="pure-menu-link">二叉树</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/" style="color:#202020;" class="pure-menu-link">背包问题</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/10/leetcode-hui-su/" style="color:#202020;" class="pure-menu-link">回溯</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/01/21/leetcode-tan-xin/" style="color:#202020;" class="pure-menu-link">贪心</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        LeetCode栈&amp;队列
      </h1>
      <span>
        
        <time class="time" datetime="2019-09-30T16:00:00.000Z">
        2019-10-01
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 142 分钟</span>
    </header>

    <div class="post-content">
      <h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"()"</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"(]"</span></span><br><span class="line">Output: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"([)]"</span></span><br><span class="line">Output: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>这道题只要学过数据结构的肯定会做，典型的利用栈的题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span> || s.charAt(i)==<span class="string">'&#123;'</span> || s.charAt(i)==<span class="string">'['</span>)&#123;</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//注意这种情况，一开始就是])&#125;</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> p=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>( (p==<span class="string">')'</span> &amp;&amp; stack.pop()!=<span class="string">'('</span>) || (p==<span class="string">']'</span> &amp;&amp; stack.pop()!=<span class="string">'['</span>) || (p==<span class="string">'&#125;'</span> &amp;&amp; stack.pop()!=<span class="string">'&#123;'</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>其实和上面的解法是一样的，只不过是用的stack是自己用数组简单封装的栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    T [] objValues=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        objValues= (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        objValues[++top]=obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objValues[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//覆盖</span></span><br><span class="line">        <span class="keyword">return</span> objValues[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3ms，94%，比之前快了一点，去看了下Stack的源码，它的pop是真的删除，我的只是移动了指针，所以效率会高很多</p>
<blockquote>
<p>后面的题可能还会利用这个<code>MyStack</code></p>
</blockquote>
<p><strong>解法三</strong></p>
<p>今天看面筋看到一个写这道题，要求O(1)的空间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        s=s.replace(<span class="string">"&#123;&#125;"</span>,<span class="string">""</span>);</span><br><span class="line">        s=s.replace(<span class="string">"()"</span>,<span class="string">""</span>);</span><br><span class="line">        s=s.replace(<span class="string">"[]"</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (len==s.length()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.equals(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>100ms，效率感人，感觉应该说的是这种做法吧，当然还可以写正则表达式来匹配，但是我不太会写。。。</p>
<h2 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">678. 有效的括号字符串</a></h2><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ol>
<li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li>
<li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li>
<li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li>
<li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>


<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"(*)"</span></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>


<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"(*))"</span></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>


<p><strong>注意:</strong></p>
<ol>
<li>字符串大小将在 [1，100] 范围内。</li>
</ol>
<p><strong>解法一</strong></p>
<p>看面筋看到的这一题，还是挺有意思的，评论区有人说了双栈，然后今天来试了下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; bracketStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; starStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>) &#123;</span><br><span class="line">            bracketStack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            starStack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (bracketStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (starStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                starStack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bracketStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消除左括号</span></span><br><span class="line">    <span class="keyword">while</span>(!starStack.isEmpty() &amp;&amp; !bracketStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(starStack.peek()&gt;bracketStack.peek())&#123; <span class="comment">//这里的逻辑不太好，其实可以很简单</span></span><br><span class="line">            bracketStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        starStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bracketStack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很可惜没有<code>bugfree</code>，最后对左括号的判断改了好几次，一开始写的<code>bracketStack.size()&lt;=starStack().size()</code>  然后提交后才意识到还要 <code>&quot;*(&quot;</code> 这样的情况，然后要消除这种情况也简单，一开始我再栈中存的就是index，从star栈里面取比bracket栈index大的，然后消除，最后再看括号栈是不是空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2020.4.10重写一下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; helpStack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(helpStack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                helpStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            helpStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; !helpStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop()&gt;helpStack.pop())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"3[a]2[bc]"</span>, 返回 <span class="string">"aaabcbc"</span>.</span><br><span class="line">s = <span class="string">"3[a2[c]]"</span>, 返回 <span class="string">"accaccacc"</span>.</span><br><span class="line">s = <span class="string">"2[abc]3[cd]ef"</span>, 返回 <span class="string">"abcabccdcdcdef"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>借助栈直接在原字符上做改动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换为StringBuilder比较好处理,且效率较高</span></span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    Stack&lt;Integer&gt;  stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//遍历索引</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;sb.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.charAt(i)==<span class="string">'['</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sb.charAt(i)==<span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left=stack.pop();<span class="comment">//对应左括号索引</span></span><br><span class="line">            String temp=sb.substring(left+<span class="number">1</span>,i);<span class="comment">//相邻括号中的字符</span></span><br><span class="line">            <span class="keyword">int</span> preInt=left;</span><br><span class="line">            <span class="comment">//'['前的数字,一开始以为只是个位数,还是挺麻烦的</span></span><br><span class="line">            <span class="keyword">while</span>(preInt-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; sb.charAt(preInt-<span class="number">1</span>)&gt;=<span class="string">'0'</span> &amp;&amp; sb.charAt(preInt-<span class="number">1</span>) &lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                preInt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//repeat次数</span></span><br><span class="line">            <span class="keyword">int</span> repeat=Integer.valueOf(sb.substring(preInt,left));</span><br><span class="line">            <span class="comment">//删除 k[encoded_string] </span></span><br><span class="line">            sb.delete(preInt,Math.min(i+<span class="number">1</span>,sb.length()));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;repeat;j++) &#123;</span><br><span class="line">                <span class="comment">//从k位置重新插入字符</span></span><br><span class="line">                sb.insert(preInt,temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新定位索引到尾部</span></span><br><span class="line">            i=preInt+(repeat*temp.length())-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始是想用一个额外的String来保存结果，结果发现比较麻烦，索性直接将原字符转换为StringBuilder，然后借助api直接在原字符上做改动，因为是在原字符上做改动，所以索引的变化需要额外的注意，这也是最麻烦的一点，需要停下来稍微思考下才能确定，其他的还好，正常的思路，最初WA了一发是因为忽略了前面的数字可能是多位数😂</p>
<p><strong>解法二</strong></p>
<p>递归的方式，改成<code>StringBuilder</code>应该会好一点😂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>; <span class="comment">//字符索引下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String sb=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;s.length())&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(index)==<span class="string">']'</span>) &#123; <span class="comment">//遇到右括号就结束</span></span><br><span class="line">            index++;<span class="comment">//index定位到右括号下一个</span></span><br><span class="line">            <span class="keyword">return</span> sb;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(index)&gt;=<span class="string">'0'</span> &amp;&amp; s.charAt(index)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=index;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;s.length() &amp;&amp; s.charAt(index)!=<span class="string">'['</span>)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> repeat=Integer.valueOf(s.substring(temp,index));</span><br><span class="line">            index++;<span class="comment">//跳过'['</span></span><br><span class="line">            String rs=decodeString(s);<span class="comment">//从左括号开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;repeat;i++) &#123;</span><br><span class="line">                sb+=rs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb+=s.charAt(index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span><br><span class="line">输出：[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">"H"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"h"</span>]</span><br><span class="line">输出：[<span class="string">"h"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"H"</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>很久之前做的了，本来是想单独搞一个递归专题，感觉没啥必要就直接加到一起了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    reverseString(s,<span class="number">0</span>,s.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> temp=s[l];</span><br><span class="line">    s[l]=s[r];</span><br><span class="line">    s[r]=temp;</span><br><span class="line">    reverseString(s,++l,--r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h2><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p>
<p>有效的运算符包括 <code>+, -, *, /</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式</p>
<p>说明：</p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>]</span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: ((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>) = <span class="number">9</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: (<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>)) = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"10"</span>, <span class="string">"6"</span>, <span class="string">"9"</span>, <span class="string">"3"</span>, <span class="string">"+"</span>, <span class="string">"-11"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>, <span class="string">"*"</span>, <span class="string">"17"</span>, <span class="string">"+"</span>, <span class="string">"5"</span>, <span class="string">"+"</span>]</span><br><span class="line">输出: <span class="number">22</span></span><br><span class="line">解释: </span><br><span class="line">  ((<span class="number">10</span> * (<span class="number">6</span> / ((<span class="number">9</span> + <span class="number">3</span>) * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / (<span class="number">12</span> * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / -<span class="number">132</span>)) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * <span class="number">0</span>) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= (<span class="number">0</span> + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= <span class="number">17</span> + <span class="number">5</span></span><br><span class="line">= <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上面自己封装的Stack</span></span><br><span class="line">    MyStack&lt;Integer&gt; stack=<span class="keyword">new</span> MyStack&lt;&gt;(tokens.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tokens.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.equals(tokens[i]))&#123;</span><br><span class="line">            stack.push(stack.pop()+stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(tokens[i]))&#123;</span><br><span class="line">            <span class="keyword">int</span> rd1=stack.pop();</span><br><span class="line">            <span class="keyword">int</span> rd2=stack.pop();</span><br><span class="line">            stack.push(rd2-rd1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(tokens[i]))&#123;</span><br><span class="line">            stack.push(stack.pop()*stack.pop());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(tokens[i]))&#123;</span><br><span class="line">            <span class="keyword">int</span> div1=stack.pop();</span><br><span class="line">            <span class="keyword">int</span> div2=stack.pop();</span><br><span class="line">            stack.push(div2/div1);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(Integer.valueOf(tokens[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12ms，90%，其实一开始看到这个题我是拒绝的，我以为又是啥数学题，然后仔细看了下发现挺简单的，思路就是利用栈，每次遇到符号就pop两个出来进行运算，然后再入栈，值得注意的地方就是减法和除法的顺序</p>
<h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></h2><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 / 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"/home/"</span></span><br><span class="line">输出：<span class="string">"/home"</span></span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"/../"</span></span><br><span class="line">输出：<span class="string">"/"</span></span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></table></figure>


<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"/home//foo/"</span></span><br><span class="line">输出：<span class="string">"/home/foo"</span></span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure>


<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"/a/./b/../../c/"</span></span><br><span class="line">输出：<span class="string">"/c"</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"/a/../../b/../c//.//"</span></span><br><span class="line">输出：<span class="string">"/c"</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 6：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"/a//b////c/d//././/.."</span></span><br><span class="line">输出：<span class="string">"/a/b/c"</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    MyStack&lt;String&gt; stack=<span class="keyword">new</span> MyStack&lt;&gt;(path.length());</span><br><span class="line">    StringBuilder str=<span class="keyword">new</span> StringBuilder(path);</span><br><span class="line">    <span class="comment">//这里划分出来有一部分是空的 ""</span></span><br><span class="line">    String[] s=path.split(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; s[i].equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">            <span class="comment">//.. 回溯</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">"."</span>.equals(s[i]) &amp;&amp; !<span class="string">""</span>.equals(s[i]) &amp;&amp; !s[i].equals(<span class="string">".."</span>) ) &#123;</span><br><span class="line">            <span class="comment">//普通的英文字符abcd</span></span><br><span class="line">            stack.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stack.size(); i++) &#123;</span><br><span class="line">        res.append(<span class="string">"/"</span>+stack.get(i));   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己封装的stack</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    T [] objValues=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        objValues= (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        objValues[++top]=obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objValues[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//覆盖</span></span><br><span class="line">        <span class="keyword">return</span> objValues[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&gt;top || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"index is wrong"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objValues[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题本来是很简单的，但是我钻到牛角尖去了，一直想着怎么在遍历过程中处理，写了一堆ifelse。。。还是太菜了啊，其实直接按照<code>&quot;/&quot;</code> 划分split字符串然后处理那个数组就可以了</p>
<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyStack stack = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);  </span><br><span class="line">stack.top();   <span class="comment">// returns 2</span></span><br><span class="line">stack.pop();   <span class="comment">// returns 2</span></span><br><span class="line">stack.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<ul>
<li>You must use <em>only</em> standard operations of a queue – which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<p><strong>解法一</strong></p>
<p>很经典的题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;Integer&gt; queue=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> ArrayDeque();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        <span class="comment">//除了新加入的元素，其他的元素都出队再入队，将新加入的元素推置队列头</span></span><br><span class="line">        <span class="keyword">while</span>(size-- &gt;<span class="number">1</span>)&#123;</span><br><span class="line">            queue.add(queue.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很巧妙的做法，将元素前n-1个出队后再重新入队，<code>1 2 --&gt; 2 1</code> 直接将堆顶推置队列头 ，将每次新加入的元素都放置队列头而不是队尾，这样实际上就完成了逆序的操作</p>
<p>这样push压栈时间复杂度<code>O(N)</code> ，<code>pop/peek</code> 时间复杂度<code>O(1)</code></p>
<p><strong>解法二</strong></p>
<p>适用于push频繁的stack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">   <span class="comment">//形式上q1是负责进栈 q2负责出栈</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList inQueue=<span class="keyword">new</span> LinkedList(); </span><br><span class="line">    <span class="keyword">private</span> LinkedList outQueue=<span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        inQueue.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// q1 ----&gt; q2 留一个</span></span><br><span class="line">        <span class="keyword">while</span>(inQueue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            outQueue.add(inQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换q1,q2的引用</span></span><br><span class="line">        LinkedList temp;</span><br><span class="line">        temp=inQueue;</span><br><span class="line">        inQueue=outQueue;</span><br><span class="line">        outQueue=temp;</span><br><span class="line">        <span class="keyword">return</span> outQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//q1 ---&gt;q2 留一个,最后一个不poll,最后poll</span></span><br><span class="line">        <span class="keyword">while</span>(inQueue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            outQueue.add(inQueue.poll());</span><br><span class="line">            <span class="keyword">if</span>(inQueue.size()==<span class="number">1</span>)&#123;</span><br><span class="line">                outQueue.add(inQueue.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换q1,q2的引用</span></span><br><span class="line">        LinkedList temp;</span><br><span class="line">        temp=inQueue;</span><br><span class="line">        inQueue=outQueue;</span><br><span class="line">        outQueue=temp;</span><br><span class="line">        <span class="keyword">return</span> outQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个队列，push压栈时间复杂度<code>O(1)</code>，pop/push出栈时间复杂度<code>O(N)</code> ，出栈的时候将一个队列的前n-1个元素全部加入到另一个队列中作为缓存，然后将最后一个元素出栈，最后别忘了交换两个队列的引用，不然push的时候就会出问题，要保证<code>inQueue</code> 一直是入栈的队列，其中存放着所有的元素</p>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  <span class="comment">// returns 1</span></span><br><span class="line">queue.pop();   <span class="comment">// returns 1</span></span><br><span class="line">queue.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<ul>
<li>You must use <em>only</em> standard operations of a stack – which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; inStack=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; outStack=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack2Queue232</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        outStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s2s();</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s2s();</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outStack.isEmpty() &amp;&amp; inStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">s2s</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!inStack.isEmpty()) &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很上面一题是姊妹题，需要注意的地方就是<code>s2s</code>的时候要确保stack2栈是空的才能push</p>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><p>push(x) – 将元素 x 推入栈中。</p>
</li>
<li><p>pop() – 删除栈顶的元素。</p>
</li>
<li><p>top() – 获取栈顶元素。</p>
</li>
<li><p>getMin() – 检索栈中的最小元素。</p>
</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>利用辅助栈，同步的push和pop</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helpStack=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helpStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (helpStack.isEmpty()) &#123;</span><br><span class="line">            helpStack.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (helpStack.peek()&gt;x) &#123;</span><br><span class="line">                helpStack.push(x);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                helpStack.push(helpStack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        helpStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helpStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>在上面的基础上进行空间的优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helpStack=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helpStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (helpStack.isEmpty()) &#123;</span><br><span class="line">            helpStack.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x&lt;=helpStack.peek()) &#123;</span><br><span class="line">            <span class="comment">//相等的也要入栈,不然不好控制后面出栈</span></span><br><span class="line">            helpStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top=stack.pop();</span><br><span class="line">        <span class="comment">//和辅助栈栈顶相同就出栈</span></span><br><span class="line">        <span class="keyword">if</span>(top==helpStack.peek())&#123;</span><br><span class="line">            helpStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(stack.pop()==helpStack.peek())&#123;</span></span><br><span class="line"><span class="comment">            helpStack.pop();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helpStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里有一个地方把我卡了一会儿，就是出栈的时候，我开始为了简洁if的条件写的</p>
<p><code>stack.pop()==helpStack.peek()</code> 然后卡在了一个case上，想了半天才意识到是<code>Integer</code>的问题，这里弹出来的是两个<code>Integer</code>并不会自动拆箱，而且值是不在 -128~127之间的，所以就false了</p>
<p><strong>解法三</strong></p>
<p>帅地上看见的解法，在栈中存一个diff差值，代表当前元素和入栈前的min的差值，空间复杂度为O(1)，但是这种做法限制比较多，比如数据的大小会有限制，同时貌似也无法做<code>peek()</code>操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack155_2</span></span>&#123;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack155_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            min=x;</span><br><span class="line">            stack.push(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> diff=x-min;</span><br><span class="line">            min=diff&gt;<span class="number">0</span>?min:x;</span><br><span class="line">            stack.push(diff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff=stack.pop();</span><br><span class="line">        <span class="comment">//小于等于0说明 min就是当前真实的栈顶元素,也就是说 min-minPre=diff</span></span><br><span class="line">        min=diff&lt;=<span class="number">0</span>?min-diff:min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*public int top() &#123;</span></span><br><span class="line"><span class="comment">        int diff=stack.peek();</span></span><br><span class="line"><span class="comment">        return diff&lt;=0?min:diff-min;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="779-第K个语法符号"><a href="#779-第K个语法符号" class="headerlink" title="779. 第K个语法符号"></a><a href="https://leetcode-cn.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">779. 第K个语法符号</a></h2><p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code> with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p>
<p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Examples:</span><br><span class="line">Input: N = <span class="number">1</span>, K = <span class="number">1</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Input: N = <span class="number">2</span>, K = <span class="number">1</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Input: N = <span class="number">2</span>, K = <span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Input: N = <span class="number">4</span>, K = <span class="number">5</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">row <span class="number">2</span>: <span class="number">01</span></span><br><span class="line">row <span class="number">3</span>: <span class="number">0110</span></span><br><span class="line">row <span class="number">4</span>: <span class="number">01101001</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li>
<li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li>
</ol>
<p><strong>解法一</strong></p>
<p>找规律，前半部分和后半部分是有一定规律的，把前六行都写出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一行: <span class="number">0</span></span><br><span class="line">第二行: <span class="number">01</span></span><br><span class="line">第三行: <span class="number">01</span>|<span class="number">10</span></span><br><span class="line">第四行: <span class="number">01</span> <span class="number">10</span>|<span class="number">10</span> <span class="number">01</span></span><br><span class="line">第五行: <span class="number">01</span> <span class="number">10</span> <span class="number">10</span> <span class="number">01</span>|<span class="number">10</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span></span><br><span class="line">第六行: <span class="number">01</span> <span class="number">10</span> <span class="number">10</span> <span class="number">01</span> <span class="number">10</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span> | <span class="number">10</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span> <span class="number">01</span> <span class="number">10</span> <span class="number">10</span> <span class="number">01</span></span><br></pre></td></tr></table></figure>

<p>  N%2!=0 对称, 第K个等于 2^(N-1)-K+1<br>  N%2==0 互补对称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(K==<span class="number">1</span> || N==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(K==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>&lt;&lt;(N-<span class="number">1</span>); <span class="comment">//当前行长度</span></span><br><span class="line">    <span class="keyword">if</span>(K&gt;len/<span class="number">2</span>)&#123; <span class="comment">//大于1/2</span></span><br><span class="line">        <span class="comment">//结合上面的规律，找前半部分和自己等价的位置</span></span><br><span class="line">        <span class="keyword">if</span>(N%<span class="number">2</span>!=<span class="number">0</span>)&#123; </span><br><span class="line">            K=len-K+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(K%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                K=len-K+<span class="number">2</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                K=len-K;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去上一行继续</span></span><br><span class="line">    <span class="keyword">return</span> kthGrammar(N-<span class="number">1</span>,K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂第O(N)，思路还算清晰，最开始没想到用<code>位运算</code>来算长度，用的<code>pow()</code>最后效率差不多，可能是底层做了优化。</p>
<p><strong>解法二</strong></p>
<p>这种解法实际上就是把整个序列看作一颗满二叉树，每个节点的值和父节点其实是有对应关系的，如果K是偶数那么就和父节点的值相反，否则就相同，所以我们可以递归的去找父节点对应的index的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//01排列</span></span><br><span class="line"><span class="comment">//              0</span></span><br><span class="line"><span class="comment">//          /        \   </span></span><br><span class="line"><span class="comment">//      0                1</span></span><br><span class="line"><span class="comment">//    /   \            /    \</span></span><br><span class="line"><span class="comment">//  0       1        1       0</span></span><br><span class="line"><span class="comment">// / \     /  \     /  \    / \ </span></span><br><span class="line"><span class="comment">//0   1   1    0   1    0  0   1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (K==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//(K+1)/2是对应父节点的index</span></span><br><span class="line">    <span class="keyword">int</span> parent=kthGrammar(N-<span class="number">1</span>,(K+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    <span class="keyword">int</span> f_parent=-(parent-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (K%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f_parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度依然是<code>O(N)</code> 但是比上面那种要更清晰明了</p>
<p><strong>解法三</strong></p>
<p>这个解法其实和上面的思路是一样的，都是利用父节点和K的奇偶来判断，其实仔细看上面的代码你会发现N其实并没有实际的意义，具体K的值只和K本身有关，下面的解法就没有用到N.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthGrammar3</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> r=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(K&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (K%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            K=K/<span class="number">2</span>;</span><br><span class="line">            r=!r;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            K=(K+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题其实还有一种解法，利用二进制，对K做奇偶检验，貌似时间复杂度是O(1)。</p>
<h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h2><p>实现 pow(<em>x</em>, <em>n</em>) ，即计算 x 的 n 次幂函数。</p>
<p><strong>解法一</strong></p>
<p>这里就要介绍一种快速幂算法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res=fastPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res*res*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想就是 <code>x^n=(x^2/n)^2</code>，常规累乘的方式计算时间复杂度是O(N)因为要遍历所有的元素，但是其实知道了<code>x^n/2</code>之后 <code>x^n</code>就可以直接平方得到了不用继续遍历，整体时间复杂度为O(logN) </p>
<p>2019.8.20，又写了一遍，提交然后没过。看了下给的测试用例，最后一个给的n是 <code>-2^31</code> 也就是int整数的最小值，int类型的取值范围是 <code>-2^31 ~ 2^31-1</code> 而这个负值在这里取反之后会直接溢出最后得到的还是 <code>-2^31</code> ，所以这里这样写 if会执行两次，x就又会变回来，所以结果直接就是<code>Infinity</code>无穷大了，所以为了保证if只会执行一次可以将其封装一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,n);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span>  half=fastPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> half*half;</span><br><span class="line">    <span class="keyword">return</span> half*half*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5222-分割平衡字符串"><a href="#5222-分割平衡字符串" class="headerlink" title="5222. 分割平衡字符串"></a>5222. 分割平衡字符串</h2><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"RLRRLLRLRL"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：s 可以分割为 <span class="string">"RL"</span>, <span class="string">"RRLL"</span>, <span class="string">"RL"</span>, <span class="string">"RL"</span>, 每个子字符串中都包含相同数量的 <span class="string">'L'</span> 和 <span class="string">'R'</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"RLLLLRRRLR"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：s 可以分割为 <span class="string">"RL"</span>, <span class="string">"LLLRRR"</span>, <span class="string">"LR"</span>, 每个子字符串中都包含相同数量的 <span class="string">'L'</span> 和 <span class="string">'R'</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"LLLLRRRR"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：s 只能保持原样 <span class="string">"LLLLRRRR"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i] = &#39;L&#39; 或 &#39;R&#39;</code></li>
</ul>
<p><strong>解法一</strong></p>
<p>19.10.13的周赛的第1题，果然比赛和刷题还是不一样，差点没做出来。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length()%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() )&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==stack.peek()) &#123;</span><br><span class="line">                stack.push(s.charAt(i));    </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener">1249. 移除无效的括号</a></h2><p>给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。</p>
<p>你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>
<p>请返回任意一个合法字符串。</p>
<p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求：</p>
<ul>
<li>空字符串或只包含小写字母的字符串</li>
<li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li>
<li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"lee(t(c)o)de)"</span></span><br><span class="line">输出：<span class="string">"lee(t(c)o)de"</span></span><br><span class="line">解释：<span class="string">"lee(t(co)de)"</span> , <span class="string">"lee(t(c)ode)"</span> 也是一个可行答案。</span><br></pre></td></tr></table></figure>


<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"a)b(c)d"</span></span><br><span class="line">输出：<span class="string">"ab(c)d"</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"))(("</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：空字符串也是有效的</span><br></pre></td></tr></table></figure>


<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"(a(b(c)d)"</span></span><br><span class="line">输出：<span class="string">"a(b(c)d)"</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 或英文小写字母 </li>
</ul>
<p><strong>解法一</strong></p>
<p>11.3周赛第三题，这题倒是没什么障碍，用栈就ok，不过我这里实现的不太好，replace时间复杂度略高，应该用一个数组做mark最后用StringBuilder做append应该效率会高很多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)&gt;=<span class="string">'a'</span> &amp;&amp; s.charAt(i)&lt;=<span class="string">'z'</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                sb.replace(i,i+<span class="number">1</span>,<span class="string">"*"</span>);    </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=stack.pop();</span><br><span class="line">        sb.replace(temp,temp+<span class="number">1</span>,<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String res=sb.toString().replace(<span class="string">"*"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a><a href="https://leetcode-cn.com/problems/score-of-parentheses/" target="_blank" rel="noopener">856. 括号的分数</a></h2><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p>
<ul>
<li>() 得 1 分。</li>
<li>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。</li>
<li>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： <span class="string">"()"</span></span><br><span class="line">输出： <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： <span class="string">"(())"</span></span><br><span class="line">输出： <span class="number">2</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： <span class="string">"()()"</span></span><br><span class="line">输出： <span class="number">2</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： <span class="string">"(()(()))"</span></span><br><span class="line">输出： <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>S 是平衡括号字符串，且只含有 ( 和 ) 。</li>
<li>2 &lt;= S.length &lt;= 50</li>
</ol>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(-<span class="number">11111</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//遇到右括号,下面的分支都是处理 ")"</span></span><br><span class="line">            <span class="keyword">int</span> top=stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(top == -<span class="number">11111</span>)&#123; <span class="comment">//栈顶是左括号，将 ( --&gt; 1</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.push(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">//遇到数值了</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=stack.pop();</span><br><span class="line">                    <span class="comment">//弹出去,直到遇到 "("就*2,其实就是把"(1"--&gt;2</span></span><br><span class="line">                    <span class="keyword">if</span>(temp==-<span class="number">11111</span>)&#123; </span><br><span class="line">                        sum*=<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum+=temp;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) res+=stack.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种解法一开始也没想出来，其实这种就类似于消消乐游戏一样，就按照题目的逻辑来写，从左向右，栈中存标识左括号的数值，这里我用的<code>-11111</code> 表示<code>（</code> ，然后向右移动，一边移动一边将<code>（）</code>给消除掉，其实上面的逻辑自己走一边就通了</p>
<p><strong>解法二</strong></p>
<p>这个解法就带有点技巧性了，看懂上面的注释，下面的代码就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (()(())) = 2*()+2*(())= (())+((()))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.charAt(i)==<span class="string">'('</span>) &#123;</span><br><span class="line">            k++; <span class="comment">//k用来计算括号的深度</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i-<span class="number">1</span>)==<span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="comment">//"()"闭合的时候计算一波</span></span><br><span class="line">                res+= <span class="number">1</span>&lt;&lt;k; <span class="comment">//2^k</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></h2><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 <code>push</code> 和弹出 pop 操作序列的结果时，返回 <code>true</code> 否则，返回 <code>false</code> </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(<span class="number">1</span>), push(<span class="number">2</span>), push(<span class="number">3</span>), push(<span class="number">4</span>), pop() -&gt; <span class="number">4</span>,</span><br><span class="line">push(<span class="number">5</span>), pop() -&gt; <span class="number">5</span>, pop() -&gt; <span class="number">3</span>, pop() -&gt; <span class="number">2</span>, pop() -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> 是 <code>popped</code> 的排列</li>
</ol>
<p><strong>解法一</strong></p>
<p>直接用栈模拟，可惜没有bugfree…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pushed==<span class="keyword">null</span> || pushed.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> popIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pushIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span></span><br><span class="line">    <span class="comment">//[1,2,3,4,5]      [4,3,5,1,2]</span></span><br><span class="line">    <span class="comment">//[1,0] [1,0]</span></span><br><span class="line">    <span class="keyword">while</span>(pushIndex&lt;pushed.length)&#123;</span><br><span class="line">        stack.push(pushed[pushIndex++]);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;popped[popIndex]==stack.peek())&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每进一个元素就判断栈顶和出栈顺序的头是否相等，然后出栈，最后看栈中是否为空就ok</p>
<h2 id="BFS广搜"><a href="#BFS广搜" class="headerlink" title="BFS广搜"></a><em>BFS广搜</em></h2><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</span><br></pre></td></tr></table></figure>


<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>这题在上一篇<a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/">dp专题</a>中有讲过，不过是dp的解法，这里主要记录BFS的解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSquares2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(n,<span class="number">0</span>));</span><br><span class="line">    visit[n]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="keyword">int</span> num=pair.num;</span><br><span class="line">        <span class="keyword">int</span> step=pair.step;</span><br><span class="line">        <span class="comment">//nums=0说明找到了，并且一定是最短的</span></span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=num;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=num-i*i;</span><br><span class="line">            <span class="comment">//注意不要添加重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (!visit[temp]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(temp,step+<span class="number">1</span>));</span><br><span class="line">                visit[temp]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num=num;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30ms 90%，比dp的方式会快很多，思路就是将这个问题转换为求图的最短路径的问题，找到一个最短的从n到0的以平方数为差的路径</p>
<h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></h2><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Explanation: The endWord <span class="string">"cog"</span> is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>这题其实很久以前就写过了，当时是看了啊哈算法的一些BFS算法然后仿照书上的写的，书上是C语言写的，所以最后我写的时候也按照C的格式去写了😅，写的贼啰嗦，现在又用”Java”的方式又重新写了一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span>     </span>&#123;</span><br><span class="line">    <span class="comment">// 不存在</span></span><br><span class="line">    mark = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    Que[] que = <span class="keyword">new</span> Que[wordList.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 循环促使话述祖</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; que.length; i++) &#123;</span><br><span class="line">        que[i] = <span class="keyword">new</span> Que();</span><br><span class="line">    &#125;</span><br><span class="line">    que[tail].word = beginWord;</span><br><span class="line">    que[tail].step = <span class="number">1</span>;</span><br><span class="line">    tail++;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        <span class="comment">// 遍历字典</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[i] == <span class="number">0</span> &amp;&amp; cmp(wordList.get(i), que[head].word)) &#123;</span><br><span class="line">                que[tail].word = wordList.get(i);</span><br><span class="line">                <span class="comment">//这里是从head开始的，所以应该是head的步数+1</span></span><br><span class="line">                que[tail].step=que[head].step+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 标记为已经走过</span></span><br><span class="line">                mark[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 统计最小步数</span></span><br><span class="line">               <span class="keyword">if</span> (que[tail].word.equals(endWord)) &#123;</span><br><span class="line">                <span class="comment">//跳出循环</span></span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tail++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次检查完一个单词就将其出队列</span></span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> que[tail].step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个函数判段没吃是否只变化了一个字母</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Que</span> </span>&#123;</span><br><span class="line">    String word;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是当时写的解法，思路就是BFS，只不过写的复杂了</p>
<p><strong>解法二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span>     </span>&#123;</span><br><span class="line">    <span class="comment">//visit数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(beginWord,<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//int flag=0;</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="comment">// 统计最小步数,放在内循环中会快一点</span></span><br><span class="line">        <span class="comment">/*if (pair.word.equals(endWord)) &#123;</span></span><br><span class="line"><span class="comment">            return pair.step;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// 遍历字典</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i] &amp;&amp; cmp(wordList.get(i),pair.word)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wordList.get(i).equals(endWord)) &#123;</span><br><span class="line">                    <span class="comment">//这里加1 是因为取的是pair的step</span></span><br><span class="line">                    <span class="comment">//到当前这个单词还要多走一步</span></span><br><span class="line">                    <span class="keyword">return</span> pair.step+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(wordList.get(i),pair.step+<span class="number">1</span>));</span><br><span class="line">                <span class="comment">//标记为已经走过</span></span><br><span class="line">                visit[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否只变化了一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Pair</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    String word;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String word,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word=word;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>273ms，47%中规中矩的做法，连续写了好几题BFS的，总算是对BFS的板子有点熟悉了，这题还有两个可以优化的点 ① <em>双端BFS</em> ② _寻找下一个字符串的方式_，只不过我没咋看懂，等看懂了再来补充，那种方式时间好像可以缩减到 20ms内…..</p>
<blockquote>
<p>这题有个困难版本，需要打印出所有的最短序列，这个在我很久之前的一篇文章中也有讲，但是至今我也还没有AC，一直是TLE，现在回头看我之前的代码已经看不懂了。。。写了100多行，略复杂BFS+DFS的做法，可能是没处理好所以TLE了，感兴趣可以看看<a href="http://imlgw.top/2018/10/31/yi-dao-leetcode-yin-fa-de-can-an/#2-%E5%8A%A0%E5%BC%BA%E7%89%88-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-2">那篇文章</a></p>
</blockquote>
<h2 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 矩阵</a></h2><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 </p>
<p><strong>示例 1:</strong><br>输入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong><br>输入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><strong>注意:</strong></p>
<ul>
<li>给定矩阵的元素个数不超过 10000</li>
<li>给定矩阵中至少有一个元素是 0</li>
<li>矩阵中的元素只在四个方向上相邻: 上、下、左、右</li>
</ul>
<p><strong>解法一</strong></p>
<p>憨憨的BFS解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历每一个1,BFS寻找离他最近的0,一次只能确定一个1,效率略低</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;=<span class="number">0</span> || matrix[<span class="number">0</span>].length &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                matrix[i][j]=findMinDis(matrix,i,j);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinDis</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//boolean[][] visit=new boolean[matrix.length][matrix[0].length];</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(x,y,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//visit[x][y]=true;</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;direction.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx=pair.x + direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny=pair.y + direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isValid(matrix,nx,ny) <span class="comment">/*&amp;&amp; !visit[nx][ny]*/</span>) &#123;</span><br><span class="line">                <span class="comment">//visit[nx][ny]=true;</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pair.step+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(nx,ny,pair.step+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//题目说了一定有0,所以不会走到这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;matrix.length &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;matrix[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x=x;</span><br><span class="line">        <span class="keyword">this</span>.y=y;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码中有很明显的改动痕迹，最开始是用visit数组保证每一个元素只会进队列一次，不会重复的进队列，但是这里为什么我去掉了呢？</p>
<p>其实主要是一开始提交的解法超时了，把visit数组去掉就过了，在数组过大的时候每次BFS都要开辟一个matrix大小的boolean数组，这无疑会极其耗费时间，但是为什么不加visit数组不会死循环呢？</p>
<p>确实，如果不加visit数组那么确实是有可能会导致死循环的，两个节点互相重复添加对方，但是这一题有个很关键的地方，题目说明了一定会有0，也就是说一定会解，那么就不会死循环，举一个很简单的例子</p>
<p><code>【0，1，1】</code> 这里我们先考虑中间的1，然后我们按照下右上左的顺序去添加周围的节点，那么队列中就为末尾的<code>[1]</code> ，当遍历到右的时候发现是0，直接return，然后我们考虑下一个1，转了一圈队列中只有一个中间的<code>[1]</code> ， 然后我们又重复刚刚的步骤会将末尾的1又加入队列，但是下一次遍历就会找到最左边的0，然后返回，所以并不会死循环，当然这样做的前提是一定要有解！</p>
<p><strong>解法二</strong></p>
<p>另一种更好的做法，以0作为源，向四周BFS，同时更新周围的1的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update: 2020.4.15</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dir=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> matrix;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(i,j,<span class="number">0</span>));</span><br><span class="line">                visit[i][j]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                matrix[i][j]=Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dir.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx=pair.x+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny=pair.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(valid(matrix,nx,ny) &amp;&amp; !visit[nx][ny])&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(nx,ny,pair.step+<span class="number">1</span>));</span><br><span class="line">                matrix[nx][ny]=pair.step+<span class="number">1</span>; <span class="comment">//这里不用判断是不是变小，第一次遇到的就是最近的</span></span><br><span class="line">                visit[nx][ny]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;matrix.length &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;matrix[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x=x;</span><br><span class="line">        <span class="keyword">this</span>.y=y;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想就是 把所有1都置为最大值, 把所有为0的位置加入队列中, 每次从队列中poll 一个节点, 更新其四周的节点, <del>如果被更新的节点距离变小了就将其也加入队列准备更新其邻接点</del> step是递增的，第一次遇到的一定是最近的</p>
<p>多源BFS，参考下面的 <a href="">994. 腐烂的橘子</a>  和 <a href="">1162. 地图分析</a></p>
<p><strong>解法三</strong></p>
<blockquote>
<p>这题的最优解应该是动态规划的解法，我实在是懒得写（菜），其实和哪个 不同路径有点类似，每个1离他最近的0的距离其实就是它周围的元素离0最近的距离+1</p>
<p>也就是 <code>matrix[i][j] =min(dp[i][j-1],dp[i-1][j],dp[i+1][j],dp[i][j+1]) + 1</code> 但是我们不可能同时求出是个方向的最小值，所以我们需要两次遍历，第一遍从左上到右下，第二遍从右下到左上，两次遍历就可以确定每个节点的值，代码以后有时间再来写</p>
</blockquote>
<h2 id="1306-跳跃游戏-III"><a href="#1306-跳跃游戏-III" class="headerlink" title="1306. 跳跃游戏 III"></a><a href="https://leetcode-cn.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. 跳跃游戏 III</a></h2><p>这里有一个非负整数数组 <code>arr</code>，你最开始位于该数组的起始下标 <code>start</code> 处。当你位于下标 i 处时，你可以跳到 <code>i + arr[i]</code> 或者 <code>i - arr[i]</code>。</p>
<p>请你判断自己是否能够跳到对应元素值为 0 的 <code>任意</code> 下标处。</p>
<p>注意，不管是什么情况下，你都无法跳到数组之外</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], start = <span class="number">5</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">到达值为 <span class="number">0</span> 的下标 <span class="number">3</span> 有以下可能方案： </span><br><span class="line">下标 <span class="number">5</span> -&gt; 下标 <span class="number">4</span> -&gt; 下标 <span class="number">1</span> -&gt; 下标 <span class="number">3</span> </span><br><span class="line">下标 <span class="number">5</span> -&gt; 下标 <span class="number">6</span> -&gt; 下标 <span class="number">4</span> -&gt; 下标 <span class="number">1</span> -&gt; 下标 <span class="number">3</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], start = <span class="number">0</span></span><br><span class="line">输出：<span class="keyword">true</span> </span><br><span class="line">解释：</span><br><span class="line">到达值为 <span class="number">0</span> 的下标 <span class="number">3</span> 有以下可能方案： </span><br><span class="line">下标 <span class="number">0</span> -&gt; 下标 <span class="number">4</span> -&gt; 下标 <span class="number">1</span> -&gt; 下标 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], start = <span class="number">2</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：无法到达值为 <span class="number">0</span> 的下标 <span class="number">1</span> 处。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>
<li><code>0 &lt;= arr[i] &lt; arr.length</code></li>
<li><code>0 &lt;= start &lt; arr.length</code></li>
</ul>
<p><strong>解法一</strong></p>
<p>BFS，某次周赛的第3题，还是挺简单的，可惜那次没参加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">    Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    visit[start]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-arr[cur]&gt;=<span class="number">0</span> &amp;&amp; !visit[cur-arr[cur]]) &#123;</span><br><span class="line">            queue.add(cur-arr[cur]);</span><br><span class="line">            visit[cur-arr[cur]]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur+arr[cur]&lt;arr.length &amp;&amp; !visit[cur+arr[cur]]) &#123;</span><br><span class="line">            queue.add(cur+arr[cur]);</span><br><span class="line">            visit[cur+arr[cur]]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<p>DFS解法，没啥好说的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">    <span class="keyword">return</span> dfs(arr,start,visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">boolean</span>[] visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[index]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (index-arr[index] &gt;=<span class="number">0</span> &amp;&amp; !visit[index-arr[index]]) &#123;</span><br><span class="line">        b=dfs(arr,index-arr[index],visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index+arr[index] &lt;arr.length &amp;&amp; !visit[index+arr[index]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> b|dfs(arr,index+arr[index],visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5314-跳跃游戏-IV"><a href="#5314-跳跃游戏-IV" class="headerlink" title="5314. 跳跃游戏 IV"></a><a href="https://leetcode-cn.com/problems/jump-game-iv/" target="_blank" rel="noopener">5314. 跳跃游戏 IV</a></h2><p>给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。</p>
<p>每一步，你可以从下标 i 跳到下标：</p>
<ul>
<li>i + 1 满足：i + 1 &lt; arr.length</li>
<li>i - 1 满足：i - 1 &gt;= 0</li>
<li>j 满足：arr[i] == arr[j] 且 i != j</li>
</ul>
<p>请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。<br>注意：任何时候你都不能跳到数组外面。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">100</span>,-<span class="number">23</span>,-<span class="number">23</span>,<span class="number">404</span>,<span class="number">100</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">404</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：那你需要跳跃 <span class="number">3</span> 次，下标依次为 <span class="number">0</span> --&gt; <span class="number">4</span> --&gt; <span class="number">3</span> --&gt; <span class="number">9</span> 。下标 <span class="number">9</span> 为数组的最后一个元素的下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：一开始就在最后一个元素处，所以你不需要跳跃。</span><br></pre></td></tr></table></figure>


<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你可以直接从下标 <span class="number">0</span> 处跳到下标 <span class="number">7</span> 处，也就是数组的最后一个元素处。</span><br></pre></td></tr></table></figure>


<p><strong>示例 4：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>


<p><strong>示例 5：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">13</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>
<li><code>-10^8 &lt;= arr[i] &lt;= 10^8</code></li>
</ul>
<p><strong>解法一</strong></p>
<p>19双周赛的最后一题，讲道理挺简单的（可我还是TLE了好长时间）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">    HashMap&lt;Integer,List&lt;Integer&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//构建等值的索引 连续相同的只保留头尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; lis=map.computeIfAbsent(arr[i],k-&gt;<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (!((i-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;arr[i-<span class="number">1</span>]==arr[i]) &amp;&amp; (i+<span class="number">1</span>&lt;arr.length&amp;&amp;arr[i+<span class="number">1</span>]==arr[i])))&#123;</span><br><span class="line">            lis.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    visit[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (pair.index==arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pair.step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pair.index+<span class="number">1</span>&lt;arr.length &amp;&amp; !visit[pair.index+<span class="number">1</span>])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> Pair(pair.index+<span class="number">1</span>,pair.step+<span class="number">1</span>));</span><br><span class="line">            visit[pair.index+<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pair.index-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; !visit[pair.index-<span class="number">1</span>]) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> Pair(pair.index-<span class="number">1</span>,pair.step+<span class="number">1</span>));</span><br><span class="line">            visit[pair.index-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list=map.get(arr[pair.index]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx=list.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!visit[idx]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(idx,pair.step+<span class="number">1</span>));</span><br><span class="line">                visit[idx]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index=index;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下数据范围，直接BFS遍历跳同值的肯定不行，所以想到了用map预处理同值的索引，结果还是TLE了，后面一个case有50000个7，这里即使做了map索引但是无奈太多了，依然会超时，这里其实这么多7，只有头和尾的7是用的，其他位置的7都是无用的，可以直接忽略，所以构建索引的时候可以跳过这些中间位置，这样可以节省很多时间</p>
<h2 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">690. 员工的重要性</a></h2><p>给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。</p>
<p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。</p>
<p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>, <span class="number">5</span>, [<span class="number">2</span>, <span class="number">3</span>]], [<span class="number">2</span>, <span class="number">3</span>, []], [<span class="number">3</span>, <span class="number">3</span>, []]], <span class="number">1</span></span><br><span class="line">输出: <span class="number">11</span></span><br><span class="line">解释:</span><br><span class="line">员工<span class="number">1</span>自身的重要度是<span class="number">5</span>，他有两个直系下属<span class="number">2</span>和<span class="number">3</span>，而且<span class="number">2</span>和<span class="number">3</span>的重要度均为<span class="number">3</span>。因此员工<span class="number">1</span>的总重要度是 <span class="number">5</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">11</span>。</span><br></pre></td></tr></table></figure>


<p><strong>注意:</strong></p>
<ol>
<li>一个员工最多有一个直系领导，但是可以有多个直系下属</li>
<li>员工数量不超过2000。</li>
</ol>
<p><strong>解法一</strong></p>
<p>BFS，没啥好说的，憨憨题直接bugfree</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Employee&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Employee e:employees) &#123;</span><br><span class="line">        map.put(e.id,e);</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(id);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Employee cur=map.get(queue.poll());</span><br><span class="line">        res+=cur.importance;</span><br><span class="line">        List&lt;Integer&gt; subordinates=cur.subordinates;</span><br><span class="line">        <span class="keyword">if</span> (!subordinates.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> eid:subordinates) &#123;</span><br><span class="line">                queue.add(eid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>DFS，本来不想写的，这类题其实都是树的题变了个说法而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Employee&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Employee e:employees) &#123;</span><br><span class="line">        map.put(e.id,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(map,id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer,Employee&gt; map,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    Employee cur=map.get(id);</span><br><span class="line">    <span class="keyword">int</span> res=cur.importance;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> eid:cur.subordinates) &#123;</span><br><span class="line">        res+=dfs(map,eid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1311-获取你好友已观看的视频"><a href="#1311-获取你好友已观看的视频" class="headerlink" title="1311. 获取你好友已观看的视频"></a><a href="https://leetcode-cn.com/problems/get-watched-videos-by-your-friends/" target="_blank" rel="noopener">1311. 获取你好友已观看的视频</a></h2><p>有 n 个人，每个人都有一个  0 到 n-1 的唯一 id 。</p>
<p>给你数组 <code>watchedVideos</code>  和 <code>friends</code> ，其中 <code>watchedVideos[i]</code>  和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。</p>
<p>Level 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。</p>
<p>给定你的 <code>id</code>  和一个 <code>level</code> 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按名字字典序从小到大排列。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://i.loli.net/2020/02/01/I5XJKQg3WwvaeB1.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：watchedVideos = [[<span class="string">"A"</span>,<span class="string">"B"</span>],[<span class="string">"C"</span>],[<span class="string">"B"</span>,<span class="string">"C"</span>],[<span class="string">"D"</span>]], friends = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]], id = <span class="number">0</span>, level = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">"B"</span>,<span class="string">"C"</span>] </span><br><span class="line">解释：</span><br><span class="line">你的 id 为 <span class="number">0</span> ，你的朋友包括：</span><br><span class="line">id 为 <span class="number">1</span> -&gt; watchedVideos = [<span class="string">"C"</span>] </span><br><span class="line">id 为 <span class="number">2</span> -&gt; watchedVideos = [<span class="string">"B"</span>,<span class="string">"C"</span>] </span><br><span class="line">你朋友观看过视频的频率为：</span><br><span class="line">B -&gt; <span class="number">1</span> </span><br><span class="line">C -&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://i.loli.net/2020/02/01/qhDZvr3sbJkgIuw.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：watchedVideos = [[<span class="string">"A"</span>,<span class="string">"B"</span>],[<span class="string">"C"</span>],[<span class="string">"B"</span>,<span class="string">"C"</span>],[<span class="string">"D"</span>]], friends = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]], id = <span class="number">0</span>, level = <span class="number">2</span></span><br><span class="line">输出：[<span class="string">"D"</span>]</span><br><span class="line">解释：</span><br><span class="line">你的 id 为 <span class="number">0</span> ，你朋友的朋友只有一个人，他的 id 为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>n == watchedVideos.length == friends.length</li>
<li>2 &lt;= n &lt;= 100</li>
<li>1 &lt;= watchedVideos[i].length &lt;= 100</li>
<li>1 &lt;= watchedVideos[i][j].length &lt;= 8</li>
<li>0 &lt;= friends[i].length &lt; n</li>
<li>0 &lt;= friends[i][j] &lt; n</li>
<li>0 &lt;= id &lt; n</li>
<li>1 &lt;= level &lt; n</li>
<li>如果 friends[i] 包含 j ，那么 friends[j] 包含 i</li>
</ul>
<p><strong>解法一</strong></p>
<p>170周赛的第三题，其实是一道水题，题目意思搞清楚就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">watchedVideosByFriends</span><span class="params">(List&lt;List&lt;String&gt;&gt; watchedVideos, <span class="keyword">int</span>[][] friends, <span class="keyword">int</span> id, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] levels=<span class="keyword">new</span> <span class="keyword">int</span>[friends.length]; <span class="comment">//这里没必要,这里用一个变量就ok了</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[friends.length];</span><br><span class="line">    HashMap&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; flist=<span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//level层的朋友</span></span><br><span class="line">    queue.add(id);</span><br><span class="line">    visit[id]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=queue.poll();</span><br><span class="line">        <span class="keyword">int</span>[] cfs=friends[cur];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cfs.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[cfs[i]]) &#123;</span><br><span class="line">                queue.add(cfs[i]);</span><br><span class="line">                levels[cfs[i]]=levels[cur]+<span class="number">1</span>;   </span><br><span class="line">                visit[cfs[i]]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (levels[cfs[i]] == level) &#123;</span><br><span class="line">                    flist.add(cfs[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flist.size();i++) &#123;</span><br><span class="line">        List&lt;String&gt; videos=watchedVideos.get(flist.get(i));</span><br><span class="line">        <span class="keyword">for</span> (String v:videos) &#123;</span><br><span class="line">            map.put(v,map.getOrDefault(v,<span class="number">0</span>)+<span class="number">1</span>); <span class="comment">//map记录videos出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面几步还是挺老道的</span></span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> ArrayList(map.keySet());</span><br><span class="line">    res.sort((v1,v2)-&gt;&#123;</span><br><span class="line">        <span class="keyword">int</span> c1=map.get(v1);</span><br><span class="line">        <span class="keyword">int</span> c2=map.get(v2);</span><br><span class="line">        <span class="keyword">return</span> c1==c2?v1.compareTo(v2):c1-c2; <span class="comment">//相等的时候按照字典序列排序</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></h2><p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。</p>
<p>示例 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 a / b = <span class="number">2.0</span>, b / c = <span class="number">3.0</span></span><br><span class="line">问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? </span><br><span class="line">返回 [<span class="number">6.0</span>, <span class="number">0.5</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span> ]</span><br></pre></td></tr></table></figure>

<p>输入为: <code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)</code>， 其中 <code>equations.size() == values.size()</code>，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回<code>vector&lt;double&gt;</code>类型。</p>
<p>基于上述例子，输入如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">equations(方程式) = [ [<span class="string">"a"</span>, <span class="string">"b"</span>], [<span class="string">"b"</span>, <span class="string">"c"</span>] ],</span><br><span class="line">values(方程式结果) = [<span class="number">2.0</span>, <span class="number">3.0</span>],</span><br><span class="line">queries(问题方程式) = [ [<span class="string">"a"</span>, <span class="string">"c"</span>], [<span class="string">"b"</span>, <span class="string">"a"</span>], [<span class="string">"a"</span>, <span class="string">"e"</span>], [<span class="string">"a"</span>, <span class="string">"a"</span>], [<span class="string">"x"</span>, <span class="string">"x"</span>] ].</span><br></pre></td></tr></table></figure>

<p>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。</p>
<p><strong>解法一</strong></p>
<p>建立图，然后BFS，这样就简单多了，比并茶集的方法直白多了，随便也学了一下如何建图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造图 + BFS/DFS</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Map&lt;String,Double&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        graph.computeIfAbsent(equations.get(i).get(<span class="number">0</span>), k -&gt; <span class="keyword">new</span> HashMap&lt;&gt;()).put(equations.get(i).get(<span class="number">1</span>), values[i]);</span><br><span class="line">        graph.computeIfAbsent(equations.get(i).get(<span class="number">1</span>), k -&gt; <span class="keyword">new</span> HashMap&lt;&gt;()).put(equations.get(i).get(<span class="number">0</span>), <span class="number">1</span> / values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    String key;</span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String key,<span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">bfs</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//讲道理,不管a,b是否在graph中,只要想等都应该返回1吧,这里是考虑了0的情况?</span></span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(a) || !graph.containsKey(b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(a,<span class="number">1.0</span>));</span><br><span class="line">    HashSet&lt;String&gt; visit=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair cur=queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (!visit.contains(cur.key)) &#123;</span><br><span class="line">            visit.add(cur.key);</span><br><span class="line">            Map&lt;String,Double&gt; map=graph.get(cur.key);</span><br><span class="line">            <span class="keyword">for</span> (String next:map.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b.equals(next)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur.val*map.get(next);</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(next,cur.val*map.get(next)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(String a,String b,HashSet&lt;String&gt; visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(a)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit.add(a);</span><br><span class="line">    Map&lt;String,Double&gt; nextMap=graph.get(a);</span><br><span class="line">    <span class="keyword">for</span> (String next:nextMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit.contains(next)) &#123;</span><br><span class="line">            <span class="keyword">double</span> subres=dfs(next,b,visit);</span><br><span class="line">            <span class="keyword">if</span> (subres!=-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> subres*nextMap.get(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    buildGraph(equations,values);</span><br><span class="line">    <span class="keyword">double</span>[] res=<span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; query:queries) &#123;</span><br><span class="line">        HashSet&lt;String&gt; visit=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//res[index++]=bfs(query.get(0),query.get(1),visit); </span></span><br><span class="line">        res[index++]=bfs(query.get(<span class="number">0</span>),query.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301. 删除无效的括号"></a><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">301. 删除无效的括号</a></h2><p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。</p>
<p><strong>说明:</strong> 输入可能包含了除 ( 和 ) 以外的字符。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()())()"</span></span><br><span class="line">输出: [<span class="string">"()()()"</span>, <span class="string">"(())()"</span>]</span><br></pre></td></tr></table></figure>


<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"(a)())()"</span></span><br><span class="line">输出: [<span class="string">"(a)()()"</span>, <span class="string">"(a())()"</span>]</span><br></pre></td></tr></table></figure>


<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">")("</span></span><br><span class="line">输出: [<span class="string">""</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>BFS解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;String&gt; visit=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visit.add(s);</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        String cur=queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (isValid(cur)) &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.charAt(i)==<span class="string">'('</span> || cur.charAt(i)==<span class="string">')'</span>) &#123;</span><br><span class="line">                String temp=cur.substring(<span class="number">0</span>,i)+cur.substring(i+<span class="number">1</span>,cur.length());</span><br><span class="line">                <span class="keyword">if</span> (!visit.contains(temp)) &#123;</span><br><span class="line">                    queue.add(temp);</span><br><span class="line">                    visit.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.isEmpty()) res.add(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是比较简单，dfs的解法比较难搞，容易TLE，这里懒得写了</p>
<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">994. 腐烂的橘子</a></h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格；</li>
<li>值 1 代表新鲜橘子；</li>
<li>值 2 代表腐烂的橘子。</li>
</ul>
<p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>
<p><strong>示例 1：</strong></p>
<p><img src="http://static.imlgw.top/blog/20200304/YGBajce2liDs.png?imageslim" alt="mark"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：左下角的橘子（第 <span class="number">2</span> 行， 第 <span class="number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="number">4</span> 个正向上。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：因为 <span class="number">0</span> 分钟时已经没有新鲜橘子了，所以答案就是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ol>
<p><strong>解法一</strong></p>
<p>BFS打卡题，这种解法应该算是比较好的了，2ms</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] diretion=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>) count++; <span class="comment">//统计好橘子的数量</span></span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//每一轮的坏橘子数量</span></span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        time++;</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Pair pair=queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx=pair.x+diretion[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny=pair.y+diretion[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(valid(grid,nx,ny) &amp;&amp; grid[nx][ny]==<span class="number">1</span>)&#123;</span><br><span class="line">                    grid[nx][ny]=<span class="number">2</span>;</span><br><span class="line">                    count--;<span class="comment">//好橘子--</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> Pair(nx,ny));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="keyword">return</span> time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x=x;</span><br><span class="line">        <span class="keyword">this</span>.y=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;grid.length &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>一开始的解法，虽然效率稍微低一点点 4ms，但是bugfree了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] diretion=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x=x;</span><br><span class="line">        <span class="keyword">this</span>.y=y;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(i,j,<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="comment">//统计一个最大的步数作为结果</span></span><br><span class="line">        <span class="comment">//max=Math.max(max,pair.step);</span></span><br><span class="line">        max=pair.step; <span class="comment">//最后弹出的哪个就是最大的，这是个递增(非单调)的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx=pair.x+diretion[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny=pair.y+diretion[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(valid(grid,nx,ny) &amp;&amp; grid[nx][ny]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[nx][ny]=<span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(nx,ny,pair.step+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(grid)?max:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;grid.length &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过勘误，发现有一处地方有点小问题，已经修改，<code>pair.step</code> 在队列中是一个递增（不单调，会相等）的过程，所以最后弹出的就是最大的</p>
<h2 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162. 地图分析"></a><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">1162. 地图分析</a></h2><p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p>
<p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://s1.ax1x.com/2020/03/29/GVuO3Q.png" alt="GVuO3Q.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释： </span><br><span class="line">海洋区域 (<span class="number">1</span>, <span class="number">1</span>) 和所有陆地区域之间的距离都达到最大，最大距离为 <span class="number">2</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://s1.ax1x.com/2020/03/29/GVKSH0.png" alt="GVKSH0.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释： </span><br><span class="line">海洋区域 (<span class="number">2</span>, <span class="number">2</span>) 和所有陆地区域之间的距离都达到最大，最大距离为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ol>
<p><strong>解法一</strong></p>
<p>这题的意思其实求<strong>离陆地最远的海洋是那一块，然后返回这个最远的距离</strong>，这个题目描述的确实让人迷惑，一会儿最远，一会儿最近，其实题目意思搞懂了就很简单了，其实和上面腐烂的橘子是一样的。多源的BFS，曼哈顿距离其实就是上下左右走的step</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] diretion=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxDis=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    Queue&lt;Pair&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(i,j,<span class="number">0</span>));</span><br><span class="line">                visit[i][j]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(queue.size()==<span class="number">0</span> || queue.size()==m*n)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        res=pair.step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx=pair.x+diretion[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny=pair.y+diretion[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(valid(grid,nx,ny) &amp;&amp; !visit[nx][ny] &amp;&amp; grid[nx][ny]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(nx,ny,pair.step+<span class="number">1</span>));</span><br><span class="line">                visit[nx][ny]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x=x;</span><br><span class="line">        <span class="keyword">this</span>.y=y;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;grid.length &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h2><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 0 到 <code>numCourse-1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span>。所以这是可能的。</span><br></pre></td></tr></table></figure>


<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span>；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span>。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
<li><code>1 &lt;= numCourses &lt;= 10^5</code></li>
</ol>
<p><strong>解法二</strong></p>
<p>学习下拓扑排序，其实核心在于邻接表的构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] indegree=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjacency=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        adjacency.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] p:prerequisites)&#123;</span><br><span class="line">        indegree[p[<span class="number">0</span>]]++; <span class="comment">//每个节点的入度值</span></span><br><span class="line">        <span class="comment">//邻接表,注意这里别搞反了,这里记录的是p[1]所有的出度节点</span></span><br><span class="line">        adjacency.get(p[<span class="number">1</span>]).add(p[<span class="number">0</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//课程id</span></span><br><span class="line">    Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cid=queue.poll();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> id:adjacency.get(cid)) &#123; <span class="comment">//cid --&gt; id</span></span><br><span class="line">            <span class="comment">//该节点的所有邻接节点入度--</span></span><br><span class="line">            indegree[id]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[id]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a><em>单调栈</em></h2><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></h2><p>给定两个<strong>没有重复元素</strong>的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>].</span><br><span class="line">输出: [-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字<span class="number">4</span>，你无法在第二个数组中找到下一个更大的数字，因此输出 -<span class="number">1</span>。</span><br><span class="line">    对于num1中的数字<span class="number">1</span>，第二个数组中数字<span class="number">1</span>右边的下一个较大数字是 <span class="number">3</span>。</span><br><span class="line">    对于num1中的数字<span class="number">2</span>，第二个数组中没有下一个更大的数字，因此输出 -<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">2</span>,<span class="number">4</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].</span><br><span class="line">输出: [<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字<span class="number">2</span>，第二个数组中的下一个较大数字是<span class="number">3</span>。</span><br><span class="line">    对于num1中的数字<span class="number">4</span>，第二个数组中没有下一个更大的数字，因此输出 -<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li><code>nums1</code>和<code>nums2</code>中所有元素是唯一的。</li>
<li><code>nums1</code>和<code>nums2</code> 的数组大小都不超过1000。</li>
</ol>
<p><strong>解法一</strong></p>
<p>单调栈，很就之前在链表专题中做过一次 <a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9">链表的下一个更大节点</a> 但是没想起来，可能当时也没留下影响</p>
<p>这题其实还比原始的题加了一点难度，原始的题就是 num1==nums2的情况，那样就不需要HashMap记录了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums2[stack.peek()]&lt;nums2[i])&#123;</span><br><span class="line">            map.put(nums2[stack.pop()],nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++) &#123;</span><br><span class="line">        res[i]=map.getOrDefault(nums1[i],-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: [<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: 第一个 <span class="number">1</span> 的下一个更大的数是 <span class="number">2</span>；</span><br><span class="line">数字 <span class="number">2</span> 找不到下一个更大的数； </span><br><span class="line">第二个 <span class="number">1</span> 的下一个最大的数需要循环搜索，结果也是 <span class="number">2</span>。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length*<span class="number">2</span>;i++) &#123;</span><br><span class="line">        index=i&gt;=nums.length?i%nums.length:i;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;nums[stack.peek()]&lt;nums[index]) &#123;</span><br><span class="line">            res[stack.pop()]=nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面一样，只不过需要循环遍历一遍，我最开始的做法相当憨憨，copy了一个两倍的数组。。。还需要注意的就是 <code>-1</code>的处理</p>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h2><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="keyword">null</span> || T.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;T[stack.peek()]&lt;T[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=stack.pop();</span><br><span class="line">            res[temp]=i-temp;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面两题一样，单调栈的解法，不过这题好像可以不用单调栈，可以从后向前递推</p>
<h2 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://leetcode-cn.com/problems/online-stock-span/" target="_blank" rel="noopener">901. 股票价格跨度</a></h2><p>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p>
<p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>
<p>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">"StockSpanner"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>,<span class="string">"next"</span>], [[],[<span class="number">100</span>],[<span class="number">80</span>],[<span class="number">60</span>],[<span class="number">70</span>],[<span class="number">60</span>],[<span class="number">75</span>],[<span class="number">85</span>]]</span><br><span class="line">输出：[<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">首先，初始化 S = StockSpanner()，然后：</span><br><span class="line">S.next(<span class="number">100</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">80</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">60</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">70</span>) 被调用并返回 <span class="number">2</span>，</span><br><span class="line">S.next(<span class="number">60</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">75</span>) 被调用并返回 <span class="number">4</span>，</span><br><span class="line">S.next(<span class="number">85</span>) 被调用并返回 <span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">注意 (例如) S.next(<span class="number">75</span>) 返回 <span class="number">4</span>，因为截至今天的最后 <span class="number">4</span> 个价格</span><br><span class="line">(包括今天的价格 <span class="number">75</span>) 小于或等于今天的价格。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>调用 StockSpanner.next(int price) 时，将有 1 &lt;= price &lt;= 10^5</li>
<li>每个测试用例最多可以调用  10000 次 StockSpanner.next</li>
<li>在所有测试用例中，最多调用 150000 次 StockSpanner.next</li>
<li>此问题的总时间限制减少了 50%</li>
</ul>
<p><strong>解法一</strong></p>
<p>我起了，一枪秒了，有什么好说的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;<span class="keyword">int</span>[]&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockSpanner</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; price&gt;=stack.peek()[<span class="number">0</span>])&#123;</span><br><span class="line">            res+=stack.pop()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;price,res&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://i.loli.net/2019/12/12/a7pVfNcYuIKFgwA.png" alt="leetCode"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://i.loli.net/2019/12/12/FAvMk3zWf4RheDi.png" alt="leetCode"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>和上面几道题一样，单调栈的解法，这里是单调递增栈，20ms，87%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights==<span class="keyword">null</span> || heights.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxArea= Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[i]&lt;=heights[stack.peek()])&#123;</span><br><span class="line">            <span class="comment">//当前的柱子小于栈顶,说明当前栈顶最多向右扩展到 i-1</span></span><br><span class="line">            <span class="keyword">int</span> cur=stack.pop();</span><br><span class="line">            <span class="comment">//为空说明向左无法扩展,标为-1不影响结果（可以提前将-1压栈）</span></span><br><span class="line">            <span class="keyword">int</span> left=stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">            <span class="comment">//这里其实是 (i-1)-(left+1)+1</span></span><br><span class="line">            maxArea=Math.max(maxArea,(i-left-<span class="number">1</span>)*heights[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理栈中剩下的元素,右边是边界，剩余栈中所有的元素实际上都可以扩展到 heights.length-1</span></span><br><span class="line">    <span class="comment">//所以为了让所有的元素都能出栈,我们可以再数组的后面想象添加一个0(也可以直接在原数组中添加一个0)</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123; </span><br><span class="line">        <span class="keyword">int</span> cur=stack.pop();</span><br><span class="line">        <span class="keyword">int</span> left=stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">        <span class="comment">//这一步很秀,在数组后面再想象一个0出来</span></span><br><span class="line">        <span class="comment">//让栈中元素向右扩张(heights.length-1)-(left+1)+1</span></span><br><span class="line">        maxArea=Math.max(maxArea,(heights.length-left-<span class="number">1</span>)*heights[cur]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是利用单调栈遍历每一个柱子，<strong>找到每一个柱子左边和右边第一个比它小的元素，比如左边第一个比当前柱子小的是i，那么很显然i+1肯定是大于等于当前柱子的，并且i+1是左边连续大于当前柱子的最后一个，也就是当前柱子能想左扩展的边界位置，右边同理，既然是要求左右比当前柱子小的第一个，那么很明显就要用单调递增栈</strong>，然后就可以直接根据这两个数据计算完全包含当前柱子的最大的矩形的面积。</p>
<p>例如: <code>3 4 5 4 3 6</code> </p>
<p>首先<code>3 4 5</code>都顺利的存入栈中，此时栈中元素为<code>【0，1，2】</code> ，当想存入下一个元素<code>i=3,h[i]=4</code>的时候，发现4比当前栈顶小，所以我们就可以开始计算<strong>完全包含栈中每个柱子</strong>的最大矩形的面积</p>
<ol>
<li><p>由于当前<strong><code>i</code></strong> 位置的元素是比栈顶小，那么就说明 <strong><code>i-1</code></strong> 位置的元素一定比当前栈顶元素大！也就是向右边最多扩展到<strong><code>i-1</code></strong>位置</p>
</li>
<li><p>由于单调栈的结构，当前栈顶的下一个栈中元素<strong><code>left</code></strong>，其实就是当前栈顶的左边最近的比它小的元素，所以<strong><code>left+1</code></strong>位置的元素一定是比当前栈顶元素大(也有可能相等)！，所以向左边最多扩展到 <strong><code>left+1</code></strong> 位置</p>
</li>
<li><p>上面其实还分析漏了一种情况，那就是栈顶和 <strong><code>i</code></strong> 位置元素相等的情况，第一点中提到的其实是 <strong><code>i</code></strong> 位置元素小于栈顶的情况，如果相等，那么向右能扩展到的位置还会是<strong><code>i-1</code></strong>么？显然不是，至少应该是<strong><code>i</code></strong>甚至更大，那我们这里计算的右边界不就是错误的？那我们将 <strong><code>=</code></strong> 去掉可以么？去掉之后单调栈就不再是严格单调了，这样的到的右边界确实准确了，但是我们的左边界由于栈中存在相等的元素，就变的不再准确了！</p>
</li>
<li><p>那我们如何处理这种情况呢？其实根本就不用处理，既然栈顶能<strong>向右</strong>扩展到 <strong><code>i-1</code></strong> 那么反过来，<strong><code>i-1</code></strong> 一样可以<strong>向左</strong>扩展到<strong>栈顶</strong> 位置，进而还可以扩展到<strong><code>left+1</code></strong>位置，而向左扩展的<strong><code>left+1</code></strong>是准确的，不会有误差，所以我们只需要等待 <strong><code>i-1</code></strong>位置的元素弹出，然后就可以重新计算得到最大值，这个最大值肯定是包含之前的哪个最大当然这里其实那个 <strong><code>heights[i]&lt;=heights[stack.peek()]</code></strong> 中的等号也可以去掉，这样栈就不是严格单调的了，<strong><code>left+1</code></strong>也不再准确，但是此时 <strong><code>i-1</code></strong> 就准确了，所以我们可以等待<strong><code>left+1</code></strong> 弹栈之后再重新计算，总而言之，就是相等的情况是不用做额外的处理</p>
<p><img src="http://static.imlgw.top/blog/20200129/gJPOkfEPDxwg.png?imageslim" alt="mark"></p>
<p>可以看到按照代码中的逻辑在计算完全包含当前绿色的栈顶元素的最大矩形的时候其实只计算到一部分，当计算到后面的相等的柱子的时候会完全包含之前的柱子的值，这样就不会有问题</p>
</li>
</ol>
<p>​       </p>
<p>经过上面的分析，代码就好写多了，不过这里还有一个地方值得注意，就是处理栈中剩余的元素，其实比较好的方法是在数组的末尾加一个0，这样确保栈中所有的元素都可以出栈，不用额外的处理，java中没法直接向数组中push元素，所以我们就想象末尾有一个0，那么所有元素向左能扩展到的最远位置就是 <code>heights.length-1</code></p>
<p><strong>解法二</strong></p>
<p>分治，480ms，27%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分治 480ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights==<span class="keyword">null</span> || heights.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    largestRectangleArea(heights,<span class="number">0</span>,heights.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxArea=Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minIndex=left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left;i&lt;=right;i++) &#123;</span><br><span class="line">        minIndex=heights[i]&lt;heights[minIndex]?i:minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    maxArea=Math.max(heights[minIndex]*(right-left+<span class="number">1</span>),maxArea);</span><br><span class="line">    largestRectangleArea(heights,left,minIndex-<span class="number">1</span>);</span><br><span class="line">    largestRectangleArea(heights,minIndex+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将数组区间以<code>minIndex</code>为分界线，分别求左边和右边的最大面积，时间复杂度<code>O(NlogN)</code></p>
<p><strong>解法三</strong></p>
<p>优化的分治 1ms，100%，没想到比单调栈还快。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights==<span class="keyword">null</span> || heights.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largestRectangleArea(heights,<span class="number">0</span>,heights.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minIndex=left;</span><br><span class="line">    <span class="keyword">boolean</span> up=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> down=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i]&lt;heights[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            up=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heights[i]&gt;heights[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            down=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minIndex=heights[i]&lt;heights[minIndex]?i:minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (up) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=left;i&lt;=right;i++) &#123;</span><br><span class="line">            maxArea=Math.max(maxArea,(right-i+<span class="number">1</span>)*heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=right;i&gt;=left;i--) &#123;</span><br><span class="line">            maxArea=Math.max(maxArea,(i-left+<span class="number">1</span>)*heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(heights[minIndex]*(right-left+<span class="number">1</span>),Math.max(largestRectangleArea(heights,minIndex+<span class="number">1</span>,right),largestRectangleArea(heights,left,minIndex-<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实相比于上面的分治，就是多了一步判断当前区间是否有序，因为有序的话就可以直接遍历得到区间的最大矩形，不用再递归做分治，我这里做了两个有序的判断，不知道是不是有的多余，我看的评论都只有一个</p>
<h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></h2><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>解法一</strong></p>
<p>特意在做了上面一题后没有马上做这一题，下面的是第二天下午做的，还行，没忘记😂，就是写的有点难看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update: 2020.4.12</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> M=matrix.length,N=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] height=<span class="keyword">new</span> <span class="keyword">int</span>[M][N+<span class="number">1</span>]; <span class="comment">//每一层多加一个0,方便后面出栈</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                height[i][j]=i-<span class="number">1</span>&gt;=<span class="number">0</span>?height[i-<span class="number">1</span>][j]+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=Math.max(maxRectangle(height[i]),res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRectangle</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i]&lt;height[stack.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> cur=stack.pop();</span><br><span class="line">            <span class="comment">//栈为空的时候说明左边的全部是比当前栈顶大的元素,可以直接扩展到0,所以这里应该是-1</span></span><br><span class="line">            <span class="keyword">int</span> left=stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">            <span class="comment">//left+1 ~ i-1 = i-1-left</span></span><br><span class="line">            max=Math.max((i-<span class="number">1</span>-left)*height[cur],max);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实计算height有一点动态规划的意思，我上面相当于写了个二维的动态规划</p>
<blockquote>
<p>2020.4.12重写了一遍，然后更新了代码，之前的代码不够简洁</p>
</blockquote>
<p><strong>解法二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化height数组,在末尾添加一个元素(默认0)让所有元素可以出栈</span></span><br><span class="line">    <span class="keyword">int</span>[] height=<span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录每一层的height</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">            height[j]=matrix[i][j]==<span class="string">'1'</span>?height[j]+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max=Math.max(max,maxArea(height));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>maxArea</code>可以直接采用上面84题的分治</p>
<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></h2><p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 你只需要对 [<span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li>输入的数组长度范围在 [1, 10,000]。</li>
<li>输入的数组可能包含<strong>重复</strong>元素 ，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li>
</ol>
<p><strong>解法一</strong></p>
<p><del>单调栈的解法明天再写</del></p>
<p>鸽了挺长时间，单调栈的解法可以说是相当优秀</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> left=Integer.MAX_VALUE,right=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()]&gt;nums[i])&#123;</span><br><span class="line">            left=Math.min(stack.pop(),left); <span class="comment">//左边界正确位置(最小值)</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()]&lt;nums[i])&#123;</span><br><span class="line">            right=Math.max(stack.pop(),right); <span class="comment">//右边界正确位置(最大值)</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left&gt;right?<span class="number">0</span>:right-left+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个单调栈中存的是从左到右递增的序列，当遇到<code>nums[i]</code>小于栈顶时，说明这个位置是错位的，正确的位置应该是<strong>栈顶的元素</strong>的位置，我们这里求的就是一个<strong>最小的错位的索引</strong></p>
<p>第二个单调栈中存的是从右向左递减的序列，当遇到<code>nums[i]</code>大于栈顶时，说明这个位置是错位的，正确的位置应该是<strong>栈顶的元素</strong>，这里求的就是一个<strong>最大的错位的索引</strong> ，两者之间的距离其实就是我们最终要求的最短无序子数组长度</p>
<p><strong>解法二</strong></p>
<p>画一个折线图，观察结果，不容易直接想出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(1)空间的解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>]&gt;nums[nums.length-<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max=Integer.MIN_VALUE,min=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            min=Math.min(min,nums[i]); <span class="comment">//无序序列中的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            max=Math.max(max,nums[i-<span class="number">1</span>]); <span class="comment">//无序序列中的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left]&gt;min) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++; <span class="comment">//左边界正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right]&lt;max) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right--; <span class="comment">//右边界正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right&lt;left?<span class="number">0</span>:right-left+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://i.loli.net/2019/05/14/5cda71129045d93180.png" alt="rainwatertrap.png"></p>
<p>上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code> 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>解法三</strong></p>
<p>单调栈解法，双指针的解法放在<a href="http://imlgw.top/2019/05/04/leetcode-shu-zu/">数组专题</a>中，其实我感觉熟悉单调栈的话，单调栈的解法会比其他方法更好理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap6</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">//栈里面维护一个递减序列</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> ( ! stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123; <span class="comment">//当遍历的元素大于栈顶元素</span></span><br><span class="line">            <span class="keyword">int</span> tmp = stack.pop(); <span class="comment">//栈顶弹出来</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">            res += (Math.min(height[i],height[stack.peek()]) - height[tmp]) * (i - stack.peek() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护递减序列</span></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单调递减栈，栈中存柱子的索引，当遇到大于栈顶的元素的时候就开始弹栈，计算<strong>栈顶元素和左右首个大于栈顶元素的所能构成的那一层的接水量</strong>，对应下面的图理解就是</p>
<p><strong><code>(Math.min(height[i],height[stack.peek()])-curTop) * (i-stack.peek()-1)</code></strong></p>
<p><img src="http://static.imlgw.top/blog/20200129/f0b4lo2Xk5Q3.png?imageslim" alt="mark"></p>
<p>依次计算①②③位置的面积，这样的思路感觉会更加的自然</p>
<h2 id="面试题33-二叉搜索树的后序遍历序列"><a href="#面试题33-二叉搜索树的后序遍历序列" class="headerlink" title="面试题33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列</a></h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>数组长度 &lt;= 1000</code></li>
</ol>
<p><strong>解法一</strong></p>
<p>单调栈的解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postorder==<span class="keyword">null</span> || postorder.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">//1 2 | 4 5 | 3</span></span><br><span class="line">    <span class="keyword">int</span> curRoot=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=postorder.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder[i]&gt;curRoot)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; postorder[i]&lt;postorder[stack.peek()])&#123;</span><br><span class="line">            curRoot=postorder[stack.pop()];</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逆序遍历这个序列，就是 <code>root -- root.right -- root.left</code> ，用一个单调递增栈，当遇到减小的值就说明进入了左子树，我们需要找到这颗树的根节点，也就是不停出栈，直到找到根节点，然后继续向后判断左子树是不是都小于这个根节点的</p>
<h2 id="面试题59-II-队列的最大值"><a href="#面试题59-II-队列的最大值" class="headerlink" title="面试题59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - II. 队列的最大值</a></h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">"MaxQueue"</span>,<span class="string">"push_back"</span>,<span class="string">"push_back"</span>,<span class="string">"max_value"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]</span><br><span class="line">输出: [<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">"MaxQueue"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [<span class="keyword">null</span>,-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deque&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Deque&lt;Integer&gt; maxQueue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxQueue.isEmpty()?-<span class="number">1</span>:maxQueue.getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    queue.addLast(value);</span><br><span class="line">    <span class="keyword">while</span>(!maxQueue.isEmpty() &amp;&amp; value&gt;maxQueue.getLast())&#123;</span><br><span class="line">        maxQueue.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    maxQueue.addLast(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=queue.removeFirst();</span><br><span class="line">    <span class="keyword">if</span>(temp==maxQueue.getFirst())&#123;</span><br><span class="line">        maxQueue.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一直以为是和最小栈一样，结果WA了两发才意识到搞错了。。。这里是一个队列，进出方向是不一样的</p>
<p>其实这题和之前的一道 <a href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC">滑动窗口最大值</a> 一样，维护一个单调递减的单调栈然后维护这个单调栈就行了</p>
<h2 id="5402-绝对差不超过限制的最长连续子数组"><a href="#5402-绝对差不超过限制的最长连续子数组" class="headerlink" title="5402. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">5402. 绝对差不超过限制的最长连续子数组</a></h2><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>], limit = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[<span class="number">8</span>] 最大绝对差 |<span class="number">8</span>-<span class="number">8</span>| = <span class="number">0</span> &lt;= <span class="number">4</span>.</span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>] 最大绝对差 |<span class="number">8</span>-<span class="number">2</span>| = <span class="number">6</span> &gt; <span class="number">4</span>. </span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="number">8</span>-<span class="number">2</span>| = <span class="number">6</span> &gt; <span class="number">4</span>.</span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">8</span>-<span class="number">2</span>| = <span class="number">6</span> &gt; <span class="number">4</span>.</span><br><span class="line">[<span class="number">2</span>] 最大绝对差 |<span class="number">2</span>-<span class="number">2</span>| = <span class="number">0</span> &lt;= <span class="number">4</span>.</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="number">2</span>-<span class="number">4</span>| = <span class="number">2</span> &lt;= <span class="number">4</span>.</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">2</span>-<span class="number">7</span>| = <span class="number">5</span> &gt; <span class="number">4</span>.</span><br><span class="line">[<span class="number">4</span>] 最大绝对差 |<span class="number">4</span>-<span class="number">4</span>| = <span class="number">0</span> &lt;= <span class="number">4</span>.</span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">4</span>-<span class="number">7</span>| = <span class="number">3</span> &lt;= <span class="number">4</span>.</span><br><span class="line">[<span class="number">7</span>] 最大绝对差 |<span class="number">7</span>-<span class="number">7</span>| = <span class="number">0</span> &lt;= <span class="number">4</span>. </span><br><span class="line">因此，满足题意的最长子数组的长度为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>], limit = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：满足题意的最长子数组是 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>]，其最大绝对差 |<span class="number">2</span>-<span class="number">7</span>| = <span class="number">5</span> &lt;= <span class="number">5</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>], limit = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= limit &lt;= 10^9</code></li>
</ul>
<p>187th周赛t3，时隔这么久又回头打一次周赛，可惜，又只做了两题，前两题10分钟不到就写完了，心想这回怎么说也得做个3题，结果。。。</p>
<p><strong>解法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minpq=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    minpq.add(nums[<span class="number">0</span>]);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxpq=<span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">    maxpq.add(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//7 2</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right &amp;&amp; right&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">while</span> (right&lt; nums.length &amp;&amp; maxpq.peek()-minpq.peek()&lt;=limit) &#123;</span><br><span class="line">            res=Math.max(right-left+<span class="number">1</span>,res);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (right&lt;nums.length) &#123;</span><br><span class="line">                maxpq.add(nums[right]);</span><br><span class="line">                minpq.add(nums[right]);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxpq.remove(nums[left]);</span><br><span class="line">        minpq.remove(nums[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是当时比赛调了半天没调出来，结束之后调出来的代码，用两优先队列维护区间最值，然后滑窗就行了，我这里就是调滑窗的时候调了半天，之前写滑窗就是乱写的，没什么章法，边WA边改，看来最近得好好总结下滑窗的题了，得搞个板子出来</p>
<p><strong>解法二</strong></p>
<p>最优解，O(N)单调队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//单调队列记录区间最值索引</span></span><br><span class="line">    LinkedList&lt;Integer&gt; maxQue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; minQue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>;right&lt;nums.length;right++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!maxQue.isEmpty() &amp;&amp; nums[maxQue.getLast()]&lt;nums[right])&#123;</span><br><span class="line">            maxQue.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        maxQue.addLast(right);</span><br><span class="line">        <span class="keyword">while</span>(!minQue.isEmpty() &amp;&amp; nums[minQue.getLast()]&gt;nums[right])&#123;</span><br><span class="line">            minQue.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        minQue.addLast(right);</span><br><span class="line">        max=maxQue.getFirst();</span><br><span class="line">        min=minQue.getFirst();</span><br><span class="line">        <span class="keyword">if</span>(nums[max]-nums[min]&lt;=limit) &#123;</span><br><span class="line">            res=Math.max(res,right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不符合要求，左边界左移，当左边界是最值的时候que弹出</span></span><br><span class="line">            <span class="keyword">if</span> (left==max) maxQue.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (left==min) minQue.removeFirst();</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实当时我确实也尝试去用两个单调队列维护最值，但是！！！还是被滑窗的边界给搞得不知道这么写了，然后就没又然后了，上面的代码也是比赛完之后自己写出来的，说到底还是菜啊！😭</p>
<h2 id="962-最大宽度坡"><a href="#962-最大宽度坡" class="headerlink" title="962. 最大宽度坡"></a><a href="https://leetcode-cn.com/problems/maximum-width-ramp/" target="_blank" rel="noopener">962. 最大宽度坡</a></h2><p>给定一个整数数组 <code>A</code>，<em>坡</em>是元组 <code>(i, j)</code>，其中  <code>i &lt; j</code> 且 <code>A[i] &lt;= A[j]</code>。这样的坡的宽度为 <code>j - i</code>。</p>
<p>找出 <code>A</code> 中的坡的最大宽度，如果不存在，返回 0 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) = (<span class="number">1</span>, <span class="number">5</span>): A[<span class="number">1</span>] = <span class="number">0</span> 且 A[<span class="number">5</span>] = <span class="number">5</span>.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) = (<span class="number">2</span>, <span class="number">9</span>): A[<span class="number">2</span>] = <span class="number">1</span> 且 A[<span class="number">9</span>] = <span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 50000</code></li>
<li><code>0 &lt;= A[i] &lt;= 50000</code></li>
</ol>
<p><strong>解法一</strong></p>
<p>想不到，着实想不到，这个单调栈的用法确实没见过，但是只要见过了看一下就懂了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty() || A[stack.peek()]&gt;=A[i])&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; A[stack.peek()]&lt;=A[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> cur=stack.pop();</span><br><span class="line">            res=Math.max(res,i-cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先把A数组中的以<code>A[0]</code>开头的递减序列抽取出来，我们最后要求的最大的宽度坡一定是以这个序列中的某一个<code>i</code>为<strong>坡底</strong>的，我们反证一下</p>
<p>假设存在某个元素位置<code>k</code>不存在于上面的递减序列中，且有最大宽度<code>j-k</code>，这也就说明<code>k</code>位置的元素<strong>一定是小于等于k前面所有的元素的</strong>，否则就会有更长的宽度，但是既然<code>k</code>小于等于前面所有的元素，那么k就一定会被加入到序列中，与假设矛盾，所以不存在k，解一定存在递减序列中</p>
<p>这样的话我们可以逆向遍历数组，每次遇到元素大于栈顶的就可以计算宽度，然后将栈顶弹出，因为是逆序遍历的，所以这个宽度一定是栈顶这个<strong>坡底<code>i</code></strong>能形成的最大宽度了， 逆序遍历再往前的话即使大于这个栈顶，形成的宽度也只会减小，所以我们遍历所有的坡底求最大值就行了，时间复杂度<code>O(N)</code></p>
<p><strong>解法二</strong></p>
<p>二分的思路，和上面一样，先构建一个以<code>A[0]</code>开头的递减序列，这里面就是我们所有的坡底，然后我们可以遍历所有的元素，然后在这个单调序列中寻找第一个小于等于当前元素的<code>index</code>，这两个构成的宽度就是<strong>当前元素</strong>所能形成的最大宽度，我们求出所有的最大宽度取一个最值就可以了，时间复杂度<code>O(NlogN)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxWidthRamp</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> order [][]<span class="keyword">int</span></span><br><span class="line">    order = <span class="built_in">append</span>(order, []<span class="keyword">int</span>&#123;<span class="number">0</span>, A[<span class="number">0</span>]&#125;)</span><br><span class="line">    <span class="comment">//构建递减序列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(A); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> A[i] &lt; order[<span class="built_in">len</span>(order)<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">            order = <span class="built_in">append</span>(order, []<span class="keyword">int</span>&#123;i, A[i]&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j, target := <span class="keyword">range</span> A &#123;</span><br><span class="line">        i := binarySearch(order, target)</span><br><span class="line">        res = Max(res, j-i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找第一个小于等于target的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(num [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(num) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> num[mid][<span class="number">1</span>] &gt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment">//注意是递减序列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[left][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在lc写的 <a href="https://leetcode-cn.com/problems/maximum-width-ramp/solution/java-dan-diao-zhan-er-fen-jie-fa-chang-shi-jie-shi/" target="_blank" rel="noopener">题解</a>欢迎前来纠错</p>
</blockquote>
<h2 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a><a href="https://leetcode-cn.com/problems/longest-well-performing-interval/" target="_blank" rel="noopener">1124. 表现良好的最长时间段</a></h2><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。</p>
<p>我们认为当员工一天中的工作小时数大于 <code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p>
<p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 <strong>大于</strong>「不劳累的天数」。</p>
<p>请你返回「表现良好时间段」的最大长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：hours = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长的表现良好时间段是 [<span class="number">9</span>,<span class="number">9</span>,<span class="number">6</span>]。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= hours.length &lt;= 10000</code></li>
<li><code>0 &lt;= hours[i] &lt;= 16</code></li>
</ul>
<p><strong>解法一</strong></p>
<p>惭愧，这题还是看的题解，这题还是挺巧妙的，我们把大于8小时的时间段看作<code>+1</code>，小于8小时的看作<code>-1</code>，这样问题就转换成了求<strong>区间和大于0的最长长度</strong>，而区间和我们又可以联想到用前缀和，这样我们将题目的例子转换一下就变成了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hours:    <span class="number">9</span> <span class="number">9</span>  <span class="number">6</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line">hours:  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>  <span class="number">1</span></span><br><span class="line">  pre:  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">2</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>只要<code>pre</code>中两点的前缀<code>pre[j]-pre[i]&gt;0</code>就说明区间<code>[i+1，j]</code>是满足条件的，我们要求的就是满足条件的最长宽度，这样一来问题其实就转换成了和上面<a href="#962-最大宽度坡">962.最大宽度坡</a>一样了，我们按照上面的步骤求解就ok了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="keyword">int</span>[] hours)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pre=<span class="keyword">new</span> <span class="keyword">int</span>[hours.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=hours.length;i++)&#123;</span><br><span class="line">        pre[i]=pre[i-<span class="number">1</span>]+(hours[i-<span class="number">1</span>]&gt;<span class="number">8</span>?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty() || pre[i]&lt;pre[stack.peek()])&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pre.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; pre[i]-pre[stack.peek()]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res=Math.max(res,i-stack.pop()); <span class="comment">//不用+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-有效的括号"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#678-有效的括号字符串"><span class="toc-text">678. 有效的括号字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-字符串解码"><span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#344-反转字符串"><span class="toc-text">344. 反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#150-逆波兰表达式求值"><span class="toc-text">150. 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-简化路径"><span class="toc-text">71. 简化路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#225-用队列实现栈"><span class="toc-text">225. 用队列实现栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#232-用栈实现队列"><span class="toc-text">232. 用栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-最小栈"><span class="toc-text">155. 最小栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#779-第K个语法符号"><span class="toc-text">779. 第K个语法符号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-Pow-x-n"><span class="toc-text">50. Pow(x, n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5222-分割平衡字符串"><span class="toc-text">5222. 分割平衡字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1249-移除无效的括号"><span class="toc-text">1249. 移除无效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#856-括号的分数"><span class="toc-text">856. 括号的分数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#946-验证栈序列"><span class="toc-text">946. 验证栈序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS广搜"><span class="toc-text">BFS广搜</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-完全平方数"><span class="toc-text">279. 完全平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127-单词接龙"><span class="toc-text">127. 单词接龙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#542-01-矩阵"><span class="toc-text">542. 01 矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1306-跳跃游戏-III"><span class="toc-text">1306. 跳跃游戏 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5314-跳跃游戏-IV"><span class="toc-text">5314. 跳跃游戏 IV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#690-员工的重要性"><span class="toc-text">690. 员工的重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1311-获取你好友已观看的视频"><span class="toc-text">1311. 获取你好友已观看的视频</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#399-除法求值"><span class="toc-text">399. 除法求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#301-删除无效的括号"><span class="toc-text">301. 删除无效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-腐烂的橘子"><span class="toc-text">994. 腐烂的橘子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1162-地图分析"><span class="toc-text">1162. 地图分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-课程表"><span class="toc-text">207. 课程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈"><span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#496-下一个更大元素-I"><span class="toc-text">496. 下一个更大元素 I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#503-下一个更大元素-II"><span class="toc-text">503. 下一个更大元素 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-每日温度"><span class="toc-text">739. 每日温度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#901-股票价格跨度"><span class="toc-text">901. 股票价格跨度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-柱状图中最大的矩形"><span class="toc-text">84. 柱状图中最大的矩形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-最大矩形"><span class="toc-text">85. 最大矩形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#581-最短无序连续子数组"><span class="toc-text">581. 最短无序连续子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-接雨水"><span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题33-二叉搜索树的后序遍历序列"><span class="toc-text">面试题33. 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题59-II-队列的最大值"><span class="toc-text">面试题59 - II. 队列的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5402-绝对差不超过限制的最长连续子数组"><span class="toc-text">5402. 绝对差不超过限制的最长连续子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#962-最大宽度坡"><span class="toc-text">962. 最大宽度坡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1124-表现良好的最长时间段"><span class="toc-text">1124. 表现良好的最长时间段</span></a></li></ol>
  </div>


  </div>
</div>


    <section id="comments" style="margin:10px;padding:10px;background:#fff;">
      <div id="vcomment" class="comment"></div> 
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
   var notify = 'false' == true ? true : false;
   var verify = 'true' == true ? true : false;
    window.onload = function() {
        new Valine({
            el: '.comment',
            notify: notify,
            verify: verify,
            app_id: "MkcXmeDvktRNBDBrVqb9KYPH-MdYXbMMI",
            app_key: "swDnb5a9u9Ksp2Rwkdm7Qulh",
            placeholder: "留下邮箱才能收到收到回复喔 ~",
            avatar:"monsterid"
        });
    }
</script>
    </section>
  
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/09/24/abstractqueuedsynchronizer/" rel="next" title="AQS源码解析（上）">
          AQS源码解析（上）
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/10/10/leetcode-hui-su/" rel="prev" title="LeetCode回溯&amp;递归">
            LeetCode回溯&amp;递归
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/imlgw" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="https://imlgw.avosapps.us/" target="_blank" rel="noopener">博客评论管理</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body>
</html>
