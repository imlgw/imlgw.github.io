<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>LeetCode链表 | iMlGw0</title><meta name="description" content="LeetCode链表"><meta name="keywords" content="LeetCode,链表"><meta name="author" content="imlgw"><meta name="copyright" content="imlgw"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Cup.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LeetCode链表"><meta name="twitter:description" content="LeetCode链表"><meta name="twitter:image" content="http://static.imlgw.top///20190227/gPprrxbrdwAx.jpg?imageslim"><meta property="og:type" content="article"><meta property="og:title" content="LeetCode链表"><meta property="og:url" content="http://imlgw.top/2019/02/27/leetcode-lian-biao/"><meta property="og:site_name" content="iMlGw0"><meta property="og:description" content="LeetCode链表"><meta property="og:image" content="http://static.imlgw.top///20190227/gPprrxbrdwAx.jpg?imageslim"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://imlgw.top/2019/02/27/leetcode-lian-biao/"><link rel="prev" title="Java多线程基础" href="http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/"><link rel="next" title="常见的排序算法总结" href="http://imlgw.top/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?93be601f1b40364d8cd640d751012180";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"imlgw.top","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: imlgw","link":"链接: http://imlgw.top/2019/02/27/leetcode-lian-biao/","source":"来源: iMlGw0","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">iMlGw0</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/board/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> LeetCode</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://imlgw.top/2019/02/27/leetcode-lian-biao/"><i class="fa-fw fa fa-tags"></i><span> 链表</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/05/04/leetcode-shu-zu/"><i class="fa-fw fa fa-tags"></i><span> 数组</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/"><i class="fa-fw fa fa-tags"></i><span> 栈&amp;队列</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 二分查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/"><i class="fa-fw fa fa-tags"></i><span> 二叉树</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/"><i class="fa-fw fa fa-tags"></i><span> 滑动窗口</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/"><i class="fa-fw fa fa-tags"></i><span> 动态规划</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/"><i class="fa-fw fa fa-tags"></i><span> 背包问题</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/10/leetcode-hui-su/"><i class="fa-fw fa fa-tags"></i><span> 回溯</span></a></li><li><a class="site-page" href="http://imlgw.top/2020/01/21/leetcode-tan-xin/"><i class="fa-fw fa fa-tags"></i><span> 贪心</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-address-book"></i><span> 大佬们</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://static.imlgw.top/maofu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">61</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">60</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/board/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> LeetCode</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://imlgw.top/2019/02/27/leetcode-lian-biao/"><i class="fa-fw fa fa-tags"></i><span> 链表</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/05/04/leetcode-shu-zu/"><i class="fa-fw fa fa-tags"></i><span> 数组</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/"><i class="fa-fw fa fa-tags"></i><span> 栈&amp;队列</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/"><i class="fa-fw fa fa-tags"></i><span> 二分查找</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/"><i class="fa-fw fa fa-tags"></i><span> 二叉树</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/"><i class="fa-fw fa fa-tags"></i><span> 滑动窗口</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/"><i class="fa-fw fa fa-tags"></i><span> 动态规划</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/"><i class="fa-fw fa fa-tags"></i><span> 背包问题</span></a></li><li><a class="site-page" href="http://imlgw.top/2019/10/10/leetcode-hui-su/"><i class="fa-fw fa fa-tags"></i><span> 回溯</span></a></li><li><a class="site-page" href="http://imlgw.top/2020/01/21/leetcode-tan-xin/"><i class="fa-fw fa fa-tags"></i><span> 贪心</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fa fa-address-book"></i><span> 大佬们</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-两数相加"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">2. 两数相加</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#445-两数相加Ⅱ"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">445. 两数相加Ⅱ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#876-链表的中间节点"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">876. 链表的中间节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#206-反转链表"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">206. 反转链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#92-反转链表Ⅱ"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">92. 反转链表Ⅱ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#725-分隔链表"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">725. 分隔链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#86-分隔-割-链表"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">86. 分隔(割)链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#160-相交链表"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">160. 相交链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#234-回文链表"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">234. 回文链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#237-删除链表中的节点"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">237. 删除链表中的节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#203-移除链表元素"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">203. 移除链表元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#19-删除链表的倒数第N个节点"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">19. 删除链表的倒数第N个节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#82-删除链表中的重复元素Ⅱ"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">82. 删除链表中的重复元素Ⅱ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#143-重排链表"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">143. 重排链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#21-合并两个有序链表"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">21. 合并两个有序链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#23-合并K个排序链表"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">23. 合并K个排序链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#430-扁平化多级双向链表"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">430. 扁平化多级双向链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#141-环形链表"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">141. 环形链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#141-环形链表Ⅱ"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">141. 环形链表Ⅱ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#61-旋转链表"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text">61. 旋转链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#328-奇偶链表"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text">328. 奇偶链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#147-对链表进行插入排序"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text">147. 对链表进行插入排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#148-排序链表"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text">148. 排序链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#138-复制带随机指针的链表"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text">138.复制带随机指针的链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#24-两两交换链表中的节点"><span class="toc_mobile_items-number">25.</span> <span class="toc_mobile_items-text">24. 两两交换链表中的节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#25-K个一组翻转链表"><span class="toc_mobile_items-number">26.</span> <span class="toc_mobile_items-text">25.K个一组翻转链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#817-链表组件"><span class="toc_mobile_items-number">27.</span> <span class="toc_mobile_items-text">817. 链表组件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#109-有序链表转换二叉搜索树"><span class="toc_mobile_items-number">28.</span> <span class="toc_mobile_items-text">109. 有序链表转换二叉搜索树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1019-链表中的下一个更大节点"><span class="toc_mobile_items-number">29.</span> <span class="toc_mobile_items-text">1019. 链表中的下一个更大节点</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-两数相加"><span class="toc-number">1.</span> <span class="toc-text">2. 两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#445-两数相加Ⅱ"><span class="toc-number">2.</span> <span class="toc-text">445. 两数相加Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#876-链表的中间节点"><span class="toc-number">3.</span> <span class="toc-text">876. 链表的中间节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-反转链表"><span class="toc-number">4.</span> <span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-反转链表Ⅱ"><span class="toc-number">5.</span> <span class="toc-text">92. 反转链表Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#725-分隔链表"><span class="toc-number">6.</span> <span class="toc-text">725. 分隔链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-分隔-割-链表"><span class="toc-number">7.</span> <span class="toc-text">86. 分隔(割)链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-相交链表"><span class="toc-number">8.</span> <span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-回文链表"><span class="toc-number">9.</span> <span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#237-删除链表中的节点"><span class="toc-number">10.</span> <span class="toc-text">237. 删除链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#203-移除链表元素"><span class="toc-number">11.</span> <span class="toc-text">203. 移除链表元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-删除链表的倒数第N个节点"><span class="toc-number">12.</span> <span class="toc-text">19. 删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-删除链表中的重复元素Ⅱ"><span class="toc-number">13.</span> <span class="toc-text">82. 删除链表中的重复元素Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#143-重排链表"><span class="toc-number">14.</span> <span class="toc-text">143. 重排链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-合并两个有序链表"><span class="toc-number">15.</span> <span class="toc-text">21. 合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-合并K个排序链表"><span class="toc-number">16.</span> <span class="toc-text">23. 合并K个排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#430-扁平化多级双向链表"><span class="toc-number">17.</span> <span class="toc-text">430. 扁平化多级双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-环形链表"><span class="toc-number">18.</span> <span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-环形链表Ⅱ"><span class="toc-number">19.</span> <span class="toc-text">141. 环形链表Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-旋转链表"><span class="toc-number">20.</span> <span class="toc-text">61. 旋转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#328-奇偶链表"><span class="toc-number">21.</span> <span class="toc-text">328. 奇偶链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#147-对链表进行插入排序"><span class="toc-number">22.</span> <span class="toc-text">147. 对链表进行插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-排序链表"><span class="toc-number">23.</span> <span class="toc-text">148. 排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-复制带随机指针的链表"><span class="toc-number">24.</span> <span class="toc-text">138.复制带随机指针的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-两两交换链表中的节点"><span class="toc-number">25.</span> <span class="toc-text">24. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K个一组翻转链表"><span class="toc-number">26.</span> <span class="toc-text">25.K个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#817-链表组件"><span class="toc-number">27.</span> <span class="toc-text">817. 链表组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#109-有序链表转换二叉搜索树"><span class="toc-number">28.</span> <span class="toc-text">109. 有序链表转换二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1019-链表中的下一个更大节点"><span class="toc-number">29.</span> <span class="toc-text">1019. 链表中的下一个更大节点</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://static.imlgw.top///20190227/gPprrxbrdwAx.jpg?imageslim)"><div id="post-info"><div id="post-title"><div class="posttitle">LeetCode链表</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-02-27<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.6k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 31 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。<br> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><strong>示例：</strong><br><strong>输入：</strong>(2 -> 4 -> 3) + (5 -> 6 -> 4)<br><strong>输出</strong>：7 -> 0 -> 8<br><strong>原因</strong>：342 + 465 = 807</p>
<p><strong>解法一</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//比较推荐的写法，简洁一点，在lc上提交区别不大</span>
<span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode temp<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> carry<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">!=</span>null <span class="token operator">||</span> l2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum<span class="token operator">=</span> <span class="token punctuation">(</span>l1<span class="token operator">!=</span>null<span class="token operator">?</span>l1<span class="token punctuation">.</span>val<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>l2<span class="token operator">!=</span>null<span class="token operator">?</span>l2<span class="token punctuation">.</span>val<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span> carry<span class="token punctuation">;</span>
        temp<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        carry<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
        l1<span class="token operator">=</span>l1<span class="token operator">!=</span>null<span class="token operator">?</span>l1<span class="token punctuation">.</span>next<span class="token operator">:</span>null<span class="token punctuation">;</span>
        l2<span class="token operator">=</span>l2<span class="token operator">!=</span>null<span class="token operator">?</span>l2<span class="token punctuation">.</span>next<span class="token operator">:</span>null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>carry<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><del>很久之前写的代码了，代码很乱，用0补齐短的那个然后对应相加注意进位就行了</del></p>
<p>2020.3.22 把之前的代码删了，一年前的代码，写的太丑了</p>
<p><strong>解法二</strong></p>
<p>2020.3.22 新增了一个解法，有点偏，没啥意思，不过熟悉下链表还是可以</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//这个解法有点偏了,为了不new节点直接在原链表上修改的</span>
<span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>l1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> carry<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    ListNode last<span class="token operator">=</span>l1<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">!=</span>null <span class="token operator">&&</span> l2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum<span class="token operator">=</span> l1<span class="token punctuation">.</span>val <span class="token operator">+</span> l2<span class="token punctuation">.</span>val<span class="token operator">+</span> carry<span class="token punctuation">;</span>
        l1<span class="token punctuation">.</span>val<span class="token operator">=</span>sum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
        carry<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
        last<span class="token operator">=</span>l1<span class="token punctuation">;</span>
        l1<span class="token operator">=</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        l2<span class="token operator">=</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">!=</span>null <span class="token operator">&&</span> carry<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token punctuation">.</span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>
        l1<span class="token punctuation">.</span>val<span class="token operator">=</span>sum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
        carry<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
        last<span class="token operator">=</span>l1<span class="token punctuation">;</span>
        l1<span class="token operator">=</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        last<span class="token punctuation">.</span>next<span class="token operator">=</span>l2<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l2<span class="token operator">!=</span>null <span class="token operator">&&</span> carry<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l2<span class="token punctuation">.</span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>
            l2<span class="token punctuation">.</span>val<span class="token operator">=</span>sum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>
            carry<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>
            last<span class="token operator">=</span>l2<span class="token punctuation">;</span>
            l2<span class="token operator">=</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>carry<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> last<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="445-两数相加Ⅱ"><a href="#445-两数相加Ⅱ" class="headerlink" title="445. 两数相加Ⅱ"></a>445. 两数相加Ⅱ</h2><p>给定两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br><strong>进阶:</strong><br>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。<br><strong>示例:</strong><br><strong>输入:</strong> (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)<br><strong>输出:</strong> 7 -> 8 -> 0 -> 7</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BigInteger b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token function">list2num</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BigInteger b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token function">list2num</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String resStr<span class="token operator">=</span>b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//再变成字符串存到连表里面</span>
    ListNode res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode real<span class="token operator">=</span>res<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator"><</span>resStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        real<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>resStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        real<span class="token operator">=</span>real<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> String  <span class="token function">list2num</span><span class="token punctuation">(</span>ListNode l<span class="token punctuation">)</span><span class="token punctuation">{</span>
    String num<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        num<span class="token operator">=</span>num<span class="token operator">+</span>l<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        l<span class="token operator">=</span>l<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这两题方法很多，下面那题实际上是上面那一题反过来的，但是题目要求不改变链表所以可以利用栈来反转，然后就跟上面的类似了，然后这里我偷了个懒用的<code>BigInteger</code>搞的速度也还行 77%beat。</p>
<hr>
<h2 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876. 链表的中间节点"></a><strong>876. 链表的中间节点</strong></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">middleNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
        ListNode fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
        ListNode slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 1 2 3 4 5 6 7</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>null<span class="token operator">&&</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p><code>快慢指针</code>，很常见很经典的做法后面很多题会用到这个。</p>
</blockquote>
<hr>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><strong>206. 反转链表</strong></h2><p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1->2->3->4->5->NULL<br><strong>输出:</strong> 5->4->3->2->1->NULL</p>
<p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p><strong>解法一:</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//从后往前</span>
    head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>解法二:</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//三指针迭代</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">reverseList2</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    ListNode pre<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode cur<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode temp<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        temp<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>
        pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        cur<span class="token operator">=</span>temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    head<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h2 id="92-反转链表Ⅱ"><a href="#92-反转链表Ⅱ" class="headerlink" title="92. 反转链表Ⅱ"></a><strong>92. 反转链表Ⅱ</strong></h2><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1->2->3->4->5->NULL, <em>m</em> = 2, <em>n</em> = 4<br><strong>输出:</strong> 1->4->3->2->5->NULL</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">==</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//用来遍历</span>
    ListNode pre<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode mid<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode rear<span class="token operator">=</span>null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//在遍历的中间连接这个表 时间复杂厚度O(N)</span>
    <span class="token comment" spellcheck="true">//所以需要先保存 m前的节点用于后面到n的时候连接n和前面的部分 preM</span>
    <span class="token comment" spellcheck="true">//还要保存m节点，在后面遍历到n的时候将M节点和后面的部分连接</span>
    <span class="token comment" spellcheck="true">//中间段的前后节点 </span>
    ListNode preM <span class="token operator">=</span>null<span class="token punctuation">;</span>
    ListNode valM<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//ListNode nNext=null;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator"><=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//count的位置实际上是指的pre的位置因为只有pre是从head开始走的</span>
        <span class="token comment" spellcheck="true">//尾指针后移</span>
        rear<span class="token operator">=</span>mid<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//保存M点前面的节点和M节点</span>
            preM<span class="token operator">=</span>pre<span class="token punctuation">;</span>
            valM<span class="token operator">=</span>mid<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//System.out.println("preM :"+preM.val);</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//连接n后面节点的值</span>
            valM<span class="token punctuation">.</span>next<span class="token operator">=</span>rear<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//在这里判断下m前有没有元素</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                head<span class="token operator">=</span>mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
                preM<span class="token punctuation">.</span>next<span class="token operator">=</span>mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">>=</span> m <span class="token operator">&&</span> count <span class="token operator"><=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//只有mid的位置大于m小于等于n才会将节点next域反转</span>
            mid<span class="token punctuation">.</span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//其他两个指针也向后移动</span>
        pre<span class="token operator">=</span>mid<span class="token punctuation">;</span>
        mid<span class="token operator">=</span>rear<span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>代码写的比较烂但是思路还是比较清晰，只扫描了一遍链表 2ms beat 100%，但是创建的指针有点多，抠边界要细心。</p>
<hr>
<h2 id="725-分隔链表"><a href="#725-分隔链表" class="headerlink" title="725. 分隔链表"></a><strong><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">725. 分隔链表</a></strong></h2><p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p>
<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>
<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>
<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>
<p>Examples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>
<p><strong>Example 1:</strong></p>
<pre class=" language-java"><code class="language-java">Input<span class="token operator">:</span> 
root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">5</span>
Output<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Explanation<span class="token operator">:</span>
The input and each element of the output are ListNodes<span class="token punctuation">,</span> not arrays<span class="token punctuation">.</span>
For example<span class="token punctuation">,</span> the input root has root<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> \root<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> and root<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">.</span>
The first element output<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> has output<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> output<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">.</span>
The last element output<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> is null<span class="token punctuation">,</span> but it's string representation as a ListNode is <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span></code></pre>
<p><strong>Example 2:</strong></p>
<pre class=" language-java"><code class="language-java">Input<span class="token operator">:</span> 
root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">3</span>
Output<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Explanation<span class="token operator">:</span>
The input has been split into consecutive parts with size difference at most <span class="token number">1</span><span class="token punctuation">,</span> and earlier parts are a larger size than the later parts<span class="token punctuation">.</span></code></pre>
<p><strong>Note:</strong></p>
<p>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</p>
<p>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</p>
<p><code>k</code> will be an integer in the range <code>[1, 50]</code>.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">splitListToParts</span><span class="token punctuation">(</span>ListNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//先要获取下链表的长度</span>
    ListNode temp<span class="token operator">=</span>root<span class="token punctuation">;</span>
    ListNode next<span class="token operator">=</span>root<span class="token punctuation">;</span>
    ListNode <span class="token punctuation">[</span><span class="token punctuation">]</span> result<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    temp<span class="token operator">=</span>root<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//任意两部分差距不能大于1，大的在前，小的在后面</span>
    <span class="token comment" spellcheck="true">//其实就是对count进行分配</span>
    <span class="token comment" spellcheck="true">//注意: 有null的情况一定是 k>count 直接按 1 切分就完事了</span>
    <span class="token comment" spellcheck="true">//k<count的情况只要在 count k 的前几个元素上加上 的余数就行了< span>
    <span class="token keyword">int</span> size<span class="token operator">=</span>count<span class="token operator">/</span>k<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num<span class="token operator">=</span>count<span class="token operator">%</span>k<span class="token punctuation">;</span>
    result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>root<span class="token punctuation">;</span>
    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator"><=</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>temp<span class="token operator">!=</span>null <span class="token operator">&&</span> index <span class="token operator"><</span> k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            next<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator"><=</span><span class="token punctuation">(</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>num <span class="token operator">&&</span> i<span class="token operator">%</span><span class="token punctuation">(</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//前几个res的分割点</span>
                result<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>next<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//切断</span>
                temp<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token punctuation">(</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>num <span class="token operator">&&</span> <span class="token punctuation">(</span>i<span class="token operator">-</span>num<span class="token punctuation">)</span><span class="token operator">%</span>size<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                result<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>next<span class="token punctuation">;</span>
                temp<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            temp<span class="token operator">=</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//剩下的情况就是后面要补null的情况</span>
        <span class="token comment" spellcheck="true">// 这里两种情况应该是可以合并的，但是k>count num>0 懒得去抠边界</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator"><</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//这个if其实没必要</span>
                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
                next<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>next<span class="token punctuation">;</span>
                temp<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
                temp<span class="token operator">=</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></count的情况只要在></span></code></pre>
<p>3ms beat 89% 这题也比较简单主要是边界要抠好</p>
<hr>
<h2 id="86-分隔-割-链表"><a href="#86-分隔-割-链表" class="headerlink" title="86. 分隔(割)链表"></a><strong>86. 分隔(割)链表</strong></h2><p>给定一个链表和一个特定值_ x_，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> head = 1->4->3->2->5->2, <em>x</em> = 3<br><strong>输出:</strong> 1->2->2->4->3->5</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">partition</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//先在头部加一个dummy节点统一操作</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//分割点</span>
    ListNode pre<span class="token operator">=</span>cutNode<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    ListNode cur<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cut<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token operator">>=</span>x<span class="token operator">&&</span>cut<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//只会执行一次在找到第一个val>=x的节点的时候---保存分割点</span>
            cutNode<span class="token operator">=</span>pre<span class="token punctuation">;</span>
            cut<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token operator"><</span>x <span class="token operator">&&</span> cut<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//找到分割点后 遍历到val<x的节点的情况---将cur连接到cutnode的后面 处理好cur相邻的两个节点< span>
            <span class="token comment" spellcheck="true">//先处理好cur相邻的节点</span>
            pre<span class="token punctuation">.</span>next<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//连接cutNode</span>
            cur<span class="token punctuation">.</span>next<span class="token operator">=</span>cutNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            cutNode<span class="token punctuation">.</span>next<span class="token operator">=</span>cur<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//cutNode后移</span>
            cutNode<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next
<span class="token punctuation">}</span></x的节点的情况---将cur连接到cutnode的后面></span></code></pre>
<p>这题也挺简单和上面的那题名字一样是在整理这篇博客的时候现场做的(2019.2.27)前后大概半个小时orz。。。比较菜，但是这个我没有在本地跑直接在LeetCode上提交的然后就过了 1ms beat84% 感觉思路比较清晰就没有本地跑，提交记录上最快的居然是用了额外空间new了两个链表然后连起来的。。。醉了可能是测试用例太少了。</p>
<hr>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><strong>160. 相交链表</strong></h2><p>编写一个程序，找到两个单链表相交的起始节点。<br>如下面的两个链表：<br><img alt="mark" data-src="http://static.imlgw.top///20190303/NVEXndTcF1R6.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p>在节点 c1 开始相交。</p>
<p><strong>示例 1：</strong></p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/ymln2djUVieT.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>输入</strong>: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br><strong>输出</strong>: Reference of the node with value = 8<br><strong>输入解释</strong>:相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p><strong>示例 2：</strong></p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/2F7qqhkUIWog.png?imageslim" src="/img/loading.gif" class="lazyload"><br><strong>输入</strong>:intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br><strong>输出</strong>:Reference of the node with value = 2<br><strong>输入解释</strong>:相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p><strong>示例 3：</strong></p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/hKSAelGSE1TY.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>输入</strong>:intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br><strong>输出</strong>:null<br><strong>输入解释</strong>:从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br><strong>解释</strong>:这两个链表不相交，因此返回 null。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果两个链表没有交点，返回 <code>null</code>.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>
</ul>
<p><strong>解法一：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode pA<span class="token operator">=</span>headA<span class="token punctuation">;</span>
    ListNode pB<span class="token operator">=</span>headB<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//计算两个链表长度然后计算差距然后向后对齐</span>
    <span class="token keyword">int</span> lenA<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> lenB<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pA<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        pA<span class="token operator">=</span>pA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        lenA<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pB<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        pB<span class="token operator">=</span>pB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        lenB<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> dis<span class="token operator">=</span>lenB<span class="token operator">></span>lenA<span class="token operator">?</span>lenB<span class="token operator">-</span>lenA<span class="token operator">:</span>lenA<span class="token operator">-</span>lenB<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>lenB<span class="token operator">></span>lenA<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>dis<span class="token operator">--</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            headB<span class="token operator">=</span>headB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>dis<span class="token operator">--</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            headA<span class="token operator">=</span>headA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//不相等就一直向后移</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>headA<span class="token operator">!=</span>headB<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//如果有一条为空说明没有交点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>headA<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        headA<span class="token operator">=</span>headA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        headB<span class="token operator">=</span>headB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> headA<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这种方法比较直接直接计算两个链表的长度然后计算差值然后将长的那个移动到对应的位置让<code>两条链表尾对齐</code>然后一起向后移动<br><strong>解法二：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//方法二 </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">getIntersectionNode2</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，向后对齐，方法还是很巧妙的。</span>
    ListNode pA<span class="token operator">=</span>headA<span class="token punctuation">;</span>
    ListNode pB<span class="token operator">=</span>headB<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>headB<span class="token operator">==</span>null <span class="token operator">||</span> headA<span class="token operator">==</span>null<span class="token punctuation">)</span>
                 <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//while(pA!=null && pB!=null ){</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pA<span class="token operator">!=</span>pB<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//要保证两个==null的时候都只能执行一次不然如果没有交点就会死循环</span>
        <span class="token comment" spellcheck="true">//改变while的条件</span>
        <span class="token comment" spellcheck="true">//改变pA，pB跳转的条件</span>
        <span class="token comment" spellcheck="true">//这样就可以保证最后没交点的时候 第二遍循环pA和pB最后会同时等于null会有出口不会死循环</span>
        pA<span class="token operator">=</span>pA<span class="token operator">==</span>null<span class="token operator">?</span>headB<span class="token operator">:</span>pA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        pB<span class="token operator">=</span>pB<span class="token operator">==</span>null<span class="token operator">?</span>headA<span class="token operator">:</span>pB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pA<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p> 同时遍历两个链表，当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，使之尾对齐，方法还是很巧妙的，代码也比较简洁。</p>
</blockquote>
<hr>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><strong>234. 回文链表</strong></h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> 1->2<br><strong>输出:</strong> false</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> 1->2->2->1<br><strong>输出:</strong> true</p>
<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 利用快慢指针找到中点</span>
    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">?</span> fast<span class="token punctuation">.</span>next <span class="token operator">:</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 如果是偶数节点，slow就是偏右的那个 奇数就是正中间的 奇数在正中间不用管</span>
    <span class="token comment" spellcheck="true">// fast是尾节点 1 1 1 1 1 1</span>
    <span class="token function">resverList</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//slow.next==null</span>
    <span class="token comment" spellcheck="true">// check</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&&</span> head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>val <span class="token operator">!=</span> head<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">resverList</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode cur <span class="token operator">=</span> node<span class="token punctuation">;</span>
    ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
    ListNode next <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这题就用到了上面的翻转链表的方法，不过这里只翻转了一半，翻转了后半段然后从两边到中间逐个节点对比</p>
<hr>
<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><strong>237. 删除链表中的节点</strong></h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/9MUvMzlcAN0G.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> head = [4,5,1,9], node = 5<br><strong>输出:</strong> [4,1,9]<br><strong>解释:</strong> 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> head = [4,5,1,9], node = 1<br><strong>输出:</strong> [4,5,9]<br><strong>解释:</strong> 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.</p>
<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<p><strong>二货做法</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deleteNodelow</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//思路就是和node后面的元素一直交换，就像冒泡排序一样</span>
    ListNode next<span class="token punctuation">;</span>
    ListNode temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode pre<span class="token operator">=</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        next<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            pre<span class="token operator">=</span>node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//先保存最后一个节点前的节点</span>
        <span class="token comment" spellcheck="true">//交换当前节点和后一个节点</span>
        temp<span class="token punctuation">.</span>val<span class="token operator">=</span>node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>val<span class="token operator">=</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        next<span class="token punctuation">.</span>val<span class="token operator">=</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        node<span class="token operator">=</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pre<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>首先想到的愚蠢的做法,怎么这么蠢？？？？</p>
<p><strong>正确做法</strong></p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>val<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<hr>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><strong>203. 移除链表元素</strong></h2><p>删除链表中等于给定值 <strong>_val _</strong>的所有节点。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1->2->6->3->4->5->6, <em><strong>val</strong></em> = 6<br><strong>输出:</strong> 1->2->3->4->5</p>
<p><strong>解法一：</strong><br>双指针 + 虚拟头节点</p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        ListNode dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//再头接待你之前加了新的节点</span>
        dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
        ListNode pre <span class="token operator">=</span> dummyHead<span class="token punctuation">,</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//不是相等的值就向后移动</span>
                pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p><strong>解法二：</strong></p>
<p>递归方法比较简洁</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">removeElements2</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span>
       <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//将下一个元素放进递归如果是==val的就会把下一个的下一个元素返回连接到当前元素</span>
    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">removeElements2</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val <span class="token operator">?</span> head<span class="token punctuation">.</span>next <span class="token operator">:</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><strong>19. 删除链表的倒数第N个节点</strong></h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1->2->3->4->5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1->2->3->5.<br>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>你能尝试使用一趟扫描实现吗？</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">&&</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//双指针 主要是头和尾的删除需要抠一下边界</span>
    <span class="token comment" spellcheck="true">//  -1 | 1 2 3 4 5 6</span>
    ListNode fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode slow<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//加了哑节点，直接先加1</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow<span class="token operator">=</span>count<span class="token operator"><</span>n<span class="token operator">?</span>slow<span class="token operator">:</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//slow到达需要删除的位置的前一个</span>
            slow<span class="token punctuation">.</span>next<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>看了评论才知道咋一遍循环，主要就是控制slow指针走<code>length-n</code>步，让快指针先走n步，然后快慢一起走，快指针到头时慢指针就到<code>length-n</code>的位置了，这题也可以用List保存每个节点让然后把待删除的节点的前一个拿出来操作，遍历两遍的方法比较简单就不写了，感觉这种方法比较好 , 这题的OJ case比较少所以没什么可比性 , 前几个都是跑了两遍的，我把最快的拷过来跑的比我还慢。。。。然后我又提交了一次 beat 90%…….</p>
<hr>
<h2 id="82-删除链表中的重复元素Ⅱ"><a href="#82-删除链表中的重复元素Ⅱ" class="headerlink" title="82. 删除链表中的重复元素Ⅱ"></a><strong>82. 删除链表中的重复元素Ⅱ</strong></h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 _没有重复出现 _的数字。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> 1->2->3->3->4->4->5<br><strong>输出:</strong> 1->2->5</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> 1->1->1->2->3<br><strong>输出:</strong> 2->3</p>
<blockquote>
<p>乍一看跟上面那一题一样？这题是排序链表上面那题是无序的，而且这题不给定元素</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">static</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//首先想到的思路是3指针，然后遍历的过程中后面的指针遇到==val的情况就让后面的指针一直后移走到！=val</span>
    <span class="token comment" spellcheck="true">//先添加个哑节点</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode cur<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode next<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode pre<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>val<span class="token operator">==</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            next<span class="token operator">=</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                pre<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
                <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>val<span class="token operator">!=</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
                pre<span class="token punctuation">.</span>next<span class="token operator">=</span>next<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//cur跟上</span>
                cur<span class="token operator">=</span>next<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//关键就是pre移动这里有坑 不能直接将pre移到cur,因为会有连续的连续存在</span>
        pre<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token operator">&&</span>cur<span class="token punctuation">.</span>val<span class="token operator">==</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">?</span>pre<span class="token operator">:</span>cur<span class="token punctuation">;</span>
        cur<span class="token operator">=</span>next<span class="token punctuation">;</span>
        next<span class="token operator">=</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>整体来说还是挺简单的只跑了一趟 1ms beta98%，评论里面大都只用了两个指针我用了三个这样感觉比较清晰<br>怎么好理解怎么来。貌似最快的是一个递归的，递归写起来确实玄学还要多练练啊</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&&</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&&</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>这题还有个简单版的那个删除后会留下一个，那样向我上面这样写pre的跳转就会更简单一点，这里就不写了</p>
<hr>
<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><strong>143. <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">重排链表</a></strong></h2><p>给定一个单链表 <em>L</em>：L0→L1→…→Ln-1→Ln<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例 1:</strong></p>
<p>给定链表 1->2->3->4, 重新排列为 1->4->2->3.</p>
<p><strong>示例 2:</strong></p>
<p>给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.</p>
<blockquote>
<p>这题和上面的回文链表有点类似，都是快慢指针不过这题稍微复杂点</p>
</blockquote>
<p><strong>解法一</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode right <span class="token operator">=</span> head<span class="token punctuation">;</span>
    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 1 1 1 1 1 1 1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        right <span class="token operator">=</span> right<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">?</span> right<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">:</span> right<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 从slow开始翻转</span>
    <span class="token function">res</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//左半部分</span>
    ListNode left <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//下一个节点</span>
    ListNode rnext <span class="token operator">=</span> right<span class="token punctuation">;</span>
    ListNode lnext <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 1 2 3 4 5 6 7 8 </span>
    <span class="token comment" spellcheck="true">// 1 8 2 7 3 6 4 5</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> null <span class="token operator">&&</span> left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 要保存right的下一个节点 , left也需要,不然无法导航到下一个节点</span>
        lnext <span class="token operator">=</span> lnext<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        rnext <span class="token operator">=</span> rnext<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 偶数个数节点,如果遍历到right链表的最后一个节点</span>
        <span class="token comment" spellcheck="true">// 偶数的话right链表会短一点 最后连接的时候</span>
        <span class="token comment" spellcheck="true">// left: 1->2->3->4->5 right: 8->7->6->5   </span>
        <span class="token comment" spellcheck="true">// 像这样会将5加到left的4和5之间,但是明显只有一个5这样添加就是有问题的</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//所以这里吧lnext赋值为null,后面就不会重复连接5这个节点</span>
            lnext<span class="token operator">=</span>null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//奇数个数的时候这样连接没问题</span>
        <span class="token comment" spellcheck="true">// 1 2 3 4 5 </span>
        <span class="token comment" spellcheck="true">// 9 8 7 6 5</span>
        <span class="token comment" spellcheck="true">//5.next=5</span>
        left<span class="token punctuation">.</span>next <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果奇数个数到最后这一步 right和left是同一个节点都为值是5的节点</span>
        <span class="token comment" spellcheck="true">//所以这里下面的直接覆盖了上面的</span>
        <span class="token comment" spellcheck="true">//5.next=null</span>
        right<span class="token punctuation">.</span>next <span class="token operator">=</span> lnext<span class="token punctuation">;</span>
        left <span class="token operator">=</span> lnext<span class="token punctuation">;</span>
        right <span class="token operator">=</span> rnext<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//反转</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">res</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
    ListNode cur <span class="token operator">=</span> node<span class="token punctuation">;</span>
    ListNode nex <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nex <span class="token operator">=</span> nex<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> nex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>也是之前的代码了，写的比较烂，但是思路还是比较清晰的，边界需要注意，速度还行 4ms  77% 。</p>
<hr>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<pre class=" language-java"><code class="language-java">输入： <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span>
输出： <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span></code></pre>
<p><strong>解法一</strong></p>
<p>常规迭代的做法</p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode res<span class="token operator">=</span>temp<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">!=</span>null<span class="token operator">&&</span>l2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l2<span class="token punctuation">.</span>val<span class="token operator"><</span>l1<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
                temp<span class="token punctuation">.</span>next<span class="token operator">=</span>l2<span class="token punctuation">;</span>
                l2<span class="token operator">=</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                temp<span class="token punctuation">.</span>next<span class="token operator">=</span>l1<span class="token punctuation">;</span>
                l1<span class="token operator">=</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        temp<span class="token punctuation">.</span>next<span class="token operator">=</span>l1<span class="token operator">==</span>null<span class="token operator">?</span>l2<span class="token operator">:</span>l1<span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>归并分治的思想，期末考试的一道题</p>
<p><strong>解法二</strong></p>
<p>递归的做法</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span>l2<span class="token punctuation">,</span>dummyNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">,</span>ListNode res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        res<span class="token punctuation">.</span>next<span class="token operator">=</span>l2<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>l2<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        res<span class="token punctuation">.</span>next<span class="token operator">=</span>l1<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token operator">></span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
        res<span class="token punctuation">.</span>next<span class="token operator">=</span>l2<span class="token punctuation">;</span>
        <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">,</span>res<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        res<span class="token punctuation">.</span>next<span class="token operator">=</span>l1<span class="token punctuation">;</span>
        <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span>l2<span class="token punctuation">,</span>res<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>上面是我一开始自己写的，一点也不<em>递归</em> </p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l2<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token operator"><</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
        l1<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        l2<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这种看着就很简洁</p>
<hr>
<h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><strong>示例:</strong></p>
<pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span>
<span class="token punctuation">[</span>
  <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span>
<span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span></code></pre>
<p><strong>解法一：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeKLists</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> null<span class="token punctuation">;</span>
    ListNode temp<span class="token operator">=</span>lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator"><</span>lists<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        temp<span class="token operator">=</span><span class="token function">merge2List</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span>lists<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">merge2List</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span>ListNode headB<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode res<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    ListNode tempA<span class="token operator">=</span>headA<span class="token punctuation">;</span>
    ListNode tempB<span class="token operator">=</span>headB<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>tempB<span class="token operator">!=</span>null<span class="token operator">&&</span>tempA<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>tempB<span class="token punctuation">.</span>val<span class="token operator">></span>tempA<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            res<span class="token punctuation">.</span>next<span class="token operator">=</span>tempA<span class="token punctuation">;</span>
            tempA<span class="token operator">=</span>tempA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
            res<span class="token punctuation">.</span>next<span class="token operator">=</span>tempB<span class="token punctuation">;</span>
            tempB<span class="token operator">=</span>tempB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        res<span class="token operator">=</span>res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">.</span>next<span class="token operator">=</span>tempA<span class="token operator">==</span>null<span class="token operator">?</span>tempB<span class="token operator">:</span>tempA<span class="token punctuation">;</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>最先想到的方法，和前面的二路归并一样，把前两个归并的结果和后面的继续归并。速度太慢了200ms左右…..时间复杂度是<code>O(N^2)</code>.<br><strong>解法二：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeKLists2</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">divide</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>lists<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">divide</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>right<span class="token punctuation">)</span><span class="token keyword">return</span> lists<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode l <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode r <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">merge2List</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">merge2List</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span>ListNode headB<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>headA<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> headB<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>headB<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> headA<span class="token punctuation">;</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode res<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    ListNode tempA<span class="token operator">=</span>headA<span class="token punctuation">;</span>
    ListNode tempB<span class="token operator">=</span>headB<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>tempB<span class="token operator">!=</span>null<span class="token operator">&&</span>tempA<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>tempB<span class="token punctuation">.</span>val<span class="token operator">></span>tempA<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            res<span class="token punctuation">.</span>next<span class="token operator">=</span>tempA<span class="token punctuation">;</span>
            tempA<span class="token operator">=</span>tempA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
            res<span class="token punctuation">.</span>next<span class="token operator">=</span>tempB<span class="token punctuation">;</span>
            tempB<span class="token operator">=</span>tempB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        res<span class="token operator">=</span>res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">.</span>next<span class="token operator">=</span>tempA<span class="token operator">==</span>null<span class="token operator">?</span>tempB<span class="token operator">:</span>tempA<span class="token punctuation">;</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>看起来很眼熟？没错就是归并排序的思路，利用分治的思想，先归并左边，再归并右边，然后merge左右的结果，时间复杂度为<code>O(NlogK)</code> (递归树深度为logK，归并每一层时间复杂度都是N)， 10ms左右，N是所有链表的元素个数，K是链表个数。而且因为是链表空间复杂度也不高。另外这题也可以改成非递归的方式如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeKLists3</span><span class="token punctuation">(</span>ListNode <span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> lists<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//两两合并将结果保存在前半部分的节点中然后缩小一半的范围</span>
            lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">merge2Lists</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> lists<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//缩小一半的范围</span>
        k <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>解法三：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//小根堆的方法</span>
<span class="token keyword">public</span> ListNode <span class="token function">mergeKLists4</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//利用一个按节点值最小次序排列的优先队列, 每次取最小的节点加入返回链表中</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator"><</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    Queue<span class="token operator"><</span>ListNode<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator"><</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>val <span class="token operator">-</span> b<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode p <span class="token operator">:</span> lists<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span>
        pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">//讲当前节点后一个节点加入队列</span>
        pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>利用了小根堆，Java里面有小根堆可以直接用，思路就是每次把每条链表的头元素都放进小根堆里面然后找出最小的加到新链表中然后，最小的那个节点的链表向后移再加到小根堆里面，方法还是相当简洁的。但是用了90ms左右比较慢，时间复杂度O(NlogK)和上面是一样的，每次调整时间复杂度都是logk，需要调整N次</p>
<hr>
<h2 id="430-扁平化多级双向链表"><a href="#430-扁平化多级双向链表" class="headerlink" title="430. 扁平化多级双向链表"></a>430. 扁平化多级双向链表</h2><p>您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong><br> 1—2—3—4—5—6–NULL<br>         |<br>         7—8—9—10–NULL<br>             |<br>             11–12–NULL</p>
<p><strong>输出:</strong><br>1-2-3-7-8-11-12-9-10-4-5-6-NULL<br><strong>以上示例的说明:</strong></p>
<p>给出以下多级双向链表:</p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/DqC2qKF5h63V.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p>我们应该返回如下所示的扁平双向链表:</p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/qOSn0TLmMuCt.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>解法一：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
        这种解法思路还是比较清晰的
        每次有子链的时候就直接把子链遍历到尾 然后添加到链表中形成新主链 把子链的入口节点child指定为null
        然后主链继续向后遍历所以整个遍历的次数就是整个链表元素的个数 O(M)
*/</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> Node <span class="token function">flatten1</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token operator">&&</span>head<span class="token punctuation">.</span>child<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Node cur<span class="token operator">=</span>head<span class="token punctuation">;</span>
    Node nNext<span class="token punctuation">;</span>
    Node child<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//有子链表</span>
            child<span class="token operator">=</span>cur<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//子链表的表头</span>
            nNext<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//主链的下一节点</span>
            <span class="token comment" spellcheck="true">//连接子链表</span>
            cur<span class="token punctuation">.</span>next<span class="token operator">=</span>child<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//主链的下一节点为子链表头</span>
            child<span class="token punctuation">.</span>prev<span class="token operator">=</span>cur<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//子链表的前驱节点</span>
            <span class="token comment" spellcheck="true">//已经拼接到主链，孩子链置为空 （这步还很关键我开始一直忘设置为null）</span>
            cur<span class="token punctuation">.</span>child<span class="token operator">=</span>null<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nNext<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//遍历到主链最后一个了</span>
                <span class="token comment" spellcheck="true">//所以没有下一个节点，后面的步骤不用继续但是也不能Break 因为最后一个节点有可能还有子链表</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//找到新主链的下一节点 (子链的最后一个)</span>
                child<span class="token operator">=</span>child<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//连接以前的主链</span>
            child<span class="token punctuation">.</span>next<span class="token operator">=</span>nNext<span class="token punctuation">;</span>
            nNext<span class="token punctuation">.</span>prev<span class="token operator">=</span>child<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//主链表向后移动</span>
        cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>解法二：</strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//标准的DFS</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Node <span class="token function">flatten2</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Node head <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//我感觉这样会快一些</span>
             Node next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//子链表扁平化 返回头节点</span>
                Node nextLayer <span class="token operator">=</span> <span class="token function">flatten2</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//子链表的头节点</span>
                <span class="token comment" spellcheck="true">//连接子链表头和主链</span>
                head<span class="token punctuation">.</span>next <span class="token operator">=</span> nextLayer<span class="token punctuation">;</span>
                nextLayer<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//然后子链表置为null</span>
                head<span class="token punctuation">.</span>child <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//遍历到子链表的结尾</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>nextLayer<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    nextLayer <span class="token operator">=</span> nextLayer<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment" spellcheck="true">//连接子链表的尾部</span>
                nextLayer<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    next<span class="token punctuation">.</span>prev <span class="token operator">=</span> nextLayer<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//这里就直接跳过子链表 之前的是head=head.next; 但是因为之前的子链表已经加到主链表中所以会浪费一些时间（子链表肯定是已经扁平化的肯定都没有子链表）</span>
            head <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>两种方法都是看的评论里面的第二种我稍微改了下，直接跳过子链表效率会高很多，不过这题case也比较少看不出差异。</p>
<hr>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><strong>141. 环形链表</strong></h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>head = [3,2,0,-4], pos = 1<br><strong>输出：</strong>true<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/H2wmyaG9uoiz.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>示例 2：</strong><br><strong>输入：</strong> head = [1,2], pos = 0<br><strong>输出：</strong> true<br><strong>解释：</strong> 链表中有一个环，其尾部连接到第一个节点。</p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/UqIc2XWwtxbo.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> head = [1], pos = -1<br><strong>输出：</strong> false<br><strong>解释：</strong> 链表中没有环。</p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190303/dAg8QrxqJJga.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>进阶：</strong></p>
<p>你能用 _O(1)_（即，常量）内存解决此问题吗？</p>
<p><strong>有一点需要注意的是只有一个节点的情况应该是不考虑的直接 false 。</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>
                  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//快慢指针 相遇的时候快指针回到头部step改为1 再次相遇的时候就是环的pos</span>
    <span class="token comment" spellcheck="true">//这题只是判断有没有环所以只要相遇就有环</span>
    ListNode slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>slow<span class="token operator">!=</span>fast<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//有环是不会走到尽头的</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">==</span>null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h2 id="141-环形链表Ⅱ"><a href="#141-环形链表Ⅱ" class="headerlink" title="141. 环形链表Ⅱ"></a>141. 环形链表Ⅱ</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>说明：</strong> 不允许修改给定的链表。 ps:上题的基础上返回入环的第一个节点</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
    Boolean isMeet<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//快指针没有到尽头</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>null<span class="token operator">&&</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        fast<span class="token operator">=</span>isMeet<span class="token operator">?</span>fast<span class="token punctuation">.</span>next<span class="token operator">:</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>slow<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isMeet<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//第一次相遇</span>
                <span class="token comment" spellcheck="true">//我这种写法开始没考虑到这种情况,入环节点就是头节点就不能继续走了</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
                fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
                isMeet<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> fast<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>这种解法还是挺有意思的<code>快慢指针</code>，快指针一次走两步慢指针一次走一步在环上相遇的时候快指针回到头节点步数调整为1，再>次相遇的>时候（这里有可能重合，当头节点就是入环节点的时候）就是入环节点。<br>原理 :<br>A—->B—->C      分别为<code>头节点</code>，<code>入环节点</code>，<code>第一次相遇的节点</code><br>分析第一次相遇时快慢指针走过的路径可得<br>AB+BC+CB+BC=2(AB+BC)  快指针走过的路程肯定是慢指针的两倍<br>化简最后就得到AB=CB 所以他们<code>再次相遇</code>就是入环的节点</p>
</blockquote>
<hr>
<h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><strong>61. <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">旋转链表</a></strong></h2><p>给定一个链表，旋转链表，将链表每个节点向右移动  <em>k</em>个位置，其中 <em>k</em>是非负数。</p>
<p><strong>示例 1:</strong></p>
<pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span>
输出<span class="token operator">:</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span>NULL
解释<span class="token operator">:</span>
向右旋转 <span class="token number">1</span> 步<span class="token operator">:</span> <span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span>NULL
向右旋转 <span class="token number">2</span> 步<span class="token operator">:</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre>
<p><strong>示例 2:</strong></p>
<pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span> <span class="token number">0</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span>NULL<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">4</span>
输出<span class="token operator">:</span> <span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">0</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span>NULL
解释<span class="token operator">:</span>
向右旋转 <span class="token number">1</span> 步<span class="token operator">:</span> <span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">0</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span>NULL
向右旋转 <span class="token number">2</span> 步<span class="token operator">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">0</span><span class="token operator">-</span><span class="token operator">></span>NULL
向右旋转 <span class="token number">3</span> 步<span class="token operator">:</span> <span class="token number">0</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span>NULL
向右旋转 <span class="token number">4</span> 步<span class="token operator">:</span> <span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">0</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre>
<p><strong>解法一</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">rotateRight</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//先获取下链表的长度，顺便记录tail的值</span>
    ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode tail<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        length<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            tail<span class="token operator">=</span>temp<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//将K化简</span>
    k<span class="token operator">=</span>k<span class="token operator">%</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//然后再遍历一遍链表在 length-k 的地方断开</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token punctuation">(</span>length<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            tail<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
            head<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            temp<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
            <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>虽然难度是mid，但是感觉这题还是比较简单，我看见有一种比较好点的方法是在第一遍循环完之后将链表转换为<code>双向链表</code>然后再移动还是比较有意思的</p>
<hr>
<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><strong>328. 奇偶链表</strong></h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> <code>1->2->3->4->5->NULL</code><br><strong>输出:</strong> <code>1->3->5->2->4->NULL</code></p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> <code>2->1->3->5->6->4->7->NULL</code><br><strong>输出:</strong> <code>2->3->6->7->1->5->4->NULL</code></p>
<p><strong>说明:</strong></p>
<ul>
<li>应当保持奇数节点和偶数节点的相对顺序。</li>
<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//奇偶链表</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">oddEvenList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 1 2 3 4 5 6 7</span>
    <span class="token comment" spellcheck="true">// 1 2 3 4 5 6</span>
    ListNode pOdd<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode pEven<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode temp<span class="token operator">=</span>pEven<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pEven<span class="token operator">!=</span>null<span class="token operator">&&</span>pEven<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        pOdd<span class="token punctuation">.</span>next<span class="token operator">=</span>pEven<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//奇数先走</span>
        pOdd<span class="token operator">=</span>pOdd<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        pEven<span class="token punctuation">.</span>next<span class="token operator">=</span>pOdd<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        pEven<span class="token operator">=</span>pEven<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pOdd<span class="token punctuation">.</span>next<span class="token operator">=</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>很像踩石头过河的游戏，一道很简单的mid，不知道为啥一开始抠了半天的边界。。。果然<br>还是不熟悉啊。Add oil ! ! ! 👍👍👍👍👍</p>
</blockquote>
<hr>
<h2 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a><strong>147. 对链表进行插入排序</strong></h2><p>插入排序的动画演示如上篇文章。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。<br>插入排序算法：<br>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>重复直到所有输入数据插入完为止。<br>示例 1：<br>输入: 4->2->1->3<br>输出: 1->2->3->4<br>示例 2：<br>输入: -1->5->3->4->0<br>输出: -1->0->3->4->5</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//beat 50%</span>
<span class="token keyword">public</span> <span class="token keyword">static</span>  ListNode <span class="token function">insertionSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哑节点</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dummyNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode tempNode<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//外循环内的指针</span>
    ListNode loopVariable<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode loopPre<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//内循环的指针</span>
    ListNode tempPre<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>loopVariable<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//头插法</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>tempNode<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>tempNode<span class="token operator">!=</span>loopVariable<span class="token punctuation">;</span>tempNode<span class="token operator">=</span>tempNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>val<span class="token operator">></span>loopVariable<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//System.out.println(loopVariable.val);</span>
                <span class="token comment" spellcheck="true">//printList(dummyNode.next);</span>
                <span class="token comment" spellcheck="true">//先处理好loopVariable的前后节点</span>
                loopPre<span class="token punctuation">.</span>next<span class="token operator">=</span>loopVariable<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//再处理tempNode前后的节点</span>
                loopVariable<span class="token punctuation">.</span>next<span class="token operator">=</span>tempNode<span class="token punctuation">;</span>
                tempPre<span class="token punctuation">.</span>next<span class="token operator">=</span>loopVariable<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//loopVariable 归位</span>
                loopVariable<span class="token operator">=</span>loopPre<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            tempPre<span class="token operator">=</span>tempNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        loopPre<span class="token operator">=</span>loopVariable<span class="token punctuation">;</span>
        loopVariable<span class="token operator">=</span>loopVariable<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的是我开始自己写的，但是提交后发现速度有点慢40ms 50%左右 然后我有点不信把比较靠前的拷了一个 10ms😂前几名10ms以内的都是用的方法不是插入….<br>在研究别人10ms的代码时突然意识到了问题所在 我在进行插入的时候没有判断就时没有关心是不是应该进行插入操作，对于数组的插入排序是不用关心这个问题的，因为是反向遍历的 而这里是链表只能正向的遍历如果不判断就会浪费很多时间</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 16ms  beat  70% 开始少写了一个if判断</span>
<span class="token keyword">public</span> <span class="token keyword">static</span>  ListNode <span class="token function">insertionSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哑节点</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dummyNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode tempNode<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//外循环内的指针</span>
    ListNode loopVariable<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode loopPre<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//内循环的指针</span>
    ListNode tempPre<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>loopVariable<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//头插法</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>loopVariable<span class="token punctuation">.</span>val<span class="token operator"><</span>loopPre<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>tempNode<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>tempNode<span class="token operator">!=</span>loopVariable<span class="token punctuation">;</span>tempNode<span class="token operator">=</span>tempNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>val<span class="token operator">></span>loopVariable<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">//System.out.println(loopVariable.val);</span>
                    <span class="token comment" spellcheck="true">//printList(dummyNode.next);</span>
                    <span class="token comment" spellcheck="true">//先处理好loopVariable的前后节点</span>
                    loopPre<span class="token punctuation">.</span>next<span class="token operator">=</span>loopVariable<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">//再处理tempNode前后的节点</span>
                    loopVariable<span class="token punctuation">.</span>next<span class="token operator">=</span>tempNode<span class="token punctuation">;</span>
                    tempPre<span class="token punctuation">.</span>next<span class="token operator">=</span>loopVariable<span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">//loopVariable 归位</span>
                    loopVariable<span class="token operator">=</span>loopPre<span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                tempPre<span class="token operator">=</span>tempNode<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        loopPre<span class="token operator">=</span>loopVariable<span class="token punctuation">;</span>
        loopVariable<span class="token operator">=</span>loopVariable<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这题整体思路就是按照插入排序的思路来的，值得注意的就是链表只能正向遍历，而且需要考虑保存的节点有两个，插入位置的前一个，以及待插入的前一个(头插法)。</p>
<hr>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><font color="red" size="5" face="黑体">148. 排序链表</font></h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<p>输入: 4->2->1->3<br>输出: 1->2->3->4<br>示例 2:</p>
<p>输入: -1->5->3->4->0<br>输出: -1->0->3->4->5</p>
<blockquote>
<p>上面那题时间复杂度明显是O(n2)最坏，这题要求是O(nlogn)和常数空间上面的插入肯定不适合了</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//归并排法</span>
<span class="token keyword">public</span> <span class="token keyword">static</span>  ListNode <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">mergeSort</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode fast<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode pre<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>null<span class="token operator">&&</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        pre<span class="token operator">=</span>slow<span class="token punctuation">;</span>
        fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pre<span class="token punctuation">.</span>next<span class="token operator">=</span>null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这里要注意断开两条链表不然后面不方便找中点</span>
    ListNode left <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//归并左边</span>
    ListNode right <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//归并右边</span>
    <span class="token keyword">return</span> <span class="token function">merge2list</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//返回 左右两条链表归并结果</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">merge2list</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span>ListNode headB<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>headA<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> headB<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>headB<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> headA<span class="token punctuation">;</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>headA<span class="token punctuation">;</span>
    ListNode temp<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>headA<span class="token operator">!=</span>null<span class="token operator">&&</span>headB<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>headA<span class="token punctuation">.</span>val<span class="token operator">></span>headB<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            temp<span class="token punctuation">.</span>next<span class="token operator">=</span>headB<span class="token punctuation">;</span>
            headB<span class="token operator">=</span>headB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
            temp<span class="token punctuation">.</span>next<span class="token operator">=</span>headA<span class="token punctuation">;</span>
            headA<span class="token operator">=</span>headA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    temp<span class="token punctuation">.</span>next<span class="token operator">=</span>headA<span class="token operator">==</span>null<span class="token operator">?</span>headB<span class="token operator">:</span>headA<span class="token punctuation">;</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>​        4ms 85%  标准的<code>归并操作</code><em>分治</em>的思想，但是我还是扣了好长时间，最后还是看了别人的代码才知道，其实一开始就想到了<code>快慢指针找中点</code>但是感觉时间复杂度可能会变得更高就没那样做。。。还是太菜了时间复杂度都不会分析。。。这里有一个小地方就是找到中点之后要记得断开中点和后面链表的连接，这样会方便后面归并，不然就需要传递一个边界的指针那样又会有很多问题（没错我开始就是这么做的😭）</p>
<p>   下面这种是后来又写的<code>经典快排</code>，400ms，12% 我都怀疑我到底写了个啥？后来把插入拿来试了下884+ms然后又看了一遍才相信我写的是快排。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//我自己写的快排</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">sortList4</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//快排实现</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span>ListNode tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tail<span class="token operator">==</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//确定枢纽元素</span>
    ListNode base<span class="token operator">=</span><span class="token function">partion</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sortList</span><span class="token punctuation">(</span>base<span class="token punctuation">.</span>next<span class="token punctuation">,</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//看了下别人的博客也学到了一种快排的新思路</span>
<span class="token comment" spellcheck="true">//慢指针左边都是小于base枢纽元素的，快指针和慢指针中间都是大于等于base枢纽元素的</span>
<span class="token comment" spellcheck="true">//慢指针后面的都是未知区域</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">partion</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span>ListNode tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ListNode base<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 3  1  3  2  5  -1 0</span>
    <span class="token comment" spellcheck="true">//    s  f</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>val<span class="token operator"><=</span>base<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//交换两个节点的值</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>fast<span class="token punctuation">,</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//归位</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//应该可以试试返回区间</span>
    <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>ListNode a<span class="token punctuation">,</span>ListNode b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token operator">=</span>a<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span>val<span class="token operator">=</span>b<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    b<span class="token punctuation">.</span>val<span class="token operator">=</span>temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>实际上快排确实不适合链表（下面光速打脸）因为毕竟不是数组可以从两边开始遍历，链表每次都需要遍历整个链表才能划分好基准位置。</p>
</blockquote>
<p>看了下前几的代码发现了这个，<code>非标准的三向切分的快排</code>，为啥说是非标准呢？看下面代码就知道了，我给加了注释</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">sortList3</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>ListNode from<span class="token punctuation">,</span> ListNode to<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>from <span class="token operator">==</span> null <span class="token operator">||</span> from <span class="token operator">==</span> to <span class="token operator">||</span> from<span class="token punctuation">.</span>next <span class="token operator">==</span> to <span class="token operator">||</span> from<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span> to<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> v <span class="token operator">=</span> from<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//基准元素</span>
    ListNode mid <span class="token operator">=</span> from<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//切分点指针</span>
    ListNode equal <span class="token operator">=</span> from<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//等于区域右边界</span>
    ListNode node <span class="token operator">=</span> from<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//遍历用的指针</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//node不到头  左开右开区间（from,to）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator"><</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//小于基准位置元素</span>
            <span class="token comment" spellcheck="true">//保存当前节点的下一个元素，用于插入节点</span>
            <span class="token comment" spellcheck="true">//小于基准元素的节点</span>
            ListNode currentNext <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//保存切分点的下一个元素，作用同上</span>
            ListNode midNext <span class="token operator">=</span> mid<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//交换node.next和mid</span>
            <span class="token comment" spellcheck="true">//纸上画一下就了解了</span>
            mid<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> midNext<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNext<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//切分点后移</span>
            mid <span class="token operator">=</span> mid<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//node的下一个等于基准元素</span>
            <span class="token comment" spellcheck="true">//3 1 2 3 4 5 6</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>equal <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//等于区域和node.next==val相邻了，直接跳过</span>
                equal <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//将node.next插入equal后面</span>
                <span class="token comment" spellcheck="true">//然后equal向后移动</span>
                <span class="token comment" spellcheck="true">//和上面的类似</span>
                ListNode nodeNext <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                ListNode equalNext <span class="token operator">=</span> equal<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                equal<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> equalNext<span class="token punctuation">;</span>
                node<span class="token punctuation">.</span>next <span class="token operator">=</span> nodeNext<span class="token punctuation">;</span>
                equal <span class="token operator">=</span> equal<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//大于直接跳过</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// [mid.next---equal] 为等于val的节点</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> mid<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>equal<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>整体思路就是一共有三个指针，<code>mid</code>(切分点)  <code>equal</code>(等于区) <code>node</code>(遍历指针) node从from遍历到to，注意这里是<code>左开右开区间</code> 就是说头from和尾to都取不到，然后将小与base的节点插入到mid的后面，然后mid后移，等于区插入到equal的后面，最后形成的就是<code>[mid.next---equal]</code> 为等于val的节点，然后对子区域递归就ok了，这个用时 <code>4ms</code> 。。。。。。还要继续加油啊！！！</p>
<hr>
<h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138.复制带随机指针的链表"></a><font color="red" size="5" face="黑体">138.复制带随机指针的链表</font></h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的深拷贝。<br>示例：<br><img alt="mark" data-src="http://static.imlgw.top///20190308/tR8e3eu2yqaq.png?imageslim" src="/img/loading.gif" class="lazyload"><br>输入：<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}</code><br>解释：<br>节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。<br>节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。</p>
<p>提示：<br>你必须返回给定头的拷贝作为对克隆列表的引用。</p>
<p><strong>解法一：</strong> 利用Map</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Node <span class="token function">copyRandomList</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator"><</span>Node<span class="token punctuation">,</span>Node<span class="token operator">></span> copNode <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator"><</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Node temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//建立对应关系</span>
        copNode<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//再循环一次复制next和Radom节点</span>
    temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        copNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token operator">=</span>copNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        copNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">.</span>random<span class="token operator">=</span>copNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>random<span class="token punctuation">)</span><span class="token punctuation">;</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> copNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>第一个循环利用Map将原链表和拷贝链表形成对应关系，第二个循环就是直接给拷贝链表的next域和random域赋值。</p>
<p><strong>解法二：</strong><code>奥义 影分身</code></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Node <span class="token function">copyRandomList2</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    Node temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//链表  奥义 - 影分身</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//这里直接将next域传入构造器完成和后面元素的连接</span>
        temp<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">,</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//连接random域</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>random<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>random<span class="token operator">=</span>temp<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 分离</span>
    Node newHead<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    Node next<span class="token operator">=</span>null<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        next<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            temp<span class="token punctuation">.</span>next<span class="token operator">=</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        temp<span class="token operator">=</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>为啥要叫影分身？因为帅…这种方法比上面的要快一点可能是创建hashMap比较耗时间，其实分析这两种方法其实都是先把链表拷贝了一份，然后通过对应关系来连接拷贝链表的next和random域，map是通过键值对的方式对应拷贝链表，这样可以方便的通过原链表找到拷贝链表的random. 然后上面这种方法也是一样，在原链表每个节点后面copy一个节点，然后根据前一个节点的random来找拷贝节点的random(前一个节点的random的next) 主要就是找到一个对应关系.</p>
<blockquote>
<p>tips: 这题OJ上的0ms是有问题的，这题本意肯定也不是这个</p>
<p><img alt="mark" data-src="http://static.imlgw.top///20190308/p1GPgJVYaURp.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
</blockquote>
<p>最开始能通过主要是OJ后台只判断了val的值，可以看出现在题目已经改了。现在肯定是跑不过的，可能是判断了random是不是new出来的(我试了下看了下返回这个)<br>输入<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}</code><br>输出<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":</code></p>
<p><code>{"$id":"3","next":null,"random":null,"val":2},"val":2},</code></p>
<p><code>"random":{"$id":"4","next":null,"random":null,"val":2},"val":1}</code><br>预期结果<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}</code></p>
<hr>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><strong>24. <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></strong></h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例:</strong></p>
<p>给定 1->2->3->4, 你应该返回 2->1->4->3.</p>
<p><strong>解法一</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode nex<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    ListNode cur<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode pre<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// -1|1 2 3 4</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>nex<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        pre<span class="token punctuation">.</span>next<span class="token operator">=</span>nex<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next<span class="token operator">=</span>nex<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        nex<span class="token punctuation">.</span>next<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        nex<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>其实跟反转链表是一样的，三个指针分别记录前 中 后三个节点然后逆序，只不过步长不一样，这里step为2，一次走两步， 我上面的代码可能写的有些乱，思路还是一样的</p>
<p><strong>解法二</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归版本</span>
<span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode next<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    head<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    next<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">return</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>递归是真的简洁，我最开始写反转链表的递归就是这么写的😂</p>
<hr>
<h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a><font color="red" size="5" face="黑体">25.K个一组翻转链表</font></h2><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p>
<p><strong>示例 :</strong></p>
<pre class=" language-java"><code class="language-java">给定这个链表：<span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span>
当 k <span class="token operator">=</span> <span class="token number">2</span> 时，应当返回<span class="token operator">:</span> <span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span>
当 k <span class="token operator">=</span> <span class="token number">3</span> 时，应当返回<span class="token operator">:</span> <span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span></code></pre>
<p><strong>说明 :</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li>
</ul>
<p><strong>解法一</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//非递归，理一下思路： 记录每次翻转前后的节点 然后翻转返回头 将每 K 个元素当成一个整体</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>
    ListNode dummyNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyNode<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode pre<span class="token operator">=</span>dummyNode<span class="token punctuation">;</span>
    ListNode cur<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode next<span class="token operator">=</span>head<span class="token punctuation">;</span>
    ListNode temp<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//temp 保存 cur 方便后面连接  K+1位置的元素</span>
        temp<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//k 个一组翻转</span>
        <span class="token keyword">int</span> step<span class="token operator">=</span>k<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>step<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&&</span> next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//next走到 K+1 位置节点</span>
            next<span class="token operator">=</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            step<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//小细节 k>链表长度时应该直接返回（我认为）等下提交了看看</span>
            <span class="token comment" spellcheck="true">//所以直接应该直接返回 (掉了k的值判断 因为有可能刚好有k个元素)</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token operator">==</span>null<span class="token operator">&&</span> step<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//翻转 cur--next.prev 返回头节点</span>
        <span class="token comment" spellcheck="true">//连接 反转后的头节点</span>
        pre<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token function">reverse</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        temp<span class="token punctuation">.</span>next<span class="token operator">=</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//pre temp向后移动</span>
        pre<span class="token operator">=</span>temp<span class="token punctuation">;</span>
        cur<span class="token operator">=</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// -1| 1 2 3 | 4 5 6 | 7 8</span>
<span class="token comment" spellcheck="true">//翻转链表并返回子链表</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ListNode pre<span class="token operator">=</span>null<span class="token punctuation">;</span>
    ListNode cur<span class="token operator">=</span>node<span class="token punctuation">;</span>
    ListNode next<span class="token operator">=</span>node<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">></span><span class="token number">0</span><span class="token operator">&&</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        next<span class="token operator">=</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>
        pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        cur<span class="token operator">=</span>next<span class="token punctuation">;</span>
        k<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//返回反转后的头节点</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"头"</span><span class="token operator">+</span>pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>7ms 74% 也是我第一道做出来的困难题，<a href="http://imlgw.top/2018/10/31/%E4%B8%80%E9%81%93LeetCode%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/">上一道困难题超时了</a><br>这题虽然说是困难题但是其实也不难，感觉就mid左右的水平，确实比上一题要复杂一点，但是只要思路理清楚其实也挺简单的，下面是我用OneNote画的一张图片。<br>4个指针分别对应 K 链表的 前一个(pre)  K链表的头节点(cur) 没有翻转前的K链表的头节点and<code>翻转后的尾节点(temp)</code>   K链表的后一个节点(next)。然后其实就简单了，写一个翻转链表的函数然后返回头节点(也可以多加一个指针指向<code>翻转前的头节点</code>)，然后就简单了，next指针一次走K步，走到 K+1 位置 同时也是<code>下一次K链表的头节点</code>，而temp则为下一次K链表的pre…然后循环这个过程就行了，其实写成递归会很简洁，但是我是真的不会写递归，太菜了Orz</p>
</blockquote>
<p><img alt="mark" data-src="http://static.imlgw.top///20190312/jl7moiy7PbjH.png?imageslim" src="/img/loading.gif" class="lazyload"></p>
<p><strong>解法二</strong></p>
<p>2020.2.23 时隔多年现在回头重新写了一个递归的写法，还是比较简洁的</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//时隔一年,回头自己写了一个递归的解法</span>
<span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> k<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//预先计算链表的长度</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        sum<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>k<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> remain<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>remain<span class="token operator"><</span>k<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ramain不足k个return </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//正常的翻转操作</span>
    ListNode cur<span class="token operator">=</span>head<span class="token punctuation">,</span>pre<span class="token operator">=</span>null<span class="token punctuation">,</span>last<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span>k<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">--</span> <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        last<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>
        pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>
        cur<span class="token operator">=</span>last<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//下一次从last开始翻转,remain-k</span>
    head<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token function">reverse</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span>k<span class="token punctuation">,</span>remain<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="817-链表组件"><a href="#817-链表组件" class="headerlink" title="817. 链表组件"></a><strong>817. 链表组件</strong></h2><p>给定一个链表（链表结点包含一个整型值）的头结点 head。<br>同时给定列表 G，该列表是上述链表中整型值的一个子集。<br>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。<br>示例 1：<br>输入:<br>head: 0->1->2->3<br>G = [0, 1, 3]<br>输出: 2<br>解释:<br>链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。<br>示例 2：<br>输入:<br>head: 0->1->2->3->4<br>G = [0, 3, 1, 4]<br>输出: 2<br>解释:<br>链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。<br>注意:<br>如果 N 是给定链表 head 的长度，1 <= N <= 10000。<br>链表中每个结点的值所在范围为 [0, N - 1]。<br>1 <= G.length <= 10000<br>G 是链表中所有结点的值的一个子集.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numComponents</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token operator">||</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isInG</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">,</span>G<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token operator">&&</span><span class="token function">isInG</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">,</span>G<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            res<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> res<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token function">isInG</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> G<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator"><</span>G<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>首先想到的方法 91ms 19%….. 有点慢了，然后我稍微改了下。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numComponents2</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    Boolean <span class="token punctuation">[</span><span class="token punctuation">]</span> isInG<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator"><</span>G<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
                isInG<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>temp<span class="token operator">!=</span>null<span class="token punctuation">;</span>temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>isInG<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token operator">&&</span>isInG<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            res<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> res<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>   用了一个数组保存了每个位置的状态速度跟前面的差不多。。。主要问题就是那个数组的创建，这种创建方式用连续的下标来对应连续的链表的每个元素，每次都要遍历G才知道当前位置是不是在G中。</p>
<p>   其实可以直接把当前节点的val作为数组的下标这样既有了对应关系也不用遍历G.可以说是很优秀了，但是实际上这样做是有前提条件的那就是链表中的元素值应该<code>没有负数</code>，还是题做少了啊 Orz。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numComponents3</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    Boolean <span class="token punctuation">[</span><span class="token punctuation">]</span> isInG<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//换一种方式 以node.val作为数组的下标</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>G<span class="token punctuation">)</span><span class="token punctuation">{</span>
        isInG<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>isInG<span class="token punctuation">[</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token operator">&&</span>isInG<span class="token punctuation">[</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            res<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> res<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h2 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><strong>109. 有序链表转换二叉搜索树</strong></h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<pre class=" language-sql"><code class="language-sql">给定的有序链表： <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

一个可能的答案是：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 它可以表示下面这个高度平衡二叉搜索树：

      <span class="token number">0</span>
     <span class="token operator">/</span> \
   <span class="token operator">-</span><span class="token number">3</span>   <span class="token number">9</span>
   <span class="token operator">/</span>   <span class="token operator">/</span>
 <span class="token operator">-</span><span class="token number">10</span>  <span class="token number">5</span></code></pre>
<p>BST不太熟看了下评论写出来的</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">sortedListToBST</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> TreeNode <span class="token function">build</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span>ListNode tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//快慢指针找中点</span>
    ListNode fast<span class="token operator">=</span>head<span class="token punctuation">,</span>slow<span class="token operator">=</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span>tail<span class="token operator">&&</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//左闭右开</span>
        fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//slow为中点或中点后一个</span>
    <span class="token comment" spellcheck="true">//1 2 3 4</span>
    TreeNode root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">build</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">build</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">,</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">1019. 链表中的下一个更大节点</a></h2><p>给出一个以头节点 <code>head</code> 作为第一个节点的链表。链表中的节点分别编号为：<code>node_1, node_2, node_3, ...</code> 。</p>
<p>每个节点都可能有下一个更大值（<em>next larger</em> <strong>value</strong>）：对于 <code>node_i</code>，如果其 <code>next_larger(node_i)</code> 是 <code>node_j.val</code>，那么就有 <code>j > i</code> 且  <code>node_j.val > node_i.val</code>，而 <code>j</code> 是可能的选项中最小的那个。如果不存在这样的 <code>j</code>，那么下一个更大值为 <code>0</code> 。</p>
<p>返回整数答案数组 <code>answer</code>，其中 <code>answer[i] = next_larger(node_{i+1})</code> 。</p>
<p><strong>注意：</strong>在下面的示例中，诸如 <code>[2,1,5]</code> 这样的<strong>输入</strong>（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p>
<p><strong>示例 1：</strong></p>
<pre class=" language-java"><code class="language-java">输入：<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre>
<p><strong>示例 2：</strong></p>
<pre class=" language-java"><code class="language-java">输入：<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre>
<p><strong>示例 3：</strong></p>
<pre class=" language-java"><code class="language-java">输入：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre>
<p><strong>提示：</strong></p>
<ol>
<li>对于链表中的每个节点，<code>1 <= node.val <= 10^9</code></li>
<li>给定列表的长度在 <code>[0, 10000]</code> 范围内</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLargerNodes</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//list里面存元素</span>
    ArrayList<span class="token operator"><</span>Integer<span class="token operator">></span> A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator"><</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode node <span class="token operator">=</span> head<span class="token punctuation">;</span> node <span class="token operator">!=</span> null<span class="token punctuation">;</span> node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
                A<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//栈里面存索引</span>
    Stack<span class="token operator"><</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator"><</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&&</span> A<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator"><</span> A<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
             res<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>新题，磨了好长时间，没做出来。。。真是菜啊 Orz，70ms，因为跑两遍。下面这个<code>14ms</code>可以说是相当快了，但，时间可能耗费在建立栈和list上了，看了下提交上的前几个都是用的数组，用数组模拟的栈。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//和上面的方法差不多,但这个更快，上面那个跑了两遍</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLargerNodes3</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//temp是链表的副本，相当于上面的list</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//top 栈顶</span>
    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ListNode node <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&&</span> temp<span class="token punctuation">[</span>stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator"><</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//后一个大于当前节点, 栈不为空</span>
            <span class="token comment" spellcheck="true">//pop出比它小的元素并赋值res，重新生成单调栈</span>
            res<span class="token punctuation">[</span>stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        temp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>思路就是利用<code>单调栈</code>，栈里面存的索引对应的元素都是单调递减的，遇到不递减的就会一直pop()直到再次单调递减。这样很容易就找到了每个元素的下一个最大元素了。</p>
<p>19.7.21 重新做了一遍这道题，第一遍还是没想出来，还是看了之前的代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLargerNodes5</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator"><</span>Integer<span class="token operator">></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator"><</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> stackIndex<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator"><</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>stackIndex<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&&</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">></span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stack<span class="token punctuation">[</span>stackIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token punctuation">[</span>stack<span class="token punctuation">[</span>stackIndex<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//维护一个递减的栈</span>
            stack<span class="token punctuation">[</span><span class="token operator">++</span>stackIndex<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span>  Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>相比上面的方法一，采用了数组模拟队列(数据范围已经给定了)，30ms，80% 。仔细看看代码发现其实第一个循环完全没有必要，可以一边遍历一边存进去。</p>
<p><strong>一次遍历</strong></p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLargerNodes6</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator"><</span>Integer<span class="token operator">></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator"><</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> stackIndex<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>temp<span class="token operator">!=</span>null<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>stackIndex<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&&</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">></span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stack<span class="token punctuation">[</span>stackIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token punctuation">[</span>stack<span class="token punctuation">[</span>stackIndex<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//维护一个递减的栈</span>
            stack<span class="token punctuation">[</span><span class="token operator">++</span>stackIndex<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span>  Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>优化后发现比之前还慢了。。。</p>
<p><strong>数组模拟链表</strong></p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextLargerNodes7</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        ListNode temp<span class="token operator">=</span>head<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> stackIndex<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>temp<span class="token operator">!=</span>null<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>stackIndex<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&&</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>list<span class="token punctuation">[</span>stack<span class="token punctuation">[</span>stackIndex<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token punctuation">[</span>stack<span class="token punctuation">[</span>stackIndex<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//维护一个递减的栈</span>
            stack<span class="token punctuation">[</span><span class="token operator">++</span>stackIndex<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span>  Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<p>这次提交了几次直接 8ms 100%了。。。</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">imlgw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/">http://imlgw.top/2019/02/27/leetcode-lian-biao/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://imlgw.top">iMlGw0</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode    </a><a class="post-meta__tags" href="/tags/%E9%93%BE%E8%A1%A8/">链表    </a></div><div class="post_share"><div class="social-share" data-image="http://static.imlgw.top///20190227/gPprrxbrdwAx.jpg?imageslim" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.png" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/"><img class="prev_cover lazyload" data-src="http://static.imlgw.top///20190323/oGikrmykzg5w.jpg?imageslim" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Java多线程基础</span></div></a></div><div class="next-post pull_right"><a href="/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/"><img class="next_cover lazyload" data-src="http://static.imlgw.top///20190407/zq6WrSBA0602.png?imageslim" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>常见的排序算法总结</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/10/leetcode-hui-su/" title="LeetCode回溯&递归"><img class="relatedPosts_cover lazyload"data-src="http://static.imlgw.top/blog/20191012/HDV7c2plcAl2.jpg?imageslim"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-27</div><div class="relatedPosts_title">LeetCode回溯&递归</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/14/leetcode-shu-ju-ku/" title="LeetCode数据库"><img class="relatedPosts_cover lazyload"data-src="http://static.imlgw.top/image/featureimages/19.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-27</div><div class="relatedPosts_title">LeetCode数据库</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/06/leetcode-er-fen-cha-zhao/" title="LeetCode二分查找"><img class="relatedPosts_cover lazyload"data-src="http://static.imlgw.top/5.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-27</div><div class="relatedPosts_title">LeetCode二分查找</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'MkcXmeDvktRNBDBrVqb9KYPH-MdYXbMMI',
  appKey:'swDnb5a9u9Ksp2Rwkdm7Qulh',
  placeholder:'留下邮箱才能收到及时收到回复~~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(http://static.imlgw.top///20190227/gPprrxbrdwAx.jpg?imageslim)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By imlgw</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://beian.miit.gov.cn/publish/query/indexFirst.action" target="_blank" rel="noopener"><span>鄂ICP备18011208号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="undefined" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body></html>