
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="数据结构,排序," />
  

  
    <meta name="description" content="大悲无泪，大悟无言，大笑无声。" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/img/cat.ico">
  
  <title>常见的排序算法总结 [ iM1Gw0 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">iM1Gw0</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">分类</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">归档</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">标签</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/music" style="color:#202020;" class="pure-menu-link">音乐</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="算法" class="pure-menu-link">算法</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/05/04/leetcode-shu-zu/" style="color:#202020;" class="pure-menu-link">数组</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/" style="color:#202020;" class="pure-menu-link">链表</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/01/leetcode-zhan-dui-lie/" style="color:#202020;" class="pure-menu-link">栈&amp;队列</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/" style="color:#202020;" class="pure-menu-link">查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou/" style="color:#202020;" class="pure-menu-link">滑动窗口</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/" style="color:#202020;" class="pure-menu-link">动态规划</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/12/06/leetcode-er-fen-cha-zhao/" style="color:#202020;" class="pure-menu-link">二分查找</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu/" style="color:#202020;" class="pure-menu-link">二叉树</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/11/29/leetcode-bei-bao-wen-ti/" style="color:#202020;" class="pure-menu-link">背包问题</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2019/10/10/leetcode-hui-su/" style="color:#202020;" class="pure-menu-link">回溯</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/01/21/leetcode-tan-xin/" style="color:#202020;" class="pure-menu-link">贪心</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/07/03/leetcode-wei-yun-suan/" style="color:#202020;" class="pure-menu-link">位运算</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="http://imlgw.top/2020/08/28/leetcode-dan-diao-zhan/" style="color:#202020;" class="pure-menu-link">单调栈</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">Github</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        常见的排序算法总结
      </h1>
      <span>
        
        <time class="time" datetime="2018-12-10T16:00:00.000Z">
        2018-12-11
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 32 分钟</span>
    </header>

    <div class="post-content">
      <h2 id="常见排序算法总结"><a href="#常见排序算法总结" class="headerlink" title="常见排序算法总结"></a>常见排序算法总结</h2><p>关于排序的部分一直想总结下一直没时间，现在来总结下吧。gif图来自微信上的文章 (<strong>五分钟学算法</strong>的公众号，挺不错干货挺多的)，原理性的东西就不讲了，图讲的比我好。如果还是不懂可以看看《算法》里面的轨迹图，那个也很直观 </p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>  <img src="http://static.imlgw.top/f02ace7b7fb9b810274e683c2be54a02_640_wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1.gif" alt="weixin"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaoPaoSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="http://static.imlgw.top/640.gif" alt="weixin"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min=nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;min)&#123;</span><br><span class="line">                min=nums[j];</span><br><span class="line">                swap(nums,j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><img src="http://static.imlgw.top/640%20%281%29.gif" alt="weixin"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j-<span class="number">1</span>];j--)&#123;</span><br><span class="line">            swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="http://static.imlgw.top/640%20%282%29.gif" alt="weixin"></p>
<h4 id="图上面的是递归版本的归并，实现如下"><a href="#图上面的是递归版本的归并，实现如下" class="headerlink" title="图上面的是递归版本的归并，实现如下"></a>图上面的是递归版本的归并，实现如下</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    MergerSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用merger2的方式(也不好，应该保证辅助数组只初始化一次)</span></span><br><span class="line">    <span class="comment">//help=new int[nums.length];</span></span><br><span class="line">    <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    MergerSort(nums,left,mid);</span><br><span class="line">    MergerSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    merger(nums,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> []help;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//其实没区别空间复杂度，都是O(N) 后面这个会更加耗费时间</span></span><br><span class="line">    <span class="comment">//int []help=new int[right-left+1];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k&lt;=right;k++)&#123;</span><br><span class="line">        <span class="comment">//一边的到达尽头,先判断两个边界,不然就要想下面那样写</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">            help[k]=nums[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;right)&#123;</span><br><span class="line">            help[k]=nums[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">            help[k]=nums[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相等的时候左边先进栈保证稳定性</span></span><br><span class="line">            help[k]=nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*// 2 </span></span><br><span class="line"><span class="comment">            if( i&lt;=mid &amp;&amp;j&lt;=right &amp;&amp; nums[i]&gt;nums[j])&#123;</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            &#125;else if( i&lt;=mid &amp;&amp;j&lt;=right &amp;&amp; nums[i]&lt;=nums[j])&#123;</span></span><br><span class="line"><span class="comment">                //相等的时候左边先进栈保证稳定性</span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            &#125;else if(i&gt;mid)&#123;</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            &#125;else if(j&gt;right)&#123; </span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k&lt;=right;k++)&#123;</span><br><span class="line">        nums[k]=help[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        while (p1 &lt;= m) &#123;</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1++];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        while (p2 &lt;= r) &#123;</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p2++];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for (i = 0; i &lt; help.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[l + i] = help[i];</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序（非递归，方向不一样，时间复杂度一样都为O(NlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSortNoRecurse</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//控制合并的长度 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz=<span class="number">1</span>;sz&lt;nums.length;sz*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//控制合并的向后移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-sz;i+=<span class="number">2</span>*sz)&#123;</span><br><span class="line">            <span class="keyword">int</span> r=i+<span class="number">2</span>*sz-<span class="number">1</span>&lt;nums.length-<span class="number">1</span>?i+<span class="number">2</span>*sz-<span class="number">1</span>:nums.length-<span class="number">1</span>;</span><br><span class="line">            merger(nums,i,i+sz-<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三向切分的快排-荷兰国旗问题"><a href="#三向切分的快排-荷兰国旗问题" class="headerlink" title="三向切分的快排(荷兰国旗问题)"></a>三向切分的快排(荷兰国旗问题)</h3><p><img src="http://static.imlgw.top/640%20%283%29.gif" alt="weixin"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排 (不具有稳定性或者难以实现)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机一个数和r交换 ---随机快排</span></span><br><span class="line">    swap(nums, l + (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)), r);</span><br><span class="line">    <span class="keyword">int</span> []index=partition2(nums,l,r);</span><br><span class="line">    QuickSort(nums,l,index[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">    QuickSort(nums,index[<span class="number">1</span>]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = l;</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">int</span> lo = l, hi = r;</span><br><span class="line">    <span class="comment">//这种partition的实现细节有点不好理解</span></span><br><span class="line">    <span class="comment">//这种partition不能随机基准元素。。。。</span></span><br><span class="line">    <span class="comment">//参照了左神的代码发现其实可以在partition之前随机一个变量和lo交换，也有同样的效果也消除了输入的影响</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="comment">//必须先从右往左,主要是为了归位的时候不出现问题</span></span><br><span class="line">        <span class="comment">//比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是lo和一个比lo大的数然而比lo大的数应该放在右边</span></span><br><span class="line">        <span class="comment">//反之如果选的是hi为基准就要先从左往右</span></span><br><span class="line">        <span class="comment">// 7  0  1  2    10  11  22</span></span><br><span class="line">        <span class="keyword">while</span> (nums[hi] &gt;= nums[base] &amp;&amp; lo &lt; hi) &#123;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nums[lo] &lt;= nums[base] &amp;&amp; lo &lt; hi) &#123;</span><br><span class="line">            lo++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">            swap(nums, lo, hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归位 lo==hi</span></span><br><span class="line">    swap(nums, hi, base);</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//荷兰国旗优化的快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition2(<span class="keyword">int</span> []arr ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="comment">// 7  0  1  2    10  11  22        </span></span><br><span class="line">    <span class="comment">//小于区为空</span></span><br><span class="line">    <span class="keyword">int</span> less=l-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//l ----&gt; more 为待定区</span></span><br><span class="line">    <span class="keyword">int</span> more=r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l]&lt;arr[r])&#123;</span><br><span class="line">            swap(arr,++less,l++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[l]&gt;arr[r])&#123;</span><br><span class="line">            <span class="comment">//大于基准时 , 大于区扩大(大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能l++)</span></span><br><span class="line">            swap(arr,--more,l);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//和大于区间的第一个交换 保证归位正确,如果选取的是以最左边为基准元素 这里就应该和less交换</span></span><br><span class="line">    <span class="comment">//到这里  [less+1,more-1]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">    swap(arr,more,r);</span><br><span class="line">    <span class="comment">//到这  [less+1,more]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="http://static.imlgw.top/640%20%284%29.gif" alt="weixin"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        heapInsert(nums,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换堆顶和最后一个节点</span></span><br><span class="line">    <span class="keyword">int</span> size= nums.length;</span><br><span class="line">    swap(nums,size-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//调整</span></span><br><span class="line">        heapIfy(nums,<span class="number">0</span>,size);</span><br><span class="line">        <span class="comment">//每次都和最后一个孩子节点交换，然后size--</span></span><br><span class="line">        swap(nums,--size,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上爬</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> []nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//迭代比较当前节点和父节点的值的大小</span></span><br><span class="line">    <span class="keyword">while</span>(nums[index]&gt;nums[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">        swap(nums,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        index=(index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下爬</span></span><br><span class="line"><span class="comment">//index位置的值变小后继续调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapIfy</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> index,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">//左孩子</span></span><br><span class="line">    <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//节点有左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;size)&#123;</span><br><span class="line">        <span class="comment">//判断是否有右孩子.....</span></span><br><span class="line">        <span class="comment">//左右孩子里的最大值 有右孩子且右孩子大于左孩子</span></span><br><span class="line">        <span class="keyword">int</span> largest=left+<span class="number">1</span>&lt;size &amp;&amp; nums[left]&lt;nums[left+<span class="number">1</span>] ?left+<span class="number">1</span>:left;</span><br><span class="line">        largest=nums[largest]&gt;nums[index]?largest:index;</span><br><span class="line">        <span class="comment">//最大值等于自己</span></span><br><span class="line">        <span class="keyword">if</span>(largest==index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换大孩子节点和自己</span></span><br><span class="line">        swap(nums,largest,index);</span><br><span class="line">        <span class="comment">//设置大孩子的index和左孩子</span></span><br><span class="line">        index=largest;</span><br><span class="line">        left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序更优的做法"><a href="#堆排序更优的做法" class="headerlink" title="堆排序更优的做法"></a>堆排序更优的做法</h3><p>上面的做法并不是最优的堆排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//N构建大根堆</span></span><br><span class="line">    <span class="comment">//从倒数第二层开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length/<span class="number">2</span>-<span class="number">1</span> ;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        heapIfy(nums,i,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printArray(nums);</span></span><br><span class="line">    <span class="keyword">while</span>(last&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        swap(nums,<span class="number">0</span>,last--);</span><br><span class="line">        heapIfy(nums,<span class="number">0</span>,last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i 大根堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapIfy</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断有没有子节点（左孩子）</span></span><br><span class="line">    <span class="keyword">int</span> left=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=last)&#123;</span><br><span class="line">        <span class="keyword">int</span> right=left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点最大值</span></span><br><span class="line">        <span class="keyword">int</span> larger=right&lt;=last &amp;&amp; nums[right] &gt; nums[left]?right:left;</span><br><span class="line">        <span class="keyword">if</span>(nums[larger]&gt;nums[i])&#123;</span><br><span class="line">            swap(nums,larger,i);</span><br><span class="line">            i=larger;</span><br><span class="line">            left=larger*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的<code>insert</code>方式时间复杂度是<code>O(NlogN)</code>，其实仔细想想，这两种方式是完全相反的，insert的方式，最后一层每个元素最坏都可能调整<code>logN</code>次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的<code>heapIfy</code>方式最后一层都只需要调整<code>1</code>次，而根节点需要调整<code>logN</code>次，而根节点<strong>只有一个</strong>时间复杂度就会大大降低，最终的时间复杂度就是O(N)，<a href="https://www.zhihu.com/question/20729324" target="_blank" rel="noopener">具体推算过程可以看这些回答</a> </p>
<p><strong>手推过程</strong></p>
<p><img src="http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim" alt="img"></p>
<p>最后推得到得复杂度是小于<code>O(2N)</code>，也就是<code>O(N)</code>的时间复杂度，如果不是刷<code>leetCode</code> 看到了类似的题可能会一直被那样去写😂</p>
<p><strong>再回首</strong></p>
<p>时隔多年，又回头写了一个，写了大概半个小时左右，边写边回忆，感觉这个写法比上面好一点点，所以记录一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)nums[i]=sc.nextInt();</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)System.out.print(nums[i]+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//求左右孩子</span></span><br><span class="line">        <span class="comment">//       0 </span></span><br><span class="line">        <span class="comment">//   1       2</span></span><br><span class="line">        <span class="comment">// 3   4   5   6 </span></span><br><span class="line">        <span class="comment">//7                 7/2=3  4/2=1 8/2=4</span></span><br><span class="line">        <span class="comment">//O(N)构建堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//从2/n开始down构建二叉树,不一定要精确,多一两个无所谓</span></span><br><span class="line">            down(nums,i,nums.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>,tail=nums.length;</span><br><span class="line">        <span class="comment">//堆排,将堆头放到尾部</span></span><br><span class="line">        <span class="keyword">while</span>(tail&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            swap(nums,index,--tail);</span><br><span class="line">            down(nums,index,tail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="comment">//求左右孩子</span></span><br><span class="line">        <span class="comment">//      0 </span></span><br><span class="line">        <span class="comment">//  1       2</span></span><br><span class="line">        <span class="comment">//3   4   5   6</span></span><br><span class="line">        <span class="keyword">while</span>(index*<span class="number">2</span>+<span class="number">1</span> &lt; size)&#123; <span class="comment">//还有孩子</span></span><br><span class="line">            <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>,right=left+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//左右子树中的较大</span></span><br><span class="line">            <span class="keyword">int</span> largeIndex = right&lt;size &amp;&amp; nums[left]&lt;nums[right] ? right:left;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt;= nums[largeIndex])&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,index,largeIndex);</span><br><span class="line">            index=largeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">        nums[a]=nums[b];</span><br><span class="line">        nums[b]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>实际上写排序就是基于插入排序的，在它之上进行了数学上的优化。</p>
<p><img src="http://static.imlgw.top/640%20%285%29.gif" alt="image"><br>    实际上从逆序对的角度来看，基于比较的排序就是为了消除逆序对的个数，而诸如冒泡选择每次都只是交换相邻的两个元素，每次交换最多只减少一个逆序对，而希尔排序扩大了这个间距，就增大了减少逆序对的可能。不过要研究他的时间复杂度就是数学上的研究的问题了，至于每次间距都减半这个也是根据大样本测试下这种递增序列性能会更好 O(∩_∩)O</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序的改进</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h=nums.length&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=h;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//实际上是增大了插入排序的间隙，最后还是对进行一次插入排序,不过那个时候的数据已经是高度有序了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j-h&gt;=<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j-h];j-=h) &#123;</span><br><span class="line">                swap(nums,j,j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h=h&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h3><p>排个序还能排出Bug？对的没错就是排出了Bug🤣 看看我最开始写的交换函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    nums[a]=nums[a]^nums[b];</span><br><span class="line">    nums[b]=nums[a]^nums[b];</span><br><span class="line">    nums[a]=nums[a]^nums[b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了抖这个机灵付出了惨痛的代价，之前用 &gt;&gt; 拿来当除2操作的时候就忽略了<code>优先级</code>的问题。。。那这里的机灵有什么问题呢？一个数异或同一个数两次就还原没毛病啊？But如果交换的两个数是同一个元素比如上面在数组中 a==b时 nums[a]异或了3次自己相当于<code>nums[a]^nums[a]^nums[a]^nums[a]=0^0=0</code>，最后就会出问题,其实开始前面的排序都没有出现问题，主要是后面的快排时发现了这个Bug因为快排为了避免数据分布的影响随机选取基准值，可能随机的是最后一个，而且快排的partition过程中也会有时也会自己和自己交换，最开始的第一步就是自己和直接交换，让小于区扩大。所以这个方法仅仅只能用来抖一抖机灵，没啥实际意义，以后还是要老老实实写，不然咋死的都不知道😁</p>
<blockquote>
<p> 未完待续……还有一类非基于比较的排序 桶排序之类的等后面再来总结加上去.</p>
</blockquote>
<h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>直接拿的左神的对数器😄，所有排序都是经过对数器测试的。 <em>talk is cheap show me the code</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorts</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*int []nums=&#123;1,0,-1,-22,213,4,535,-112,99999&#125;;</span></span><br><span class="line"><span class="comment">        //ShellSort(nums);</span></span><br><span class="line"><span class="comment">        //MaoPaoSort(nums);</span></span><br><span class="line"><span class="comment">        //SelectSort(nums);</span></span><br><span class="line"><span class="comment">        //MergerSort(nums,0,nums.length-1);</span></span><br><span class="line"><span class="comment">        QuickSort(nums,0,nums.length-1);</span></span><br><span class="line"><span class="comment">        printArray(nums);*/</span></span><br><span class="line">        <span class="keyword">int</span> testTime = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">        Boolean succeed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">            <span class="keyword">long</span> time=System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//冒泡</span></span><br><span class="line">            <span class="comment">//MaoPaoSort(arr1);</span></span><br><span class="line">            <span class="comment">//选择</span></span><br><span class="line">            <span class="comment">//SelectSort(arr1);</span></span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            <span class="comment">//InsertSort(arr1);</span></span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">            <span class="comment">//MergerSort(arr1);</span></span><br><span class="line">            <span class="comment">//非递归归并</span></span><br><span class="line">            <span class="comment">//MergerSortNoRecurse(arr1);</span></span><br><span class="line">            <span class="comment">//希尔</span></span><br><span class="line">            <span class="comment">//ShellSort(arr1);</span></span><br><span class="line">            <span class="comment">//快排</span></span><br><span class="line">            <span class="comment">//QuickSort(arr1,0,arr1.length-1);</span></span><br><span class="line">            <span class="comment">//堆排序</span></span><br><span class="line">            HeapSort(arr1);</span><br><span class="line">            <span class="keyword">long</span> time2=System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(time2-time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//系统排序</span></span><br><span class="line">            comparator(arr2);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis()-time2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">                succeed = <span class="keyword">false</span>;</span><br><span class="line">                printArray(arr1);</span><br><span class="line">                printArray(arr2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(succeed ? <span class="string">"Nice!"</span> : <span class="string">"Fucking fucked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初级排序算法</span></span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//冒泡排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaoPaoSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;min)&#123;</span><br><span class="line">                    min=nums[j];</span><br><span class="line">                    swap(nums,j,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//直接插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j-<span class="number">1</span>];j--)&#123;</span><br><span class="line">                swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//插入排序的改进</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=nums.length&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=h;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="comment">//实际上是增大了插入排序的间隙，最后还是对进行一次插入排序,不过那个时候的数据已经是高度有序了</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j-h&gt;=<span class="number">0</span>&amp;&amp;nums[j]&lt;nums[j-h];j-=h) &#123;</span><br><span class="line">                    swap(nums,j,j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">        help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        MergerSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用merger2的方式(也不好，应该保证辅助数组只初始化一次)</span></span><br><span class="line">        <span class="comment">//help=new int[nums.length];</span></span><br><span class="line">        <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        MergerSort(nums,left,mid);</span><br><span class="line">        MergerSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        merger(nums,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> []help;</span><br><span class="line">    <span class="comment">//归并操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//其实没区别空间复杂度，都是O(N) 后面这个会更加耗费时间</span></span><br><span class="line">        <span class="comment">//int []help=new int[right-left+1];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k&lt;=right;k++)&#123;</span><br><span class="line">            <span class="comment">//一边的到达尽头,先判断两个边界,不然就要想下面那样写</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">                help[k]=nums[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;right)&#123;</span><br><span class="line">                help[k]=nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                help[k]=nums[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//相等的时候左边先进栈保证稳定性</span></span><br><span class="line">                help[k]=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*// 2 </span></span><br><span class="line"><span class="comment">            if( i&lt;=mid &amp;&amp;j&lt;=right &amp;&amp; nums[i]&gt;nums[j])&#123;</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            &#125;else if( i&lt;=mid &amp;&amp;j&lt;=right &amp;&amp; nums[i]&lt;=nums[j])&#123;</span></span><br><span class="line"><span class="comment">                //相等的时候左边先进栈保证稳定性</span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            &#125;else if(i&gt;mid)&#123;</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            &#125;else if(j&gt;right)&#123; </span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k&lt;=right;k++)&#123;</span><br><span class="line">            nums[k]=help[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//asddsdasdasdasd</span></span><br><span class="line">        <span class="comment">/*while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        while (p1 &lt;= m) &#123;</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1++];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        while (p2 &lt;= r) &#123;</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p2++];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for (i = 0; i &lt; help.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[l + i] = help[i];</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并排序（非递归，方向不一样，时间复杂度一样都为O(NlogN)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSortNoRecurse</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">        help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//控制合并的长度 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz=<span class="number">1</span>;sz&lt;nums.length;sz*=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//控制合并的向后移动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-sz;i+=<span class="number">2</span>*sz)&#123;</span><br><span class="line">                <span class="keyword">int</span> r=i+<span class="number">2</span>*sz-<span class="number">1</span>&lt;nums.length-<span class="number">1</span>?i+<span class="number">2</span>*sz-<span class="number">1</span>:nums.length-<span class="number">1</span>;</span><br><span class="line">                merger(nums,i,i+sz-<span class="number">1</span>,r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//快排 (不具有稳定性或者难以实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//随机一个数和r交换 ---随机快排</span></span><br><span class="line">        swap(nums, l + (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)), r);</span><br><span class="line">        <span class="keyword">int</span> []index=partition2(nums,l,r);</span><br><span class="line">        QuickSort(nums,l,index[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">        QuickSort(nums,index[<span class="number">1</span>]+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> base = l;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> lo = l, hi = r;</span><br><span class="line">        <span class="comment">//这种partition的实现细节有点不好理解</span></span><br><span class="line">        <span class="comment">//这种partition不能随机基准元素。。。。</span></span><br><span class="line">        <span class="comment">//参照了左神的代码发现其实可以在partition之前随机一个变量和lo交换，也有同样的效果也消除了输入的影响</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="comment">//必须先从右往左,主要是为了归位的时候不出现问题</span></span><br><span class="line">            <span class="comment">//比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是lo和一个比lo大的数然而比lo大的数应该放在右边</span></span><br><span class="line">            <span class="comment">//反之如果选的是hi为基准就要先从左往右</span></span><br><span class="line">            <span class="comment">// 7  0  1  2    10  11  22</span></span><br><span class="line">            <span class="keyword">while</span> (nums[hi] &gt;= nums[base] &amp;&amp; lo &lt; hi) &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nums[lo] &lt;= nums[base] &amp;&amp; lo &lt; hi) &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">                swap(nums, lo, hi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//归位 lo==hi</span></span><br><span class="line">        swap(nums, hi, base);</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//荷兰国旗优化的快排</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition2(<span class="keyword">int</span> []arr ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">        <span class="comment">// 7  0  1  2    10  11  22        </span></span><br><span class="line">        <span class="comment">//小于区为空</span></span><br><span class="line">        <span class="keyword">int</span> less=l-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//l ----&gt; more 为待定区</span></span><br><span class="line">        <span class="keyword">int</span> more=r;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l]&lt;arr[r])&#123;</span><br><span class="line">                swap(arr,++less,l++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[l]&gt;arr[r])&#123;</span><br><span class="line">                <span class="comment">//大于基准时 , 大于区扩大(大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能l++)</span></span><br><span class="line">                swap(arr,--more,l);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//和大于区间的第一个交换 保证归位正确,如果选取的是以最左边为基准元素 这里就应该和less交换</span></span><br><span class="line">        <span class="comment">//到这里  [less+1,more-1]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">        swap(arr,more,r);</span><br><span class="line">        <span class="comment">//到这  [less+1,more]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            heapInsert(nums,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个节点</span></span><br><span class="line">        <span class="keyword">int</span> size= nums.length;</span><br><span class="line">        swap(nums,size-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//调整</span></span><br><span class="line">            heapIfy(nums,<span class="number">0</span>,size);</span><br><span class="line">            <span class="comment">//每次都和最后一个孩子节点交换，然后size--</span></span><br><span class="line">            swap(nums,--size,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向上爬</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> []nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//迭代比较当前节点和父节点的值的大小</span></span><br><span class="line">        <span class="keyword">while</span>(nums[index]&gt;nums[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">            swap(nums,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            index=(index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下爬</span></span><br><span class="line">    <span class="comment">//index位置的值变小后继续调整为大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapIfy</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> index,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//节点有左孩子</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;size)&#123;</span><br><span class="line">            <span class="comment">//判断是否有右孩子.....</span></span><br><span class="line">            <span class="comment">//左右孩子里的最大值 有右孩子且右孩子大于左孩子</span></span><br><span class="line">            <span class="keyword">int</span> largest=left+<span class="number">1</span>&lt;size &amp;&amp; nums[left]&lt;nums[left+<span class="number">1</span>] ?left+<span class="number">1</span>:left;</span><br><span class="line">            largest=nums[largest]&gt;nums[index]?largest:index;</span><br><span class="line">            <span class="comment">//最大值等于自己</span></span><br><span class="line">            <span class="keyword">if</span>(largest==index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换大孩子节点和自己</span></span><br><span class="line">            swap(nums,largest,index);</span><br><span class="line">            <span class="comment">//设置大孩子的index和左孩子</span></span><br><span class="line">            index=largest;</span><br><span class="line">            left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不知道为啥快排交换的时候这样写会出现很多0</span></span><br><span class="line">        <span class="comment">//查询知道，当a==b时自己和直接交换，a异或自己4次后a==0.....</span></span><br><span class="line">        nums[a]=nums[a]^nums[b];</span><br><span class="line">        nums[b]=nums[a]^nums[b];</span><br><span class="line">        nums[a]=nums[a]^nums[b];</span><br><span class="line">        <span class="comment">/*int temp=nums[a];</span></span><br><span class="line"><span class="comment">        nums[a]=nums[b];</span></span><br><span class="line"><span class="comment">        nums[b]=temp;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for test  对数器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">comparator</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) (maxValue * Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr1 == <span class="keyword">null</span> &amp;&amp; arr2 != <span class="keyword">null</span>) || (arr1 != <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1.length != arr2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        </p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#常见排序算法总结"><span class="toc-text">常见排序算法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接插入排序"><span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序"><span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图上面的是递归版本的归并，实现如下"><span class="toc-text">图上面的是递归版本的归并，实现如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非递归版本"><span class="toc-text">非递归版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三向切分的快排-荷兰国旗问题"><span class="toc-text">三向切分的快排(荷兰国旗问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序更优的做法"><span class="toc-text">堆排序更优的做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BUG"><span class="toc-text">BUG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对数器"><span class="toc-text">对数器</span></a></li></ol></li></ol>
  </div>


  </div>
</div>

    <section id="comments" style="margin:10px;padding:10px;background:#fff;">
      
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'imlgw';
    
    var disqus_url = 'http://imlgw.top/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//imlgw.disqus.com/count.js" async></script>



    </section>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2018/12/03/nodejs-mo-fang-express-feng-zhuang-lu-you/" rel="next" title="NodeJS模仿Express封装路由">
          NodeJS模仿Express封装路由
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/02/27/leetcode-lian-biao/" rel="prev" title="LeetCode链表">
            LeetCode链表
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/imlgw" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://imlgw.avosapps.us/" target="_blank" rel="noopener">博客评论管理</a>
    </div>
    <div id="bottom-inner">
        <a class="bottom-item" href="http://beian.miit.gov.cn/publish/query/indexFirst.action" target="_blank">鄂ICP备18011208号</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"right","hOffset":0,"vOffset":-70},"mobile":{"show":false,"scale":0.2},"log":false});</script></body>
</html>
