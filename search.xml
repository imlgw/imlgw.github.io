<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用的一些工具和网站</title>
      <link href="/2019/12/23/wo-chang-yong-de-yi-xie-gong-ju-he-wang-zhan/"/>
      <url>/2019/12/23/wo-chang-yong-de-yi-xie-gong-ju-he-wang-zhan/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="整理下我常用的一些工具和网站"><a href="#整理下我常用的一些工具和网站" class="headerlink" title="整理下我常用的一些工具和网站"></a>整理下我常用的一些工具和网站</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="PDFread"><a href="#PDFread" class="headerlink" title="PDFread"></a>PDFread</h3><p>一个pdf阅读器，绿色软件体积很小只有10M，很久之前在一个公共号上看见的，链接：<a href="https://pan.baidu.com/s/15MSlABLZkJHChako1GEGdA" target="_blank" rel="noopener">https://pan.baidu.com/s/15MSlABLZkJHChako1GEGdA</a><br>提取码：7a5i </p><h3 id="BandZip"><a href="#BandZip" class="headerlink" title="BandZip"></a>BandZip</h3><p>解压缩的软件，比某<code>数字</code>压缩软件好用，比<code>7z</code>功能多而且好看(7z也不错)，挺良心的，至少没广告 <a href="https://www.bandisoft.com/bandizip/" target="_blank" rel="noopener">官网下载地址</a>(可能被Q)</p><h3 id="MPic"><a href="#MPic" class="headerlink" title="MPic"></a>MPic</h3><p> 图床神器，贼方便，会检测剪切板里的图片包括QQ截图，自动上传一键获取外链贼爽，不过<code>可惜</code>只能配合七牛云。<a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">官网地址</a></p><h3 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h3><p>文件检索神器，速度很快体积很小。<a href="https://www.voidtools.com/zh-cn/" target="_blank" rel="noopener">下载地址</a></p><h3 id="FSCaptrue"><a href="#FSCaptrue" class="headerlink" title="FSCaptrue"></a>FSCaptrue</h3><p> 截图工具，截长屏很方便，体积很小。<a href="https://www.appcgn.com/faststone-capture.html" target="_blank" rel="noopener">下载地址</a></p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p> 也是我现在编辑这篇文章用的编辑器，我也换了很多的<code>markdown</code>编辑器，最开始的<em>Yu writer</em>(一直没更新，bug挺多，更新后收费了)，然后 <em>markeditor</em>(这个还可以，但是在win上界面我有点看不习惯。。2.0不支持win,而且时不时弹窗授权)，中间还试过很多像什么小书匠，markpad，都是装完就卸了。。。现在换到Typora(之前也试过)越用越喜欢。</p><h3 id="CCleaner"><a href="#CCleaner" class="headerlink" title="CCleaner"></a>CCleaner</h3><p>垃圾清理软件，清注册表贼舒服操作比较简单，拒绝辣鸡软件残留（也是绿软）。链接：<a href="https://pan.baidu.com/s/1TrOYF2893FYHKjTlQbFykA" target="_blank" rel="noopener">https://pan.baidu.com/s/1TrOYF2893FYHKjTlQbFykA</a> 提取码：ql42 </p><h3 id="Dism"><a href="#Dism" class="headerlink" title="Dism++"></a>Dism++</h3><p>跟上面的一样也是垃圾清理软件，但是这个不能瞎搞😀  <a href="https://www.chuyu.me/zh-Hans/index.html" target="_blank" rel="noopener">下载地址</a></p><h3 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h3><p>快速修改hosts文件，我用这个主要是博客在本地跑的时候，因为图片加了防盗链加载不出来，用这个改了hosts。</p><h3 id="TeamViewer"><a href="#TeamViewer" class="headerlink" title="TeamViewer"></a>TeamViewer</h3><p>远程帮人调试，改bug的时候用到，比QQ好用的多，QQ很卡而且一些关键操作不允许。</p><h3 id="夜神模拟器"><a href="#夜神模拟器" class="headerlink" title="夜神模拟器"></a>夜神模拟器</h3><p>PC端模拟安卓手机，可以用来调试安卓。</p><h3 id="DeskGo"><a href="#DeskGo" class="headerlink" title="DeskGo :"></a>DeskGo :</h3><p><a href="https://pc.qq.com/detail/5/detail_23125.html" target="_blank" rel="noopener">腾讯桌面整理</a>，tx难得的良心软件，本来是QQ安全管家里面附带的，后来被单独提取出来了，没广告，没捆绑，占用小（几十M）。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190414/Ch6k6LNP3CU2.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="油猴："><a href="#油猴：" class="headerlink" title="油猴："></a>油猴：</h3><p><code>tampermonkey</code>这个是要配合浏览器来使用的(谷歌或者极速360吧)，如果可以科学上网的话直接引用商城就搜得到</p><p><img alt="mark" data-src="http://static.imlgw.top///20190414/5ioOotVWEqJO.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>它的骚操作可太多了：) <a href="https://zhuanlan.zhihu.com/p/32155254" target="_blank" rel="noopener">右转bi乎</a><img alt="mark" data-src="http://static.imlgw.top///20190414/QIORRorFVAah.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>没法科学上网可以去<a href="http://chromecj.com/web-development/2018-07/1468/download.html" target="_blank" rel="noopener">这里</a>下载</p><h3 id="天若OCR"><a href="#天若OCR" class="headerlink" title="天若OCR"></a>天若OCR</h3><p>也是很良心的软件，没广告，绿软，体积小，5M，识别准确度也挺好的。</p><p>链接：<a href="https://pan.baidu.com/s/198PUMdtLU-huU5U1oN9tMw" target="_blank" rel="noopener">https://pan.baidu.com/s/198PUMdtLU-huU5U1oN9tMw</a><br>提取码：vces </p><h3 id="微软输入法"><a href="#微软输入法" class="headerlink" title="微软输入法"></a>微软输入法</h3><p>win10平台上最好的输入法没有之一（Google输入法好像也可以），别用垃圾sg，前几天<a href="https://answers.microsoft.com/zh-hans/windows/forum/windows_10-update/systemserviceexception%E8%93%9D%E5%B1%8F/e5c0a131-a155-4cc0-a871-b6089d474313?rtAction=1553553854556" target="_blank" rel="noopener">社区</a>看到有人更新win10因为sg崩溃了。流氓软件贼他妈难卸载，经历过的人都知道。想不通为啥不用原生的输入法？</p><h3 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h3><p>最好用，无广告，页面简洁，强大的解码器，能播放所有视频的播放器。（前身是KMPlayer）占用小，(微软自带的那个不能倍数播放。。。不然我也不会用这个)</p><h3 id="MobaXterm"><a href="#MobaXterm" class="headerlink" title="MobaXterm"></a>MobaXterm</h3><p>(19-5-2)炒鸡好用的SSH客户端，功能强大，界面好看，也是个绿软，再也不用到处找Xshell的注册码了（而且我也不喜欢Xshell，我一直用的putty+winscp，现在发现这个可以直接结合putty和sinscp👍）</p><p><img alt="mark" data-src="http://static.imlgw.top///20190502/rKdNPEwUmstf.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="Multrin"><a href="#Multrin" class="headerlink" title="Multrin"></a>Multrin</h3><p>github上偶然发现的一个 <a href="https://github.com/sentialx/multrin" target="_blank" rel="noopener">小项目</a> ，将所有的tab聚合到一起让后提供一个快捷键快速切换，挺不错的。</p><p>相比<strong>alt+tab</strong>，这个软件的优势就是会让桌面显得更加整洁</p><h3 id="UTools"><a href="#UTools" class="headerlink" title="UTools"></a><a href="https://u.tools/" target="_blank" rel="noopener">UTools</a></h3><p>也是挺不错的一款工具，一开始感觉占用比较大，后来想想其实没啥影响，然后用了一段时间，有一个图床的插件相当方便啊！</p><h3 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h3><p>不用多说了吧</p><p>链接：<a href="https://pan.baidu.com/s/1L7XgRnLAinUcAqx6oeNt0w" target="_blank" rel="noopener">https://pan.baidu.com/s/1L7XgRnLAinUcAqx6oeNt0w</a><br>提取码：9z54 </p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><h3 id="改图宝"><a href="#改图宝" class="headerlink" title="改图宝"></a><a href="http://www.gaitubao.com/#" target="_blank" rel="noopener">改图宝</a></h3><p>最开始时为了裁剪图片，后来发现还可以按照 指定大小压缩图片，也是个神器啊~</p><h3 id="CodeToImage"><a href="#CodeToImage" class="headerlink" title="CodeToImage"></a><a href="https://carbon.now.sh" target="_blank" rel="noopener">CodeToImage</a></h3><p>可以把代码美化为好看的图片然后导出</p><p><img alt="c" data-src="http://static.imlgw.top///20190407/sAP81lBQEv3Q.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a><a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a></h3><p>在线画图工具，谁用谁知道，现在有离线版本的了</p><h3 id="在线免费抠图"><a href="#在线免费抠图" class="headerlink" title="在线免费抠图"></a><a href="https://www.gaoding.com/koutu" target="_blank" rel="noopener">在线免费抠图</a></h3><p> 很方便操作也很简单</p><h3 id="高清图片素材"><a href="#高清图片素材" class="headerlink" title="高清图片素材"></a><a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">高清图片素材</a></h3><p>  免费，高清，素材多，用来做壁纸什么的都挺不错</p><h3 id="unsplash"><a href="#unsplash" class="headerlink" title="unsplash"></a><a href="https://unsplash.com" target="_blank" rel="noopener">unsplash</a></h3><p> 也是图片素材站</p><h3 id="img9无限图床"><a href="#img9无限图床" class="headerlink" title="img9无限图床"></a><a href="https://img9.top" target="_blank" rel="noopener">img9无限图床</a></h3><p>  我现在都是用的七牛云，第三方的还是不放心（目前还正常，我博客的前几篇都是在这个上面），除此之外还有 <code>微博</code> 也是个好图床，</p><h3 id="SM-MS"><a href="#SM-MS" class="headerlink" title="SM.MS"></a><a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a></h3><p> 也是图床，比上面那个更专业，有api</p><blockquote><p>后续如果还有好的工具和网站会继续添加进来 😀</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树初探</title>
      <link href="/2019/12/17/zi-dian-shu/"/>
      <url>/2019/12/17/zi-dian-shu/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>在计算机科学中，<strong>trie</strong>，又称<strong>前缀树</strong>或<strong>字典树</strong>，字典树设计的核心思想是空间换时间，所以数据结构本身比较消耗空间。但它利用了字符串的<strong>共同前缀（Common Prefix）</strong>作为存储依据，以此来节省存储空间，并加速搜索时间。Trie 的字符串搜索时间复杂度为 <strong>O(m)</strong>，m 为最长的字符串的长度，其查询性能与集合中的字符串的数量无关。其在搜索字符串时表现出的高效，使得特别适用于构建文本搜索和词频统计等应用</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>与二分搜索树不同，<strong>键不是直接保存在节点中，而是由节点在树中的位置决定</strong>。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有<strong>叶子节点</strong>和部分内部节点所对应的键才有相关的值</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="使用TreeMap实现"><a href="#使用TreeMap实现" class="headerlink" title="使用TreeMap实现"></a>使用TreeMap实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord; <span class="comment">//是否是一个完整单词</span></span><br><span class="line">        <span class="keyword">public</span> TreeMap<character,node> next;</character,node></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap<>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>{</span><br><span class="line">        root=<span class="keyword">new</span> Node();</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向Trie中添加word</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLoop</span><span class="params">(String word)</span></span>{</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<word.length();i++) {< span><br><span class="line">            <span class="keyword">char</span> c=word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c)==<span class="keyword">null</span>) {</span><br><span class="line">                cur.next.put(c,<span class="keyword">new</span> Node());</span><br><span class="line">            }</span><br><span class="line">            cur=cur.next.get(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!cur.isWord) {</span><br><span class="line">            size++;</span><br><span class="line">            cur.isWord=<span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span></span>{</span><br><span class="line">        add(root,word,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node cur,String word,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index==word.length()) {</span><br><span class="line">            <span class="keyword">if</span> (!cur.isWord) {</span><br><span class="line">                size++;</span><br><span class="line">                cur.isWord=<span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (cur.next.get(c)==<span class="keyword">null</span>) {</span><br><span class="line">            cur.next.put(c,<span class="keyword">new</span> Node());</span><br><span class="line">        }</span><br><span class="line">        add(cur.next.get(c),word,index+<span class="number">1</span>); <span class="comment">//尾递归</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询word是否在Trie中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> contains(root,word,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node cur,String word,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index==word.length()) {</span><br><span class="line">            <span class="keyword">return</span> cur.isWord;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=word.charAt(index);</span><br><span class="line">        <span class="keyword">return</span> cur.next.containsKey(c) && contains(cur.next.get(c),word,index+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsLoop</span><span class="params">(String word)</span></span>{</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<word.length();i++) {< span><br><span class="line">            Character c=word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!cur.next.containsKey(c)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">            }</span><br><span class="line">            cur=cur.next.get(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否有某个前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPerfix</span><span class="params">(String perfix)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> hasPerfix(root,perfix,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPerfix</span><span class="params">(Node cur,String perfix,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index==perfix.length()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=perfix.charAt(index);</span><br><span class="line">        <span class="keyword">return</span> cur.next.containsKey(c) && hasPerfix(cur.next.get(c),perfix,index+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//懒得写循环了。。。</span></span><br><span class="line">}</span><br></word.length();i++)></span></word.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>整体上来说其实很简单，这里用的是TreeMap来存储当前节点的下一层节点，可以看到，在Node中并没有直接存储某个字符，而是对应了TreeMap的Key，但是由于TreeMap底层是红黑树，其实在数据量比较小的时候并没有优势，所以在某些情况下，我们也可以直接使用数组来存储节点，比如下面这道题</p><h2 id="LeetCode练手例题"><a href="#LeetCode练手例题" class="headerlink" title="LeetCode练手例题"></a>LeetCode练手例题</h2><h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></h3><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(<span class="string">"apple"</span>);</span><br><span class="line">trie.search(<span class="string">"apple"</span>);   <span class="comment">// 返回 true</span></span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// 返回 false</span></span><br><span class="line">trie.startsWith(<span class="string">"app"</span>); <span class="comment">// 返回 true</span></span><br><span class="line">trie.insert(<span class="string">"app"</span>);   </span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// 返回 true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li><li>保证所有输入均为非空字符串</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord; <span class="comment">//是否是一个完整单词</span></span><br><span class="line">        <span class="keyword">public</span> Node[] next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>{</span><br><span class="line">        root=<span class="keyword">new</span> Node();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        insert(root,word,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node cur,String word,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index==word.length()) {</span><br><span class="line">            <span class="keyword">if</span> (!cur.isWord) {</span><br><span class="line">                cur.isWord=<span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (cur.next[c-<span class="string">'a'</span>]==<span class="keyword">null</span>) {</span><br><span class="line">            cur.next[c-<span class="string">'a'</span>]=<span class="keyword">new</span> Node();</span><br><span class="line">        }</span><br><span class="line">        insert(cur.next[c-<span class="string">'a'</span>],word,index+<span class="number">1</span>); <span class="comment">//尾递归</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> search(root,word,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(Node cur,String word,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index==word.length()) {</span><br><span class="line">            <span class="keyword">return</span> cur.isWord;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=word.charAt(index);</span><br><span class="line">        <span class="keyword">return</span> cur.next[c-<span class="string">'a'</span>]!=<span class="keyword">null</span>&& search(cur.next[c-<span class="string">'a'</span>],word,index+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> startsWith(root,prefix,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(Node cur,String prefix,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index==prefix.length()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=prefix.charAt(index);</span><br><span class="line">        <span class="keyword">return</span> cur.next[c-<span class="string">'a'</span>]!=<span class="keyword">null</span> && startsWith(cur.next[c-<span class="string">'a'</span>],prefix,index+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div><p>这里题目说明了所有的输入都是小写字符，所以可以直接使用固定大小的Node数组来实现，相比于上面的TreeMap时间空间上都会有很大的提升</p><h3 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">211. 添加与搜索单词 - 数据结构设计</a></h3><p>设计一个支持以下两种操作的数据结构：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(word)</span></span></span><br><span class="line"><span class="function">bool <span class="title">search</span><span class="params">(word)</span></span></span><br></pre></td></tr></tbody></table></figure></div><p><code>search(word)</code> 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 <code>.</code> 可以表示任何一个字母。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">addWord(<span class="string">"bad"</span>)</span><br><span class="line">addWord(<span class="string">"dad"</span>)</span><br><span class="line">addWord(<span class="string">"mad"</span>)</span><br><span class="line">search(<span class="string">"pad"</span>) -> <span class="keyword">false</span></span><br><span class="line">search(<span class="string">"bad"</span>) -> <span class="keyword">true</span></span><br><span class="line">search(<span class="string">".ad"</span>) -> <span class="keyword">true</span></span><br><span class="line">search(<span class="string">"b.."</span>) -> <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><p>你可以假设所有单词都是由小写字母 <code>a-z</code> 组成的。</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord; <span class="comment">//是否找到了一个单词</span></span><br><span class="line">    <span class="keyword">public</span> Node[] next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">        next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>{</span><br><span class="line">    root=<span class="keyword">new</span> Node();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>{</span><br><span class="line">    addWord(root,word,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(Node cur,String word,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == word.length()) {</span><br><span class="line">        cur.isWord=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span> c=word.charAt(index);</span><br><span class="line">    <span class="keyword">if</span> (cur.next[c-<span class="string">'a'</span>]==<span class="keyword">null</span>) {</span><br><span class="line">        cur.next[c-<span class="string">'a'</span>]= <span class="keyword">new</span> Node();</span><br><span class="line">    }</span><br><span class="line">    addWord(cur.next[c-<span class="string">'a'</span>],word,index+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> search(root,word,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(Node cur,String word,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == word.length()) {</span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span> c=word.charAt(index);</span><br><span class="line">    <span class="keyword">if</span> (c==<span class="string">'.'</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<cur.next.length;i++) {< span><br><span class="line">            <span class="keyword">if</span>(cur.next[i]!=<span class="keyword">null</span> && search(cur.next[i],word,index+<span class="number">1</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cur.next[c-<span class="string">'a'</span>]!=<span class="keyword">null</span> && search(cur.next[c-<span class="string">'a'</span>],word,index+<span class="number">1</span>);</span><br><span class="line">}</span><br></cur.next.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>没啥好说的，遇到点就循环判断每个子节点就ok</p><h3 id="677-键值映射"><a href="#677-键值映射" class="headerlink" title="677. 键值映射"></a><a href="https://leetcode-cn.com/problems/map-sum-pairs/" target="_blank" rel="noopener">677. 键值映射</a></h3><p>实现一个 MapSum 类里的两个方法，<code>insert</code> 和 <code>sum</code>。</p><p>对于方法 <code>insert</code>，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。</p><p>对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: insert(<span class="string">"apple"</span>, <span class="number">3</span>), 输出: Null</span><br><span class="line">输入: sum(<span class="string">"ap"</span>), 输出: <span class="number">3</span></span><br><span class="line">输入: insert(<span class="string">"app"</span>, <span class="number">2</span>), 输出: Null</span><br><span class="line">输入: sum(<span class="string">"ap"</span>), 输出: <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>有了前面的铺垫，其实这个也很简单</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord; <span class="comment">//是否找到了一个单词</span></span><br><span class="line">        <span class="keyword">public</span> Node[] next;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord,<span class="keyword">int</span> value)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>,value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>{</span><br><span class="line">        root=<span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        insert(root,key,val,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a p p l e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node cur,String key, <span class="keyword">int</span> val,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index==key.length()) {</span><br><span class="line">            cur.isWord=<span class="keyword">true</span>;</span><br><span class="line">            cur.value=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=key.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (cur.next[c-<span class="string">'a'</span>]==<span class="keyword">null</span>) {</span><br><span class="line">            cur.next[c-<span class="string">'a'</span>]=<span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        insert(cur.next[c-<span class="string">'a'</span>],key,val,index+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sum(root,prefix,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node cur,String prefix,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index == prefix.length()) {</span><br><span class="line">            <span class="keyword">return</span> tireSum(cur);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span> c=prefix.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (cur.next[c-<span class="string">'a'</span>]==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum(cur.next[c-<span class="string">'a'</span>],prefix,index+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tireSum</span><span class="params">(Node cur)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur.isWord) {</span><br><span class="line">    sum+=cur.value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">26</span>;i++) {</span><br><span class="line">    sum+=cur.next[i]!=<span class="keyword">null</span>?tireSum(cur.next[i]):<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还是和上面一样，利用前缀树，不过要在上面的基础上做一些改动添加一个value字段用来保存值，先在树中找到要求的前缀的最后一个单词所在的节点，然后就直接求这个节点所有的子节点中isWord的单词的value累加和就ok了，我上面的实现并不好，都是写的递归，而且是尾递归，很鸡肋其实</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树初探</title>
      <link href="/2019/12/09/xian-duan-shu/"/>
      <url>/2019/12/09/xian-duan-shu/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线段树其实属于比较高级的数据结构了，本人并不是竞赛选手，这里的代码也是借鉴的bobo老师的视频课来实现的，面试什么的一般是不会考的，这里主要是出于兴趣练练手</p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307. 区域和检索 - 数组可修改</a></p><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -> <span class="number">9</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -> <span class="number">8</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ol><li>数组仅可以在 update 函数下进行修改。</li><li>你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。</li></ol><blockquote><p>这题如果数组不能修改的话就好说了，可以直接利用数组的前缀和，但是这里数组是会变化的，难道没更新一次都要重新遍历么？那也太慢了吧，有没有一种结构能高效的插入同时也能高效的查询？</p></blockquote><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性（它是一颗平衡二叉树），它基本能保持每个操作的复杂度为<code>O(logN)</code></p><p>线段树的每个节点表示一个区间，父区间为<code>[a,b]</code> 则左子区间为<code>[a,(a+b)/2]</code>右子区间为<code>[(a+b)/2+1,b]</code> 最底层的叶子节点就是对应的一个个具体的元素值，这里我们采用数组来实现线段树</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span><<span class="title">E</span>></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiFunction<e,e,e> function;</e,e,e></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr,BiFunction<e,e,e> function)</e,e,e></span></span>{</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[arr.length];</span><br><span class="line">        <span class="keyword">this</span>.function=function;</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,data,<span class="number">0</span>,arr.length);</span><br><span class="line">        <span class="comment">//值得思考为什么是4n</span></span><br><span class="line">        tree = (E[]) <span class="keyword">new</span> Object[<span class="number">4</span>*arr.length];</span><br><span class="line">        buildSegmentTree(<span class="number">0</span>,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传入的BiFuction构建线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (left==right) {</span><br><span class="line">            tree[index] =data[right];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> leftIndex=leftChild(index);</span><br><span class="line">        <span class="keyword">int</span> rightIndex=rightChild(index);</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        buildSegmentTree(leftIndex,left,mid);</span><br><span class="line">        buildSegmentTree(rightIndex,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//根据业务需求传入BiFunction</span></span><br><span class="line">        tree[index]=function.apply(tree[leftIndex],tree[rightIndex]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//范围搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> searchRange(<span class="number">0</span>,<span class="number">0</span>,data.length-<span class="number">1</span>,left,right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span> rootIndex,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> targetLeft,<span class="keyword">int</span> targetRight)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (targetLeft == left && targetRight == right) {</span><br><span class="line">            <span class="keyword">return</span> tree[rootIndex];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetLeft>mid) {</span><br><span class="line">            <span class="keyword">return</span> searchRange(rightChild(rootIndex),mid+<span class="number">1</span>,right,targetLeft,targetRight);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (targetRight<=mid) {</span><br><span class="line">            <span class="keyword">return</span> searchRange(leftChild(rootIndex),left,mid,targetLeft,targetRight);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> function.apply(searchRange(leftChild(rootIndex),left,mid,targetLeft,mid),searchRange(rightChild(rootIndex),mid+<span class="number">1</span>,right,mid+<span class="number">1</span>,targetRight));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index<<span class="number">0</span> || index>=data.length) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index illegal"</span>);</span><br><span class="line">        }</span><br><span class="line">        update(<span class="number">0</span>,<span class="number">0</span>,data.length-<span class="number">1</span>,index,e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rootIndex,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> targetIndex,E e)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (left == right) {</span><br><span class="line">            tree[rootIndex]=e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetIndex<=mid) {</span><br><span class="line">            update(leftChild(rootIndex),left,mid,targetIndex,e);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            update(rightChild(rootIndex),mid+<span class="number">1</span>,right,targetIndex,e);</span><br><span class="line">        }</span><br><span class="line">        tree[rootIndex]=function.apply(tree[leftChild(rootIndex)],tree[rightChild(rootIndex)]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index<<span class="number">0</span> || index>=data.length) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index is illegal!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>没啥好说的，整体还是挺简单的，代码中用到了Java8的函数式接口，确实挺方便的</p><p>其实我觉得有一个比较关键的点就是线段树需要多大的数组空间？</p><p>首先一颗H层（H从1开始）的满二叉树一共有 <code>2^H-1</code>  个节点，我们忽略那一个节点，约为<code>2^H</code>个节点，而最后一层（h-1层）有 <code>2^(h-1)</code>个节点，也就是说最后一层的节点树大致等于前面所有层节点的和，所以我们可以得出一个结论，在线段树中如果需要表示的区间大小为n，并且n刚好等于2的k次幂的话（也就是放好构成一颗满二叉树），那么就只需要2n的节点个数，但是如果是<code>n=2^k+c</code> 那么当前层就存不下这n个元素，需要存到下一层，也就是空间还需要*2，所以最后我们就需要 4n 的空间去存储这颗线段树。</p><p>这个时候再回头去做上面的题就会很简单了😁</p><blockquote><p>线段树其实还有很多的扩展，上面的是最最最基本的最简单的线段树结构，我还根本就没摸到线段树的门😂，只是知道了有这么个结构</p><p>由于我实在是太菜了，也没有时间去了解那些结构了</p><p>当然面试的时候并不会考线段树这些玩意儿，我也只是为了练练手，真正的竞赛的题目也不会像上面那么简单，了解即可😅</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由于cmd引发的血案</title>
      <link href="/2019/12/08/you-yu-cmd-yin-fa-de-xie-an/"/>
      <url>/2019/12/08/you-yu-cmd-yin-fa-de-xie-an/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>给教务处做一个工作量审核的web项目，前几天完成后部署在机房电脑上进行测试，但是测试的时候出现了Bug，会存在一个用户登录的时候，整个应用卡死，所有人都无法登陆，因为登陆模块是我写的，我当时就慌了（并不），然后赶紧去机房看看到底是啥情况</p><h2 id="FixBug"><a href="#FixBug" class="headerlink" title="FixBug"></a>FixBug</h2><p>其实我首先想到的就是数据库的问题，但是看了我控制台的输出，发现代码其实根本就还没到数据库层！所以先排除了数据库的问题</p><p>然后我就想到了可能是GC的问题，然后我打开了 <code>jvisualvm</code>，准备查看当前的堆占用和GC情况，但是由于现在是正常的，看不出来什么，所以我们需要复现这个Bug，结果我们几个人在哪里搞了半天死活复现不了😂</p><blockquote><p>在经过我们快一个小时坚持不懈的尝试下，终于复现了！</p></blockquote><p>页面hang住，所有人都无法登陆，后台也并没有任何的错误信息，然后我赶紧去看了下 <code>jvisualvm</code> 发现堆并没有任何变化，GC也并没有发生！而且更诡异的是其他的已经登陆的人是可以正常的操作的！只是卡住了登陆的人，所以GC的问题也排除了</p><p>排除上面两个原因，剩下的就只有一个原因了，线程死锁！</p><p>在dump出线程快照后终于发现了问题所在</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191208/XKUriuCE9nTb.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>图中的这条线程卡在了 <code>PrintStream.println()</code> 上，而这个是我在Service打印的log信息，为什么会在这里卡住？？？这不科学啊，然后我看了 其他 tomcat的工作线程，发现还有好几个都是<code>BLOCK</code> 状态，都在等 <code>[0x0000004df8afd000]</code>这把锁，这个锁被另一个tomcat的工作线程 <code>http-bio-80-exec[2]</code> 所持有，而且它并不是<code>BLOCK</code>状态，而是 <code>RUNNABLE</code> 状态，这个线程正在执行 <code>java.io.FileOutputStream.writeBytes()</code> 方法，我们去看看<code>println</code>的源码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints a String and then terminate the line.  This method behaves as</span></span><br><span class="line"><span class="comment"> * though it invokes <code>{<span class="doctag">@link</span> #print(String)}</code> and then</span></span><br><span class="line"><span class="comment"> * <code>{<span class="doctag">@link</span> #println()}</code>.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x  The <code>String</code> to be printed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看出在println方法确实是加了锁的，锁的对象就是当前的PrintStream实例对象，而占用这个锁的对象的线程则正在执行下面这个方法，是个本地方法我们看不到底层的细节</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes a sub array as a sequence of bytes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b the data to be written</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> off the start offset in the data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len the number of bytes that are written</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> append {<span class="doctag">@code</span> true} to first advance the position to the</span></span><br><span class="line"><span class="comment"> *     end of file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IOException If an I/O error has occurred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></tbody></table></figure></div><p>无奈，借助搜索引擎，果然查到了同样的问题 </p><p><a href="https://my.oschina.net/u/1030459/blog/908007" target="_blank" rel="noopener">一个RUNNABLE状态的线程hang在了java.io.FileOutputStream.writeBytes方法上</a></p><p>当然原问题是来自<a href="https://stackoverflow.com/questions/634102/log4j-is-hanging-my-application-what-am-i-doing-wrong" target="_blank" rel="noopener">StackOverflow</a> </p><p>问题的根本原因：在CMD窗口点击了黑框之后，控制台就会被暂停<img alt="mark" data-src="http://static.imlgw.top/blog/20191208/1em5YGsoGyxT.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>，进入编辑模式，之后向控制台的输入内容都会被阻塞，但是正在输出的线程也并不会<code>BLOCK</code>，状态仍然是<code>RUNNABLE</code>，也就是上面所描述的情况，当你这个时候在CMD状态下按一下回车或者其他的键释放console，退出编辑模式<img alt="mark" data-src="http://static.imlgw.top/blog/20191208/4RXkNizHfNsP.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这个线程又会继续往下执行，要解决这个问题可以调整cmd的设置，我这里其实无所谓，因为后面并不会在win上运行</p><p>至此问题就基本解决了（其实都不算问题），没想到还会被cmd给坑一把，不过增长了一点排查问题的能力也还是不错的😁</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode二分查找</title>
      <link href="/2019/12/06/leetcode-er-fen-cha-zhao/"/>
      <url>/2019/12/06/leetcode-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><blockquote><p> 从 <a href="http://imlgw.top/2019/05/04/leetcode-shu-zu/">数组专题</a> 中抽取出来的 </p></blockquote><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> 不存在 nums 中因此返回 -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li>你可以假设 nums 中的所有元素是不重复的</li><li>n 将在 [1, 10000]之间</li><li>nums 的每个元素都将在 [-9999, 9999]之间</li></ul><p><strong>解法一</strong></p><p>比较经典的二分</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){< span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] > target){</span><br><span class="line">            right=mid;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></target){<></span></right){<></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>按照板子来的二分，最后需要后处理一下不存在的情况</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//模板二分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){ <span class="comment">//排除mid</target){></span></right){<></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            right=mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left!=nums.length&&nums[left]==target?left:-<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">int</span> lo=<span class="number">0</span>,hi=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[hi]<target){< span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]>=target){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){< span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(lo<nums.length&&nums[lo]>target){</nums.length&&nums[lo]></span><br><span class="line">                <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]>target){</span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(hi>=<span class="number">0</span>&&nums[hi]<target){< span><br><span class="line">                <span class="keyword">return</span> hi+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//相等的情况，直接返回这个index</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//到不了这里</span></span><br><span class="line">}</span><br></target){<></span></target){<></span></target){<></span></pre></td></tr></tbody></table></figure></div><p>其实上面的代码写的并不好，写的很奇怪。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">int</span> lo=<span class="number">0</span>,hi=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[hi]<target){< span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]>=target){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){< span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]>target){</span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">    <span class="comment">//return hi+1</span></span><br><span class="line">}</span><br></target){<></span></target){<></span></pre></td></tr></tbody></table></figure></div><p>如果熟悉二分的过程，其实最后返回<code>lo</code>或者<code>hi+1</code>就可以了。</p><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>把最开始写的拉跨解法也放上来吧</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (nums.length==<span class="number">1</span>||nums[<span class="number">0</span>]<nums[nums.length-<span class="number">1</nums[nums.length-<span></span>]) {<br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid]>nums[mid-<span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]>nums[<span class="number">0</span>]) {</span><br><span class="line">                left=mid;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">}</span><br></right){<></span></pre></td></tr></tbody></table></figure></div><p>说实话，我都不知道咋对的。。。</p><p><strong>解法二</strong></p><p>模板解法，还是模板写起来清晰舒服</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid]>nums[right]) { <span class="comment">//排除mid的分支</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            right=mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">}</span><br></right){<></span></pre></td></tr></tbody></table></figure></div><p>需要注意要和右边界比较，和左边界比较不一定正确</p><p>比如 <code>1 2 3 4 5</code> 和<code>2 3 4 5 1</code> 两个的中点都大于左边界，但是你无法确定此时应该如果缩短区间，除非做特判，但是那样就麻烦了</p><h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明：</strong></p><ul><li>这道题是 寻找旋转排序数组中的最小值 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？  </li></ul><p><strong>解法一</strong></p><p>相比上一题有了重复的元素，在跳转的时候需要分清楚情况，在mid和中点相等的时候只排除右边界一个元素</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] > nums[right]){</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] < nums[right]){</span><br><span class="line">            right=mid;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            right--; <span class="comment">//和右边界相等,无法判断,只缩减一步</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">}</span><br></right){<></span></pre></td></tr></tbody></table></figure></div><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>题目明确要求了时间复杂度O(logn)，所以肯定还是要二分，先上代码吧</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((nums == <span class="keyword">null</span>) || (len <= <span class="number">0</span>)) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo <= hi) {</span><br><span class="line">            <span class="keyword">int</span> mid = lo + ((hi - lo) / <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 左, 右 指的是旋转点左右</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] > target) { <span class="comment">//首先是大于target的情况</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (target < nums[lo]) {</span><br><span class="line">                    <span class="comment">//target在右边</span></span><br><span class="line">                    <span class="comment">//mid未知还需要判断下 画一个折线图就很清楚了</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] <= nums[hi]) { <span class="comment">//mid也在右边</span></span><br><span class="line">                        hi = mid - <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">//mid在左边</span></span><br><span class="line">                        lo = mid + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (target > nums[lo]) {</span><br><span class="line">                    <span class="comment">//说明mid在左边, target也在左边</span></span><br><span class="line">                    hi = mid - <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> lo;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] < target) { <span class="comment">//小于target的情况</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (target < nums[hi]) {</span><br><span class="line">                    <span class="comment">//mid在右边，target在右边</span></span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (target > nums[hi]) {</span><br><span class="line">                    <span class="comment">//target在左边</span></span><br><span class="line">                    <span class="comment">//mid未知还需要判断下</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] > nums[hi]) { <span class="comment">//mid在左边</span></span><br><span class="line">                        lo = mid + <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        hi = mid - <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> hi;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*if(hi>=0&&lo<len&&nums[lo]<nums[hi]){< span></len&&nums[lo]<nums[hi]){<></span><br><span class="line"><span class="comment">                   //切换成有序的二分</span></span><br><span class="line"><span class="comment">                   while(lo<=hi){</span></span><br><span class="line"><span class="comment">                         mid=lo+(hi-lo)/2;</span></span><br><span class="line"><span class="comment">                         if(nums[mid]>target){</span></span><br><span class="line"><span class="comment">                                    hi=mid-1;</span></span><br><span class="line"><span class="comment">                         }else if(nums[mid]<target){< span></target){<></span><br><span class="line"><span class="comment">                                    lo=mid+1;</span></span><br><span class="line"><span class="comment">                       }else return mid;</span></span><br><span class="line"><span class="comment">                   }</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br></span></span></pre></td></tr></tbody></table></figure></div><p>1ms，99% 纯if判断<strong>target</strong>和<strong>mid</strong>的位置，然后选择移动<strong>lo</strong>还是<strong>hi</strong>，一开始我随便找了几组数然后就开始写，写到后面发现都是bug😂，这里画个图很方便</p><p><img alt="mark" data-src="http://static.imlgw.top///20190507/vQgFb8yle0FH.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>在里面找点会很清晰</p><p><strong>解法二</strong></p><p>当然还有一种更加简单也不用这么复杂的方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> lo=<span class="number">0</span>,hi=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]>=nums[lo]){</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            index=binarySearch(nums,target,lo,mid);</span><br><span class="line">            <span class="comment">//对右半部分二分</span></span><br><span class="line">            <span class="keyword">if</span>(index==-<span class="number">1</span>){</span><br><span class="line">                lo=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//lo-->mid 没找到就对右半部分继续划分</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">return</span> index;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]<nums[lo]){< span><br><span class="line">            <span class="comment">//右半部分有序</span></span><br><span class="line">            index=binarySearch(nums,target,mid,hi);</span><br><span class="line">            <span class="keyword">if</span>(index==-<span class="number">1</span>){</span><br><span class="line">                hi=mid-<span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">return</span> index;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>  index;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]>target){</span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]<target){< span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></target){<></span></nums[lo]){<></span></pre></td></tr></tbody></table></figure></div><p>这个应该比上一个慢一点，最好情况下是_<strong>O(logN)</strong>_直接将<strong>target</strong>划分到有序的那一边，如果没划分到有序的那一边就会花费时间去二分尝试切割数组，时间复杂度应该是<code>logN+log(N/2)+log(N/4)+...log(N/N)</code> 最后整体复杂度应该是<code>O(logN*logN)</code> ，虽然比 <code>logN</code> 好很多，但是并不是我们想要的算法</p><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: [-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>时间复杂度O(logN)，肯定还是要二分</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//两次二分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">    <span class="keyword">if</span>(nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{-<span class="number">1</span>,-<span class="number">1</span>};</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{left(nums,target,<span class="number">0</span>,nums.length-<span class="number">1</span>),right(nums,target,<span class="number">0</span>,nums.length-<span class="number">1</span>)};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//5,7,7,8,8,8,8,10,10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//System.out.println("lo: "+nums[lo]+"mid: "+nums[mid] +"hi: "+nums[hi]);</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){< span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]>target){</span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(mid><span class="number">0</span>){ <span class="comment">//nums[mid]=target</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid-<span class="number">1</span>]!=target){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//控制向左找</span></span><br><span class="line">                hi=mid-<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//0</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){< span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]>target){</span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(mid<nums.length-<span class="number">1</nums.length-<span></span>){</target){<></span><br><span class="line">            <span class="keyword">if</span>(nums[mid+<span class="number">1</span>]!=target){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//控制向右找</span></span><br><span class="line">                lo=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//nums.length</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></target){<></span></pre></td></tr></tbody></table></figure></div><p>1ms ，99% 核心就是两次二分，分别向左和向后二分整个数组， 在相等的时候并不返回，多判断一下，左边的就控制hi向左边继续找，右边就控制lo向右边继续找，直到下一个不等于target就返回，和上面一题一样都是二分的变种</p><p><strong>解法二</strong></p><p>统一的解法，上面的做法虽然直白，但是没有通用性，这里借鉴评论区大佬 <a href="https://www.liwei.party/" target="_blank" rel="noopener">liweiwei1419</a>的<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">讲解</a>写一个通用的解法，之前写二分一直都是凭感觉，不注意细节，有错误就debug，东改一改，西改一改，然后就过了。。。毫无章法，以后要统一写法了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//两次二分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">    <span class="keyword">if</span>(nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{-<span class="number">1</span>,-<span class="number">1</span>};</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{left(nums,target,<span class="number">0</span>,nums.length-<span class="number">1</span>),right(nums,target,<span class="number">0</span>,nums.length-<span class="number">1</span>)};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//找大于等于target的第一个元素,小于肯定不符合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(lo<hi){< span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){ <span class="comment">//排除小于target的,剩下【lo,hi】都是大于等于的</target){></span></hi){<></span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            hi=mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[hi]==target?hi:-<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//找小于等于target的最后一个元素,大于肯定不符合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(lo<hi){< span><br><span class="line">        <span class="comment">//选取右中值</span></span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]>target){ <span class="comment">//排除大于target,剩下[lo,hi]都是小于等于的</span></span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//根据这个判断需要选取右中值</span></span><br><span class="line">            lo=mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[hi]==target?hi:-<span class="number">1</span>;</span><br><span class="line">}</span><br></hi){<></span></pre></td></tr></tbody></table></figure></div><h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h2><p>给定一个包含 n + 1 个整数的数组 <code>nums</code>，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明：</strong></p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次 </li></ul><p><strong>解法一</strong></p><p>这题还是挺有意思的，题目要求了数组nums是只读的，且不能使用额外的空间，且时间复杂度还要小于O(N^2)，否则的话其实可以排序，或者使用Hash表来做，这里我们使用二分来做</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>,right=nums.length-<span class="number">1</span>; <span class="comment">//左右边界</span></span><br><span class="line">    <span class="comment">//这里实际上是对【1,2,3,4,...n-1】这个区间进行二分</span></span><br><span class="line">    <span class="comment">//在过程中对mid检测每个数在nums数组中出现的次数</span></span><br><span class="line">    <span class="comment">//1 3 4 2 2实际上是对【1,2,3,4】区间进行二分</span></span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=count(nums,mid);</span><br><span class="line">        <span class="comment">//排除中位数,小于mid的数<=mid,一定不是,说明重复元素一定在右边</span></span><br><span class="line">        <span class="keyword">if</span>(temp<=mid){ <span class="comment">//1 2 3 4</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            right=mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//n-1个整数 , 1~n有n个数     </span></span><br><span class="line"><span class="comment">//1 2 2 3 4     1~4之间, 1 2 3 4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (nums[i]<=n) {</span><br><span class="line">            res++;          </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums.length;i++)></span></right){<></span></pre></td></tr></tbody></table></figure></div><p>这样的解法还是很巧妙的，对nums数组的<strong>取值范围</strong>进行二分，二分的核心就是，nums数组中，小于取值范围中mid的元素应该小于等于mid</p><p>举个例子：<code>[1 3 4 2 2]</code> 取值范围是<code>[1 2 3 4]</code> ，取中点2，正常情况下nums中小于等于2的元素，应该最多有2个，也就是<code>[1 2]</code>2个，但是这里在nums中，有3个<code>[1 2 2]</code> 大于2了，这就说明一定有重复的元素，而且一定是小于中点2的，也就是在左半边，下一步就应该舍弃右半边，在<code>[1,2]</code>中继续查找 </p><p>这里按照我们之前的模板来写，先找排除mid的条件，<strong>在nums中小于mid的元素的数量小于等于mid的时候，包括mid在内的右边界都会被排除，肯定都不是重复的元素</strong> ，然后就按照模板写出二分就行了</p><p><strong>解法二</strong></p><p>快慢指针的做法，技巧性很强，一般人第一次做是很难想到这种做法的，其实和 <a href="http://imlgw.top/2019/02/27/leetcode-lian-biao-tag/#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">链表专题</a> 中的环形链表是一样的做法，然后按照那个思路走就行了，不清楚原理可以看看上面环形链表的解法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> slow=<span class="number">0</span>,fast=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isMeet=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">        fast=isMeet?nums[fast]:nums[nums[fast]];</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        <span class="keyword">if</span> (fast==slow) {</span><br><span class="line">            <span class="keyword">if</span> (isMeet) {</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            }</span><br><span class="line">            fast=<span class="number">0</span>;</span><br><span class="line">            isMeet=<span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种解法的关键是将数组值看作索引然后再数组像链表一样移动，比如 <code>[1,2,3,4,5,6,7,8,9,5]</code>用值作为索引连接起来就是<code>1 2 3 4 [5 6 7 8 9] [5 6 7 8 9] ....</code> ，时间复杂度<code>O(N)</code> 技巧性比较强，如果面试管不追问的话其实答出上面的二分就ok了</p><h2 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852. 山脉数组的峰顶索引"></a><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">852. 山脉数组的峰顶索引</a></h2><p>我们把符合下列属性的数组 A 称作山脉：</p><ul><li>A.length >= 3</li><li>存在 0 < i < A.length - 1 使得A[0] < A[1] < … A[i-1] < A[i] > A[i+1] > … > A[A.length - 1]</li></ul><p>给定一个确定为山脉的数组，返回任何满足 <code>A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]</code> 的 i 的值。</p><p> <strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>其实还是上面的模板，只不过做了一点点改动而已，很傻逼的WA了一发，我也是服了自己了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=A.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//System.out.println(mid);</span></span><br><span class="line">        <span class="keyword">if</span> (mid><span class="number">0</span> && mid<a.length && a[mid]> A[mid-<span class="number">1</span>] && A[mid]<a[mid+<span class="number">1</a[mid+<span></a.length></span>]) {</right){<></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (mid><span class="number">0</span> && mid<a.length && a[mid]< a[mid-<span class="number">1</a.length></span>] && A[mid]>A[mid+<span class="number">1</span>]){<br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="1283-使结果不超过阈值的最小除数"><a href="#1283-使结果不超过阈值的最小除数" class="headerlink" title="1283. 使结果不超过阈值的最小除数"></a><a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/" target="_blank" rel="noopener">1283. 使结果不超过阈值的最小除数</a></h2><p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>threshold</code>  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</p><p>请你找出能够使上述结果小于等于阈值 <code>threshold</code> 的除数中 最小 的那个。</p><p>每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。</p><p>题目保证一定有解。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>], threshold = <span class="number">6</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：如果除数为 <span class="number">1</span> ，我们可以得到和为 <span class="number">17</span> （<span class="number">1</span>+<span class="number">2</span>+<span class="number">5</span>+<span class="number">9</span>）。</span><br><span class="line">如果除数为 <span class="number">4</span> ，我们可以得到和为 <span class="number">7</span> (<span class="number">1</span>+<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>) 。如果除数为 <span class="number">5</span> ，和为 <span class="number">5</span> (<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">2</span>)。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>], threshold = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">19</span>], threshold = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= nums.length <= 5 * 10^4</code></li><li><code>1 <= nums[i] <= 10^6</code></li><li><code>nums.length <= threshold <= 10^6</code></li></ul><p><strong>解法一</strong></p><p>周赛的题，太蠢了，没做出来。。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDivisor</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> threshold)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">            sum+=(nums[i]+mid-<span class="number">1</span>)/mid; <span class="comment">//向上取整</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum>threshold) {</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            right=mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br></nums.length;i++)></span></right){<></span></pre></td></tr></tbody></table></figure></div><p>其实只要明确一点这题就很容易想到二分，解空间为：<code>[1，max(nums[i])]</code> 我们只需要在这个区间之内做二分搜索就ok了，再然后就是向上取整的一个小技巧</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和优先队列</title>
      <link href="/2019/12/01/dui-he-you-xian-dui-lie/"/>
      <url>/2019/12/01/dui-he-you-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>首先我们要明白，堆实际上是一颗完全二叉树，借助<strong>完全二叉树</strong>父子节点关系的性质，我们就可以很方便的在数组中实现这一结构，而堆也分为两种，一种是大根堆，顾名思义也就是父节点value大于子节点value，小根堆则相反</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>借助这个类实现堆结构，直接用<code>ArrayList</code>也可以</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span><<span class="title">E</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，传入数组的容量capacity构造Array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>{</span><br><span class="line">        data = (E[])<span class="keyword">new</span> Object[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造函数，默认数组的容量capacity=10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数组是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在index索引的位置插入一个新元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(index < <span class="number">0</span> || index > size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Add failed. Require index >= 0 and index <= size."</span>);</span><br><span class="line">        <span class="keyword">if</span>(size == data.length)</span><br><span class="line">            resize(<span class="number">2</span> * data.length); <span class="comment">//2倍扩容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">1</span>; i >= index ; i --){</span><br><span class="line">            data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">        }</span><br><span class="line">        data[index] = e;</span><br><span class="line">        size ++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向所有元素后添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>{</span><br><span class="line">        add(size, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有元素前添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>{</span><br><span class="line">        add(<span class="number">0</span>, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取index索引位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(index < <span class="number">0</span> || index >= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Get failed. Index is illegal."</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改index索引位置的元素为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(index < <span class="number">0</span> || index >= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Set failed. Index is illegal."</span>);</span><br><span class="line">        data[index] = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找数组中是否有元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i < size ; i ++){</span><br><span class="line">            <span class="keyword">if</span>(data[i].equals(e))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i < size ; i ++){</span><br><span class="line">            <span class="keyword">if</span>(data[i].equals(e))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除index位置的元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(index < <span class="number">0</span> || index >= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Remove failed. Index is illegal."</span>);</span><br><span class="line"></span><br><span class="line">        E ret = data[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span> ; i < size ; i ++)</span><br><span class="line">            data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">        size --;</span><br><span class="line">        data[size] = <span class="keyword">null</span>; <span class="comment">// loitering objects != memory leak</span></span><br><span class="line">        <span class="comment">//数据不到1/4的时候缩减</span></span><br><span class="line">        <span class="keyword">if</span>(size == data.length / <span class="number">4</span> && data.length / <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除第一个元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除最后一个元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> index = find(e);</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)</span><br><span class="line">            remove(index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (a<<span class="number">0</span>||a>=size || b<<span class="number">0</span>||b>=size) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index illegal"</span>);</span><br><span class="line">        }</span><br><span class="line">        E temp=data[a];</span><br><span class="line">        data[a]=data[b];</span><br><span class="line">        data[b]=temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(String.format(<span class="string">"Array: size = %d , capacity = %d\n"</span>, size, data.length));</span><br><span class="line">        res.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i < size ; i ++){</span><br><span class="line">            res.append(data[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != size - <span class="number">1</span>)</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">        }</span><br><span class="line">        res.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组空间的容量变成newCapacity大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>{</span><br><span class="line">        E[] newData = (E[])<span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i < size ; i ++)</span><br><span class="line">            newData[i] = data[i];</span><br><span class="line">        data = newData;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span><<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span><<span class="title">E</span>>></span>{</span><br><span class="line">    <span class="keyword">private</span> Array<e> data;</e></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>{</span><br><span class="line">        data=<span class="keyword">new</span> Array<>(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>{</span><br><span class="line">        data=<span class="keyword">new</span> Array<>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> data.getSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index==<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index 0 don't have parent"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>{</span><br><span class="line">        data.addLast(e);</span><br><span class="line">        siftUp(data.getSize()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> cur)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(cur><span class="number">0</span> && data.get(parent(cur)).compareTo(data.get(cur)) < <span class="number">0</span>){</span><br><span class="line">            data.swap(cur,parent(cur));</span><br><span class="line">            cur=parent(cur);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">findMax</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (data.getSize()==<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"heap is empty !!!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>  data.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">popMax</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (data.getSize()==<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"heap is empty !!!"</span>);</span><br><span class="line">        }</span><br><span class="line">        E res=findMax();</span><br><span class="line">        data.swap(<span class="number">0</span>,data.getSize()-<span class="number">1</span>);</span><br><span class="line">        data.removeLast();</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> cur)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(leftChild(cur)<data.getsize()){ <span class="comment">//有左孩子</data.getsize()){></span><br><span class="line">            <span class="keyword">int</span> large=leftChild(cur);</span><br><span class="line">            <span class="comment">//如果也有右孩子,就比较下两个节点的值取最大值</span></span><br><span class="line">            <span class="keyword">if</span> (large+<span class="number">1</span><data.getsize() && data.get(large).compareto(data.get(large+<span class="number">1</data.getsize()></span>))<<span class="number">0</span>) {<br><span class="line">                large=large+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//比左右孩子都大就直接结束了</span></span><br><span class="line">            <span class="keyword">if</span> (data.get(large).compareTo(data.get(cur))<=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            data.swap(large,cur);</span><br><span class="line">            cur=large;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实上面的实现还是有一些缺陷的，只能按照给定的键的默认排序规则进行比较，不方便实现自定义的比较规则，需要进行封装才可以，关于这一点其实可以借鉴Java中的<code>PriorityQueue</code></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] nums=generateRandomArray(<span class="number">50000000</span>,<span class="number">500</span>);</span><br><span class="line">        MaxHeap heap=<span class="keyword">new</span> MaxHeap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">            heap.add(nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">            nums[i]=(<span class="keyword">int</span>)heap.popMax();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">            <span class="keyword">if</span> (nums[i-<span class="number">1</span>]<nums[i]) {< span><br><span class="line">                System.out.println(<span class="string">"fuxk!!!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"sucess!!!!!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) {</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr.length; i++) {</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) (maxValue * Math.random());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums[i])></span></nums.length;i++)></span></nums.length;i++)></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SharedSecrets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An unbounded priority {<span class="doctag">@linkplain</span> Queue queue} based on a priority heap.</span></span><br><span class="line"><span class="comment"> * The elements of the priority queue are ordered according to their</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@linkplain</span> Comparable natural ordering}, or by a {<span class="doctag">@link</span> Comparator}</span></span><br><span class="line"><span class="comment"> * provided at queue construction time, depending on which constructor is</span></span><br><span class="line"><span class="comment"> * used.  A priority queue does not permit {<span class="doctag">@code</span> null} elements.</span></span><br><span class="line"><span class="comment"> * A priority queue relying on natural ordering also does not permit</span></span><br><span class="line"><span class="comment"> * insertion of non-comparable objects (doing so may result in</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> ClassCastException}).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <p>The <em>head</em> of this queue is the <em>least</em> element<br><span class="line"><span class="comment"> * with respect to the specified ordering.  If multiple elements are</span></span><br><span class="line"><span class="comment"> * tied for least value, the head is one of those elements -- ties are</span></span><br><span class="line"><span class="comment"> * broken arbitrarily.  The queue retrieval operations {<span class="doctag">@code</span> poll},</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> remove}, {<span class="doctag">@code</span> peek}, and {<span class="doctag">@code</span> element} access the</span></span><br><span class="line"><span class="comment"> * element at the head of the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span></p><p>A priority queue is unbounded, but has an internal<br><span class="line"><span class="comment"> * <i>capacity</i> governing the size of an array used to store the</span></span><br><span class="line"><span class="comment"> * elements on the queue.  It is always at least as large as the queue</span></span><br><span class="line"><span class="comment"> * size.  As elements are added to a priority queue, its capacity</span></span><br><span class="line"><span class="comment"> * grows automatically.  The details of the growth policy are not</span></span><br><span class="line"><span class="comment"> * specified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span></p><p>This class and its iterator implement all of the<br><span class="line"><span class="comment"> * <em>optional</em> methods of the {<span class="doctag">@link</span> Collection} and {<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Iterator} interfaces.  The Iterator provided in method {<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #iterator()} is <em>not</em> guaranteed to traverse the elements of</span></span><br><span class="line"><span class="comment"> * the priority queue in any particular order. If you need ordered</span></span><br><span class="line"><span class="comment"> * traversal, consider using {<span class="doctag">@code</span> Arrays.sort(pq.toArray())}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span></p><p><strong>Note that this implementation is not synchronized.</strong><br><span class="line"><span class="comment"> * Multiple threads should not access a {<span class="doctag">@code</span> PriorityQueue}</span></span><br><span class="line"><span class="comment"> * instance concurrently if any of the threads modifies the queue.</span></span><br><span class="line"><span class="comment"> * Instead, use the thread-safe {<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.util.concurrent.PriorityBlockingQueue} class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span></p><p>Implementation note: this implementation provides<br><span class="line"><span class="comment"> * O(log(n)) time for the enqueuing and dequeuing methods</span></span><br><span class="line"><span class="comment"> * ({<span class="doctag">@code</span> offer}, {<span class="doctag">@code</span> poll}, {<span class="doctag">@code</span> remove()} and {<span class="doctag">@code</span> add});</span></span><br><span class="line"><span class="comment"> * linear time for the {<span class="doctag">@code</span> remove(Object)} and {<span class="doctag">@code</span> contains(Object)}</span></span><br><span class="line"><span class="comment"> * methods; and constant time for the retrieval methods</span></span><br><span class="line"><span class="comment"> * ({<span class="doctag">@code</span> peek}, {<span class="doctag">@code</span> element}, and {<span class="doctag">@code</span> size}).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span></p><p>This class is a member of the<br><span class="line"><span class="comment"> * <a href="{<span class=" doctag">@docRoot</a></span><a href="{<span class=" doctag">}/../technotes/guides/collections/index.html"></a></span><a href="{<span class=" doctag"><br><span class="line"><span class="comment"> * Java Collections Framework</span></span></a>.<br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch, Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <e> the type of elements held in this collection</e></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span><<span class="title">E</span>> <span class="keyword">extends</span> <span class="title">AbstractQueue</span><<span class="title">E</span>></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7720805057305804111L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Priority queue represented as a balanced binary heap: the two</span></span><br><span class="line"><span class="comment">     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span></span><br><span class="line"><span class="comment">     * priority queue is ordered by comparator, or by the elements'</span></span><br><span class="line"><span class="comment">     * natural ordering, if comparator is null: For each node n in the</span></span><br><span class="line"><span class="comment">     * heap and each descendant d of n, n <= d.  The element with the</span></span><br><span class="line"><span class="comment">     * lowest value is in queue[0], assuming the queue is nonempty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of elements in the priority queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The comparator, or null if priority queue uses elements'</span></span><br><span class="line"><span class="comment">     * natural ordering.</span></span><br><span class="line"><span class="comment">     * 如果没有传入比较器的话，按照元素的自然排序进行比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator<!--? <span class="keyword"-->super</span> E> comparator;<br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this priority queue has been</span></span><br><span class="line"><span class="comment">     * <i>structurally modified</i>.  See AbstractList for gory details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a {<span class="doctag">@code</span> PriorityQueue} with the default initial</span></span><br><span class="line"><span class="comment">     * capacity (11) that orders its elements according to their</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@linkplain</span> Comparable natural ordering}.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入自定义的比较规则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator<!--? <span class="keyword"-->super</span> E> comparator)</span> </span>{<br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator<!--? <span class="keyword"-->super</span> E> comparator)</span> </span>{<br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity < <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a {<span class="doctag">@code</span> PriorityQueue} containing the elements in the</span></span><br><span class="line"><span class="comment">     * specified collection.  If the specified collection is an instance of</span></span><br><span class="line"><span class="comment">     * a {<span class="doctag">@link</span> SortedSet} or is another {<span class="doctag">@code</span> PriorityQueue}, this</span></span><br><span class="line"><span class="comment">     * priority queue will be ordered according to the same ordering.</span></span><br><span class="line"><span class="comment">     * Otherwise, this priority queue will be ordered according to the</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@linkplain</span> Comparable natural ordering} of its elements.</span></span><br><span class="line"><span class="comment">     * 传入一个集合类型，如果是SortSet（有序）类型的集合或者也是PriorityQueue就会按照相同的规则去比较。</span></span><br><span class="line"><span class="comment">     * 否则就会按照元素的自然排序规则去比较。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed</span></span><br><span class="line"><span class="comment">     *         into this priority queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if elements of the specified collection</span></span><br><span class="line"><span class="comment">     *         cannot be compared to one another according to the priority</span></span><br><span class="line"><span class="comment">     *         queue's ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment">     *         of its elements are null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection<!--? extends E--> c)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet<!--?-->) {</span><br><span class="line">            SortedSet<!--? extends E--> ss = (SortedSet<!--? extends E-->) c;</span><br><span class="line">            <span class="comment">//拿到SortSet集合中元素的比较器，用于后序的操作</span></span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator<!--? <span class="keyword"-->super</span> E>) ss.comparator();<br><span class="line">            initElementsFromCollection(ss);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue<!--?-->) {</span><br><span class="line">            PriorityQueue<!--? extends E--> pq = (PriorityQueue<!--? extends E-->) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator<!--? <span class="keyword"-->super</span> E>) pq.comparator();<br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a {<span class="doctag">@code</span> PriorityQueue} containing the elements in the</span></span><br><span class="line"><span class="comment">     * specified priority queue.  This priority queue will be</span></span><br><span class="line"><span class="comment">     * ordered according to the same ordering as the given priority</span></span><br><span class="line"><span class="comment">     * queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the priority queue whose elements are to be placed</span></span><br><span class="line"><span class="comment">     *         into this priority queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if elements of {<span class="doctag">@code</span> c} cannot be</span></span><br><span class="line"><span class="comment">     *         compared to one another according to {<span class="doctag">@code</span> c}'s</span></span><br><span class="line"><span class="comment">     *         ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified priority queue or any</span></span><br><span class="line"><span class="comment">     *         of its elements are null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue<!--? extends E--> c)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator<!--? <span class="keyword"-->super</span> E>) c.comparator();<br><span class="line">        initFromPriorityQueue(c);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a {<span class="doctag">@code</span> PriorityQueue} containing the elements in the</span></span><br><span class="line"><span class="comment">     * specified sorted set.   This priority queue will be ordered</span></span><br><span class="line"><span class="comment">     * according to the same ordering as the given sorted set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the sorted set whose elements are to be placed</span></span><br><span class="line"><span class="comment">     *         into this priority queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if elements of the specified sorted</span></span><br><span class="line"><span class="comment">     *         set cannot be compared to one another according to the</span></span><br><span class="line"><span class="comment">     *         sorted set's ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified sorted set or any</span></span><br><span class="line"><span class="comment">     *         of its elements are null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet<!--? extends E--> c)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator<!--? <span class="keyword"-->super</span> E>) c.comparator();<br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromPriorityQueue</span><span class="params">(PriorityQueue<!--? extends E--> c)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == PriorityQueue<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">            <span class="keyword">this</span>.queue = c.toArray();</span><br><span class="line">            <span class="keyword">this</span>.size = c.size();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//从SortSet有序集合中的元素直接复制到当前的queue中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection<!--? extends E--> c)</span> </span>{</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">        <span class="keyword">if</span> (a.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">a</span> </span>= Arrays.copyOf(a, a.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.queue = a;</span><br><span class="line">        <span class="keyword">this</span>.size = a.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes queue array with elements from the given Collection.</span></span><br><span class="line"><span class="comment">     * 从无序集合中构建queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection<!--? extends E--> c)</span> </span>{</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">        <span class="comment">//复制完成之后进行调整</span></span><br><span class="line">        heapify();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity of the array.</span></span><br><span class="line"><span class="comment">     * queue 数组扩容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity < <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity >> <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE > <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (minCapacity < <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity > MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this priority queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the specified element cannot be</span></span><br><span class="line"><span class="comment">     *         compared with elements currently in this priority queue</span></span><br><span class="line"><span class="comment">     *         according to the priority queue's ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this priority queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Queue#offer})</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the specified element cannot be</span></span><br><span class="line"><span class="comment">     *         compared with elements currently in this priority queue</span></span><br><span class="line"><span class="comment">     *         according to the priority queue's ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i >= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes a single instance of the specified element from this queue,</span></span><br><span class="line"><span class="comment">     * if it is present.  More formally, removes an element {<span class="doctag">@code</span> e} such</span></span><br><span class="line"><span class="comment">     * that {<span class="doctag">@code</span> o.equals(e)}, if this queue contains one or more such</span></span><br><span class="line"><span class="comment">     * elements.  Returns {<span class="doctag">@code</span> true} if and only if this queue contained</span></span><br><span class="line"><span class="comment">     * the specified element (or equivalently, if this queue changed as a</span></span><br><span class="line"><span class="comment">     * result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this queue, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this queue changed as a result of the call</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            removeAt(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version of remove using reference equality, not equals.</span></span><br><span class="line"><span class="comment">     * Needed by iterator.remove.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this queue, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if removed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeEq</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; i++) {</span><br><span class="line">            <span class="keyword">if</span> (o == queue[i]) {</span><br><span class="line">                removeAt(i);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() {</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(queue, size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <t> T[] toArray(T[] a) {</t></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">if</span> (a.length < size)</span><br><span class="line">            <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(queue, size, a.getClass());</span><br><span class="line">        System.arraycopy(queue, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length > size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator<e> <span class="title">iterator</span><span class="params">()</span> </e></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span><<span class="title">E</span>> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index (into queue array) of element to be returned by</span></span><br><span class="line"><span class="comment">         * subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next,</span></span><br><span class="line"><span class="comment">         * unless that element came from the forgetMeNot list.</span></span><br><span class="line"><span class="comment">         * Set to -1 if element is deleted by a call to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ArrayDeque<e> forgetMeNot = <span class="keyword">null</span>;</e></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Element returned by the most recent call to next iff that</span></span><br><span class="line"><span class="comment">         * element was drawn from the forgetMeNot list.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> E lastRetElt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * Queue should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> cursor < size ||</span><br><span class="line">                (forgetMeNot != <span class="keyword">null</span> && !forgetMeNot.isEmpty());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (cursor < size)</span><br><span class="line">                <span class="keyword">return</span> (E) queue[lastRet = cursor++];</span><br><span class="line">            <span class="keyword">if</span> (forgetMeNot != <span class="keyword">null</span>) {</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                lastRetElt = forgetMeNot.poll();</span><br><span class="line">                <span class="keyword">if</span> (lastRetElt != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> lastRetElt;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (lastRet != -<span class="number">1</span>) {</span><br><span class="line">                E moved = PriorityQueue.<span class="keyword">this</span>.removeAt(lastRet);</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (moved == <span class="keyword">null</span>)</span><br><span class="line">                    cursor--;</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (forgetMeNot == <span class="keyword">null</span>)</span><br><span class="line">                        forgetMeNot = <span class="keyword">new</span> ArrayDeque<>();</span><br><span class="line">                    forgetMeNot.add(moved);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (lastRetElt != <span class="keyword">null</span>) {</span><br><span class="line">                PriorityQueue.<span class="keyword">this</span>.removeEq(lastRetElt);</span><br><span class="line">                lastRetElt = <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            }</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; i++)</span><br><span class="line">            queue[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">        E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the ith element from queue.</span></span><br><span class="line"><span class="comment">     * 删除某个位置的元素</span></span><br><span class="line"><span class="comment">     * Normally this method leaves the elements at up to i-1,</span></span><br><span class="line"><span class="comment">     * inclusive, untouched.  Under these circumstances, it returns</span></span><br><span class="line"><span class="comment">     * null.  Occasionally, in order to maintain the heap invariant,</span></span><br><span class="line"><span class="comment">     * it must swap a later element of the list with one earlier than</span></span><br><span class="line"><span class="comment">     * i.  Under these circumstances, this method returns the element</span></span><br><span class="line"><span class="comment">     * that was previously at the end of the list and is now at some</span></span><br><span class="line"><span class="comment">     * position before i. This fact is used by iterator.remove so as to</span></span><br><span class="line"><span class="comment">     * avoid missing traversing elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        <span class="comment">// assert i >= 0 && i < size;</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        <span class="keyword">if</span> (s == i) <span class="comment">// removed last element 移除最后一个元素</span></span><br><span class="line">            queue[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            E moved = (E) queue[s]; <span class="comment">//保存队列尾部的元素</span></span><br><span class="line">            queue[s] = <span class="keyword">null</span>; <span class="comment">//置为null</span></span><br><span class="line">            siftDown(i, moved); <span class="comment">//moved直接插入到i位置，相当于直接删除了i位置的元素</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == moved) {</span><br><span class="line">                siftUp(i, moved);</span><br><span class="line">                <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                    <span class="keyword">return</span> moved;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts item x at position k, maintaining heap invariant by</span></span><br><span class="line"><span class="comment">     * promoting x up the tree until it is greater than or equal to</span></span><br><span class="line"><span class="comment">     * its parent, or is the root.</span></span><br><span class="line"><span class="comment">     * 将x插入k位置，并进行上浮调整</span></span><br><span class="line"><span class="comment">     * To simplify and speed up coercions and comparisons. the</span></span><br><span class="line"><span class="comment">     * Comparable and Comparator versions are separated into different</span></span><br><span class="line"><span class="comment">     * methods that are otherwise identical. (Similarly for siftDown.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k the position to fill</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the item to insert</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">        Comparable<!--? <span class="keyword"-->super</span> E> key = (Comparable<!--? <span class="keyword"-->super E>) x;<br><span class="line">        <span class="keyword">while</span> (k > <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) >>> <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) >= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        }</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (k > <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) >>> <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) >= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        }</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts item x at position k, maintaining heap invariant by</span></span><br><span class="line"><span class="comment">     * demoting x down the tree repeatedly until it is less than or</span></span><br><span class="line"><span class="comment">     * equal to its children or is a leaf.</span></span><br><span class="line"><span class="comment">     * 插入元素x到到位置k,并进行下沉调整</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k the position to fill</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the item to insert</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);  <span class="comment">//带比较器的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x); <span class="comment">//不带比较器，用x的compator</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">        Comparable<!--? <span class="keyword"-->super</span> E> key = (Comparable<!--? <span class="keyword"-->super E>)x;<br><span class="line">        <span class="keyword">int</span> half = size >>> <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="keyword">while</span> (k < half) {</span><br><span class="line">            <span class="keyword">int</span> child = (k << <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right < size &&</span><br><span class="line">                ((Comparable<!--? <span class="keyword"-->super</span> E>) c).compareTo((E) queue[right]) > <span class="number">0</span>)<br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) <= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        }</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> half = size >>> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k < half) {</span><br><span class="line">            <span class="keyword">int</span> child = (k << <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right < size &&</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) > <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) <= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        }</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Establishes the heap invariant (described above) in the entire tree,</span></span><br><span class="line"><span class="comment">     * assuming nothing about the order of the elements prior to the call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (size >>> <span class="number">1</span>) - <span class="number">1</span>; i >= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparator<!--? <span class="keyword"-->super</span> E> comparator() {<br><span class="line">        <span class="keyword">return</span> comparator;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Saves this queue to a stream (that is, serializes it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The length of the array backing the instance is</span></span><br><span class="line"><span class="comment">     *             emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment">     *             (each an {<span class="doctag">@code</span> Object}) in the proper order.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>{</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out array length, for compatibility with 1.5 version</span></span><br><span class="line">        s.writeInt(Math.max(<span class="number">2</span>, size + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the "proper order".</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; i++)</span><br><span class="line">            s.writeObject(queue[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes the {<span class="doctag">@code</span> PriorityQueue} instance from a stream</span></span><br><span class="line"><span class="comment">     * (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in (and discard) array length</span></span><br><span class="line">        s.readInt();</span><br><span class="line"></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">size</span>)</span>;</span><br><span class="line">        queue = <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; i++)</span><br><span class="line">            queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Elements are guaranteed to be in "proper order", but the</span></span><br><span class="line">        <span class="comment">// spec has never explained what that might be.</span></span><br><span class="line">        heapify();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a <em><a href="Spliterator.html#binding">late-binding</a></em></span></span><br><span class="line"><span class="comment">     * and <em>fail-fast</em> {<span class="doctag">@link</span> Spliterator} over the elements in this</span></span><br><span class="line"><span class="comment">     * queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span></p><p>The {<span class="doctag">@code</span> Spliterator} reports {<span class="doctag">@link</span> Spliterator#SIZED},<br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> Spliterator#SUBSIZED}, and {<span class="doctag">@link</span> Spliterator#NONNULL}.</span></span><br><span class="line"><span class="comment">     * Overriding implementations should document the reporting of additional</span></span><br><span class="line"><span class="comment">     * characteristic values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a {<span class="doctag">@code</span> Spliterator} over the elements in this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator<e> <span class="title">spliterator</span><span class="params">()</span> </e></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PriorityQueueSpliterator<e>(<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</e></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueSpliterator</span><<span class="title">E</span>> <span class="keyword">implements</span> <span class="title">Spliterator</span><<span class="title">E</span>> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This is very similar to ArrayList Spliterator, except for</span></span><br><span class="line"><span class="comment">         * extra null checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue<e> pq;</e></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;            <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fence;            <span class="comment">// -1 until first use</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount; <span class="comment">// initialized when fence set</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Creates new spliterator covering the given range */</span></span><br><span class="line">        PriorityQueueSpliterator(PriorityQueue<e> pq, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence,</e></span><br><span class="line">                             <span class="keyword">int</span> expectedModCount) {</span><br><span class="line">            <span class="keyword">this</span>.pq = pq;</span><br><span class="line">            <span class="keyword">this</span>.index = origin;</span><br><span class="line">            <span class="keyword">this</span>.fence = fence;</span><br><span class="line">            <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>{ <span class="comment">// initialize fence to size on first use</span></span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) < <span class="number">0</span>) {</span><br><span class="line">                expectedModCount = pq.modCount;</span><br><span class="line">                hi = fence = pq.size;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> hi;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PriorityQueueSpliterator<e> <span class="title">trySplit</span><span class="params">()</span> </e></span>{</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) >>> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo >= mid) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> PriorityQueueSpliterator<e>(pq, lo, index = mid,</e></span><br><span class="line">                                                expectedModCount);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer<!--? <span class="keyword"-->super</span> E> action)</span> </span>{<br><span class="line">            <span class="keyword">int</span> i, hi, mc; <span class="comment">// hoist accesses and checks from loop</span></span><br><span class="line">            PriorityQueue<e> q; Object[] a;</e></span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> ((q = pq) != <span class="keyword">null</span> && (a = q.queue) != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> ((hi = fence) < <span class="number">0</span>) {</span><br><span class="line">                    mc = q.modCount;</span><br><span class="line">                    hi = q.size;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    mc = expectedModCount;</span><br><span class="line">                <span class="keyword">if</span> ((i = index) >= <span class="number">0</span> && (index = hi) <= a.length) {</span><br><span class="line">                    <span class="keyword">for</span> (E e;; ++i) {</span><br><span class="line">                        <span class="keyword">if</span> (i < hi) {</span><br><span class="line">                            <span class="keyword">if</span> ((e = (E) a[i]) == <span class="keyword">null</span>) <span class="comment">// must be CME</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            action.accept(e);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (q.modCount != mc)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer<!--? <span class="keyword"-->super</span> E> action)</span> </span>{<br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index;</span><br><span class="line">            <span class="keyword">if</span> (lo >= <span class="number">0</span> && lo < hi) {</span><br><span class="line">                index = lo + <span class="number">1</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E)pq.queue[lo];</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                action.accept(e);</span><br><span class="line">                <span class="keyword">if</span> (pq.modCount != expectedModCount)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">long</span>) (getFence() - index);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.NONNULL;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></p></span></span></pre></td></tr></tbody></table></figure></div><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>d叉堆</strong>：多叉堆，上面我们实现的都是二叉堆，但是其实我们还可以将其扩展为多叉堆，一个节点有多个子节点</p><p><strong>索引堆</strong>：我们上面实现的二叉堆只能看见堆顶的元素，看不到堆中的元素，有时候我们可能需要操作堆中间的元素，索引堆顾名思义就是有索引可以对应每个元素，借此就可以操作堆中间的元素</p><p><strong>二项堆</strong>，<strong>斐波拉契堆</strong> ….. 这些结构其实都是扩展的，简单了解即可</p><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p><a href="https://github.com/imlgw/LeetCode/blob/master/tree/heap/MaxHeap.java" target="_blank" rel="noopener">Github</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode背包问题</title>
      <link href="/2019/11/29/leetcode-bei-bao-wen-ti/"/>
      <url>/2019/11/29/leetcode-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><blockquote><p>从<a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/">动态规划专题</a> 中抽取出来的</p></blockquote><h2 id="92-背包问题（lintCode）"><a href="#92-背包问题（lintCode）" class="headerlink" title="92.背包问题（lintCode）"></a><a href="https://www.lintcode.com/problem/backpack/description" target="_blank" rel="noopener">92.背包问题（lintCode）</a></h2><p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p><ul><li>你不可以将物品进行切割</li></ul><p><strong>样例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">样例 <span class="number">1</span>:</span><br><span class="line">输入:  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>], backpack size=<span class="number">10</span></span><br><span class="line">输出:  <span class="number">9</span></span><br><span class="line">样例 <span class="number">2</span>:</span><br><span class="line">输入:  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], backpack size=<span class="number">12</span></span><br><span class="line">输出:  <span class="number">12</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>挑战</strong></p><ul><li><p>O(n x m) time and O(m) memory.</p></li><li><p>O(n x m) memory is also acceptable if you do not know how to optimize memory.</p></li></ul><p><strong>解法一</strong></p><p>记忆化递归，对于每个元素，有两种选择，装或者不装🤣 （不知道为啥这么经典的题目LeetCode上居然没有</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//用Integer[][],空间会超空间。。。lintCode好严格</span></span><br><span class="line"><span class="keyword">int</span> [][] cache=<span class="keyword">null</span>;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack2</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    cache=<span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<a.length;i++) {< span><br><span class="line">        Arrays.fill(cache[i],-<span class="number">1</span>);   </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="keyword">null</span> || A.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> putPack(m,A,A.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将A[index,A.len-1]范围内的元素装进大小为m的背包的最大收益</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">putPack</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="comment">//index==0的时候不应该返回=0代表第一个,是可以装的</span></span><br><span class="line">    <span class="comment">//对于m也是一样, 这种边界思考一下m就等于0，或者就只有一个元素，index就等于0这种特例就可以</span></span><br><span class="line">    <span class="comment">//只要这种特例是正确的那么整个递归就是正确的,并不需要去思考整个递归的结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (index<<span class="number">0</span> || m<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index][m]!=-<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][m];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//不装index位置的元素</span></span><br><span class="line">    <span class="keyword">int</span> res=putPack(m,A,index-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (A[index]<=m) {</span><br><span class="line">        <span class="comment">//说明可以装下index位置的元素，所以我们将index位置的元素装进去试试看</span></span><br><span class="line">        <span class="comment">//然后求出剩下的空间还最多能装多少，最后求是装index收益大还是不装index收益大</span></span><br><span class="line">        res=Math.max(res,A[index]+putPack(m-A[index],A,index-<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    cache[index][m]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></a.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>暴力递归的时间复杂度将会是<code>O((2^N)*N)</code></p><p>其实整个递归的思路是很清晰明白的，对于每个元素，有两种情况，这也是之所以称之为0-1背包的原因</p><ul><li>不选的话，背包的容量不变，改变为问题<code>putPack(m,A,index-1)</code></li><li>选的话，背包的容量变小，改变为问题<code>putPack(m-A[index],A,index-1)+A[index]</code></li></ul><p>到底选还是不选，取决于两种方案哪一种更好，我们要求的，就是这个最好的方案，知道了这样的递推关系后我们就可以很容易的写出递归方程，这里在递归的过程中有可能会产生重叠的子问题（其实这里我还纠结了好一会儿，我一直感觉没有重叠的子问题，后来画一下递归树就明白了，只是重叠的不明显），所以我们可以通过缓存每次计算的结果来进行记忆化递归，整体的时间复杂度应该是<code>O(2^N)</code>，空间<code>O(M*N)</code>显然不是我们想要的结果</p><blockquote><p>这里一开始我是想用<code>Integer[][]</code>的数组，然后就不用赋初始值，判断不为null就行，结果空间溢出了。。。lintCode好严格，换成<code>int[][]</code>然后赋个初始值就过了</p></blockquote><p><strong>解法二</strong></p><p>动态规划解法，在讲解之前，我们用一个二维表来分析下整个递推的过程</p><p>物品列表（样例1），因为这题价值就是重量，所以w和v是一样的</p><table><thead><tr><th>index</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>w</td><td>3</td><td>4</td><td>8</td><td>5</td></tr><tr><td>v</td><td>3</td><td>4</td><td>8</td><td>5</td></tr></tbody></table><p>DpTable（样例1）</p><table><thead><tr><th align="center">index\m</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td align="center">0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td align="center">1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>4</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td align="center">2</td><td>0</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>4</td><td>7</td><td>8</td><td>8</td><td>8</td></tr><tr><td align="center">3</td><td>0</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>5</td><td>7</td><td>8</td><td>9</td><td>9</td></tr></tbody></table><p>一行一行的看，从左到右，<code>dp[index][m]</code>代表 <strong>背包总容量不超过m的情况下，考虑装入<code>[0,index]</code>中的元素能获得最大收益</strong>，比如<code>dp[1][7]</code>代表的就是背包总容量不超过7的情况下，考虑装入<code>[0,1]</code> 范围内的元素所能获得的最大收益，人脑思考结果自然是7了，下面我们分析下如果dp推出这个结果</p><p>前面我们已经分析过0-1背包的递归过程，每个元素面临两个选择，这里也一样</p><p><code>dp[1][7]</code>如果我们选择不装入当前index位置的元素的话，那么最大收益就是<code>dp[0][7]=3</code>这一点应该没啥疑问</p><p>如果我们考虑装入当前index位置的元素的话，m肯定会减小，那么所获得的最大收益就应该是<code>A[index]+dp[0][7-4]=7</code> </p><blockquote><p>注意这里当前index的值都是依赖于上一层<code>index-1</code>的计算结果的，也就是依赖于上一次<code>m,[0,index-1]</code>最大值的结果，所以我们需要手动的初始化第一层的值）</p></blockquote><p>最后我们得到的核心状态方程就是下面这样的</p><p><code>dp[index][m]=max(dp[index-1][m],A[index]+dp[index-1][j-A[index]])</code></p><p>然后我们根据这个很容易就可以写出dp的解法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//二维动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="keyword">null</span> || A.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[A.length][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<a.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=m;j++) {</span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">0</span>) {<span class="comment">//初始化第一列</span></span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) {<span class="comment">//初始化第一行</span></span><br><span class="line">                dp[i][j]=j-A[i]>=<span class="number">0</span>?A[i]:<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (i><span class="number">0</span>) {</span><br><span class="line">                dp[i][j]=j-A[i]>=<span class="number">0</span>?Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-A[i]]+A[i]):dp[i-<span class="number">1</span>][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[A.length-<span class="number">1</span>][m];</span><br><span class="line">}</span><br></a.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>当然我们肯定是不满足于这种二维的dp的，所以我们还得优化下空间，这里每一层都只依赖于上一层的结果，所以我么很容易就可以改成一维的，当然这里还有个小坑，如果直接按照上面的代码来改的话就是错的，我们先看看正确的改法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack4</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="keyword">null</span> || A.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<a.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=m;j>=<span class="number">0</span>;j--) {<span class="comment">//从右向左，避免覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">0</span>) {<span class="comment">//初始化第一列</span></span><br><span class="line">                dp[j]=<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) {<span class="comment">//初始化第一行</span></span><br><span class="line">                dp[j]= j-A[i]>=<span class="number">0</span>?A[i]:<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[j]=j-A[i]>=<span class="number">0</span>?Math.max(dp[j],dp[j-A[i]]+A[i]):dp[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">}</span><br></a.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>可以看到，我们的内层循环不再是从左往右，而是从右往左，这样的好处就是避免了<code>dp[j-A[i]]</code>已经被<code>当前层前面的元素</code>覆盖的尴尬情况，结合上面的表推一下就知道了</p><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>].</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>现在递归写起来已经有点感觉了，类似的题基本上都能写出记忆化递归的方法来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归37ms 44%,开始慢是因为stream的原因</span></span><br><span class="line">Boolean[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//int sum=Arrays.stream(nums).sum();</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e:nums) sum+=e; <span class="comment">//求和</span></span><br><span class="line">    cache=<span class="keyword">new</span> Boolean[nums.length][sum+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">2</span>!=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> partition(nums,<span class="number">0</span>,<span class="number">0</span>,sum/<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试添加[0,index]位置的元素,看能否使得half=sum (这里其实应该直接在sum上减,看能不能减为0)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> half,<span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==nums.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index][half]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][half];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (half==sum) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    cache[index][half]=partition(nums,index+<span class="number">1</span>,half,sum) || </span><br><span class="line">        (half<sum&&partition(nums,index+<span class="number">1</sum&&partition(nums,index+<span></span>,half+nums[index],sum));<br><span class="line">    <span class="keyword">return</span> cache[index][half];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>动态规划，依然是典型的背包问题，可以理解为用nums中的元素，填满sum/2容量大小的背包，递推公式</p><p> <code>dp[i][j] =dp[i-1][j] || dp[i-1][j-nums[i]]</code>  选当前元素和不选当前元素，有一个能填满就ok</p><p><code>dp[i][j]</code> 含义为：考虑<code>[0,i]</code> 范围内的元素，能否恰好装满 <code>j</code>大小的容器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//二维dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//int sum=Arrays.stream(nums).sum(); 用stream好慢</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e:nums) sum+=e; <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">2</span>!=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> half=sum/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//dp[i][j]的含义是从[0,i]中选取元素,能否刚好填满j</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length][half+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=half;j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j]= nums[<span class="number">0</span>]==j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=half;j++) {</span><br><span class="line">            dp[i][j]= j>=nums[i]?dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i]]:dp[i-<span class="number">1</span>][j];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果在某个位置（每行最后一个）已经刚好填满了就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i][half]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][half];</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>空间上的优化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e:nums) sum+=e; <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">2</span>!=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> half=sum/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//dp[j]的含义是从[0,i]中选取元素,能否刚好填满j</span></span><br><span class="line">    <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[half+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=half;j++) {</span><br><span class="line">        dp[j]= nums[<span class="number">0</span>]==j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=half;j>=nums[i];j--) {</span><br><span class="line">            <span class="comment">//dp[i][j]= j>=nums[i]?dp[i-1][j] || dp[i-1][j-nums[i]]:dp[i-1][j];</span></span><br><span class="line">            dp[j]=dp[j]||dp[j-nums[i]];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (dp[half]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[half];</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong><br>你可以认为每种硬币的数量是无限的</p><p><strong>解法一</strong></p><p>其实就是dfs，我最开始就是写的dfs只不过时间复杂度太高，没做记忆化，这里其实一开始做了记忆化也一直没跑过，一直超时，最后给的case是6249 好像也不算很大吧，然后我后来把<code>fill</code> 填充数组删了，用Integer就跑过了。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归AC 50%左右</span></span><br><span class="line"><span class="keyword">private</span> Integer[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange2</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount)</span></span>{</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//Arrays.fill(cache,-1); 这里fill直接tle了。。。。</span></span><br><span class="line">    <span class="keyword">return</span> takeCoins(coins,amount);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">takeCoins</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[amount]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[amount];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//int t1=coins(coins,amount,index+1);</span></span><br><span class="line">    <span class="keyword">int</span> res=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (amount<coins[i]) <span class="keyword">continue</coins[i])></span>;</coins.length;i++)></span><br><span class="line">        <span class="keyword">int</span> sub=takeCoins(coins,amount-coins[i]);</span><br><span class="line">        <span class="keyword">if</span> (sub!=-<span class="number">1</span>) {</span><br><span class="line">            res=Math.min(sub+<span class="number">1</span>,res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cache[amount]= res==Integer.MAX_VALUE?-<span class="number">1</span>:res;</span><br><span class="line">    <span class="keyword">return</span> cache[amount];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>动态规划，二维dp，注意这里其实和前面的背包问题就有区别了，这里实际上就是个<code>无限背包</code>问题，因为这里的硬币是无限的，每个面值的硬币都可以重复的选取</p><p><strong>DpTable</strong></p><table><thead><tr><th>Coin / Amount</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>0（1）</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>1（2）</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td><code>3</code></td><td>3</td><td>4</td><td>4</td><td>5</td><td>5</td><td>6</td></tr><tr><td>2（5）</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td><td>3</td></tr></tbody></table><p><strong>状态定义</strong></p><p>这里<code>dp[i][j]</code> 的含义为：<strong>考虑<code>[0，i]</code> 范围内的元素，能凑成 <code>j</code> 所需的最少硬币数</strong>，和之前的01背包问题状态定义没什么区别</p><p><strong>状态方程</strong></p><p>首先明确一点，这里我们对第<code>coins[i]</code>个硬币有两种选择 </p><ol><li>不拿 </li><li>拿，拿1~k个(k为硬币个数的限制，这里没有限制，所以是无穷大)</li></ol><p>进而我们可以的到状态转移的方程：</p><p><code>f[i][j] = min(f[i-1][j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)</code></p><p>但是这个方程有很多计算是重复的</p><p><code>f[i][j-c]=min(f[i-1][j-c], f[i-1][j-2*c]+1, ..., f[i-1][j-k*c]+k-1)</code></p><p>两者合并得到</p><p><code>f[i][j] = min(f[i-1]f[j], f[i][j-c]+1)</code>  有了状态方程，代码就好写了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange4</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[coins.length][amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j]=j%coins[<span class="number">0</span>]==<span class="number">0</span>?j/coins[<span class="number">0</span>]:Integer.MAX_VALUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">            <span class="keyword">if</span> (j<coins[i] || dp[i][j-coins[i]]="=Integer.MAX_VALUE)" {< span><br><span class="line">                <span class="comment">//放不下</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                dp[i][j]=Math.min(dp[i][j-coins[i]]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[coins.length-<span class="number">1</span>][amount]!=Integer.MAX_VALUE?dp[coins.length-<span class="number">1</span>][amount]:-<span class="number">1</span>;</span><br><span class="line">}</span><br></coins[i]></span></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>空间优化</strong></p><p>感觉一维的解释起来会更加清晰易懂 <code>f(11)=1 + min(f(10),f(9),f(6))</code> 这个里面就具有最优子结构，而且一看就明白了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//填充初始值为Integer.MAX_VALUE,代表不可达</span></span><br><span class="line">    Arrays.fill(dp,Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//除了dp[0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="comment">//注意这里不能逆序！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=coins[i];j<=amount;j++) {</span><br><span class="line">            <span class="keyword">if</span> (dp[j-coins[i]]!=Integer.MAX_VALUE) {</span><br><span class="line">                dp[j]=Math.min(dp[j-coins[i]]+<span class="number">1</span>,dp[j]);   </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==Integer.MAX_VALUE?-<span class="number">1</span>:dp[amount];</span><br><span class="line">}</span><br></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">3</span>, coins = [<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 只用面额<span class="number">2</span>的硬币不能凑成总金额<span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">10</span>, coins = [<span class="number">10</span>] </span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong></p><p>你可以假设：</p><ul><li>0 <= amount (总金额) <= 5000</li><li>1 <= coin (硬币面额) <= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><p><strong>解法一</strong></p><p>求方案数，不考虑顺序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (coins==<span class="keyword">null</span> || coins.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> amount==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[coins.length][amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) {</span><br><span class="line">                dp[<span class="number">0</span>][j]=j%coins[i]==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) {</span><br><span class="line">                dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                  dp[i][j]= j>=coins[i]?dp[i-<span class="number">1</span>][j]+dp[i][j-coins[i]]:dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//dp[i][j]= j>=coins[i]?dp[i-1][j]+dp[i-1][j-coins[i]]:dp[i-1][j];</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[coins.length-<span class="number">1</span>][amount];</span><br><span class="line">}</span><br></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>空间优化</strong></p><p><code>f(5)=f(4)+f(3)+f(0)</code> 突然感觉写二维的有点多余。。。这种子结构要清晰的多</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//直接理解一维dp还是不太容易,但是知道递推公式后先写个二维dp再改为一维就很容易</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这种方式相当于对dpTable从左向右,一行行的递推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<coins.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=amount;j++) {</span><br><span class="line">            <span class="comment">//dp[j]+= dp[j-coins[i]]:0;</span></span><br><span class="line">            dp[j]=j-coins[i]>=<span class="number">0</span>?dp[j]+dp[j-coins[i]]:dp[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* 交换一下内外顺序就变成了另一个问题的解</span></span><br><span class="line"><span class="comment">    for (int j=0;j<=amount;j++) {</span></span><br><span class="line"><span class="comment">        for (int i=0;i<coins.length;i++) {< span></coins.length;i++)></span><br><span class="line"><span class="comment">            dp[j]+= j-coins[i]>=0?dp[j-coins[i]]:0;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">}</span><br></span></coins.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>记忆化递归，基本上dp能过得，记忆化递归一定能过，相比之下，我觉得记忆化递归会好写一些</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (coins==<span class="keyword">null</span> || coins.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> amount==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[coins.length][amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> takeCoins(amount,coins,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Integer[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[index,coins.length] 中凑成amount的方案数，考虑顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">takeCoins</span><span class="params">(<span class="keyword">int</span> amount,<span class="keyword">int</span>[] coins,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (index>=coins.length || amount<<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index][amount]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][amount];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (amount==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[index][amount]=takeCoins(amount-coins[index],coins,index)+takeCoins(amount,coins,index+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a></h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">target = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line"></span><br><span class="line">因此输出为 <span class="number">7</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶：</strong><br>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？</p><p><strong>解法一</strong></p><p>记忆化递归，没啥好说的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归 1ms 100%</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[target+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> combination(nums,target);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Integer[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (cache[target]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[target];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (target-nums[i]>=<span class="number">0</span>) {</span><br><span class="line">            res+=combination(nums,target-nums[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[target]=res;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>动态规划，乍一看好像和上面一题一样，实际上并不一样，这里是考虑顺序的，最优子结构也是</p><p><code>f(5)=f(4)+f(3)+f(0)</code> 这样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//一维dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<=target;i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<nums.length;j++) {< span><br><span class="line">            dp[i]+= i>=nums[j]?dp[i-nums[j]]:<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">}</span><br></nums.length;j++)></span></pre></td></tr></tbody></table></figure></div><p>这里还是要存个疑啊，没搞明白啊，为啥交换个顺序就不一样了呢？一个是按行打表，一个是按列打表？？？还是递归好写。。。</p><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a></h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">一共有<span class="number">5</span>种方法让最终目标和为<span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong></p><ul><li>数组非空，且长度不会超过20。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果能被32位整数存下</li></ul><p><strong>解法一</strong></p><p>后面的题都优先写记忆化递归了，动态规划确实有点难顶</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap<integer,integer> cache=new HashMap<></integer,integer></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span> || S><span class="number">1000</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)sum+=n;</span><br><span class="line">    <span class="keyword">if</span>(S>sum)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相当于平移了一下,从[-sum,sum] --> [0,2*sum]</span></span><br><span class="line">    cache=<span class="keyword">new</span> Integer[nums.length][<span class="number">2</span>*sum+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findTarget(nums,S,<span class="number">0</span>,<span class="number">2</span>*sum+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTarget</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> S,<span class="keyword">int</span> index,<span class="keyword">int</span> max)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (S==<span class="number">0</span> && index ==nums.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index>=nums.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(S <<span class="number">0</span>  && cache[index][S+max]!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> cache[index][S+max];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (S>=<span class="number">0</span> && cache[index][S]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index][S];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> temp=findTarget(nums,S-nums[index],index+<span class="number">1</span>,max)+findTarget(nums,S+nums[index],index+<span class="number">1</span>,max);</span><br><span class="line">    <span class="keyword">if</span> (S<<span class="number">0</span>) {</span><br><span class="line">        cache[index][S+max]=temp;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        cache[index][S]=temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>  temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题还是挺有意思的，因为里面是有负数的，直接记忆化是不行的，需要转换一下，这里我是直接将cache数组扩大，同时保证不会有覆盖，所以直接扩大为 2sum就ok，这样整个S的范围就从<code>[-sum,+sum]</code> 变为 <code>[0,2sum]</code> 从而可以缓存所有的递归结果，其实也可以使用两个数组一个存正数，一个存负数，然后只需要符号取反就ok了，只不过占用的空间会大一点</p><h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a></h2><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p><p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p><p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p><p><strong>注意:</strong></p><ul><li>给定 0 和 1 的数量都不会超过 100。</li><li>给定字符串数组的长度不会超过 600。</li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: Array = {<span class="string">"10"</span>, <span class="string">"0001"</span>, <span class="string">"111001"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>}, m = <span class="number">5</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释: 总共 <span class="number">4</span> 个字符串可以通过 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 拼出，即 <span class="string">"10"</span>,<span class="string">"0001"</span>,<span class="string">"1"</span>,<span class="string">"0"</span> 。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: Array = {<span class="string">"10"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>}, m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 你可以拼出 <span class="string">"10"</span>，但之后就没有剩余数字了。更好的选择是拼出 <span class="string">"0"</span> 和 <span class="string">"1"</span> 。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>其实这是一个多重背包问题，一个物品有多个权值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer [][][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[m+<span class="number">1</span>][n+<span class="number">1</span>][strs.length];</span><br><span class="line">    <span class="keyword">return</span> findMax(strs,m,n,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//m:0 n:1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index>=strs.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[m][n][index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[m][n][index];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] oz=count(strs[index]);</span><br><span class="line">    <span class="keyword">if</span> (oz[<span class="number">1</span>]<=n && oz[<span class="number">0</span>]<=m) {</span><br><span class="line">        <span class="keyword">return</span> cache[m][n][index]=Math.max(<span class="number">1</span>+findMax(strs,m-oz[<span class="number">0</span>],n-oz[<span class="number">1</span>],index+<span class="number">1</span>),findMax(strs,m,n,index+<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[m][n][index]=findMax(strs,m,n,index+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] count(String str){</span><br><span class="line">    <span class="keyword">int</span> one=<span class="number">0</span>,zero=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] s=str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c:s) {</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="string">'1'</span>) {</span><br><span class="line">            one++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            zero++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{zero,one};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"leetcode"</span>, wordDict = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">"leetcode"</span> 可以被拆分成 <span class="string">"leet code"</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"applepenapple"</span>, wordDict = [<span class="string">"apple"</span>, <span class="string">"pen"</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">"applepenapple"</span> 可以被拆分成 <span class="string">"apple pen apple"</span>。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"catsandog"</span>, wordDict = [<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>记忆化递归，值得注意的点就是递归的终止条件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归</span></span><br><span class="line">Boolean[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List<string> wordDict)</string></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    cache=<span class="keyword">new</span> Boolean[s.length()];</span><br><span class="line">    HashSet<string> set=<span class="keyword">new</span> HashSet<>(wordDict);</string></span><br><span class="line">    <span class="keyword">return</span> dfs(s,set,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断【index,s.len】中的字符是否能拆分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, HashSet<string> dict,<span class="keyword">int</span> index)</string></span> </span>{</span><br><span class="line">    <span class="comment">//终止条件一开始写的false....</span></span><br><span class="line">    <span class="comment">//这里的终止条件还是有点迷惑的,这里index只有在字典中存在当前元素的时候才会向后移动</span></span><br><span class="line">    <span class="comment">//所以当index移动到s==length的时候就说明前面的单词都匹配上了</span></span><br><span class="line">    <span class="keyword">if</span> (index==s.length()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index+<span class="number">1</span>;i<=s.length();i++) {</span><br><span class="line">        <span class="comment">//System.out.println(s.substring(index,i));</span></span><br><span class="line">        <span class="comment">//这里下一次dfs的index也要注意</span></span><br><span class="line">        <span class="keyword">if</span> (dict.contains(s.substring(index,i)) && dfs(s,dict,i)){</span><br><span class="line">            <span class="keyword">return</span> cache[index]=<span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[index]=<span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>看了官方的解有BFS，然后也实现了一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//BFS,需要一个visit保证不会重复访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List<string> wordDict)</string></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    HashSet<string> dict=<span class="keyword">new</span> HashSet<>(wordDict);</string></span><br><span class="line">    <span class="comment">//queue中存index</span></span><br><span class="line">    LinkedList<integer> queue=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">    queue.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> index=queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (!visit[index]) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=index+<span class="number">1</span>;i<=s.length();i++) {</span><br><span class="line">                <span class="keyword">if</span>(dict.contains(s.substring(index,i))){</span><br><span class="line">                    <span class="keyword">if</span> (i==s.length()) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            visit[index]=<span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>一开始没想到用visit数组，感觉index是递增的好像没什么重复的元素，但是其实是有的，不用visit会超时</p><h2 id="1255-得分最高的单词集合"><a href="#1255-得分最高的单词集合" class="headerlink" title="1255. 得分最高的单词集合"></a><a href="https://leetcode-cn.com/problems/maximum-score-words-formed-by-letters/" target="_blank" rel="noopener">1255. 得分最高的单词集合</a></h2><p>你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。</p><p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。</p><p>单词拼写游戏的规则概述如下：</p><ul><li>玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。</li><li>可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。</li><li>单词表 words 中每个单词只能计分（使用）一次。</li><li>根据字母得分情况表score，字母 ‘a’, ‘b’, ‘c’, … , ‘z’ 对应的得分分别为 score[0], score[1], …, score[25]。</li><li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和</li></ul><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"dad"</span>,<span class="string">"good"</span>], letters = [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"d"</span>,<span class="string">"d"</span>,<span class="string">"g"</span>,<span class="string">"o"</span>,<span class="string">"o"</span>], score = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">23</span></span><br><span class="line">解释：</span><br><span class="line">字母得分为  a=<span class="number">1</span>, c=<span class="number">9</span>, d=<span class="number">5</span>, g=<span class="number">3</span>, o=<span class="number">2</span></span><br><span class="line">使用给定的字母表 letters，我们可以拼写单词 <span class="string">"dad"</span> (<span class="number">5</span>+<span class="number">1</span>+<span class="number">5</span>)和 <span class="string">"good"</span> (<span class="number">3</span>+<span class="number">2</span>+<span class="number">2</span>+<span class="number">5</span>)，得分为 <span class="number">23</span> 。</span><br><span class="line">而单词 <span class="string">"dad"</span> 和 <span class="string">"dog"</span> 只能得到 <span class="number">21</span> 分。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">"xxxz"</span>,<span class="string">"ax"</span>,<span class="string">"bx"</span>,<span class="string">"cx"</span>], letters = [<span class="string">"z"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"x"</span>,<span class="string">"x"</span>,<span class="string">"x"</span>], score = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">27</span></span><br><span class="line">解释：</span><br><span class="line">字母得分为  a=<span class="number">4</span>, b=<span class="number">4</span>, c=<span class="number">4</span>, x=<span class="number">5</span>, z=<span class="number">10</span></span><br><span class="line">使用给定的字母表 letters，我们可以组成单词 <span class="string">"ax"</span> (<span class="number">4</span>+<span class="number">5</span>)， <span class="string">"bx"</span> (<span class="number">4</span>+<span class="number">5</span>) 和 <span class="string">"cx"</span> (<span class="number">4</span>+<span class="number">5</span>) ，总得分为 <span class="number">27</span> 。</span><br><span class="line">单词 <span class="string">"xxxz"</span> 的得分仅为 <span class="number">25</span> 。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">"leetcode"</span>], letters = [<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"t"</span>,<span class="string">"c"</span>,<span class="string">"o"</span>,<span class="string">"d"</span>], score = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">字母 <span class="string">"e"</span> 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= words.length <= 14</code></li><li><code>1 <= words[i].length <= 15</code></li><li><code>1 <= letters.length <= 100</code></li><li><code>letters[i].length == 1</code></li><li><code>score.length == 26</code></li><li><code>0 <= score[i] <= 10</code></li><li><code>words[i] 和 letters[i]</code>只包含小写的英文字母</li></ul><p><strong>解法一</strong></p><p>看着题目就知道这题不简单😂，11.10的周赛最后一题，1ms，用01背包的思路做的，很多地方其实还没处理好</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreWords</span><span class="params">(String[] words, <span class="keyword">char</span>[] letters, <span class="keyword">int</span>[] score)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] les=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<letters.length;i++) {< span><br><span class="line">        les[letters[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxScoreWords(words,letters,score,<span class="number">0</span>,les);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreWords</span><span class="params">(String[] words, <span class="keyword">char</span>[] letters, <span class="keyword">int</span>[] score,<span class="keyword">int</span> index,<span class="keyword">int</span>[] les)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==words.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=maxScoreWords(words,letters,score,index+<span class="number">1</span>,les);</span><br><span class="line">    String word=words[index];</span><br><span class="line">    <span class="keyword">if</span> (hasWord(les,word)) {</span><br><span class="line">        <span class="keyword">int</span>[] bak=<span class="keyword">new</span> <span class="keyword">int</span>[les.length];</span><br><span class="line">        System.arraycopy(les,<span class="number">0</span>,bak,<span class="number">0</span>,les.length);</span><br><span class="line">        res=Math.max(res,getScore(bak,word,score)+maxScoreWords(words,letters,score,index+<span class="number">1</span>,bak));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWord</span><span class="params">(<span class="keyword">int</span>[] les,String word)</span></span>{</span><br><span class="line">    <span class="keyword">int</span>[] bak=<span class="keyword">new</span> <span class="keyword">int</span>[les.length];</span><br><span class="line">    System.arraycopy(les,<span class="number">0</span>,bak,<span class="number">0</span>,les.length);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:word.toCharArray()){</span><br><span class="line">        <span class="keyword">if</span> (bak[c-<span class="string">'a'</span>]!=<span class="number">0</span>) {</span><br><span class="line">            bak[c-<span class="string">'a'</span>]--;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count==word.length();</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span>[] les,String word,<span class="keyword">int</span>[] score)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> sc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c:word.toCharArray()) {</span><br><span class="line">        les[c-<span class="string">'a'</span>]--;</span><br><span class="line">        sc+=score[c-<span class="string">'a'</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sc;</span><br><span class="line">}</span><br></letters.length;i++)></span></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map映射</title>
      <link href="/2019/11/25/map-ying-she/"/>
      <url>/2019/11/25/map-ying-she/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span><<span class="title">K</span>,<span class="title">V</span>></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key,V newValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="LinkedListMap"><a href="#LinkedListMap" class="headerlink" title="LinkedListMap"></a>LinkedListMap</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListMap</span><<span class="title">K</span>,<span class="title">V</span>> <span class="keyword">implements</span> <span class="title">Map</span><<span class="title">K</span>,<span class="title">V</span>></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value,Node next)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(key,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> key.toString()+<span class="string">" : "</span>+value.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListMap</span><span class="params">()</span></span>{</span><br><span class="line">        dummyNode=<span class="keyword">new</span> Node();</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(K key)</span></span>{</span><br><span class="line">        Node cur=dummyNode.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key)) {</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            }</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> getNode(key)==<span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>{</span><br><span class="line">        Node node=getNode(key);</span><br><span class="line">        <span class="keyword">return</span> node==<span class="keyword">null</span>?<span class="keyword">null</span>:node.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>{</span><br><span class="line">        Node node = getNode(key);</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>){</span><br><span class="line">            dummyNode.next=<span class="keyword">new</span> Node(key,value,dummyNode.next);</span><br><span class="line">            size++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            node.value=value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key,V value)</span></span>{</span><br><span class="line">        Node node = getNode(key);</span><br><span class="line">        <span class="keyword">if</span>(contains(key)){</span><br><span class="line">            node.value=value;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key +<span class="string">" doesn't exist!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>{</span><br><span class="line">        Node prev=dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(prev.next!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (prev.next.key.equals(key)) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            prev=prev.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (prev.next==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//其实可以和上面一样抛一个异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node deleNode=prev.next;</span><br><span class="line">        prev.next=deleNode.next;</span><br><span class="line">        deleNode.next=<span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> deleNode.value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="BSTMap"><a href="#BSTMap" class="headerlink" title="BSTMap"></a>BSTMap</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTMap</span><<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>,<span class="title">V</span>> <span class="keyword">implements</span> <span class="title">Map</span><<span class="title">K</span>,<span class="title">V</span>></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">            left=<span class="keyword">null</span>;</span><br><span class="line">            right=<span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTMap</span><span class="params">()</span></span>{</span><br><span class="line">        root=<span class="keyword">null</span>;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>{</span><br><span class="line">        root=put(root,key,value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add元素后返回新的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node,K key,V value)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) < <span class="number">0</span>){</span><br><span class="line">            node.left=put(node.left, key,value);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) > <span class="number">0</span>) {</span><br><span class="line">            node.right=put(node.right, key,value);   </span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//相等的情况</span></span><br><span class="line">            node.value=value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node,K key)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> temp=node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span> (temp==<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (temp><span class="number">0</span>) { <span class="comment">//node.key > key</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.left,key);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> getNode(node.right,key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> getNode(root,key)!=<span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>{</span><br><span class="line">        Node node=getNode(root,key);</span><br><span class="line">        <span class="keyword">return</span> node==<span class="keyword">null</span>?<span class="keyword">null</span>:node.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key,V newValue)</span></span>{</span><br><span class="line">        Node node=getNode(root,key);</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>) {</span><br><span class="line">            node.value=newValue;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key+ <span class="string">" doesn't exist"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getMin</span><span class="params">(Node root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> getMin(root.left);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (node.left==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        }</span><br><span class="line">        node.left=deleteMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>{</span><br><span class="line">        Node node=getNode(root,key);</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        root=remove(node,key);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Node root,K key)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(root.key)><span class="number">0</span>) { <span class="comment">//key > root</span></span><br><span class="line">            root.right=remove(root.right,key);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(root.key)<<span class="number">0</span>) {</span><br><span class="line">            root.left=remove(root.left,key);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (root.right==<span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            }</span><br><span class="line">            Node deleNode=root;</span><br><span class="line">            root=getMin(root.right);</span><br><span class="line">            root.right=deleteMin(deleNode.right);</span><br><span class="line">            root.left=deleNode.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="MapTest"><a href="#MapTest" class="headerlink" title="MapTest"></a>MapTest</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Map<integer,integer> map=<span class="keyword">new</span> BSTMap<>();</integer,integer></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">7</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">9</span>,<span class="number">32131</span>);</span><br><span class="line">        map.put(<span class="number">11</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(map.contains(<span class="number">13</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(map.getSize()); <span class="comment">//10</span></span><br><span class="line">        System.out.println(map.get(<span class="number">9</span>)); <span class="comment">//32131</span></span><br><span class="line">        map.remove(<span class="number">9</span>);</span><br><span class="line">        System.out.println(map.get(<span class="number">9</span>)); <span class="comment">//null</span></span><br><span class="line">        System.out.println(map.getSize()); <span class="comment">//10</span></span><br><span class="line">        map.set(<span class="number">11</span>,<span class="number">1234567</span>);</span><br><span class="line">        System.out.println(map.get(<span class="number">11</span>)); <span class="comment">//1234567</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/imlgw/LeetCode/tree/master/tree/map" target="_blank" rel="noopener">Github</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU队列实现</title>
      <link href="/2019/11/16/lrucache/"/>
      <url>/2019/11/16/lrucache/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p><strong>进阶:</strong></p><p>你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>改了好几次才改对，核心思路就是利用HashMap+双向链表</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    HashMap<integer,node> map=<span class="keyword">new</span> HashMap<>();</integer,node></span><br><span class="line"></span><br><span class="line">    Node head=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node tail=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> capacity=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">            Node node=map.get(key);</span><br><span class="line">            <span class="comment">//移动到链表头</span></span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        Node newHead=<span class="keyword">new</span> Node(key,value);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">            Node node=map.get(key);</span><br><span class="line">            node.value=value;</span><br><span class="line">            <span class="comment">//移动到链表头</span></span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (map.size()==capacity) {</span><br><span class="line">            map.remove(tail.key);</span><br><span class="line">            removeNode(tail);</span><br><span class="line">        }</span><br><span class="line">        move2Head(newHead);</span><br><span class="line">        map.put(key,newHead);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (node.key==tail.key) {</span><br><span class="line">            tail=tail.pre;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.pre==<span class="keyword">null</span> || node.next==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        node.pre.next=node.next;</span><br><span class="line">        node.next.pre=node.pre;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Node newHead)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (map.size()==<span class="number">0</span>) {</span><br><span class="line">            head=tail=newHead;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (newHead.key==head.key) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        removeNode(newHead);</span><br><span class="line">        newHead.next=head;</span><br><span class="line">        newHead.pre=<span class="keyword">null</span>;</span><br><span class="line">        head.pre=newHead;</span><br><span class="line">        head=newHead;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div><p>既然已经实现了，我们就来考虑下为啥要这样实现</p><p>其实我一开始也不知道咋实现，查了下才知道，这里有几个点需要注意：</p><ol><li><p>首先是题目要求get/put时间复杂度是<code>O(1)</code> 的，而我们在get/put的时候肯定会频繁的移动元素的位置，那我们肯定是不能用数组，队列之类的结构了</p></li><li><p>那我们能用单链表么？我们可以将最近访问的节点放在头部，然后每次满的时候剔除尾节点的元素，由于是链表，移动节点的位置都是很容易的，但是我们如果要get一个元素的时候就麻烦了，需要遍历整个链表才能取到元素，也就是说单链表定位某个元素比较耗时，所以我们考虑用HashMap来辅助单链表，这样我们以key为map的key，Node节点为map的value就可以迅速定位到某个元素</p></li><li><p>单链表+HashMap就可以了么？其实还差点儿，如果现在满了，需要删除最后一个节点，那我们就需要将tail的前一个作为新的tail，但是由于是单链表，没有前置指针，不方便定位前一个节点，所以我们最后的方案就是采用<strong>双向链表+HashMap</strong>来实现LRU</p><p><img alt="img" data-src="https://pic4.zhimg.com/80/v2-09f037608b1b2de70b52d1312ef3b307_hd.jpg" src="/img/loading.gif" class="lazyload"></p></li></ol><p>其实LRU思想并不复杂，按照规则来移动节点，删除节点就OK，操作系统教程上也有类似的过程图，理解了下面的图代码就好写了</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191116/BISfMVdI96FT.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>但是如果实现的方式不太好的话，就会写很多if-else判断一些边界，比如我上面自己的实现就是。。。</p><p>其实还有一个原因就是我上面的方式head和tail是真实的节点，不是虚节点，所以会有很多边界的逻辑判断，面试的时候不建议那样写，很容易出问题！！！</p><p><strong>解法二</strong></p><p>面试中比较推荐像这样写</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    HashMap<integer,node> map=<span class="keyword">new</span> HashMap<>();</integer,node></span><br><span class="line"></span><br><span class="line">    Node head=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node tail=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> capacity=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">        <span class="comment">//初始化头尾节点,注意这两个节点只是个哨兵节点,并不会存入map中</span></span><br><span class="line">        head=<span class="keyword">new</span> Node(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        tail=<span class="keyword">new</span> Node(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre=head;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">            Node node=map.get(key);</span><br><span class="line">            <span class="comment">//移动到链表头</span></span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        Node newHead=<span class="keyword">new</span> Node(key,value);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">            Node node=map.get(key);</span><br><span class="line">            <span class="comment">//设置节点值为新value</span></span><br><span class="line">            node.value=value;</span><br><span class="line">            <span class="comment">//移动到链表头</span></span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//满了,先剔除tail再插入</span></span><br><span class="line">        <span class="keyword">if</span> (map.size()==capacity) {</span><br><span class="line">            map.remove(popTail().key);</span><br><span class="line">        }</span><br><span class="line">        addFirst(newHead);</span><br><span class="line">        map.put(key,newHead);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出tail</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">popTail</span><span class="params">()</span></span>{</span><br><span class="line">        Node newTail=tail.pre;</span><br><span class="line">        removeNode(newTail);</span><br><span class="line">        <span class="keyword">return</span> newTail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>{</span><br><span class="line">        node.pre.next=node.next;</span><br><span class="line">        node.next.pre=node.pre;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头添加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node node)</span></span>{</span><br><span class="line">        node.next=head.next;</span><br><span class="line">        head.next.pre=node;</span><br><span class="line">        head.next=node;</span><br><span class="line">        node.pre=head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动节点到head</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Node node)</span></span>{</span><br><span class="line">        <span class="comment">//删除原链表中对应位置的node</span></span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="comment">//从头再添加一遍</span></span><br><span class="line">        addFirst(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>像这样写，就不用考虑那么多边界，写那么多的if和else，预先开辟两个节点的作为哨兵节点，这样代码就显得清晰简洁，也不容易出问题</p><p><a href="https://zhuanlan.zhihu.com/p/34133067" target="_blank" rel="noopener">参考</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis思维导图</title>
      <link href="/2019/11/16/redis-si-wei-dao-tu/"/>
      <url>/2019/11/16/redis-si-wei-dao-tu/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:2000px; height:5000px;" src="https://www.processon.com/embed/mind/5dda2b45e4b0bbcb8a6ae8bc"></iframe><h2 id="原始Xmind文件"><a href="#原始Xmind文件" class="headerlink" title="原始Xmind文件"></a>原始Xmind文件</h2><p><a href="http://static.imlgw.top/Redis.xmind" target="_blank" rel="noopener">Redis思维导图</a></p><p><img alt="Redis" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/Redis.png" src="/img/loading.gif" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索树</title>
      <link href="/2019/11/08/er-fen-sou-suo-shu/"/>
      <url>/2019/11/08/er-fen-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p><strong>二叉查找树</strong>（英语：Binary Search Tree），也称为<strong>二分搜索树</strong>，<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree）也可以简写为 <code>BST</code>，是指一棵空树或者具有下列性质的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树</a>：</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol><p>二叉查找树相比于其他数据结构的优势在于查找、插入的<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度</a>较低。为<code>O(logN)</code>。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合，映射等</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>先搭一个基本的架子出来，后面再来慢慢的完善功能</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span><<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span><<span class="title">E</span>>></span>{</span><br><span class="line">    <span class="comment">//TreeNode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.e=e;</span><br><span class="line">            left=<span class="keyword">null</span>;</span><br><span class="line">            right=<span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span></span>{</span><br><span class="line">        root=<span class="keyword">null</span>;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>{</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>{</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>添加函数，时间复杂度<code>O(logN)</code>，只要抓住了它的性质就很好写，画个图描述下这个过程</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191113/P39b50Ikv4sV.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>① 首先和root节点8比较，比8小，所以肯定再8的左子树中</p><p>② 再和root的左子树根节点5比较，比5大，所以最后肯定插入5的右子树中</p><p>③ 再和5节点的右子树根节点6比较，比6大，所以最后插入6的右子树中</p><p>④ 右子树为空，直接插入到6的右边</p><p>根据上面的流程我们很容易写出代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLoop</span><span class="params">(E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        size++;</span><br><span class="line">        root=<span class="keyword">new</span> Node(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Node temp=root;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(temp.e)><span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (temp.right==<span class="keyword">null</span>) {</span><br><span class="line">                temp.right=<span class="keyword">new</span> Node(e);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            temp=temp.right;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(temp.e)<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (temp.left==<span class="keyword">null</span>) {</span><br><span class="line">                temp.left=<span class="keyword">new</span> Node(e);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            temp=temp.left;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">return</span>; <span class="comment">//不能有相等元素</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里既然是树结构，用循环似乎有的显得不够优雅😂</p><p>所以我们尝试把这个改成递归</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>){</span><br><span class="line">        root = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size ++;</span><br><span class="line">    }<span class="keyword">else</span> add(root, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以node为根的二分搜索树中插入元素e,略显繁琐</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(Node node, E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(e.equals(node.e)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) < <span class="number">0</span> && node.left == <span class="keyword">null</span>){</span><br><span class="line">        node.left = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) > <span class="number">0</span> && node.right == <span class="keyword">null</span>){</span><br><span class="line">        node.right = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) < <span class="number">0</span>)</span><br><span class="line">        add(node.left, e);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//e.compareTo(node.e) > 0</span></span><br><span class="line">    add(node.right, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个递归？？？咋感觉比循环还繁琐🙄 </p><p>确实，上面这个递归的终止条件太繁琐了，<code>compareTo</code>一共比较了4次，有很多重复代码，所以我们还得改改😋</p><p>我们让这个<code>add</code>函数有返回值，返回插入后的根节点，这样我们的函数 <code>add(Node node,E e)</code> 定义就变成了 <strong>插入元素<code>e</code>到 以 <code>node</code> 为根节点的BST中，并且返回根节点</strong> ，清楚了递归函数的定义，我们再来写方法就会容易很多</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>{</span><br><span class="line">    root=add(root,e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素`e`到 以 `node` 为根节点的BST中，并且返回根节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) < <span class="number">0</span>){</span><br><span class="line">        <span class="comment">//插入左子树中，并返回根节点，然后接在node.left</span></span><br><span class="line">        node.left=add(node.left, e);</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) > <span class="number">0</span>) { <span class="comment">//注意不要写else,前面没有对相等的元素做判断</span></span><br><span class="line">        <span class="comment">//插入右子树中，并返回根节点，然后接在node.right</span></span><br><span class="line">        node.right=add(node.right, e);   </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还是那句话，写递归函数，不要纠结于函数的每一步是如何去进行，如何去得到结果的，从全局出发，只要搞清楚递归函数的定义，按照函数的定义来写代码，最后思考一下边界，最后的代码就一定是正确的！</p><p>这个边界的思考，其实也很简单，就比如上面的这个结束条件，我们不用去考虑一步步直到递归终结时是什么情况，我们思考一下极端的边界情况（其实这就是终结的情况），root为null，还没有初始化，BST还是空的，这个时候add元素，其实想都不用想，肯定是直接把这个 e作为根节点返回就ok了，所以很自然的就写出了终止条件</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找相比于上面的添加，会简单很多，可以很容易的写出代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//查询操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (e==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> contains(e,root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e,Node root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(root.e)==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> e.compareTo(root.e)<<span class="number">0</span>?contains(e,root.left):contains(e,root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里我为了简洁写了三目，不熟悉的可以改成if，整体时间复杂度依然是<code>O(logN)</code> ，比线性表的查找会快很多！</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>老生常谈的话题，这个在我之前的 <a href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu-di-gui/">LeetCode-二叉树</a> 里面也做过了，这里再翻出来看看，其实重点是想把后序遍历给搞清楚了，之前一直挺迷糊的</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历,递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTravelRecur</span><span class="params">()</span></span>{</span><br><span class="line">    preorderTravel(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorderTravel</span><span class="params">(Node root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    System.out.print(root.e+<span class="string">" "</span>);</span><br><span class="line">    preorderTravel(root.left);</span><br><span class="line">    preorderTravel(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历,非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTravelNoRecur</span><span class="params">()</span></span>{</span><br><span class="line">    Stack<node> stack=<span class="keyword">new</span> Stack<>();</node></span><br><span class="line">    Node cur=root;</span><br><span class="line">    <span class="keyword">while</span>( cur!=<span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">            System.out.print(cur.e+<span class="string">" "</span>);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        cur=cur.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意这里并不是经典的前序遍历方式，是按照 “模板” 来的，首先我们考虑栈里面存的是什么，这里的栈里面存的实际上是 <code>左子树的左边</code> 的集合，这里我不知道咋描述，画个图吧</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191113/BF0cCcWcy3zP.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>图中绿色部分就是我所说的<strong>左子树的左边的集合</strong>，整个栈的入栈顺序就是从左往右，从上到下，依次的将这些“左边” 入栈，并且在没有左子树，也就是遍历到叶子节点的时候开始出栈，然后切换成<code>当前出栈的节点</code>的右子树，将右子树的<code>左子树的左边</code>重复前面的过程继续入栈出栈，我们要考虑的就是在什么时候访问节点！</p><p>细心的同学肯定已经发现了，其实这里进栈顺序和出栈顺序，分别对应的就是这颗树前序遍历和中序遍历！！！所以我们就只需要在进栈和出栈的时候，进行访问节点的操作，就可以完成前序和后序遍历</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历,递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderTravelRecur</span><span class="params">()</span></span>{</span><br><span class="line">    inorderTravel(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTravel</span><span class="params">(Node root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    inorderTravel(root.left);</span><br><span class="line">    System.out.print(root.e+<span class="string">" "</span>);</span><br><span class="line">    inorderTravel(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="非递归写法-1"><a href="#非递归写法-1" class="headerlink" title="非递归写法"></a>非递归写法</h4><p>结合上面的分析，我们也可以很容易的得出非递归的中序遍历的写法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历,非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderTravelNoRecur</span><span class="params">()</span></span>{</span><br><span class="line">    Stack<node> stack=<span class="keyword">new</span> Stack<>();</node></span><br><span class="line">    Node cur=root;</span><br><span class="line">    <span class="keyword">while</span>( cur!=<span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        System.out.print(cur.e+<span class="string">" "</span>);</span><br><span class="line">        cur=cur.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="递归写法-2"><a href="#递归写法-2" class="headerlink" title="递归写法"></a>递归写法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历,递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTravelRecur</span><span class="params">()</span></span>{</span><br><span class="line">    postorderTravel(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorderTravel</span><span class="params">(Node root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    postorderTravel(root.left);</span><br><span class="line">    postorderTravel(root.right);</span><br><span class="line">    System.out.print(root.e+<span class="string">" "</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="非递归写法-2"><a href="#非递归写法-2" class="headerlink" title="非递归写法"></a>非递归写法</h4><p>这里的非递归写法就不一样了，比前两种要复杂</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历,非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTravelNoRecur</span><span class="params">()</span></span>{</span><br><span class="line">    Stack<node> stack=<span class="keyword">new</span> Stack<>();</node></span><br><span class="line">    Node cur=root,lastNode=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        cur=stack.peek();<span class="comment">//查看栈顶元素</span></span><br><span class="line">        <span class="comment">//如果右子树为空或者右节点已经访问过，则当前节点出栈，并记录lastNode</span></span><br><span class="line">        <span class="keyword">if</span> (cur.right==<span class="keyword">null</span> || lastNode==cur.right) { </span><br><span class="line">            System.out.print(cur.e+<span class="string">" "</span>);</span><br><span class="line">            stack.pop();</span><br><span class="line">            lastNode=cur;</span><br><span class="line">            <span class="comment">//为了下一次能直接查看栈顶元素</span></span><br><span class="line">            <span class="comment">//cur的使命其实已经结束了，cur和它的孩子都已经访问了，下一次直接从栈顶取，不然就死循环了</span></span><br><span class="line">            cur=<span class="keyword">null</span>; </span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191113/zM80igBy0RDX.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>其实不管是什么遍历，对于这个模板来说，<strong>栈的轨迹都是一样的</strong>，只不过访问节点的时机有所不同，蓝色线条代表审查的顺序，红色辅助的代表出栈部分，右边对应的就是遍历过程中栈的变化，和对应结果的变化，对照这个图再分析下就很清楚了。</p><p>如果觉得实在是不好理解也可以换用下面的方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTravelNoRecur2</span><span class="params">()</span> </span>{</span><br><span class="line">    Stack<node> stack=<span class="keyword">new</span> Stack<>();</node></span><br><span class="line">    stack.push(root);</span><br><span class="line">    Node lastNode=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">        <span class="comment">//取栈顶元素</span></span><br><span class="line">        Node cur=stack.peek();</span><br><span class="line">        <span class="comment">//左右子树都为空，或者上一个访问的节点是当前节点的子节点就输出该节点</span></span><br><span class="line">        <span class="keyword">if</span> ( (cur.left==<span class="keyword">null</span> && cur.right ==<span class="keyword">null</span>) || </span><br><span class="line">             (lastNode!=<span class="keyword">null</span> &&(cur.left==lastNode || cur.right==lastNode))){</span><br><span class="line">            stack.pop();</span><br><span class="line">            System.out.print(cur.e+<span class="string">" "</span>);</span><br><span class="line">            lastNode=cur;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span> (cur.right!=<span class="keyword">null</span>) {</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            } <span class="keyword">if</span> (cur.left!=<span class="keyword">null</span>) {</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            }  </span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种方式相比上面就好理解多了，左右子树都为空，或者上一个访问的节点是当前节点的子节点，就可以输出该节点了，注意添加的时候是逆序添加的，这样就可以保证先访问左节点，再访问右节点，最后访问根节点</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><h4 id="递归写法-3"><a href="#递归写法-3" class="headerlink" title="递归写法"></a>递归写法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> levelOrder(TreeNode root) {</list<integer></span><br><span class="line">    List<list<integer>> res = <span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    helper(res, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List<list<integer>> res, TreeNode root, <span class="keyword">int</span> depth)</list<integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//需要增加一层</span></span><br><span class="line">    <span class="keyword">if</span> (res.size() == depth) res.add(<span class="keyword">new</span> LinkedList<>());</span><br><span class="line">    res.get(depth).add(root.val);</span><br><span class="line">    helper(res, root.left, depth + <span class="number">1</span>);</span><br><span class="line">    helper(res, root.right, depth + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="非递归写法-3"><a href="#非递归写法-3" class="headerlink" title="非递归写法"></a>非递归写法</h4><p>经典的BFS</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelorderTravel</span><span class="params">()</span></span>{</span><br><span class="line">    Queue<node> queue=<span class="keyword">new</span> LinkedList<>();</node></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            Node node=queue.poll();</span><br><span class="line">            System.out.print(node.e+<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>其实关于前中后序的遍历方式，还有很多，我这里主要记录的是<code>模板</code>的思路，其实还有一种很🐂🍺的做法，模拟系统栈的方式，具体可以参考我之前的  <a href="http://imlgw.top/2019/11/06/leetcode-er-cha-shu-di-gui/#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">LeetCode二叉树</a> 这里就不多解释了</p></blockquote><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><h3 id="向下取整（floor）"><a href="#向下取整（floor）" class="headerlink" title="向下取整（floor）"></a>向下取整（floor）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span></span>{</span><br><span class="line">    Node node=floor(root,e);</span><br><span class="line">    <span class="keyword">return</span> node!=<span class="keyword">null</span>?node.e:<span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">floor</span><span class="params">(Node root,E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> temp=e.compareTo(root.e);</span><br><span class="line">    <span class="keyword">if</span> (temp==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (temp<<span class="number">0</span>) { <span class="comment">//root.e > e,求小于e的值,一定在左边</span></span><br><span class="line">        <span class="keyword">return</span> floor(root.left,e);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//tmep>0 e>root.e</span></span><br><span class="line">    Node node=floor(root.right,e);</span><br><span class="line">    <span class="keyword">return</span> node!=<span class="keyword">null</span>?node:root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="向上取整（ceiling）"><a href="#向上取整（ceiling）" class="headerlink" title="向上取整（ceiling）"></a>向上取整（ceiling）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span></span>{</span><br><span class="line">    Node node=ceiling(root,e);</span><br><span class="line">    <span class="keyword">return</span> node!=<span class="keyword">null</span>?node.e:<span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">ceiling</span><span class="params">(Node root,E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> temp=e.compareTo(root.e);</span><br><span class="line">    <span class="keyword">if</span> (temp==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (temp><span class="number">0</span>) { <span class="comment">//root.e<e,求的是最后大于root.e的元素,一定在右边< span></e,求的是最后大于root.e的元素,一定在右边<></span><br><span class="line">        <span class="keyword">return</span> ceiling(root.right,e);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//tmep<0 e<root.e< span></root.e<></span><br><span class="line">    Node node=ceiling(root.left,e);</span><br><span class="line">    <span class="keyword">return</span> node!=<span class="keyword">null</span>?node:root;</span><br><span class="line">}</span><br></span></span></pre></td></tr></tbody></table></figure></div><p>这两个函数还是挺有用的，比如这个题 <a href="http://imlgw.top/2019/09/15/leetcode-cha-zhao/#220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III">220-存在重复元素-III </a> 通过率只有25%的mid题。。。。</p><h2 id="获取第K大"><a href="#获取第K大" class="headerlink" title="获取第K大"></a>获取第K大</h2><p>获取第k大（从0开始）的元素，如果左子树节点数小于<code>k</code>，则第k大的元素肯定在右子树，同时我们可以直接排除<code>size(left)+1</code> 个元素（加上根节点） 。</p><p>然后直接在 右子树中继续搜索 <code>getKth(root.right,k-size(left)-1)</code>  ，只有当左子树刚好k个元素的时候，根节点就是我们要找的<code>Kth</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (k>=size || k<<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getKth(root,k).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getKth</span><span class="params">(Node root,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> temp = childSize(root.left);</span><br><span class="line">    <span class="keyword">if</span> (temp>k) {</span><br><span class="line">        <span class="keyword">return</span> getKth(root.left,k);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (temp<k) {< span><br><span class="line">        <span class="keyword">return</span> getKth(root.right,k-temp-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></k)></span></pre></td></tr></tbody></table></figure></div><blockquote><p>这里其实我的实现是有问题的，我的时间复杂度是<code>O(NlogN)</code>！！！！主要是<code>childSize()</code>时间复杂度是O(N)不是O(1)，在《算法4》中这个实现的时间复杂度就是O(1)，书上在定义的Node的时候给Node加了一个count属性，用来记录每个节点的子节点数（包括自己），在每次add和delete的时候动态的维护这个count，这样最后求子节点数的操作时间复杂度就是O(1)的了，那个版本的我也实现了一下，但是我没有在这篇文章中这样写（主要是懒得改），而且这也不是重点，感兴趣可以去看看 <a href="https://github.com/imlgw/LeetCode/blob/master/tree/BSTWithCount.java" target="_blank" rel="noopener">BSTWithCount</a> 主要就是要<strong>注意操作count的时机</strong></p></blockquote><h2 id="Rank"><a href="#Rank" class="headerlink" title="Rank()"></a>Rank()</h2><p>其实是上面的逆过程，如果根节点等于key，那么直接返回左子树的键总数；如果key小于根节点，就继续去左子树中递归找，如果大于根节点，返回<code>size(left)+1</code>加上它在右子树中的<code>rank()</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">(E e)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> getRank(root,e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">(Node root,E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(root.e)<<span class="number">0</span>) { <span class="comment">//e<root.e< span></root.e<></span><br><span class="line">        <span class="keyword">return</span> getRank(root.left,e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(root.e)><span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> getRank(root.right,e)+childSize(root.left)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> childSize(root.left);</span><br><span class="line">}</span><br></span></pre></td></tr></tbody></table></figure></div><h2 id="Max-amp-Min"><a href="#Max-amp-Min" class="headerlink" title="Max&Min"></a>Max&Min</h2><p>没啥好说的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//求最大值,递归比较优雅</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMax</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> getMax(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getMax</span><span class="params">(Node root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root.right==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getMax(root.right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//求最小值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> getMin(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getMin</span><span class="params">(Node root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getMin(root.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除应该来说是BST中里面比较复杂的一个操作了，我们先从简单的开始</p><h3 id="删除最值"><a href="#删除最值" class="headerlink" title="删除最值"></a>删除最值</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//删除最小的键</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>{</span><br><span class="line">    root=deleteMin(root);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//删除node为头节点的树中的最小值，并返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">    }</span><br><span class="line">    node.left=deleteMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最大的键</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span></span>{</span><br><span class="line">    root=deleteMax(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node node)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node.right==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">    }</span><br><span class="line">    node.right=deleteMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>递归函数定义为<strong>删除node为头节点的树中的最小值，并返回头节点</strong>，删除最小值实际上就是删除二叉树最左边的节点，所以我们递归的删除node.left就ok，当node.left为空的时候返回node.right，这样前面节点的left就接在了node.right上，就达到了删除的作用</p><h3 id="删除任意值"><a href="#删除任意值" class="headerlink" title="删除任意值"></a>删除任意值</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//删除任意的键</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E e)</span></span>{</span><br><span class="line">    root=delete(root,e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除以node为首的BST中,值为e的节点并且返回根节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node,E e)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e)><span class="number">0</span>) { <span class="comment">//e>root.e</span></span><br><span class="line">        node.right=delete(node.right,e);</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e)<<span class="number">0</span>) {</span><br><span class="line">        node.left=delete(node.left,e);</span><br><span class="line">    }<span class="keyword">else</span>{ <span class="comment">//e==root.e</span></span><br><span class="line">        <span class="keyword">if</span> (node.left==<span class="keyword">null</span>) { <span class="comment">//如果没有左子树就返回右子树</span></span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right==<span class="keyword">null</span>) { <span class="comment">//如果没有右子树就返回左子树</span></span><br><span class="line">            <span class="keyword">return</span> node.left;</span><br><span class="line">        }</span><br><span class="line">        Node delNode=node;</span><br><span class="line">        <span class="comment">//有左右子节点都有</span></span><br><span class="line">        node=getMin(node.right); <span class="comment">//用右子树的最小值填补删除的元素的空位</span></span><br><span class="line">        <span class="comment">//删除对应的右子树的最小值,然后连接起来</span></span><br><span class="line">        node.right=deleteMin(delNode.right);</span><br><span class="line">        node.left=delNode.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里文字的描述比较无力，画个图就清晰明白了，核心的思想就是利用右子树中的最小值填补待删除节点</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191113/yyI0q2yftm0X.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>当然这里其实也是有坑的，主要就是连最后两句</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//删除对应的右子树的最小值,然后连接起来</span></span><br><span class="line">node.right=deleteMin(delNode.right);</span><br><span class="line">node.left=delNode.left;</span><br></pre></td></tr></tbody></table></figure></div><p>这里的两句话是不能交换的，如果我们交换了两句话的位置，那么我们下一步删除最小值就会出现问题，我们希望的是删除右子树中最小的node节点，结果你先把待删除节点的left接到了node的左边，这样的话node就不再是delNode.right中的最小值，最后结果可能就会成这个样子，成了一个闭环！！！</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191113/qc5kHljj03uq.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>所以最后的结果肯定是不对的，其实这一点书上并没有提到，我也是在做这道题<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">删除节点</a> 的时候写反了，才发现这个问题，感兴趣可以去试试</p><blockquote><p>其实这样的删除时一种很随机的做法，虽然能正确的删除元素，但是并没有考虑树的对称性，关于树的对称性，我们后面再来研究</p></blockquote><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://github.com/imlgw/LeetCode/blob/master/tree/BST.java" target="_blank" rel="noopener">BST.java</a></p><p><a href="https://github.com/imlgw/LeetCode/blob/master/tree/BSTTest.java" target="_blank" rel="noopener">BSTTest.java</a></p><p><a href="https://github.com/imlgw/LeetCode/blob/master/tree/BSTWithCount.java" target="_blank" rel="noopener">BSTWithCount.java</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode二叉树</title>
      <link href="/2019/11/06/leetcode-er-cha-shu/"/>
      <url>/2019/11/06/leetcode-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h2><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><p><strong>解法一</strong></p><p>递归，没啥好说的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>){</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>教科书上的写法，经典的前序遍历非递归实现方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">        TreeNode top=stack.pop();</span><br><span class="line">        res.add(top.val);</span><br><span class="line">        <span class="comment">//注意顺序</span></span><br><span class="line">        <span class="keyword">if</span> (top.right!=<span class="keyword">null</span>) {</span><br><span class="line">            stack.push(top.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (top.left!=<span class="keyword">null</span>) {</span><br><span class="line">            stack.push(top.left);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法三</strong></p><p>非递归，模拟递归栈的方式，记录节点以及是否需要继续寻找子节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<command> stack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">    stack.push(<span class="keyword">new</span> Command(<span class="keyword">true</span>,root));</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">        Command command=stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (!command.isGo) {</span><br><span class="line">            res.add(command.node.val);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            TreeNode node=command.node;</span><br><span class="line">            <span class="comment">//逆序进栈</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="keyword">true</span>,node.right));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="keyword">true</span>,node.left));</span><br><span class="line">            }    </span><br><span class="line">            stack.push(<span class="keyword">new</span> Command(<span class="keyword">false</span>,node));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>{</span><br><span class="line">    <span class="keyword">boolean</span>  isGo; <span class="comment">//是否继续寻找子节点</span></span><br><span class="line">    TreeNode node; <span class="comment">//当前节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(<span class="keyword">boolean</span> isGo,TreeNode node)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.isGo=isGo;</span><br><span class="line">        <span class="keyword">this</span>.node=node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>bobo老师的一种思路，可以说是相当妙了👏，一下就解决了三种遍历的非递归实现，另外两种只需要调整一下进栈的顺序就可以了！</p><p><strong>解法四</strong></p><p>找到一个板子，可以很好的解决三种遍历</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//经典的非递归实现方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">preorderTraversal4</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    TreeNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||!stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>) {</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//没有左子树了</span></span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        <span class="comment">//切换为右子树</span></span><br><span class="line">        cur=cur.right;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>关于 <code>while(cur!=null||!stack.isEmpty())</code>，其实栈中存的只是某一个根节点的所有左子树，并不是所有的节点，所以栈为空不代表已经遍历完所有节点了，只能代表当前节点的左子树都遍历完了，还有右子树还没遍历，只有当右子树也为空也就是<code>cur==null</code> 的时候才是遍历完了，具体看一下下面这颗树就明白了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>    <span class="number">6</span> </span><br><span class="line">  /      \</span><br><span class="line"><span class="number">3</span>       <span class="number">8</span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><h2 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589. N叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N叉树的前序遍历</a></h2><p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img alt="MWwEt0.png" data-src="https://s2.ax1x.com/2019/11/20/MWwEt0.png" src="/img/loading.gif" class="lazyload"></p><p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p><strong>解法一</strong></p><p>递归没啥好说的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//递归的方式</span></span><br><span class="line">List<integer> res=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">preorder</span><span class="params">(Node root)</span> </integer></span>{</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    List<node> children=root.children;</node></span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="keyword">for</span> (Node node:children) {</span><br><span class="line">        preorder(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>迭代的方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">preorder</span><span class="params">(Node root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    Stack<node> stack=<span class="keyword">new</span> Stack<>();</node></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">        Node node=stack.pop();</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        List<node> children=node.children;</node></span><br><span class="line">        <span class="comment">//逆序添加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=children.size()-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">            stack.add(children.get(i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>到这里我是真的对遍历的那个板子无感了，这里我开始想用板子写，结果发现并不好写，无从下手（可能是我太菜），所以采用了经典的前序遍历方式，果然经典就是经典，通用性很强，而且相当好理解，所以以后遇到遍历的题目，尽量还是自己写，别套板子（对后序的板子也一直不是特别理解，所以也一直没记住，套板子还是要建立在理解的基础上啊，不然永远不会做！）</p><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><p><strong>解法一</strong></p><p>递归的方式和模拟栈的方式就不记录了，重点看一下这个板子</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//经典的非递归实现方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">inorderTraversal3</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    TreeNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||!stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>) {</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//没有左子树了</span></span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        <span class="comment">//将当前节点添加到res中</span></span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        <span class="comment">//切换为右子树</span></span><br><span class="line">        cur=cur.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h2><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><p><strong>解法一</strong></p><p>这题是个hard题，没那么容易（不过根据bobo老师的方式来做确实简单😂）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">postorderTraversal3</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    TreeNode cur=root,lastNode=<span class="keyword">null</span>; <span class="comment">//lastNode为上一次访问的节点</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||!stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>) {</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//没有左子树了,把后一个左节点拿出来</span></span><br><span class="line">        cur=stack.peek();</span><br><span class="line">        <span class="comment">//如果没有右节点,或者右节点访问过了</span></span><br><span class="line">        <span class="keyword">if</span> (cur.right==<span class="keyword">null</span>||cur.right==lastNode) {</span><br><span class="line">            <span class="comment">//添加节点</span></span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="comment">//记录当前节点为lastNode</span></span><br><span class="line">            lastNode=cur;</span><br><span class="line">            <span class="comment">//将他pop出去</span></span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="comment">//节点已经弹出</span></span><br><span class="line">            <span class="comment">//指向null,不然就死循环了</span></span><br><span class="line">            cur=<span class="keyword">null</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//右节点不为空,并且没访问过</span></span><br><span class="line">            <span class="comment">//切换为右子树,重复上面的步骤</span></span><br><span class="line">            cur=cur.right;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种题一定要记住 “招式”，乱写只会越写越乱</p><p><strong>解法二</strong></p><p>这种解法似乎更加容易理解！！！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">postorderTraversals</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode lastNode=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">        TreeNode cur=stack.peek();</span><br><span class="line">        <span class="keyword">if</span> ((cur.left==<span class="keyword">null</span> && cur.right ==<span class="keyword">null</span>) || (lastNode!=<span class="keyword">null</span> &&( cur.left==lastNode || cur.right==lastNode))) {</span><br><span class="line">            stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            lastNode=cur;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span> (cur.right!=<span class="keyword">null</span>) {</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (cur.left!=<span class="keyword">null</span>) {</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></h2><p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img alt="NTree" data-src="https://i.loli.net/2019/12/01/KAQP9UNfV5bau7J.png" src="/img/loading.gif" class="lazyload"></p><p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p><strong>解法一</strong></p><p>递归的解法，没啥好说的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List<integer> res=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">postorder</span><span class="params">(Node root)</span> </integer></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    List<node> children=root.children;</node></span><br><span class="line">    <span class="keyword">for</span> (Node node:children) {</span><br><span class="line">        dfs(node);</span><br><span class="line">    }</span><br><span class="line">    res.add(root.val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>锁了！这才是树遍历的板子</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">postorder</span><span class="params">(Node root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    Stack<node> stack=<span class="keyword">new</span> Stack<>();</node></span><br><span class="line">    stack.push(root);</span><br><span class="line">    Node lastNode=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">        Node node=stack.peek();</span><br><span class="line">        List<node> children=node.children;</node></span><br><span class="line">        <span class="keyword">if</span> (children.isEmpty() || (lastNode!=<span class="keyword">null</span> && lastNode == children.get(children.size()-<span class="number">1</span>))) {</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            stack.pop();</span><br><span class="line">            lastNode=node;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=children.size()-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">                stack.push(children.get(i));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题开始因为一个空的case把我搞晕了，搞了半天才发现</p><h2 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102. 二叉树的层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层次遍历</a></h2><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>return its level order traversal as:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>BFS，利用队列</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> levelOrder(TreeNode root) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="comment">//count代表的其实就是每一层的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        List<integer> list=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            <span class="comment">//取出当前节点,并将其左右子节点入队列</span></span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">        res.add(list);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>递归DFS，这种其实还是挺有意思的，可以看下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> levelOrder(TreeNode root) {</list<integer></span><br><span class="line">    List<list<integer>> res = <span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    helper(res, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List<list<integer>> res, TreeNode root, <span class="keyword">int</span> depth)</list<integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//需要增加一层</span></span><br><span class="line">    <span class="keyword">if</span> (res.size() == depth) res.add(<span class="keyword">new</span> LinkedList<>());</span><br><span class="line">    res.get(depth).add(root.val);</span><br><span class="line">    helper(res, root.left, depth + <span class="number">1</span>);</span><br><span class="line">    helper(res, root.right, depth + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></h2><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img alt="NTee" data-src="https://i.loli.net/2019/12/01/He8KVlms1jynbvr.png" src="/img/loading.gif" class="lazyload"></p><p>返回其层序遍历:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">     [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">     [<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ol><li>树的深度不会超过 <code>1000</code>。</li><li>树的节点总数不会超过 <code>5000</code>。</li></ol><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> levelOrder(Node root) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> LinkedList<>();</list<integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    Queue<node> queue=<span class="keyword">new</span> LinkedList<>();</node></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        List<integer> temp=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            Node node=queue.poll();</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child:node.children) {</span><br><span class="line">                queue.add(child);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!temp.isEmpty()) {</span><br><span class="line">            res.add(temp);   </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></h2><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>return its bottom-up level order traversal as:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> levelOrderBottom(TreeNode root) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        List<integer> list=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            TreeNode top=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (top.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(top.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (top.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(top.right);</span><br><span class="line">            }</span><br><span class="line">            list.add(top.val);</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//从头添加</span></span><br><span class="line">        res.add(<span class="number">0</span>,list);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>主要是复习下层次遍历，相比上面就多了 <code>res.add(0,list)</code> 从头部添加</p><h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>return its zigzag level order traversal as:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> zigzagLevelOrder(TreeNode root) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">boolean</span> reverse=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        LinkedList<integer> list=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (reverse) {</span><br><span class="line">                <span class="comment">//从头添加，相当于逆序了</span></span><br><span class="line">                list.addFirst(node.val);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">        reverse=!reverse;</span><br><span class="line">        res.add(list);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>和上面一题一样，老想着怎么去按照题目的要求去遍历节点，哎，太蠢了，灵活一点啊</p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h2><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            <---</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         <---</span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       <---</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>还是和上面一样，一上午做了三道一样的题，这题吸取了上面的教训没有去想怎么遍历了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    LinkedList<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//取每一层最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">1</span>) {</span><br><span class="line">                res.add(node.val);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>只记录每一层最后一个节点，最后得到的就是右视图</p><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 [3,9,20,null,null,15,7]</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回它的最大深度 3 。</p><p><strong>解法一</strong></p><p>递归解法，很简洁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//maxDepth(root)=1+max(maxDepth(root.left),maxDepth(root.right));</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> maxLeft=maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> maxRight=maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> (maxLeft>maxRight?maxLeft:maxRight)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>BFS，广度优先搜索</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;<span class="comment">//注意初始值</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">        max++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559. N叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">559. N叉树的最大深度</a></h2><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img alt="3叉树" data-src="https://s2.ax1x.com/2019/11/20/MWwEt0.png" src="/img/loading.gif" class="lazyload"></p><p>我们应返回其最大深度，3。</p><p><strong>说明:</strong></p><ol><li>树的深度不会超过 <code>1000</code>。</li><li>树的节点总不会超过 <code>5000</code>。</li></ol><p><strong>解法一</strong></p><p>没啥好说的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    List<node> children=root.children;</node></span><br><span class="line">    <span class="keyword">for</span> (Node node:children) {</span><br><span class="line">        max=Math.max(max,maxDepth(node));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>   </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回它的最小深度  2.</p><p><strong>解法一</strong></p><p>最大都求了，最小也来一发，经典BFS做法，求最短路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> min=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        min++;</span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left==<span class="keyword">null</span> && node.right==<span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>递归</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.right)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.right==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>很上面最大的相反，但是有个细节需要注意，如果一个根节点左右子树，<strong>有一颗为空</strong>，如果不处理，按照之前的逻辑，这颗空子树下一次就会返回0，肯定会比另一颗小最后返回的就是到这颗子树的路径，但是仔细想想这样是正确的么？明显不是，最短路径的尽头一定是叶子节点也就是左右子树都为空的时候，所以这里需要特别注意</p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></h2><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure></div><p>输出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>备注:</strong><br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="comment">//交换左右节点</span></span><br><span class="line">    TreeNode temp=root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意递归调用和交换节点的顺序，不能搞反了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode right=root.right;</span><br><span class="line">    root.right=invertTree(root.left);</span><br><span class="line">    root.left=invertTree(right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>比较简洁也比较符合递归的做法</p><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:       <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          / \       / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:      <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          /           \</span><br><span class="line">         <span class="number">2</span>             <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>],     [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:       <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          / \       / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">1</span>     <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span> && q==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span> && q!=<span class="keyword">null</span> && p.val==q.val) {</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.right,q.right)&&isSameTree(p.left,q.left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h2><p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。</p><p><strong>说明：</strong></p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>BFS，权当复习了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> nextLevel=queue.size();</span><br><span class="line">        <span class="keyword">while</span>(nextLevel><span class="number">0</span>){</span><br><span class="line">            TreeNode node=queue.poll(); </span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            nextLevel--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>递归解法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//暴力</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> countNodes(root.left)+countNodes(root.right)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>更加精简点可以缩减成一行</p><p><strong>解法三</strong></p><p>这题是mid难度，而且题目给的条件还没用上：<strong>这是一颗完全二叉树</strong>，所以我们可以利用它的性质来做，众所周知，<strong>满二叉树的节点个数</strong>可以直接根据公式 <code>2^H-1</code> 计算得来，所以我们只要判断当前的完全二叉树是不是<strong>满二叉树</strong>，如果是直接算出来，这样就可以省去中间很多节点的遍历</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//利用完全二叉树的性质</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeNode left=root.left;</span><br><span class="line">    TreeNode right=root.right;</span><br><span class="line">    <span class="keyword">int</span> hight=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left!=<span class="keyword">null</span> && right!=<span class="keyword">null</span>){</span><br><span class="line">        left=left.left;</span><br><span class="line">        right=right.right;</span><br><span class="line">        hight++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//同时向左向右走，走到最后left==null就说明这颗树是满二叉树，可以利用公式直接求出节点个数</span></span><br><span class="line">    <span class="comment">//否则就对其左右子树递归求解</span></span><br><span class="line">    <span class="keyword">return</span> left==<span class="keyword">null</span>?(<span class="number">1</span><<hight)-<span class="number">1</hight)-<span></span>:countNodes(root.left)+countNodes(root.right)+<span class="number">1</span>;<br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>不得不说这样的方式还是挺巧妙的，时间复杂度应该是<code>O(2logN)</code>? </p><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1</p></blockquote><p><strong>示例 1:</strong></p><p>给定二叉树 [3,9,20,null,null,15,7]</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回 true 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">      <span class="number">1</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">4</span>   <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回 false 。</p><p><strong>解法一</strong></p><p>暴力法，结合上面的[二叉树最大深度](#104. 二叉树的最大深度)，<strong>自顶向下</strong>，求左右子树的高度差</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//top 2 bottom</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(hight(root.left)-hight(root.right))><span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) && isBalanced(root.right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hight</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(hight(root.right),hight(root.left))+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>自顶向下，先判断根节点，然后判断左右子树，很明显。在判断左右子树的时候，会重复的遍历判断根节点的时候已经遍历过的节点，时间复杂度应该是<code>O(N^2)</code></p><p><strong>解法二</strong></p><p>自底向上，利用一个实例变量保存结果，其实就是在上面的求heigh过程中将左右子树的高度先取出来直接比较，如果差距大于1就直接记录下结果false，但是其实这里还是可以优化下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ans=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//buttom 2 top</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    hight(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hight</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//递归分治，自底向上，在求高度的过程中计算左右高度差</span></span><br><span class="line">    <span class="keyword">int</span> left=hight(root.left);</span><br><span class="line">    <span class="keyword">int</span> right=hight(root.right);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(left-right)><span class="number">1</span>) {</span><br><span class="line">        ans=<span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>自底向上，只需要遍历一遍二叉树就可以得到结果，时间复杂度<code>O(N)</code> </p><p><strong>解法三</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> hight(root)!=-<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hight</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left=hight(root.left);</span><br><span class="line">    <span class="keyword">if</span> (left==-<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> right=hight(root.right);</span><br><span class="line">    <span class="keyword">if</span> (right==-<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.abs(left-right)><span class="number">1</span>?-<span class="number">1</span>:Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在不符合的时候一路<code>return -1</code> 节省后面的计算</p><h2 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a><a href="https://leetcode-cn.com/problems/binary-tree-tilt/" target="_blank" rel="noopener">563. 二叉树的坡度</a></h2><p>给定一个二叉树，计算整个树的坡度。</p><p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p><p>整个树的坡度就是其所有节点的坡度之和。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">         <span class="number">1</span></span><br><span class="line">       /   \</span><br><span class="line">      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: </span><br><span class="line">结点的坡度 <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">结点的坡度 <span class="number">3</span> : <span class="number">0</span></span><br><span class="line">结点的坡度 <span class="number">1</span> : |<span class="number">2</span>-<span class="number">3</span>| = <span class="number">1</span></span><br><span class="line">树的坡度 : <span class="number">0</span> + <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong></p><ol><li>任何子树的结点的和不会超过32位整数的范围。</li><li>坡度的值不会超过32位整数的范围。. </li></ol><p><strong>解法一</strong></p><p>很快写出来的解法，发现这题和上面的 <strong>平衡二叉树</strong> 有异曲同工之妙！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//首先想到的解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> findTilt(root.left)+findTilt(root.right)+Math.abs(childSum(root.left)-childSum(root.right));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">childSum</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> childSum(root.left)+childSum(root.right)+root.val;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>嵌套递归，相当暴力</p><p><strong>解法二</strong></p><p>上面的做法确实有点可惜，其实在计算childSum的时候就可以字节把坡度算出来然后累加就是整体的坡度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tilt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果发现上面的做法傻逼了。。。其实我知道是不对的,但是不知道咋改,不过写了个嵌套递归也还行hahaha</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    childSum(root);</span><br><span class="line">    <span class="keyword">return</span> tilt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">childSum</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left=childSum(root.left);</span><br><span class="line">    <span class="keyword">int</span> right=childSum(root.right);</span><br><span class="line">    tilt+=Math.abs(left-right);</span><br><span class="line">    <span class="keyword">return</span> left+right+root.val;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></h2><p>给定一个二叉树和一个目标和，判断该树中是否存在<strong>根节点到叶子节点</strong>的路径，这条路径上所有节点值相加等于目标和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \      \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5->4->11->2</code></p><p><strong>解法一</strong></p><p>递归解法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//需要注意这里的叶节点判断</span></span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span> && root.right==<span class="keyword">null</span>&&root.val==sum) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>值得注意的地方就是这个叶子节点的判断，一开始没注意到，直接写的 <code>root.val==sum</code> ，其实如果不是叶子节点的话，其实是不成立的，比如</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">2</span>       sum=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p>其实这就是<code>false</code> ，因为他没有右子树，而题目要求的是从<strong>根节点到叶子节点</strong></p><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></h2><p>计算给定二叉树的所有左叶子之和。</p><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p><p><strong>解法一</strong></p><p>说实话，这些题给的例子都挺误导人的，会让人不自觉地忽略<strong>叶子节点</strong>这个条件😂</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">    sumOfLeft(root);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumOfLeft</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//注意这里的条件！！！！</span></span><br><span class="line">    <span class="keyword">if</span> (root.left!=<span class="keyword">null</span> && root.left.left==<span class="keyword">null</span> &&root.left.right==<span class="keyword">null</span>) {</span><br><span class="line">        sum+=root.left.val;</span><br><span class="line">    }</span><br><span class="line">    sumOfLeft(root.left);</span><br><span class="line">    sumOfLeft(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> 输入:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="string">"1->2->5"</span>, <span class="string">"1->3"</span>]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: <span class="number">1</span>-><span class="number">2</span>-><span class="number">5</span>, <span class="number">1</span>-><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>递归DFS的解法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </string></span>{</span><br><span class="line">    List<string> res=<span class="keyword">new</span> ArrayList<>();</string></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span>&&root.left==<span class="keyword">null</span>&&root.right==<span class="keyword">null</span>) {</span><br><span class="line">        res.add(String.valueOf(root.val));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//左子树的所有路径</span></span><br><span class="line">    List<string> lefts=binaryTreePaths(root.left);</string></span><br><span class="line">    <span class="comment">//右子树的所有路径</span></span><br><span class="line">    List<string> rights=binaryTreePaths(root.right);</string></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在每条路径前面加上当前根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<lefts.size();i++) {< span><br><span class="line">        res.add(root.val+<span class="string">"->"</span>+lefts.get(i));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<rights.size();i++) {< span><br><span class="line">        res.add(root.val+<span class="string">"->"</span>+rights.get(i));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></rights.size();i++)></span></lefts.size();i++)></span></pre></td></tr></tbody></table></figure></div><p>比上面的递归稍微复杂点，核心思想还是要抓住递归的本质，不要去纠结递归每一步都是怎么得到的，从宏观上去写代码，还是要多练啊</p><p><strong>解法二</strong></p><p>BFS广搜</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </string></span>{</span><br><span class="line">    List<string> res=<span class="keyword">new</span> ArrayList<>();</string></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<treenode> node_stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    Stack<string> path_stack=<span class="keyword">new</span> Stack<>();</string></span><br><span class="line">    node_stack.add(root);</span><br><span class="line">    path_stack.add(String.valueOf(root.val));</span><br><span class="line">    String path=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span>(!node_stack.isEmpty()){</span><br><span class="line">        TreeNode node=node_stack.pop();</span><br><span class="line">        path=path_stack.pop();</span><br><span class="line">        <span class="comment">//叶子节点，这条路径搜索结束，添加到res中</span></span><br><span class="line">        <span class="keyword">if</span> (node.left==<span class="keyword">null</span>&&node.right==<span class="keyword">null</span>) {</span><br><span class="line">            res.add(path);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">            node_stack.add(node.left);</span><br><span class="line">            path_stack.add(path+<span class="string">"->"</span>+node.left.val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">            node_stack.add(node.right);</span><br><span class="line">            path_stack.add(path+<span class="string">"->"</span>+node.right.val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里和传统的BFS不太一样，是用的栈来遍历的</p><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \    / \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>和上一题的做法基本一致，本来应该是一遍bugfree的，编译错误整了半天</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> pathSum(TreeNode root, <span class="keyword">int</span> sum) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> LinkedList<>();</list<integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span> && root.left==<span class="keyword">null</span> && root.right==<span class="keyword">null</span> && root.val==sum) {</span><br><span class="line">        LinkedList<integer>  lis= <span class="keyword">new</span> LinkedList<>(); </integer></span><br><span class="line">        lis.add(root.val);</span><br><span class="line">        res.add(lis);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//左右子树符合条件的路径</span></span><br><span class="line">    List<list<integer>> lefts=pathSum(root.left,sum-root.val);</list<integer></span><br><span class="line">    List<list<integer>> rights=pathSum(root.right,sum-root.val);</list<integer></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<lefts.size();i++) {< span><br><span class="line">        ((LinkedList<integer>)lefts.get(i)).addFirst(root.val);</integer></span><br><span class="line">        res.add(lefts.get(i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<rights.size();i++) {< span><br><span class="line">        ((LinkedList<integer>)rights.get(i)).addFirst(root.val);</integer></span><br><span class="line">        res.add(rights.get(i));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></rights.size();i++)></span></lefts.size();i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>废了老大劲终于把BFS写出来了。。。可以看出还是借鉴的上面的思路</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> pathSum2(TreeNode root,<span class="keyword">int</span> sum) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> LinkedList<>();</list<integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//节点栈</span></span><br><span class="line">    Stack<treenode> node_stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    <span class="comment">//路径栈</span></span><br><span class="line">    Stack<list<integer>> path_stack=<span class="keyword">new</span> Stack<>();</list<integer></span><br><span class="line">    <span class="comment">//节点sum栈</span></span><br><span class="line">    Stack<integer> sum_stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    <span class="comment">//给每个栈存入初始值</span></span><br><span class="line">    node_stack.add(root);</span><br><span class="line">    path_stack.add(<span class="keyword">new</span> LinkedList(){{</span><br><span class="line">        add(root.val);</span><br><span class="line">    }});</span><br><span class="line">    sum_stack.add(root.val);</span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="keyword">while</span>(!node_stack.isEmpty()){</span><br><span class="line">        TreeNode node=node_stack.pop();</span><br><span class="line">        List<integer> pathList=path_stack.pop();</integer></span><br><span class="line">        <span class="keyword">int</span> tempS=sum_stack.pop();</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (node.left==<span class="keyword">null</span> && node.right==<span class="keyword">null</span>&&tempS==sum) {</span><br><span class="line">            res.add(pathList);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//这三个栈是同步的,node栈存放当前节点</span></span><br><span class="line">            <span class="comment">//path栈存放根节点到当前节点的路径</span></span><br><span class="line">            <span class="comment">//sum栈存放的是path栈中所有节点的val和</span></span><br><span class="line">            node_stack.add(node.left);</span><br><span class="line">            <span class="comment">//这里不要直接操作pathList,否则左右的路径会混在一起</span></span><br><span class="line">            LinkedList<integer> tlis= <span class="keyword">new</span> LinkedList(pathList);</integer></span><br><span class="line">            tlis.add(node.left.val);</span><br><span class="line">            path_stack.add(tlis);</span><br><span class="line">            <span class="comment">//累加路径上的节点值</span></span><br><span class="line">            sum_stack.add(tempS+node.left.val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">            node_stack.add(node.right);</span><br><span class="line">            <span class="comment">//同上</span></span><br><span class="line">            LinkedList<integer> tlis= <span class="keyword">new</span> LinkedList(pathList);</integer></span><br><span class="line">            tlis.add(node.right.val);</span><br><span class="line">            path_stack.add(tlis);</span><br><span class="line">            sum_stack.add(tempS+node.right.val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>用到三个栈，同步保存节点的信息，还是挺简单的</p><h2 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. 求根到叶子节点数字之和</a></h2><p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 <code>1->2->3</code> 代表数字 <code>123</code></p><p>计算从根到叶子节点生成的所有数字之和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="number">25</span></span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-><span class="number">2</span> 代表数字 <span class="number">12</span>.</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-><span class="number">3</span> 代表数字 <span class="number">13</span>.</span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">0</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">5</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">1026</span></span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-><span class="number">9</span>-><span class="number">5</span> 代表数字 <span class="number">495</span>.</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-><span class="number">9</span>-><span class="number">1</span> 代表数字 <span class="number">491</span>.</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-><span class="number">0</span> 代表数字 <span class="number">40</span>.</span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>BFS，延续上面的做法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> ) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<treenode> node_stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    Stack<integer> sum_stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    node_stack.add(root);</span><br><span class="line">    sum_stack.add(root.val);</span><br><span class="line">    <span class="keyword">while</span>(!node_stack.isEmpty()){</span><br><span class="line">        TreeNode node=node_stack.pop();</span><br><span class="line">        <span class="keyword">int</span> tempS=sum_stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node.left==<span class="keyword">null</span> && node.right==<span class="keyword">null</span>) {</span><br><span class="line">            res+=tempS;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">            node_stack.add(node.left);</span><br><span class="line">             <span class="comment">//注意*10,在上一层的基础上*10</span></span><br><span class="line">            sum_stack.add(tempS*<span class="number">10</span>+node.left.val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">            node_stack.add(node.right);</span><br><span class="line">            sum_stack.add(tempS*<span class="number">10</span>+node.right.val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>DFS解法，一开始没想出来。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers2</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    sumNumber(<span class="number">0</span>,root);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumNumber</span><span class="params">(<span class="keyword">int</span> parent,TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> cur=parent*<span class="number">10</span>+root.val;</span><br><span class="line">    <span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span> && root.left==<span class="keyword">null</span>&& root.right==<span class="keyword">null</span>) {</span><br><span class="line">        sum+=cur;</span><br><span class="line">    }</span><br><span class="line">    sumNumber(cur,root.left);</span><br><span class="line">    sumNumber(cur,root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">root = [<span class="number">10</span>,<span class="number">5</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">11</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">1</span>], sum = <span class="number">8</span></span><br><span class="line">      <span class="number">10</span></span><br><span class="line">     /  \</span><br><span class="line">    <span class="number">5</span>   -<span class="number">3</span></span><br><span class="line">   / \    \</span><br><span class="line">  <span class="number">3</span>   <span class="number">2</span>   <span class="number">11</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>  -<span class="number">2</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回 3。和等于 8 的路径有:</p><ol><li>5 -> 3</li><li>5 -> 2 -> 1</li><li>-3 -> 11</li></ol><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> ) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=findPath(root,sum);</span><br><span class="line">    res+=pathSum(root.left,sum);</span><br><span class="line">    res+=pathSum(root.right,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPath</span><span class="params">(TreeNode node,<span class="keyword">int</span> sum)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.val==sum) {</span><br><span class="line">        res++;</span><br><span class="line">    }</span><br><span class="line">    res+=findPath(node.left,sum-node.val);</span><br><span class="line">    res+=findPath(node.right,sum-node.val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>emmmm，这题分类是easy确实太迷了，嵌套的递归，看了解法确实看的懂，但是写是绝对写不出来的（眼睛：我懂了，脑子：你懂个锤子）除非能记住</p><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）</p><p>例如，给定如下二叉搜索树:  <code>root = [6,2,8,0,4,7,9,null,null,3,5]</code></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191001/KlQJmqmdWmP3.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><p><strong>解法一</strong></p><p>看了一点点思路，然后bugfree</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line">    <span class="comment">//特殊情况,其中一个已经是另一个的祖先了</span></span><br><span class="line">    <span class="comment">//if (p==root || q==root) return root;</span></span><br><span class="line">    <span class="comment">//都小于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.val<root.val && q.val<root.val) {< span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (p.val > root.val && q.val > root.val) {</span><br><span class="line">        <span class="comment">//都大于根节点</span></span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//一大一小 或者有一个是root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></root.val></span></pre></td></tr></tbody></table></figure></div><p>其实核心就是利用好BST的性质，左子树一定小于根节点，右子树一定大于根节点，求公共祖先，如果一个节点在左子树，一个在右子树，那么最近的公共祖先一定是root，除此之外，还有一种特殊情况就是当两个节点已经有祖先关系的时候，那么直接返回祖先节点就可以了</p><blockquote><p>这里其实前面的<code>if</code>可以去掉，题目中说到了所有节点的值都是唯一的，所以节点值相等就说明是同一个节点，就已经包含在最后一个else的情况中了</p></blockquote><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 输入为: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>递归解法，很巧妙</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode node,Integer low,Integer high)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (low!=<span class="keyword">null</span> && low>=node.val || high!=<span class="keyword">null</span> && high<=node.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> isValidBST(node.left,low,node.val) && isValidBST(node.right,node.val,high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>一定要注意BST的性质是根节点<strong>大于所有</strong> 右子树的节点，<strong>小于所有</strong>左子树的节点，而不是简单的验证当前节点和左右节点的大小关系就可以了，所以我们在验证的时候传入对应的<strong>上界</strong>和<strong>下界</strong>，节点必须要大于下界，小于上界，那么上界和下界从哪里来？<em>当前节点就是左子树的上界，右子树的下界！</em>  然后递归左右子树就ok了</p><blockquote><p>这题其实还有一个坑，只不过我这个做法直接跳过了，题目的case中有的节点值是<code>Integer.MIN_VALUE</code>，和<code>Integer.MAX_VALUE</code>  ，如果上界下界直接用int来传递的话，很有可能递归初始调用就是这样的</p><p><code>return isValidBST(root,Integer.MIN_VALUE,Integer.MAX_VALUE);</code> 这就正中出题人下怀，所以我们这里用一个包装类型，这样我们只需要检测上界下界是不是null就可以了</p></blockquote><p><strong>解法二</strong></p><p>这个就利用了BST和中序遍历的关系，我们知道中序遍历是 <code>左->根->右</code>  这个顺序放到 BST中恰好就是一个升序的序列，所以我们就可以利用这个性质来判断二叉树是不是BST</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//BST的中序遍历一定是升序的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">    LinkedList<integer> order=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    TreeNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">            stack.add(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        <span class="comment">//和上一次的最后一个节点值比较</span></span><br><span class="line">        <span class="keyword">if</span> (!order.isEmpty() && order.getLast()>= cur.val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        order.add(cur.val);</span><br><span class="line">        cur=cur.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里其实可以不用list保存结果，用一个int保存上一次的节点值就行了</p><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h2><p>将一个按照升序排列的有序数组，转换为一棵<strong>高度平衡二叉搜索树</strong></p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定有序数组: [-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">一个可能的答案是：[<span class="number">0</span>,-<span class="number">3</span>,<span class="number">9</span>,-<span class="number">10</span>,<span class="keyword">null</span>,<span class="number">5</span>]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">     / \</span><br><span class="line">   -<span class="number">3</span>   <span class="number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> -<span class="number">10</span>  <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left>right) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid=(right-left)/<span class="number">2</span>+left;</span><br><span class="line">    TreeNode node=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    node.left=sortedArrayToBST(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">    node.right=sortedArrayToBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题最开始终止条件写错了，思路是对的，对递归运用的还是不够熟练，终止条件其实只需要想一下极端情况就可以了</p><h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a></h2><p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 k 个最小的元素</p><p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">2</span>], k = <span class="number">1</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶：</strong><br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p><p><strong>解法一</strong></p><p>非递归中序遍历</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    TreeNode cur=root;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">            stack.add(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (count==k-<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        }</span><br><span class="line">        cur=cur.right;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//没找到</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还是利用BST中序遍历是升序的性质，在取到第k个元素的时候就直接<code>break</code></p><p><strong>解法二</strong></p><p>递归的方式，加了两个额外的实例变量其实不太好</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    kthSmallest(root,k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kthSmall</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    kthSmall(root.left,k);</span><br><span class="line">    <span class="keyword">if</span> (count==k-<span class="number">1</span>) {</span><br><span class="line">        res=root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    count++;</span><br><span class="line">    kthSmall(root.right,k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶</strong></p><p>可以维护一个大根堆，就和最小栈一样，每次对BST操作的时候同步操作这个大根堆</p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p> <img alt="mark" data-src="http://static.imlgw.top/blog/20191003/m0bWNSMUQWy2.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">4</span> 的最近公共祖先是节点 <span class="number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || p==root ||q==root) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span> (left!=<span class="keyword">null</span> && right!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (left!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (right!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题，说实话，我是想不出来</p><p>在左、右子树中分别查找是否包含p或q：</p><ul><li>如果以下两种情况（左子树包含p，右子树包含q/左子树包含q，右子树包含p），那么此时的根节点就是最近公共祖先</li><li>如果左子树包含p和q，那么到root->left中继续查找，最近公共祖先在左子树里面</li><li>如果右子树包含p和q，那么到root->right中继续查找，最近公共祖先在右子树里面 </li></ul><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是<strong>镜像对称</strong>的:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><p><strong>解法一</strong></p><p>哎，感觉刷题还是得在白天，脑子清醒点，下午就感觉做题老是出问题，一开始题都没看清就开始做</p><p>其实一开始是想BFS层次遍历然后判断每一层是不是镜像对称的，然后发现有些case是过不了的，比如</p><p><code>[1,3,3,2,null,2]</code> 这样的case</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"> /   /</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><del>层序遍历判断不出了这样的case</del>   下面解法四打脸</p><p>然后换一种遍历方式，其实一开始就想到了前序遍历，如果是镜像对称的话，前序遍历刚好就是对称的，但是！！！还是有case过不了！！！我们再看上面的case，我们改一改</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> /   /</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p>第<code>192/195个case</code>，我惊了，居然还有这种操作！！！实在没办法翻了下解答，发现有位老兄也是这样做的，然后他很巧妙的在每个节点值后面加了一个<strong>层数</strong>，他好像是直接当作字符串添加的，我感觉不太好，改用了数组，最后判断的时候需要保证层数和值都相同才行，完整代码如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//[1,2,2,2,null,2] 忘了还有这样的case了,哭了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    List<integer[]> lis=<span class="keyword">new</span> ArrayList<>();</integer[]></span><br><span class="line">    preTravle(root,lis,<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=lis.size()-<span class="number">1</span>;i<=j;i++,j--) {</span><br><span class="line">        <span class="keyword">if</span> (lis.get(i)[<span class="number">0</span>]!= lis.get(j)[<span class="number">0</span>] ||  lis.get(j)[<span class="number">1</span>]!= lis.get(i)[<span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTravle</span><span class="params">(TreeNode node,List<integer[]> lis,<span class="keyword">int</span> k)</integer[]></span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>) {</span><br><span class="line">        preTravle(node.left,lis,k+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里其实用个字符串就可以，但是感觉拼接的效率不高，而且，是不是有可能出现问题？</span></span><br><span class="line">        <span class="comment">// 11+3 ==1+13 ？？？是不是有可能出现类似这样的情况</span></span><br><span class="line">        Integer[] temp=<span class="keyword">new</span> Integer[<span class="number">2</span>];</span><br><span class="line">        temp[<span class="number">0</span>]=node.val;</span><br><span class="line">        temp[<span class="number">1</span>]=k;</span><br><span class="line">        lis.add(temp);</span><br><span class="line">        preTravle(node.right,lis,k+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>递归的解法，应该算是官解了，一开始也是想用递归写的，没抓住问题的本质，太菜了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//转换为求左右子树是否镜像对称的问题</span></span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left,root.right);</span><br><span class="line">    <span class="comment">//return isSymmetric(root,root);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode t1,TreeNode t2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span> && t2==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//有一个为null</span></span><br><span class="line">    <span class="keyword">if</span> (t1== <span class="keyword">null</span> || t2==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//都不为null</span></span><br><span class="line">    <span class="keyword">return</span> t1.val==t2.val && isSymmetric(t1.left,t2.right) && isSymmetric(t1.right,t2.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>一棵树是镜像对称，说明左右子树左右对称，所以这个问题就可以转换为，判断左右两颗子树是否是镜像对称的问题</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191107/Ae6daB6SuXdl.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>判断两颗树是否成镜像对称的话，其实就和照镜子一样的，如上图，判断左子树和右子树是否成镜像对称，就需要判断<code>t1的左子树和t2的右子树是否镜像对称,t1的右子树和t2的左子树是否镜像对称</code>，根据这个就可以写出递归函数，还是挺妙的</p><p><strong>解法三</strong></p><p>类似于层次遍历，其实就是根据上面的递归方法改来的，核心思想和上面递归的是一样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//非递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">        TreeNode t1=stack.pop();</span><br><span class="line">        TreeNode t2=stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (t1==<span class="keyword">null</span> && t2==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span> || t1.val!=t2.val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*if (t1.val!=t2.val) {</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">         }*/</span></span><br><span class="line">        stack.push(t1.left);</span><br><span class="line">        stack.push(t2.right);</span><br><span class="line">        stack.push(t1.right);</span><br><span class="line">        stack.push(t2.left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法四</strong></p><p>前序遍历，其实我一开始也想到了用占位的方式，但是因为之前遍历方式不同，导致没想好在哪里加</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        ArrayList<integer> lis=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            <span class="comment">//lis.add(node.val);</span></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                lis.add(node.left.val);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//-1占位</span></span><br><span class="line">                lis.add(-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                lis.add(node.right.val);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//为空加-1占位</span></span><br><span class="line">                lis.add(-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//对每一层经常判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=lis.size()-<span class="number">1</span>;i<=j;i++,j--) {</span><br><span class="line">            <span class="keyword">if</span> (lis.get(i)!=lis.get(j)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样的做法明显时间复杂度会之前要高，不仅遍历了整颗树一遍，还对每一层遍历了一遍，一共遍历了两遍</p><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></h2><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     /   / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">       /</span><br><span class="line">      <span class="number">7</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong> 您可以假设树（即给定的根节点）不为 NULL。</p><p><strong>解法一</strong></p><p>这种题写一百遍了😂，然而我还是没有bugfree</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//其实这种层序遍历的方式对这题有一点小题大作，不过我还是比较习惯这种方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> count=queue.size();</span><br><span class="line">        <span class="keyword">int</span> temp=count;</span><br><span class="line">        <span class="keyword">while</span>(count><span class="number">0</span>){</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (count==temp) {</span><br><span class="line">                res=node.val;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>最左边的值，也就是最后一行的第一个元素，dfs深度优先，深度每增加一次就更新一次res</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue2</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    dfs(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res=-<span class="number">1</span>,max=Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node,<span class="keyword">int</span> depth)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (depth>max) {</span><br><span class="line">        max=depth;</span><br><span class="line">        res=node.val;</span><br><span class="line">    }</span><br><span class="line">    dfs(node.left,depth+<span class="number">1</span>);</span><br><span class="line">    dfs(node.right,depth+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>返回如下的二叉树：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (preorder==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> preleft,<span class="keyword">int</span> preright,<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inleft,<span class="keyword">int</span> inright)</span> </span>{</span><br><span class="line">    <span class="comment">//递归出口只需要想一下边界,比如只要一个节点的时候,很明显只有一个节点的时候这几个值都是 0</span></span><br><span class="line">    <span class="comment">//但是此时肯定不能返回null,所以这里递归出口不是大于等于,而是大于</span></span><br><span class="line">    <span class="keyword">if</span> (preleft>preright || inleft>inright) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(preorder[preleft]);</span><br><span class="line">    <span class="keyword">int</span> index=inleft;</span><br><span class="line">    <span class="keyword">while</span>(inorder[index] != preorder[preleft]) {</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line">    root.left=buildTree(preorder,preleft+<span class="number">1</span>,preleft+index-inleft,inorder,inleft,index-<span class="number">1</span>);</span><br><span class="line">    root.right=buildTree(preorder,preleft+index-inleft+<span class="number">1</span>,preright,inorder,index+<span class="number">1</span>,inright);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题核心思想就是利用这几种遍历的性质，文字总是苍白的，看个图吧</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191106/pcmvnEK8Hwg8.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这样一看就清晰了，前序遍历左边第一个节点 <code>1</code> 一定是根节点，所以我们首先确定了根节点，然后我们去中序遍历中去找这个根节点（一定有），如上图，我们找到了中间的 <code>1</code>然后再根据中序遍历的性质，我们可以就知道，中序遍历中，这个<code>1</code> 的左边是 <code>1</code> 的左子树，右边是<code>1</code> 的右子树，到这里我们就确定了根节点及其左右子树，剩下的就交给递归去完成了😁，我们只需要对左右子树分别递归该过程就可以得到一颗完整的树了</p><p>当然这里值得注意的地方就是下标的变换，要十分注意，自己带入几个值试试</p><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>返回如下的二叉树：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>方法同上，只不过是从后往前了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (inorder==<span class="keyword">null</span> || inorder.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> buildTree(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR, <span class="keyword">int</span>[] postorder,<span class="keyword">int</span> pL,<span class="keyword">int</span> pR)</span> </span>{</span><br><span class="line">    <span class="comment">//递归出口只需要想一下边界,比如只要一个节点的时候,很明显只有一个节点的时候这几个值都是0</span></span><br><span class="line">    <span class="comment">//但是此时肯定不能返回null,所以这里递归出口不是大于等于,而是大于</span></span><br><span class="line">    <span class="keyword">if</span> (inL>inR || pL>pR) { </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(postorder[pR]);</span><br><span class="line">    <span class="keyword">int</span> index=inL;</span><br><span class="line">    <span class="keyword">while</span>(inorder[index]!=postorder[pR]){</span><br><span class="line">        index++; <span class="comment">//一定有,所以不用担心越界的问题</span></span><br><span class="line">    }</span><br><span class="line">    root.left=buildTree(inorder,inL,index-<span class="number">1</span>,postorder,pL,pL+index-inL-<span class="number">1</span>);</span><br><span class="line">    root.right=buildTree(inorder,index+<span class="number">1</span>,inR,postorder,pL+index-inL,pR-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>和上面一样没啥好说的</p><p><strong>解法二</strong></p><p>上面两种解法提交后效率都不高，这里去中序遍历中找根节点的操作其实可以用Hash表代替</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//hash表优化</span></span><br><span class="line">HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (inorder==<span class="keyword">null</span> || inorder.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<inorder.length;i++) {< span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> buildTree(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR, <span class="keyword">int</span>[] postorder,<span class="keyword">int</span> pL,<span class="keyword">int</span> pR)</span> </span>{</span><br><span class="line">    <span class="comment">//递归出口只需要想一下边界,比如只要一个节点的时候,很明显只有一个节点的时候这几个值都是相等的</span></span><br><span class="line">    <span class="comment">//但是此时肯定不能返回null,所以这里递归出口不是大于等于,而是大于</span></span><br><span class="line">    <span class="keyword">if</span> (inL>inR || pL>pR) { </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(postorder[pR]);</span><br><span class="line">    <span class="keyword">int</span> index=map.get(postorder[pR]);</span><br><span class="line">    root.left=buildTree(inorder,inL,index-<span class="number">1</span>,postorder,pL,pL+index-inL-<span class="number">1</span>);</span><br><span class="line">    root.right=buildTree(inorder,index+<span class="number">1</span>,inR,postorder,pL+index-inL,pR-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></inorder.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h2><p>给定一个二叉树，原地将它展开为链表。</p><p>例如，给定二叉树</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p>将其展开为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>题目没抄错，就是这样的，确实题目没有说明按照什么方式展开，但是看case能猜到是前序遍历的方式展开（靠猜的？）</p></blockquote><p><strong>解法一</strong></p><p>前序遍历，递归的解法，用一个全局变量保存链表的结尾，每次将节点添加到last的后面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode last=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (last!=<span class="keyword">null</span>) {</span><br><span class="line">        last.left=<span class="keyword">null</span>;</span><br><span class="line">        last.right=root;</span><br><span class="line">    }</span><br><span class="line">    last=root;</span><br><span class="line">    TreeNode right=root.right;<span class="comment">//保存右子树</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>需要注意的地方就是需要保存右子树，因为前面的操作将左子树添加到根节点右子树的时候，会导致原本的右子树丢失</p><p><strong>解法二</strong></p><p>变形的后序遍历，递归解法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode pre=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right=pre;</span><br><span class="line">    root.left=<span class="keyword">null</span>;</span><br><span class="line">    pre=root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>相比前面的解法，为了不丢失右子树，先遍历右子树，再遍历左子树，整个序列就是<code>6 5 4 3 2 1</code>  我们只需要将每个节点的right指向前一个节点就ok了</p><p><strong>解法三</strong></p><p>迭代，我觉得这种解法应该来说是最容易理解的，而且是完全的 <code>in-place</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    TreeNode mRight=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) {</span><br><span class="line">            mRight=root.left;</span><br><span class="line">            <span class="comment">//找到左子树的最右节点</span></span><br><span class="line">            <span class="keyword">while</span>(mRight.right!=<span class="keyword">null</span>){</span><br><span class="line">                mRight=mRight.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//将根的右节点接在 mRight.right</span></span><br><span class="line">            mRight.right=root.right;</span><br><span class="line">            <span class="comment">//将root.left接在root.right</span></span><br><span class="line">            root.right=root.left;</span><br><span class="line">            <span class="comment">//左节点置为null</span></span><br><span class="line">            root.left=<span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//重复该过程</span></span><br><span class="line">        root=root.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>画个图就是这样</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191108/BIx12P1AYjeX.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></h2><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">struct Node {</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL</p><p>初始状态下，所有 next 指针都被设置为 NULL</p><p><img alt="leet" data-src="https://i.loli.net/2019/11/10/eC4VBqXmwuspZlG.png" src="/img/loading.gif" class="lazyload"></p><p><strong>解法一</strong></p><p>开始没做出来，菜！！！然后特意留到今天总结，又在web上提交了一遍</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span> ||root.left==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    root.left.next=root.right;</span><br><span class="line">    <span class="keyword">if</span> (root.next!=<span class="keyword">null</span>) {</span><br><span class="line">        root.right.next=root.next.left;   </span><br><span class="line">    }</span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>这个解法梳理还是很清奇的，类似拉拉链的过程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span> ||root.left==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    Node left=root.left;</span><br><span class="line">    Node right=root.right;</span><br><span class="line">    <span class="comment">//有的像拉拉链的过程</span></span><br><span class="line">    <span class="keyword">while</span>(left!=<span class="keyword">null</span>){</span><br><span class="line">        left.next=right;</span><br><span class="line">        left=left.right;</span><br><span class="line">        right=right.left;</span><br><span class="line">    }</span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li><p>首先找到需要删除的节点；</p></li><li><p>如果找到了，删除它。</p></li></ol><p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">7</span>]</span><br><span class="line">key = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">给定需要删除的节点值是 <span class="number">3</span>，所以我们首先找到 <span class="number">3</span> 这个节点，然后删除它。</span><br><span class="line"></span><br><span class="line">一个正确的答案是 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>], 如下图所示。</span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"> /     \</span><br><span class="line"><span class="number">2</span>       <span class="number">7</span></span><br><span class="line"></span><br><span class="line">另一个正确答案是 [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="keyword">null</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">7</span>]。</span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line">   \   \</span><br><span class="line">    <span class="number">4</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>更多解释看另一篇 <a href="http://imlgw.top/2019/11/08/er-fen-sou-suo-shu/#%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E5%80%BC">二叉搜索树</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;           </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.val>key) {</span><br><span class="line">        root.left=deleteNode(root.left,key);</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (root.val<key) {< span><br><span class="line">        root.right=deleteNode(root.right,key);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (root.right==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//用右子树的最小值填补删除的元素</span></span><br><span class="line">        TreeNode delNode=root;</span><br><span class="line">        root=getMin(root.right);</span><br><span class="line">        <span class="comment">//下面的left和right不能交换,还好刚开始写错了一波,不然也不会发现,哈哈啊哈哈哈</span></span><br><span class="line">        <span class="comment">//这里的deleteMin是为了删除delNode的最小值root,如果你先把delNode.left连接到了root.left</span></span><br><span class="line">        <span class="comment">//那么root就不再是最小值了,再进行deleteMin就会导致root无法删除,最后返回root,导致root.right=root形成环</span></span><br><span class="line">        <span class="comment">//结果无法打印</span></span><br><span class="line">        root.right=deleteMin(delNode.right);</span><br><span class="line">        root.left=delNode.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteMin</span><span class="params">(TreeNode node)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">    }</span><br><span class="line">    node.left=deleteMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node.left==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getMin(node.left);</span><br><span class="line">}</span><br></key)></span></pre></td></tr></tbody></table></figure></div><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如, </p><p>给定二叉搜索树:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="number">4</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">7</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">和 插入的值: <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div><p>你可以返回这个二叉搜索树:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   /</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div><p>或者这个树也是有效的:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">     <span class="number">5</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   </span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.val>val) {</span><br><span class="line">        root.left=insertIntoBST(root.left,val);   </span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (root.val<val) {< span><br><span class="line">        root.right=insertIntoBST(root.right,val);   </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></val)></span></pre></td></tr></tbody></table></figure></div><p>没啥好说的，看代码就懂了</p><h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">662. 二叉树最大宽度</a></h2><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。<strong>这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</strong></p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">           <span class="number">1</span></span><br><span class="line">         /   \</span><br><span class="line">        <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">       / \     \  </span><br><span class="line">      <span class="number">5</span>   <span class="number">3</span>     <span class="number">9</span> </span><br><span class="line"></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The maximum width existing in the third level with the length <span class="number">4</span> (<span class="number">5</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">9</span>).</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">          <span class="number">1</span></span><br><span class="line">         /  </span><br><span class="line">        <span class="number">3</span>    </span><br><span class="line">       / \       </span><br><span class="line">      <span class="number">5</span>   <span class="number">3</span>     </span><br><span class="line"></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The maximum width existing in the third level with the length <span class="number">2</span> (<span class="number">5</span>,<span class="number">3</span>).</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">          <span class="number">1</span></span><br><span class="line">         / \</span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span> </span><br><span class="line">       /        </span><br><span class="line">      <span class="number">5</span>      </span><br><span class="line"></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The maximum width existing in the second level with the length <span class="number">2</span> (<span class="number">3</span>,<span class="number">2</span>).</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 4:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">          <span class="number">1</span></span><br><span class="line">         / \</span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span></span><br><span class="line">       /     \  </span><br><span class="line">      <span class="number">5</span>       <span class="number">9</span> </span><br><span class="line">     /         \</span><br><span class="line">    <span class="number">6</span>           <span class="number">7</span></span><br><span class="line">Output: <span class="number">8</span></span><br><span class="line">Explanation:The maximum width existing in the fourth level with the length <span class="number">8</span> (<span class="number">6</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>).</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Note:</strong> Answer will in the range of 32-bit signed integer.</p><p><strong>解法一</strong></p><p>一开始居然没想到，哎😐还是菜啊</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue<treenode> queue=<span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">    LinkedList<integer> idxs=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">    idxs.add(<span class="number">1</span>);</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        <span class="keyword">while</span>(size><span class="number">0</span>){</span><br><span class="line">            TreeNode top=queue.poll();</span><br><span class="line">            <span class="keyword">int</span> index=idxs.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (top.left!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(top.left);</span><br><span class="line">                idxs.add(index*<span class="number">2</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (top.right!=<span class="keyword">null</span>) {</span><br><span class="line">                queue.add(top.right);</span><br><span class="line">                idxs.add(index*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            size--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (idxs.size()!=<span class="number">0</span>) {</span><br><span class="line">            max=Math.max(idxs.getLast()-idxs.getFirst()+<span class="number">1</span>,max);    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还是层次遍历的思路，不过需要额外添加一个索引列表，用来<strong>记录每个节点对应在完全二叉树中的索引</strong>，这个索引值完全可以根据上一层父节点的索引的到，我们初始化定义根节点的index为1，然后进行层次遍历记录每一层的每个节点的index就ok，当遍历完一层之后统计列表最左和最右两个节点之差，这个值就是当前层的宽度，最后求个最大值就ok了，很可惜，看了答案才知道</p><p><strong>解法二</strong></p><p>递归版本</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    dfs(root,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> LinkedList<>());</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node,<span class="keyword">int</span> depth,<span class="keyword">int</span> index,List<integer> leftIdxs)</integer></span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (depth>=leftIdxs.size()) {</span><br><span class="line">        leftIdxs.add(index);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//记录当前节点和当前层最左节点的差</span></span><br><span class="line">    max=Math.max(index-leftIdxs.get(depth)+<span class="number">1</span>,max);</span><br><span class="line">    dfs(node.left,depth+<span class="number">1</span>,index*<span class="number">2</span>,leftIdxs);</span><br><span class="line">    dfs(node.right,depth+<span class="number">1</span>,index*<span class="number">2</span>+<span class="number">1</span>,leftIdxs);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个版本在空间复杂度可能会低一点，list中只存每个层最左的节点，当深度大于等于list的长度时候说明当前节点一定是新一层的最左节点，这个时候添加进去就ok，然后求每个节点和当前层最左的节点index差值就最后更新最大值就ok，这个解法还是没有那么自然，还是上面的BFS好理解一点</p><h2 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938. 二叉搜索树的范围和"></a><a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">938. 二叉搜索树的范围和</a></h2><p>给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。</p><p>二叉搜索树保证具有唯一的值。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="keyword">null</span>,<span class="number">18</span>], L = <span class="number">7</span>, R = <span class="number">15</span></span><br><span class="line">输出：<span class="number">32</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">18</span>,<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">6</span>], L = <span class="number">6</span>, R = <span class="number">10</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li>树中的结点数量最多为 10000 个。</li><li>最终的答案保证小于 2^31</li></ul><p><strong>解法一</strong></p><p>还行，这题反应过来了，中序遍历</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">    preorder(root,L,R);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    rangeSumBST(root.left,L,R);</span><br><span class="line">    <span class="keyword">if</span> (root.val>=L && root.val<=R) {</span><br><span class="line">        sum+=root.val;</span><br><span class="line">    }</span><br><span class="line">    rangeSumBST(root.right,L,R);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree <span class="number">1</span>                     Tree <span class="number">2</span>                  </span><br><span class="line">          <span class="number">1</span>                         <span class="number">2</span>                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span>                     <span class="number">1</span>   <span class="number">3</span>                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      <span class="number">5</span>                             <span class="number">4</span>   <span class="number">7</span>                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">5</span>   <span class="number">4</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (t2==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>  t1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    }</span><br><span class="line">    t1.val+=t2.val;</span><br><span class="line">    t1.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">    t1.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \     </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示</p><p><strong>解法一</strong></p><p>树的题目做多了，发现其实也就几种题型，都很熟悉，这题就和上面的 <a href>二叉树的坡度</a> ，<a href>平衡二叉树</a> 很类似，这题需要注意<strong>直径不一定过根节点</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    hight(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hight</span><span class="params">(TreeNode node)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left=hight(node.left);</span><br><span class="line">    <span class="keyword">int</span> right=hight(node.right);</span><br><span class="line">    max=Math.max(left+right,max);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>和之前一样，先写了个暴力的嵌套递归😂，代码确实简介，难道这就是暴力美学么，i了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> root==<span class="keyword">null</span>?<span class="number">0</span>:Math.max(hight(root.left)+hight(root.right),Math.max(diameterOfBinaryTree(root.right),diameterOfBinaryTree(root.left)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hight</span><span class="params">(TreeNode node)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> node==<span class="keyword">null</span>?<span class="number">0</span>:Math.max(hight(node.left),hight(node.right))+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></h2><p>给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。</p><p><strong>示例 :</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">最小绝对差为<span class="number">1</span>，其中 <span class="number">2</span> 和 <span class="number">1</span> 的差的绝对值为 <span class="number">1</span>（或者 <span class="number">2</span> 和 <span class="number">3</span>）。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong> 树中至少有2个节点。</p><p><strong>解法一</strong></p><p>很可惜，这题还WA了一次。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    Stack<treenode> stack=<span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">    TreeNode cur=root;</span><br><span class="line">    <span class="keyword">int</span> diff=Integer.MAX_VALUE,last=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || cur!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        }</span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (last!=-<span class="number">1</span>) {</span><br><span class="line">            diff=Math.min(diff,Math.abs(last-cur.val));   </span><br><span class="line">        }</span><br><span class="line">        last=cur.val;</span><br><span class="line">        cur=cur.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>递归的方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> diff = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    inorder(root.left);</span><br><span class="line">    diff = last==-<span class="number">1</span>?diff:Math.min(diff,Math.abs(last-root.val));</span><br><span class="line">    last = root.val;</span><br><span class="line">    inorder(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode回溯&amp;递归</title>
      <link href="/2019/10/10/leetcode-hui-su/"/>
      <url>/2019/10/10/leetcode-hui-su/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）注意 1 不对应任何字母</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191012/Ro4wr1dv5pR7.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"23"</span></span><br><span class="line">输出：[<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String[] letter={<span class="string">" "</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<string> res=<span class="keyword">new</span> LinkedList<>();</string></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">letterCombinations</span><span class="params">(String digits)</span> </string></span>{</span><br><span class="line">    <span class="comment">//空字符串要注意</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(digits)) <span class="keyword">return</span> res;</span><br><span class="line">    letterCombinations(digits,<span class="number">0</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCombinations</span><span class="params">(String digits,<span class="keyword">int</span> index,String str)</span> </span>{</span><br><span class="line">    <span class="comment">//递归出口,当index==digits的长度的时候就说明走到尽头了</span></span><br><span class="line">    <span class="comment">//需要回头尝试其他的情况</span></span><br><span class="line">    <span class="keyword">if</span> (index==digits.length()) {</span><br><span class="line">        res.add(str);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//当前字符对应的字母组合</span></span><br><span class="line">    <span class="keyword">char</span>[] ls=letter[digits.charAt(index)-<span class="number">48</span>].toCharArray();</span><br><span class="line">    <span class="comment">//遍历每种可能,其实就是DFS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<ls.length;i++) {< span><br><span class="line">        letterCombinations(digits,index+<span class="number">1</span>,str+ls[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></ls.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>可想而知，这个算法的时间复杂度相当高，<code>3^N * 4^M = O(2^N)</code> M是能表示3个字符的数字个数，N是表示4个字符的数字个数，指数级别的算法，但是也没有其他别的比较好的算法了</p><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"25525511135"</span></span><br><span class="line">输出: [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>其实还是有一个大致的思路，但是没写出来，很多细节不知道咋处理</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </string></span>{</span><br><span class="line">    restoreIpAddresses(s,<span class="number">0</span>,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">LinkedList<string> res=<span class="keyword">new</span> LinkedList<>();</string></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreIpAddresses</span><span class="params">(String s,<span class="keyword">int</span> index,String des,<span class="keyword">int</span> count)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count><span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//到字符串末尾了</span></span><br><span class="line">    <span class="keyword">if</span> (index==s.length()) {</span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">4</span>) {</span><br><span class="line">            res.add(des.substring(<span class="number">0</span>,des.length()-<span class="number">1</span>));    </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果为0就不用切分了,这里就相当于直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(index)==<span class="string">'0'</span>) {</span><br><span class="line">        restoreIpAddresses(s,index+<span class="number">1</span>,des+<span class="string">"0."</span>,count+<span class="number">1</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//不为0就需要继续切分为1，2，3</span></span><br><span class="line">        <span class="comment">//切分过程中需要注意要小于255,同时需要一个计数器来判度是否终止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<<span class="number">4</span>;i++) {</span><br><span class="line">            <span class="keyword">if</span> (index+i<=s.length()) {</span><br><span class="line">                String temp=s.substring(index,index+i);</span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(temp)<=<span class="number">255</span>){</span><br><span class="line">                    restoreIpAddresses(s,index+i,des+temp+<span class="string">"."</span>,count+<span class="number">1</span>);    </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></h2><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"aab"</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>总算自己完整做了一题出来了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<string>> partition(String s) {</list<string></span><br><span class="line">    partition(s,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line">List<list<string>> res=<span class="keyword">new</span> ArrayList<>();</list<string></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(String s,<span class="keyword">int</span> index,List<string> lis)</string></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==s.length()) {</span><br><span class="line">        <span class="comment">//注意这里要copy一个list不能直接添加lis</span></span><br><span class="line">        <span class="comment">//lis引用的对象后面还会继续变化，最后会变为null</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index+<span class="number">1</span>;i<=s.length();i++) {</span><br><span class="line">        String temp=s.substring(index,i);</span><br><span class="line">        <span class="comment">//System.out.println(index+"="+i+"="+temp);</span></span><br><span class="line">        <span class="keyword">if</span> (isPalind(temp)) {</span><br><span class="line">            lis.add(temp);</span><br><span class="line">            partition(s,i,lis);</span><br><span class="line">            <span class="comment">//不能直接remove(temp),主要是会有重复的字符,所以会导致最后的顺序不一致,而且效率也很低</span></span><br><span class="line">            <span class="comment">//lis.remove(temp);</span></span><br><span class="line">            lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalind</span><span class="params">(String s)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=s.length()-<span class="number">1</span>;i<=j;i++,j--) {</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>4ms，93%，其实就是暴力回溯，还是挺简单的，一开始忘了<code>remove()</code>，直接把所有结果打出来了， 然后一直在想怎么调整递归的结构。。。DFS基本的套路都忘了😂</p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h2><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>经典的全排列问题，熟悉了DFS套路之后都挺简单的，注意回溯就行了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> permute(<span class="keyword">int</span>[] nums) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    permute(nums,<span class="keyword">new</span> ArrayList(),visit);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] nums,List<integer> lis,<span class="keyword">boolean</span>[] visit)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (lis.size()==nums.length) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        lis.add(nums[i]);</span><br><span class="line">        visit[i]=<span class="keyword">true</span>;</span><br><span class="line">        permute(nums,lis,visit);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        visit[i]=<span class="keyword">false</span>;</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="60-第k个排列"><a href="#60-第k个排列" class="headerlink" title="60. 第k个排列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. 第k个排列</a></h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><ol><li><code>"123"</code></li><li><code>"132"</code></li><li><code>"213"</code></li><li><code>"231"</code></li><li><code>"312"</code></li><li><code>"321"</code></li></ol><p>给定 n 和 k，返回第 k 个排列。</p><p><strong>说明：</strong></p><ul><li>给定 n 的范围是 [1, 9]。</li><li>给定 k 的范围是[1,  n!]。</li></ul><p>*<em>示例 1: *</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = <span class="number">3</span>, k = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"213"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = <span class="number">4</span>, k = <span class="number">9</span></span><br><span class="line">输出: <span class="string">"2314"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    getPermutation(n,k,<span class="number">0</span>,visit,<span class="keyword">new</span> StringBuilder(<span class="string">""</span>));</span><br><span class="line">    <span class="keyword">return</span> res.get(k-<span class="number">1</span>).toString();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<stringbuilder> res=<span class="keyword">new</span> LinkedList<>();</stringbuilder></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k,<span class="keyword">int</span> count,<span class="keyword">boolean</span>[] visit,StringBuilder str)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count == n) {</span><br><span class="line">        res.add(<span class="keyword">new</span> StringBuilder(str));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (res.size()==k) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=n;i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) {</span><br><span class="line">            str.append(i);</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            getPermutation(n,k,count+<span class="number">1</span>,visit,str);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">            str.delete(str.length()-<span class="number">1</span>,str.length());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>偶然发现这一题并没有记录，之前没有记录的原因肯定是因为方法太垃圾了，这题最优解是 <code>康托展开</code>，说实话，暂时并不想去了解😂，后面有时间再说吧</p><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>开始我很纠结这题，后来想通了，其实就是去重，遇到已经存在于结果中相同的元素就直接跳过就行了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> permuteUnique(<span class="keyword">int</span>[] nums) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//Arrays.sort(nums); 解法二需要先排序</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    permuteUnique(nums,<span class="keyword">new</span> ArrayList(),visit);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permuteUnique</span><span class="params">(<span class="keyword">int</span>[] nums,List<integer> lis,<span class="keyword">boolean</span>[] visit)</integer></span></span>{</span><br><span class="line">    HashSet<integer> set=<span class="keyword">new</span> HashSet<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (lis.size()==nums.length) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!visit[i] && !set.contains(nums[i])) {</span><br><span class="line">            lis.add(nums[i]);</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            permuteUnique(nums,lis,visit);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">            lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permuteUnique2</span><span class="params">(<span class="keyword">int</span>[] nums,List<integer> lis,<span class="keyword">boolean</span>[] visit)</integer></span></span>{</span><br><span class="line">    <span class="keyword">if</span> (lis.size()==nums.length) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//剪枝去重，和前一个元素比较</span></span><br><span class="line">        <span class="comment">//Bug警告，应该写!visit[i-1]</span></span><br><span class="line">        <span class="keyword">if</span> (i><span class="number">0</span>&&nums[i]==nums[i-<span class="number">1</span>] && !visit[i-<span class="number">1</span>]) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) {</span><br><span class="line">            lis.add(nums[i]);</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            permuteUnique2(nums,lis,visit);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">            lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>关于去重的方式，其实我们可以从回溯的<strong>根节点</strong>来考虑，也就是我们考虑最顶层的【<strong>1，1，2</strong>】的遍历情况，每一次遍历实际上都是在找<strong>以当前元素开头的排列</strong>，当第一次已经遍历完1开头的所以排列后，后面的循环再碰到1自然就可以直接跳过了，所以我们可以在一次遍历中用HashMap来去重，来保证一次循环中不会有重复的元素被选取，其实也只有这题可以用HashSet，因为这里排列是讲究顺序的，循序完全一样才是重复，后面的题都是不讲究顺序的，都需要排序才能去重，具体后面再分析</p><blockquote><p>我首先想到的就是Hash表，这里翻了下评论区好像都是用的第二种方式去重的，难道用HashSet不好么😂，第二种必须要先排序，保证相同的元素都聚在一起，方便判断，这种题在纸上画一画递归树其实就很清楚了</p></blockquote><h3 id="Bug警告"><a href="#Bug警告" class="headerlink" title="Bug警告"></a>Bug警告</h3><p>这里 <code>!visit[i-1]</code>和 <code>visit[i-1]</code>对于这题来说并不影响正确性，但是你如果将生成的过程打印出来对比下就知道为啥了，具体的请看下面 <a href>1079. 活字印刷</a> 的解释</p><h2 id="1286-字母组合迭代器"><a href="#1286-字母组合迭代器" class="headerlink" title="1286. 字母组合迭代器"></a><a href="https://leetcode-cn.com/problems/iterator-for-combination/" target="_blank" rel="noopener">1286. 字母组合迭代器</a></h2><p>请你设计一个迭代器类，包括以下内容：</p><ul><li>一个构造函数，输入参数包括：一个 有序且字符唯一 的字符串 characters（该字符串只包含小写英文字母）和一个数字 combinationLength 。</li><li>函数 next() ，按 字典序 返回长度为 combinationLength 的下一个字母组合。</li><li>函数 hasNext() ，只有存在长度为 combinationLength 的下一个字母组合时，才返回 True；否则，返回 False。</li></ul><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">CombinationIterator iterator = <span class="keyword">new</span> CombinationIterator(<span class="string">"abc"</span>, <span class="number">2</span>); <span class="comment">// 创建迭代器 iterator</span></span><br><span class="line"></span><br><span class="line">iterator.next(); <span class="comment">// 返回 "ab"</span></span><br><span class="line">iterator.hasNext(); <span class="comment">// 返回 true</span></span><br><span class="line">iterator.next(); <span class="comment">// 返回 "ac"</span></span><br><span class="line">iterator.hasNext(); <span class="comment">// 返回 true</span></span><br><span class="line">iterator.next(); <span class="comment">// 返回 "bc"</span></span><br><span class="line">iterator.hasNext(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li>1 <= combinationLength <= characters.length <= 15</li><li>每组测试数据最多包含 10^4 次函数调用。</li><li>题目保证每次调用函数 next 时都存在下一个字母组合。</li></ul><p><strong>解法一</strong></p><p>唉，真的菜，好久没写回溯了，又給忘了，这题开始被别人误导了，以为是下一个排列，然后就一直在想怎么去求next，其实根本就不用这样…</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedList<string> res=<span class="keyword">new</span> LinkedList<>();</string></span><br><span class="line"></span><br><span class="line"><span class="comment">//abc</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CombinationIterator</span><span class="params">(String characters, <span class="keyword">int</span> combinationLength)</span> </span>{</span><br><span class="line">    dfs(<span class="string">""</span>,combinationLength,<span class="number">0</span>,<span class="number">0</span>,characters);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> res.pollFirst();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur,<span class="keyword">int</span> len,<span class="keyword">int</span> index,<span class="keyword">int</span> count,String source)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count == len) {</span><br><span class="line">        res.add(cur); <span class="comment">//直接根据cur得长度判断就ok了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<source.length();i++) {< span><br><span class="line">        dfs(cur+source.charAt(i),len,i+<span class="number">1</span>,count+<span class="number">1</span>,source);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> !res.isEmpty();</span><br><span class="line">}</span><br></source.length();i++)></span></pre></td></tr></tbody></table></figure></div><blockquote><p>回头开了下之前的代码，发现都写得不好，很喜欢加个count统计数量，其实直接根据cur得长度判断就可以了</p></blockquote><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>其实一开始没写出剪枝的代码，看了一点提示后才写出了下面的的第一种剪枝的方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (k>n || n<=<span class="number">0</span> ||k<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//boolean[] visit=new boolean[n+1];</span></span><br><span class="line">    combine(n,k,<span class="number">1</span>,<span class="keyword">new</span> ArrayList(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="comment">//剪枝优化1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k,<span class="keyword">int</span> index,List<integer> lis,<span class="keyword">int</span> count)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count==k) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//1 2 3 4 | 3</span></span><br><span class="line">    <span class="comment">//index = 3 k=3  n=4 count=0 (3为头,显然是不行的,肯定会和前面重复) --> 3<=3</span></span><br><span class="line">    <span class="comment">//index = 3 k=3  n=4 count=1 (3为第二个,是可行的) --> 3 <= 2</span></span><br><span class="line">    <span class="keyword">if</span> (n-index+<span class="number">2</span><=k-count) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<=n;i++) {</span><br><span class="line">        lis.add(i);</span><br><span class="line">        combine(n,k,i+<span class="number">1</span>,lis,count+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//回溯的关键</span></span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//剪枝优化2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k,<span class="keyword">int</span> index,List<integer> lis,<span class="keyword">int</span> count)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count==k) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//循环的区间至少要有k-count个元素 也就是[i,N]之间至少要有k-count个元素</span></span><br><span class="line">    <span class="comment">//N-i+1>=k-count --> i<=n-(k-count)+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<=n-(k-count)+<span class="number">1</span>;i++) {</span><br><span class="line">        lis.add(i);</span><br><span class="line">        combine4(n,k,i+<span class="number">1</span>,lis,count+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//回溯的关键</span></span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>举个例子<code>1，2，3，4 k=3</code>  其实在循环n=3的时候就可以结束了，因为后面已经没有那么多元素可以和3构成组合了</p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 ，<code>candidates</code> 中的数字可以无限制重复被选取</p><p>说明：</p><ul><li><p>所有数字（包括 target）都是正整数。</p></li><li><p>解集不能包含重复的组合。 </p></li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>没有任何剪枝处理的回溯，感觉一开始就想好怎么剪枝还是不太容易，这题其实和上面的组合很类似，值得注意的就是子递归调用的时候传递的index参数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (candidates==<span class="keyword">null</span> || candidates.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    combinationSum(candidates,target,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> index,<span class="keyword">int</span> sum,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sum>target) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (target==sum) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//这里一次循环其实就确定了包含i的所有可能解，所以起点是index不是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<candidates.length;i++) {< span><br><span class="line">        <span class="comment">//跳过比target大的</span></span><br><span class="line">        <span class="keyword">if</span> (candidates[i]>target) <span class="keyword">continue</span>;</span><br><span class="line">        sum+=candidates[i];</span><br><span class="line">        lis.add(candidates[i]);</span><br><span class="line"><span class="comment">//其实主要就是搞清楚每次从哪里开始,以及每次循环的作用</span></span><br><span class="line">        <span class="comment">//可以重复选取自己，所以子递归也从i开始而不是i+1</span></span><br><span class="line">        combinationSum(candidates,target,i,sum,lis);</span><br><span class="line">        sum-=candidates[i];</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></candidates.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>剪枝优化，主要是要先排个序，这样如果在循环过程中，累加和已经大于target了就直接return，如果不排序就不能return，因为无法确保后面会不会更小的元素</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (candidates==<span class="keyword">null</span> || candidates.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//排序,方便剪枝</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    combinationSum(candidates,target,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="comment">//剪枝优化2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> index,<span class="keyword">int</span> sum,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sum>target) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (target==sum) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<candidates.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (sum+candidates[i]>target) <span class="keyword">return</span>;</span><br><span class="line">        sum+=candidates[i];</span><br><span class="line">        lis.add(candidates[i]);</span><br><span class="line">        <span class="comment">//注意这里传递进去的index是i</span></span><br><span class="line">        combinationSum(candidates,target,i,sum,lis);</span><br><span class="line">        sum-=candidates[i];</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></candidates.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这两天状态还可以啊，好多题都可以完全独立的写出来了😁</p><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (candidates ==<span class="keyword">null</span> || candidates.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    combinationSum2(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinationSum2</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> index,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    <span class="comment">/*if (target<0) {</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<candidates.length;i++) {< span><br><span class="line">        <span class="comment">//注意这里i>index</span></span><br><span class="line">        <span class="keyword">if</span> (i>index && candidates[i]==candidates[i-<span class="number">1</span>]  ) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//排过序的,可以直接return</span></span><br><span class="line">        <span class="keyword">if</span> (target-candidates[i]<<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        lis.add(candidates[i]);</span><br><span class="line">        combinationSum2(candidates,target-candidates[i],i+<span class="number">1</span>,lis);</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></candidates.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>回溯其实值得注意的就那几个点，循环的起点，下次递归的起点，回溯，出口，这几个点都搞清楚了其实就很简单了，关键的地方就是如何去重</p><p>这题如果参照上面[全排列2](## 47. 全排列 II) 的第一种HashSet的去重方式的话，明显是有问题的，HashSet的去重方式只能保证<strong>每一次循环中不会有重复的元素被选取</strong>，但是这题即使循环中没有重复的元素被选取，结果仍然会有重复</p><p>比如 <code>10,1,2,7,6,1,5</code> 遍历1的时候会得到<code>1 2 5</code>，后续遍历2的时候又会得到一个 <code>2 1 5</code> ，但是其实在第一次循环的时候就<strong>已经找到了所有包含1的解，后面循环中包含1的解其实都重复了</strong>，如果我们排序后就变为 <code>1 1 2 5 6 7 10</code> 把相同的元素聚集到一起，一方面可以去重，另一方面还可以剪枝，在第一次循环的时候就已经找到了所有的 带有1的解，后面的连着的1都可以跳过了，后续就不会再有包含1的解了，如果不排序，后面仍然会有包含1的解</p><h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></h2><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p><strong>说明：</strong></p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">9</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>感觉比上面两题还简单一点，可以直接剪枝</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List<list<integer>> combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) {</list<integer></span><br><span class="line">    combinationSum3(k,n,<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//n=9 1 2 6, 1 3 5, 2 3 4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n,<span class="keyword">int</span> index,<span class="keyword">int</span> count,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count==k && n==<span class="number">0</span>) {</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<=<span class="number">9</span>;i++) {</span><br><span class="line">        <span class="comment">//有序的,可以直接return</span></span><br><span class="line">        <span class="keyword">if</span> (n-i<<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        lis.add(i);</span><br><span class="line">        combinationSum3(k,n-i,i+<span class="number">1</span>,count+<span class="number">1</span>,lis);</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h2><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List<list<integer>> subsets(<span class="keyword">int</span>[] nums) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    subsets(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    <span class="comment">//if (index<=nums.length) {</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">    <span class="comment">//}</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i<nums.length;i++) {< span><br><span class="line">        lis.add(nums[i]);</span><br><span class="line">        subsets(nums,i+<span class="number">1</span>,lis);</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>简单的回溯，注意收集结果的时机就行</p><p><strong>解法二</strong></p><p>BFS，类似于二叉树层次遍历，首先初始化一个空的list，后面每次迭代都将list中的所有元素都取出来加上当前元素，再重新加入到list中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> subsets(<span class="keyword">int</span>[] nums) {</list<integer></span><br><span class="line">    List<list<integer>> queue=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    }</span><br><span class="line">    queue.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> next=queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<next;j++) {< span><br><span class="line">            List<integer> temp=<span class="keyword">new</span> ArrayList(queue.get(j));</integer></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            queue.add(temp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">}</span><br></next;j++)></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h2><p>给定一个<strong>可能包含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>和40题很类似，主要就是这个去重的操作，比如题目给的case，<code>[1,2,2]</code> 已经有序了，在选择第一个2的时候其实就已经将所有包含2的子集都求出来了，后面的2就可以直接跳过，当然这里1，2，2本身就是有序的，试想如果是<code>2,1,2</code> 遍历第一个2会将所有包含2的子集求出来，但是遍历到1的时候会将第三个2包含进来，也就是<code>1，2</code> 这个解，但是前面已经求出了<code>[2,1]</code> 这就重复了，排序就是为了将相同的元素聚合到一起，这样遇到相同的元素就跳过，后面的元素就不会再包含已经遍历过的元素了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> subsetsWithDup(<span class="keyword">int</span>[] nums) {</list<integer></span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//需要先排序，便于跳过相同的元素</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    subsets(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>  List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList(lis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (i>index && nums[i] == nums[i-<span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        lis.add(nums[i]);</span><br><span class="line">        subsets(nums,i+<span class="number">1</span>,lis);</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/" target="_blank" rel="noopener">357. 计算各个位数不同的数字个数</a></h2><p>给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">91</span> </span><br><span class="line">解释: 答案应为除去 <span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span> 外，在 [<span class="number">0</span>,<span class="number">100</span>) 区间内的所有数字。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><blockquote><p>这里要存个疑问，这里的回溯记忆化应该是错的，可能是数据太少了，没测试出来，但是居然真的提高了效率。。。。这就很诡异</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//这种可以做记忆化,0ms</span></span><br><span class="line">Integer[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=<span class="number">9</span>;i++) { <span class="comment">//不考虑0开头的</span></span><br><span class="line">        visit[i]=<span class="keyword">true</span>;</span><br><span class="line">        res+=countNumbersWithUniqueDigits2(n,visit,<span class="number">1</span>);</span><br><span class="line">        visit[i]=<span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>; <span class="comment">//加的是0这种情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//[index,n](位数)区间内,能构成最多的不重复数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">boolean</span>[] visit,<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (index==n) { <span class="comment">//没得选,只有一种</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<=<span class="number">9</span>;i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) {</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            count+=countNumbersWithUniqueDigits2(n,visit,index+<span class="number">1</span>);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[index]=count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我都不好意思放到回溯专题中，开始写了个贼脑残的回溯451ms，实在不好意思放上来</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//数学方法(初中数学)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits3</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n><span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">10</span>,count=<span class="number">9</span>; <span class="comment">//i=1的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<=n;i++) {</span><br><span class="line">        count*=(<span class="number">11</span>-i); <span class="comment">//9*9*8*7*6*5.....</span></span><br><span class="line">        res+=count;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>说实话，这种方法我一开始写第一种很脑残的回溯的时候推出来了的，但是我居然没意识到。。。。</p><h2 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a>89. 格雷编码</h2><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释:</span><br><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">0</span></span><br><span class="line">输出: [<span class="number">0</span>]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 <span class="number">0</span> 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 <span class="number">2</span>n。当 n = <span class="number">0</span> 时，长度为 <span class="number">20</span> = <span class="number">1</span>。</span><br><span class="line">     因此，当 n = <span class="number">0</span> 时，其格雷编码序列为 [<span class="number">0</span>]。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>又一个脑残做法。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">grayCode3</span><span class="params">(<span class="keyword">int</span> n)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    res.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> max=(<span class="number">1</span><<n)-<span class="number">1</n)-<span></span>; <span class="comment">//注意优先级</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[max+<span class="number">1</span>];</span><br><span class="line">    grayCode3(max,res,visit);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grayCode3</span><span class="params">(<span class="keyword">int</span> max,List<integer> lis,<span class="keyword">boolean</span>[] visit)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (lis.size()>max) { <span class="comment">// list.size()==max+1 eg. when max=3 the list.size()=4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> last=lis.get(lis.size()-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=max;i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visit[i] && Integer.bitCount(i^last)==<span class="number">1</span>) {</span><br><span class="line">            lis.add(i);</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(grayCode3(max,lis,visit)){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>正常的回溯，每次修改一位，<strong>直接生成下一个可能的格雷码</strong>，而不是向上面一样一个个遍历。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//常规回溯</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">grayCode2</span><span class="params">(<span class="keyword">int</span> n)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span><<n];< span><br><span class="line">    res.add(<span class="number">0</span>);</span><br><span class="line">    visit[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    grayCode2(n,res,visit,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grayCode2</span><span class="params">(<span class="keyword">int</span> n,List<integer> lis,<span class="keyword">boolean</span>[] visit,<span class="keyword">int</span> last)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (lis.size()>=(<span class="number">1</span><<n)) { <span class="comment">// list.size()==max+1 eg. when max=3 the list.size()=4</n))></span></n];<></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++) {< span><br><span class="line">        <span class="comment">//直接生成下一个</span></span><br><span class="line">        <span class="keyword">int</span> next=last^(<span class="number">1</span><<i); <span class="comment">//这一步其实就是从后往前,依次改变last一位</i);></span></n;i++)></span><br><span class="line">        <span class="keyword">if</span> (!visit[next]) {</span><br><span class="line">            lis.add(next);</span><br><span class="line">            visit[next]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(grayCode2(n,lis,visit,next)){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">            visit[next]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法三</strong></p><p>不停的和自己右移一位的值做异或，最终就可以的到完整的格雷码，至于原理并不想去研究😂，先记住再说</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//最优解,规律</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">1</span><<n;i++) {< span><br><span class="line">        res.add(i^(i>><span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></n;i++)></span></pre></td></tr></tbody></table></figure></div><p>看了评论区发现还有个规律，每一层的格雷码都是上一层前面加0 和逆序上一层在前面加1，感觉可能和上面的规律是一样的，一图以蔽之</p><p><img alt="leetCode题解" data-src="http://static.imlgw.top/blog/20191219/7rzdkpDvA4IN.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h2 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a><a href="https://leetcode-cn.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">526. 优美的排列</a></h2><p>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p><ol><li>第 i 位的数字能被 i 整除</li><li>i 能被第 i 位上的数字整除</li></ol><p>现在给定一个整数 N，请问可以构造多少个优美的排列？</p><p><strong>解法一</strong></p><p>回溯法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> countArrangement(N,visit,<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">boolean</span>[] visit,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index > N) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=N;i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visit[i] && (index%i==<span class="number">0</span> || i%index==<span class="number">0</span>)) {</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            res+=countArrangement(N,visit,index+<span class="number">1</span>);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实我是想改成记忆化递归的，不然我也不会这样写，但是后面改的时候居然出了bug，这也算是打醒了我，我一直以为这样的回溯都能改成记忆化递归。。。这里很明显无法做记忆化，因为你每次回溯的时候index相同，但是visit数组的状态是不一样的，直接记忆化肯定就错了。。。但是说到这里我发现上面的 <a href="##">357.各个位数不同数字个数</a> 居然这样过了，并且还真的提高了效率。。。。</p><h2 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener">784. 字母大小写全排列</a></h2><p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: S = <span class="string">"a1b2"</span></span><br><span class="line">输出: [<span class="string">"a1b2"</span>, <span class="string">"a1B2"</span>, <span class="string">"A1b2"</span>, <span class="string">"A1B2"</span>]</span><br><span class="line"></span><br><span class="line">输入: S = <span class="string">"3z4"</span></span><br><span class="line">输出: [<span class="string">"3z4"</span>, <span class="string">"3Z4"</span>]</span><br><span class="line"></span><br><span class="line">输入: S = <span class="string">"12345"</span></span><br><span class="line">输出: [<span class="string">"12345"</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意：</strong></p><ul><li>S 的长度不超过12。</li><li>S 仅由数字和字母组成。 </li></ul><p><strong>解法一</strong></p><p>一看是简单题，屁颠屁颠就开始搞，结果发现没想象中简单（主要是我太菜了）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List<string> res=<span class="keyword">new</span> ArrayList<>();</string></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </string></span>{</span><br><span class="line">    letterCasePermutation(S,<span class="number">0</span>,<span class="keyword">new</span> StringBuilder(S));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCasePermutation</span><span class="params">(String S,<span class="keyword">int</span> index,StringBuilder cur)</span> </span>{</span><br><span class="line">    res.add(cur.toString()); <span class="comment">//变化一次就添加一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<s.length();i++) {< span><br><span class="line">        <span class="keyword">char</span> c=S.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c>=<span class="string">'0'</span> && c<=<span class="string">'9'</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        cur.replace(i,i+<span class="number">1</span>,letterCase(c));</span><br><span class="line">        letterCasePermutation(S,i+<span class="number">1</span>,cur);</span><br><span class="line">        cur.replace(i,i+<span class="number">1</span>,letterCase(cur.charAt(i))); <span class="comment">//状态重置</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里其实有一个小技巧：c^(1<<5)就可以使大写变小写,小写变大写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">letterCase</span><span class="params">(<span class="keyword">char</span> c)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (c>=<span class="string">'a'</span> && c<=<span class="string">'z'</span>) { <span class="comment">//65:A 97:a</span></span><br><span class="line">        c-=<span class="number">32</span>;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (c>=<span class="string">'A'</span> && c<=<span class="string">'Z'</span>) {</span><br><span class="line">        c+=<span class="number">32</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c+<span class="string">""</span>;</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>这里的状态重置和之前的不太一样，不过整体还是很好想的，其实也可以完全不用循环的形式</p><h2 id="1079-活字印刷"><a href="#1079-活字印刷" class="headerlink" title="1079. 活字印刷"></a><a href="https://leetcode-cn.com/problems/letter-tile-possibilities/" target="_blank" rel="noopener">1079. 活字印刷</a></h2><p>你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"AAB"</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可能的序列为 <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"AA"</span>, <span class="string">"AB"</span>, <span class="string">"BA"</span>, <span class="string">"AAB"</span>, <span class="string">"ABA"</span>, <span class="string">"BAA"</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"AAABBC"</span></span><br><span class="line">输出：<span class="number">188</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ol><li><code>1 <= tiles.length <= 7</code></li><li><code>tiles</code> 由大写英文字母组成</li></ol><p><strong>解法一</strong></p><p>这道题还是挺有意思的，有点结合全排列和子集的意思，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(String tiles)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[tiles.length()];</span><br><span class="line">    <span class="keyword">char</span>[] cs=tiles.toCharArray();</span><br><span class="line">    Arrays.sort(cs);</span><br><span class="line">    numTilePossibilities(cs,visit);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序去重</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="keyword">char</span>[]cs,<span class="keyword">boolean</span>[] visit)</span> </span>{</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<cs.length;i++) {< span><br><span class="line">        <span class="comment">//想清楚这里为啥必须是!visit[i-1]</span></span><br><span class="line">        <span class="keyword">if</span>(i><span class="number">0</span> && cs[i]==cs[i-<span class="number">1</span>] && !visit[i-<span class="number">1</span>]){ </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) {</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            numTilePossibilities(cs,visit);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></cs.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这题收获比较大，对排列组合类型的题目又多了一层理解，同时也纠正了之前的错误观点</p><h3 id="Bug警告！！！"><a href="#Bug警告！！！" class="headerlink" title="Bug警告！！！"></a>Bug警告！！！</h3><p>看一下最开始写的错误解法，唯一的区别就在这个<code>!visit[i-1]</code>上！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i><span class="number">0</span> && cs[i]==cs[i-<span class="number">1</span>] && visit[i-<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure></div><p>这里我之前一直理解成了保留第一个分支，上一个元素已经访问过了，后面就直接跳过，做了这一题写出问题了才知道原来这里完全理解反了😂，当时没有仔细想，其实这里细想一下就很容易发现问题，visit数组其实保证的是当前这一条<strong>自上而下的纵向分支内不会有重复</strong>，而这里我们<strong>要确保的其实是横向的不重复，也就是同一层内不重复</strong>，所以这里使用<code>visit[i-1]</code> 其实从语义上来说就是有问题的，画个图来说明下为啥会有问题</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191221/Fv53BFPU6n1y.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>画个递归树，然后模拟一下，其实就明白了，使用<code>visit[i-1]</code>的方式，生成的第一个分支其实就不完整了，只有后面的第二个分支才会是完整的，所以<strong>可以理解为保留最后一个分支，将前面的分支剪掉</strong>，在全排列中因为有长度限制，第一个分支并没有达到给定的长度，所以并不会加入结果集，对结果没有影响，（其实是会影响效率的，会重复的遍历分支，这个打印一下生成全排列过程的结果集就能看出来）</p><p>但是在这一题，并没有长度的限制，所以count会将第一个不完整的分支也当作结果集算进去，而后面第二个分支的时候（完整分支）又会计算一遍，结果就错了</p><p>那为什么<code>!visit[i-1]</code> 就可以呢？</p><p>其实也很好理解，visit虽然保证的是纵向的不重复，但是每遍历完一个分支后，都会回溯状态，而我们又是<strong>按照顺序来遍历元素</strong>的，所以如果上一个元素的 visit[i]是false，那就说明上一个元素的分支已经遍历完了！以它开头的所有排列都找完了，这个时候我们判断是否相等然后跳过，才是真正的保留了第一个分支！后面的直接跳过，减少了多余的操作，同时也不会出现bug，所以你明白以后要用那个了吧😉</p><h2 id="1291-顺次数"><a href="#1291-顺次数" class="headerlink" title="1291. 顺次数"></a><a href="https://leetcode-cn.com/problems/sequential-digits/" target="_blank" rel="noopener">1291. 顺次数</a></h2><p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。</p><p>请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输出：low = <span class="number">100</span>, high = <span class="number">300</span></span><br><span class="line">输出：[<span class="number">123</span>,<span class="number">234</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输出：low = <span class="number">1000</span>, high = <span class="number">13000</span></span><br><span class="line">输出：[<span class="number">1234</span>,<span class="number">2345</span>,<span class="number">3456</span>,<span class="number">4567</span>,<span class="number">5678</span>,<span class="number">6789</span>,<span class="number">12345</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li>10 <= low <= high <= 10^9 </li></ul><p><strong>解法一</strong></p><p>回溯tag下的，某一次周赛的题，我写的已经不像回溯了，尾递归，有点鸡肋</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">sequentialDigits</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </integer></span>{</span><br><span class="line">    String slow=String.valueOf(low);</span><br><span class="line">    <span class="keyword">int</span> slen=slow.length();</span><br><span class="line">    <span class="keyword">int</span> first=Integer.valueOf(slow.charAt(<span class="number">0</span>))-<span class="string">'0'</span>-<span class="number">1</span>;</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">int</span> start=first,len=slen;</span><br><span class="line">    <span class="keyword">if</span>(first+len><span class="number">9</span>){</span><br><span class="line">        start=<span class="number">0</span>;</span><br><span class="line">        len++;</span><br><span class="line">    }</span><br><span class="line">    sequentialDigits(low,high,start,len,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String str=<span class="string">"123456789"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sequentialDigits</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> start,<span class="keyword">int</span> len,List<integer> list)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(start+len><span class="number">9</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> cur=Integer.valueOf(str.substring(start,start+len));</span><br><span class="line">    <span class="keyword">if</span>(cur>high){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(cur>=low){</span><br><span class="line">        list.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(start+len==<span class="number">9</span>){</span><br><span class="line">        sequentialDigits(low,high,<span class="number">0</span>,len+<span class="number">1</span>,list);    </span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        sequentialDigits(low,high,start+<span class="number">1</span>,len,list);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实直接暴力枚举<code>1~9</code>的所有顺序组合然后判断在不在<code>low~high</code> 之间就ok了，最再排个序就ok，一共也只有36个，个人感觉我上面的还是比单纯的暴力会好一点，首先不用排序，其次也不会从头开始遍历，会根据low的值来选取从哪里开始截取，但是这题数据量有限，体现不出来差异</p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 <code>n = 3</code>，生成结果为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>哎，知道是回溯还是没做出来，还是太菜了啊</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </string></span>{</span><br><span class="line">    dfs(n,<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<string> res=<span class="keyword">new</span> LinkedList<>();</string></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,String sb,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left>n <span class="comment">/*|| right>n*/</span> || right>left) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left==n && right ==n) {</span><br><span class="line">        res.add(sb.toString());   </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    dfs(n,sb+<span class="string">"("</span>,left+<span class="number">1</span>,right);</span><br><span class="line">    dfs(n,sb+<span class="string">")"</span>,left,right+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>关键还是没想明白这题的递归条件，我知道是先生成 “(“ 再生成 “)” 但是终止条件一直没想清楚，其实我们需要给左右括号加一个计数器<code>left和right</code>，用来记录已经生成的左右括号的数量，然后我们思考终止条件是啥，首先很容易想到的就是左右括号数量 <code>left==right</code> 的时候，这是合法的终止条件，但是这样就够了么？很明显不够，<code>()))((</code> 类似这样的就并不是合法的，所以我们还需要保证生成括号的合法性，所以这种时候若是不太清楚的就可以来画一画递归树</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191024/9uvjEQzjtKtf.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>图画的比较魔性，但是还是很容易看懂的，通过这个递归树我还发现了上面代码的一点小问题，<code>right>n</code> 是个冗余条件，合法条件 <code>right<left<n< code>，right肯定不会超过n，正如上面三个画 ❌的地方就是对应的三个不合法的终止条件，有了这个就可以很容易的写出回溯代码，下面的是用的<code>StringBuilder</code>的，需要回溯字符串，更符合回溯的思想，上面的String是不可变对象，所以不需要手动回溯</left<n<></code></p><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </string></span>{</span><br><span class="line">    dfs(n,<span class="keyword">new</span> StringBuilder(),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List<string> res=<span class="keyword">new</span> LinkedList<>();</string></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,StringBuilder sb,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left>n || right>n || right>left) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left==n && right ==n) {</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    dfs(n,sb.append(<span class="string">"("</span>),left+<span class="number">1</span>,right);</span><br><span class="line">    sb.delete(sb.length()-<span class="number">1</span>,sb.length());</span><br><span class="line">    dfs(n,sb.append(<span class="string">")"</span>),left,right+<span class="number">1</span>);</span><br><span class="line">    sb.delete(sb.length()-<span class="number">1</span>,sb.length());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306. 累加数"></a><a href="https://leetcode-cn.com/problems/additive-number/" target="_blank" rel="noopener">306. 累加数</a></h2><p>累加数是一个字符串，组成它的数字可以形成累加序列。</p><p>一个有效的累加序列必须<strong>至少</strong>包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。</p><p>给定一个只包含数字 <code>'0'-'9'</code> 的字符串，编写一个算法来判断给定输入是否是累加数。</p><p><strong>说明:</strong> 累加序列里的数不会以 0 开头，所以不会出现 <code>1, 2, 03</code> 或者 <code>1, 02, 3</code> 的情况。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"112358"</span></span><br><span class="line">输出: <span class="keyword">true</span> </span><br><span class="line">解释: 累加序列为: <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> 。<span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>, <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span>, <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span>, <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"199100199"</span></span><br><span class="line">输出: <span class="keyword">true</span> </span><br><span class="line">解释: 累加序列为: <span class="number">1</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">199</span>。<span class="number">1</span> + <span class="number">99</span> = <span class="number">100</span>, <span class="number">99</span> + <span class="number">100</span> = <span class="number">199</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶:</strong></p><ul><li>你如何处理一个溢出的过大的整数输入?</li></ul><p><strong>解法一</strong></p><p>在回溯专题里翻到的，说实话，case有点恶心</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>{</span><br><span class="line">    LinkedList<string> list=<span class="keyword">new</span> LinkedList<>();</string></span><br><span class="line">    list.add(<span class="string">"-1"</span>);</span><br><span class="line">    list.add(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(num,<span class="number">0</span>,list);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String num,<span class="keyword">int</span> index,List<string> list)</string></span> </span>{</span><br><span class="line">    <span class="comment">//System.out.println(list);</span></span><br><span class="line">    <span class="keyword">if</span> (index==num.length() && list.size()><span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>;i<=num.length();i++){</span><br><span class="line">        <span class="comment">//0开头应该直接break,除非是单独的0....</span></span><br><span class="line">        <span class="keyword">if</span> (num.charAt(index)==<span class="string">'0'</span> && i>index+<span class="number">1</span>) { <span class="comment">//"101" .....</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (i-index>num.length()/<span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        String sub=num.substring(index,i);</span><br><span class="line">        String a=list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">        String b=list.get(list.size()-<span class="number">2</span>);</span><br><span class="line">        list.add(sub);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="string">"-1"</span>.equals(a)||<span class="string">"-1"</span>.equals(b) || addTwoStr(a,b).equals(sub)) && dfs(num,i,list)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//大数相加</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">addTwoStr</span><span class="params">(String a,String b)</span></span>{</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> aIdx=a.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> bIdx=b.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">while</span>(aIdx>=<span class="number">0</span> || bIdx>=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> as=aIdx>=<span class="number">0</span>?a.charAt(aIdx)-<span class="number">48</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bs=bIdx>=<span class="number">0</span>?b.charAt(bIdx)-<span class="number">48</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=as+bs+temp;</span><br><span class="line">        temp=(sum)/<span class="number">10</span>;</span><br><span class="line">        res.append(sum%<span class="number">10</span>);</span><br><span class="line">        aIdx--;bIdx--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (temp==<span class="number">1</span>) {</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>回溯不难想到，这一类回溯咋说呢，属于 “一镜到底” 的那种，可以看看解数独的哪个解法，也是这样的（其实就是参考的那个）带一个boolean返回值，走到结尾走不通才会回溯，N皇后这种就不太一样，不管是否成功都会回溯，反正目前大致的感觉就是这样，后面遇到更多题型再来总结</p><p>不过感觉这题的关键不是回溯，而是边界的处理，首先是溢出的问题，我看见有进阶的就没考虑溢出，结果还是溢出了，而且溢出了两次！！！最后没办法，也不想用<code>BigInteger</code>就自己写了大数相加的逻辑</p><p>除了溢出的问题，这题需要注意 <code>0</code> 在这个<code>0</code> 上也WA了一发，因为回溯还是在分割字符串，但是如果有0的话就不能随便的分割了，具体看代码就懂了</p><h2 id="842-将数组拆分成斐波那契序列"><a href="#842-将数组拆分成斐波那契序列" class="headerlink" title="842. 将数组拆分成斐波那契序列"></a><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener">842. 将数组拆分成斐波那契序列</a></h2><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p><p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p><ul><li>0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；</li><li>F.length >= 3；</li><li>对于所有的0 <= i < F.length - 2，都有 <code>F[i] + F[i+1] = F[i+2]</code> 成立。</li></ul><p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p><p>返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"123456579"</span></span><br><span class="line">输出：[<span class="number">123</span>,<span class="number">456</span>,<span class="number">579</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"11235813"</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "112358130"</span><br><span class="line">输出: []</span><br><span class="line">解释: 这项任务无法完成。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"0123"</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：每个块的数字不能以零开头，因此 <span class="string">"01"</span>，<span class="string">"2"</span>，<span class="string">"3"</span> 不是有效答案。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 5：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"1101111"</span></span><br><span class="line">输出: [<span class="number">110</span>, <span class="number">1</span>, <span class="number">111</span>]</span><br><span class="line">解释: 输出 [<span class="number">11</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">11</span>] 也同样被接受。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= S.length <= 200</code></li><li>字符串 S 中只含有数字。</li></ul><p><strong>解法一</strong></p><p>和上面那题一样，但是这题会简单一点，不用处理大数相加的情况，同时限定了数字的范围就是32位int，所以只要范围超过了int32就直接break</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </integer></span>{</span><br><span class="line">    LinkedList<integer> res=<span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    dfs(S,<span class="number">0</span>,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String S,<span class="keyword">int</span> index,List<integer> lis)</integer></span></span>{</span><br><span class="line">    <span class="keyword">if</span> (index == S.length()) {</span><br><span class="line">        <span class="keyword">return</span> lis.size()><span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index+<span class="number">1</span>;i<=S.length();i++) {</span><br><span class="line">        String temp=S.substring(index,i);</span><br><span class="line">        <span class="comment">//长度大于10,或者Long解析出来大于INT_MAX了就直接break</span></span><br><span class="line">        <span class="keyword">if</span> (S.charAt(index) == <span class="string">'0'</span> && i>index+<span class="number">1</span> || temp.length()><span class="number">10</span> || Long.valueOf(temp)>Integer.MAX_VALUE) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> str=Integer.valueOf(temp);</span><br><span class="line">        <span class="keyword">int</span> one=lis.size()>=<span class="number">2</span> ? lis.get(lis.size()-<span class="number">1</span>):-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two=lis.size()>=<span class="number">2</span> ? lis.get(lis.size()-<span class="number">2</span>):-<span class="number">1</span>;</span><br><span class="line">        lis.add(str);</span><br><span class="line">        <span class="keyword">if</span> ((one==-<span class="number">1</span> || two==-<span class="number">1</span> || one+two==str) && dfs(S,i,lis)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></h2><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">'.'</span> 匹配任意单个字符</span><br><span class="line"><span class="string">'*'</span> 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></tbody></table></figure></div><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p><strong>说明:</strong></p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: <span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">'a'</span>。因此，字符串 <span class="string">"aa"</span> 可被视为 <span class="string">'a'</span> 重复了一次。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: <span class="string">".*"</span> 表示可匹配零个或多个（<span class="string">'*'</span>）任意字符（<span class="string">'.'</span>）。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aab"</span></span><br><span class="line">p = <span class="string">"c*a*b"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 表示零个或多个，这里 <span class="string">'c'</span> 为 <span class="number">0</span> 个, <span class="string">'a'</span> 被重复一次。因此可以匹配字符串 <span class="string">"aab"</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 5:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"mississippi"</span></span><br><span class="line">p = <span class="string">"mis*is*p*."</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>回溯</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> match(s,<span class="number">0</span>,p,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String s,<span class="keyword">int</span> sIdx, String p,<span class="keyword">int</span> pIdx)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sIdx>=s.length() && pIdx>=p.length()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pIdx>=p.length()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//这里的判断其实不太对,也不能说不对,会稍微慢一点,因为题目中是不会给**这样的case的</span></span><br><span class="line">    <span class="comment">//可以直接一次跳两步判断是不是*</span></span><br><span class="line">    <span class="keyword">if</span> (sIdx == s.length()) {</span><br><span class="line">        <span class="comment">//后面没有*的情况 aaa aaaa</span></span><br><span class="line">        <span class="keyword">if</span> (pIdx==p.length()-<span class="number">1</span> && p.charAt(pIdx)!=<span class="string">'*'</span>) { <span class="comment">//p也到尽头,并且不为*</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(pIdx<p.length()){ <span class="comment">//p没到尽头,检查后面的是否有两个连续的非*</p.length()){></span><br><span class="line">            <span class="keyword">if</span> (p.charAt(pIdx) != <span class="string">'*'</span> && (pIdx+<span class="number">1</span><p.length() && p.charat(pidx+<span class="number">1</p.length()></span>)!=<span class="string">'*'</span>)) {<br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            pIdx++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//aaa aaa*c</span></span><br><span class="line">        <span class="keyword">return</span> p.charAt(pIdx-<span class="number">1</span>)==<span class="string">'*'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pIdx+<span class="number">1</span> < p.length() && p.charAt(pIdx+<span class="number">1</span>) ==<span class="string">'*'</span>) { <span class="comment">//pIdx下一个是 *</span></span><br><span class="line">        <span class="comment">//*匹配至少一个</span></span><br><span class="line">        <span class="keyword">if</span> ((s.charAt(sIdx) == p.charAt(pIdx) || p.charAt(pIdx)==<span class="string">'.'</span>) && match(s,sIdx+<span class="number">1</span>,p,pIdx)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//*匹配0个</span></span><br><span class="line">        <span class="keyword">return</span> match(s,sIdx,p,pIdx+<span class="number">2</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//pIdx下一个不是*</span></span><br><span class="line">        <span class="keyword">if</span> ((p.charAt(pIdx) == s.charAt(sIdx) || p.charAt(pIdx)==<span class="string">'.'</span>) && match(s,sIdx+<span class="number">1</span>,p,pIdx+<span class="number">1</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题还是挺麻烦的，毕竟是hard题，我也是看了题解才写出来，核心就是要把题目意思理解对，我这里没有做记忆化，懒得写</p><h2 id="二维平面上的回溯"><a href="#二维平面上的回溯" class="headerlink" title="二维平面上的回溯"></a><em><strong>二维平面上的回溯</strong></em></h2><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></h2><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = <span class="string">"ABCCED"</span>, 返回 <span class="keyword">true</span>.</span><br><span class="line">给定 word = <span class="string">"SEE"</span>, 返回 <span class="keyword">true</span>.</span><br><span class="line">给定 word = <span class="string">"ABCB"</span>, 返回 <span class="keyword">false</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题其实并不难，但是我一开始就钻到死胡里去了，我直接拿起来就想的是暴力dfs从（0，0）开始遍历每种情况，直到找到一个相等的。。。我真是个hapi</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    board =</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">      ['A','B','C','E'],</span></span><br><span class="line"><span class="comment">      ['S','F','C','S'],</span></span><br><span class="line"><span class="comment">      ['A','D','E','E']</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方向: 右,下,左,上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,-<span class="number">1</span>},{-<span class="number">1</span>,<span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (board==<span class="keyword">null</span> || word==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] words=word.toCharArray();</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<board.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<board[<span class="number">0</board[<span></span>].length;j++) {</board.length;i++)></span><br><span class="line">            <span class="comment">//遍历board每个元素,以为个元素为起点都试一下</span></span><br><span class="line">            <span class="keyword">if</span>(dfs(board,words,<span class="number">0</span>,i,j,visit)){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word,<span class="keyword">int</span> index,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visit)</span> </span>{</span><br><span class="line">    <span class="comment">//遍历到word的最后一个字符了,直接比较就可以得出结果</span></span><br><span class="line">    <span class="keyword">if</span> (index == word.length-<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> word[index] == board[x][y];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     这样写如果board只有一个元素就会错了,后面的isValid会直接false,但是有可能word就是这个board</span></span><br><span class="line"><span class="comment">     if (index == word.length) {</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">     }*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当元素相等的时候才有继续的必要</span></span><br><span class="line">    <span class="keyword">if</span> (board[x][y]==word[index]) {</span><br><span class="line">        visit[x][y]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<direction.length;i++) {< span><br><span class="line">            <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//保证合法性</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(board,nx,ny)&&!visit[nx][ny]&&dfs(board,word,index+<span class="number">1</span>,nx,ny,visit)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        visit[x][y]=<span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] cs,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x>=<span class="number">0</span> && x<cs.length && y>=<span class="number">0</span> && y< cs[<span class="number">0</span>].length;</cs.length></span><br><span class="line">}</span><br></direction.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>和上面一题类似，很惭愧，一开始也没写出来，写了个大概，细节没有捋清楚</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方向: 右,下,左,上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,-<span class="number">1</span>},{-<span class="number">1</span>,<span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (grid==<span class="keyword">null</span>||grid.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<grid.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<grid[<span class="number">0</grid[<span></span>].length;j++) {</grid.length;i++)></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="string">'1'</span>&&!visit[i][j]) {</span><br><span class="line">                dfs(grid,i,j,visit);</span><br><span class="line">                res++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visit)</span> </span>{</span><br><span class="line">    <span class="comment">//其实整个dfs做的就是对visit[x][y]标记,标记为true代表访问过</span></span><br><span class="line">    visit[x][y]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<direction.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isValid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]==<span class="string">'1'</span>) {</span><br><span class="line">            dfs(grid,nx,ny,visit);</span><br><span class="line">            <span class="comment">//无需回溯visit状态</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x>=<span class="number">0</span> && x<grid.length && y>=<span class="number">0</span> && y<grid[<span class="number">0</grid[<span></grid.length></span>].length;</direction.length;i++)></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></h2><p>给定一个二维的矩阵，包含 <code>'X'</code> 和 <code>'O'</code>（<strong>字母 O</strong>）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></tbody></table></figure></div><p>运行你的函数后，矩阵变为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的</p><p><strong>解法一</strong></p><p>这题在很久以前（看了提交记录是一年前的）开始学dfs的时候，在leetcode搜索到了这一题，当时也做出来了，只不过效率感人，放上来看看是个啥玩意</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义4个方向（顺时针 右...）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] direction = { { <span class="number">1</span>, <span class="number">0</span> }, { <span class="number">0</span>, <span class="number">1</span> }, { -<span class="number">1</span>, <span class="number">0</span> }, { <span class="number">0</span>, -<span class="number">1</span> } };</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] mark = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(board.length==<span class="number">0</span>) { <span class="keyword">return</span>; }</span><br><span class="line">    <span class="comment">// 根据传进来的board给mark初始化</span></span><br><span class="line">    mark = <span class="keyword">new</span> <span class="keyword">int</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">// 遍历边缘找出边缘的 O 的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < board.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) {</span><br><span class="line">            dfs(<span class="number">0</span>, i, board);</span><br><span class="line">            <span class="comment">//执行完之后再赋值当前位置的O 避免在边缘角落的问题</span></span><br><span class="line">            mark[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (board[i][board[<span class="number">0</span>].length - <span class="number">1</span>] == <span class="string">'O'</span>) {</span><br><span class="line">            dfs(board[<span class="number">0</span>].length, i, board);</span><br><span class="line">            mark[i][board[<span class="number">0</span>].length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 上边缘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < board[<span class="number">0</span>].length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][i] == <span class="string">'O'</span>) {</span><br><span class="line">            dfs(i, <span class="number">0</span>, board);</span><br><span class="line">            mark[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 下边缘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < board[<span class="number">0</span>].length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (board[board.length - <span class="number">1</span>][i] == <span class="string">'O'</span>) {</span><br><span class="line">            dfs(i, board.length - <span class="number">1</span>, board);</span><br><span class="line">            mark[board.length - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < board.length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < board[<span class="number">0</span>].length; j++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span> && mark[i][j] == <span class="number">0</span>) {</span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tx, ty;</span><br><span class="line">    <span class="comment">// 首先判断边缘上有没有 O 有的话将与他联通的 O 都加上标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <= <span class="number">3</span>; i++) {</span><br><span class="line">        <span class="comment">// x=x+direction[i][0]; 这样写每个点向4个方向扩展如果这样写 点的走向就有问题了</span></span><br><span class="line">        tx = x + direction[i][<span class="number">0</span>];</span><br><span class="line">        ty = y + direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// System.out.println(tx+" "+ty);</span></span><br><span class="line">        <span class="keyword">if</span> (tx < board[<span class="number">0</span>].length && tx >= <span class="number">0</span> && ty < board.length && ty >= <span class="number">0</span> && board[ty][tx] == <span class="string">'O'</span></span><br><span class="line">            && mark[ty][tx] == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 代表走过了</span></span><br><span class="line">            mark[ty][tx] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里没有处理好，我的dfs函数的参数是坐标但是对应到mark里面和board里面就不是坐标了就颠倒了</span></span><br><span class="line">            <span class="comment">// 比如按照坐标来 2 , 1 ---->对应到数组里面就是 1 ，2</span></span><br><span class="line">            dfs(tx, ty, board);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>21ms，8% 乍一看好像没啥问题，但是为啥这么慢呢？看看今天下午重新做的解</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方向: 右,下,左,上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,-<span class="number">1</span>},{-<span class="number">1</span>,<span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (board==<span class="keyword">null</span> || board.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> lx=<span class="number">0</span>,ly=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历4条边的'O',将与相连的'O'都标记为true</span></span><br><span class="line">    <span class="keyword">while</span>(lx<board.length) { < span><br><span class="line">        <span class="keyword">if</span> (board[lx][<span class="number">0</span>]==<span class="string">'O'</span>) { <span class="comment">//左</span></span><br><span class="line">            dfs(board,lx,<span class="number">0</span>,visit);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (board[lx][board[<span class="number">0</span>].length-<span class="number">1</span>] == <span class="string">'O'</span>) { <span class="comment">//右</span></span><br><span class="line">            dfs(board,lx,board[<span class="number">0</span>].length-<span class="number">1</span>,visit);</span><br><span class="line">        }</span><br><span class="line">        lx++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ly<board[<span class="number">0</board[<span></span>].length) { </board.length)></span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][ly]==<span class="string">'O'</span>) { <span class="comment">//上</span></span><br><span class="line">            dfs(board,<span class="number">0</span>,ly,visit);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (board[board.length-<span class="number">1</span>][ly] == <span class="string">'O'</span>) { <span class="comment">//下</span></span><br><span class="line">            dfs(board,board.length-<span class="number">1</span>,ly,visit);   </span><br><span class="line">        }</span><br><span class="line">        ly++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历将所有visit=false的O变为X</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<board.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<board[<span class="number">0</board[<span></span>].length;j++) {</board.length;i++)></span><br><span class="line">            <span class="keyword">if</span> (board[i][j]==<span class="string">'O'</span> && !visit[i][j]) {</span><br><span class="line">                board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visit)</span> </span>{</span><br><span class="line">    visit[x][y]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<direction.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isValid(board,nx,ny) && board[nx][ny]==<span class="string">'O'</span> && !visit[nx][ny]) {</span><br><span class="line">            dfs(board,nx,ny,visit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x>=<span class="number">0</span> && x<grid.length && y>=<span class="number">0</span> && y<grid[<span class="number">0</grid[<span></grid.length></span>].length;</direction.length;i++)></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>2ms，比较明显的区别就是dfs给visit数组赋值的时机不同，一个是在循环里面，一个是在函数开头，也就是说第一种解法并不会立即给边缘的<code>'O'</code> 标记，这样导致的问题就是它后续的节点仍然会搜索到这个边缘的 <code>'O'</code> 这样就会造成重复的计算，所以说，一定要捋清楚这个过程，不能乱写</p><h2 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">417. 太平洋大西洋水流问题</a></h2><p>给定一个 <code>m x n</code> 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标</p><p><strong>提示：</strong></p><ol><li><p>输出坐标的顺序不重要</p></li><li><p>m 和 n 都小于150</p></li></ol><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定下面的 <span class="number">5</span>x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  <span class="number">1</span>   <span class="number">2</span>   <span class="number">2</span>   <span class="number">3</span>  (<span class="number">5</span>) *</span><br><span class="line">       ~  <span class="number">3</span>   <span class="number">2</span>   <span class="number">3</span>  (<span class="number">4</span>) (<span class="number">4</span>) *</span><br><span class="line">       ~  <span class="number">2</span>   <span class="number">4</span>  (<span class="number">5</span>)  <span class="number">3</span>   <span class="number">1</span>  *</span><br><span class="line">       ~ (<span class="number">6</span>) (<span class="number">7</span>)  <span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>  *</span><br><span class="line">       ~ (<span class="number">5</span>)  <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">4</span>  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[<span class="number">0</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">4</span>, <span class="number">0</span>]] (上图中带括号的单元).</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>其实和上面也是如出一辙，只不过最开始没想到两个visit数组来做</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方向键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,-<span class="number">1</span>},{-<span class="number">1</span>,<span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List<list<integer>> pacificAtlantic(<span class="keyword">int</span>[][] matrix) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    <span class="comment">//leetcode老是喜欢搞些幺蛾子</span></span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//太平洋</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] pacific=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="comment">//大西洋</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] atlantic=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<m;i++) {< span><br><span class="line">        dfs(matrix,i,<span class="number">0</span>,pacific);</span><br><span class="line">        dfs(matrix,i,n-<span class="number">1</span>,atlantic);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++) {< span><br><span class="line">        dfs(matrix,<span class="number">0</span>,i,pacific);</span><br><span class="line">        dfs(matrix,m-<span class="number">1</span>,i,atlantic);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<m;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<n;j++) {< span><br><span class="line">            <span class="comment">//同时为true的就是解</span></span><br><span class="line">            <span class="keyword">if</span> (pacific[i][j] && atlantic[i][j]) {</span><br><span class="line">                res.add(Arrays.asList(i,j));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visit)</span> </span>{</span><br><span class="line">    visit[x][y]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//向4个方向floodfill</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<direction.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isValid(matrix,nx,ny) && matrix[nx][ny]>= matrix[x][y] && !visit[nx][ny]) {</span><br><span class="line">            dfs(matrix,nx,ny,visit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x>=<span class="number">0</span> && x<matrix.length && y>=<span class="number">0</span> && y<matrix[<span class="number">0</matrix[<span></matrix.length></span>].length;</direction.length;i++)></span><br><span class="line">}</span><br></n;j++)></span></m;i++)></span></n;i++)></span></m;i++)></span></pre></td></tr></tbody></table></figure></div><p>6ms，96%，还是比较ok的</p><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></h2><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191011/ac4lTcAFesSc.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘ . ‘ 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  <span class="comment">// 解法 1</span></span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  <span class="comment">// 解法 2</span></span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: <span class="number">4</span> 皇后问题存在两个不同的解法</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>Hard题，N皇后问题可以说是很经典的问题了，之前有看过，但是都是一脸懵逼，无从下手，这一次看了下提示还是自己给做出来了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List<list<string>> res=<span class="keyword">new</span> ArrayList<>();</list<string></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] col;</span><br><span class="line"><span class="comment">//private boolean[] row;</span></span><br><span class="line"><span class="comment">//两条对角线</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] dia1;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] dia2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List<list<string>> solveNQueens(<span class="keyword">int</span> n) {</list<string></span><br><span class="line">    <span class="keyword">if</span> (n<=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    col=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="comment">//row=new boolean[n];</span></span><br><span class="line">    dia1=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    dia2=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    dfs(n,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> index,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==n) {</span><br><span class="line">        res.add(generateRes(lis));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//检测第index行第i列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++) {< span><br><span class="line">        <span class="comment">//注意对角线的下标</span></span><br><span class="line">        <span class="keyword">if</span> (!col[i] && !dia1[index-i+n-<span class="number">1</span>] && !dia2[i+index]) {</span><br><span class="line">            col[i]=<span class="keyword">true</span>;</span><br><span class="line">            dia1[index-i+n-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            dia2[index+i]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//尝试添加</span></span><br><span class="line">            lis.add(i);</span><br><span class="line">            dfs(n,index+<span class="number">1</span>,lis);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            lis.remove(lis.size()-<span class="number">1</span>);</span><br><span class="line">            col[i]=<span class="keyword">false</span>;</span><br><span class="line">            dia1[index-i+n-<span class="number">1</span>]=<span class="keyword">false</span>;</span><br><span class="line">            dia2[index+i]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据lis生成解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">generateRes</span><span class="params">(List<integer> lis)</integer></span></string></span>{</span><br><span class="line">    List<string> res=<span class="keyword">new</span> ArrayList<>();</string></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<lis.size();i++) {< span><br><span class="line">        <span class="keyword">int</span> index = lis.get(i);</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<lis.size();j++) {< span><br><span class="line">            <span class="keyword">if</span> (j!=index){</span><br><span class="line">                sb.append(<span class="string">"."</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></lis.size();j++)></span></lis.size();i++)></span></n;i++)></span></pre></td></tr></tbody></table></figure></div><p>核心思路就是：一行行遍历，然后dfs尝试在每个位置放置皇后，我觉得主要的难点在于如何判断各个列，对角线是否已经有皇后，这一点需要细致的观察，有一条对角线的横纵坐标之和为常数，另一条横纵坐标之差是个常数，借此便可以唯一确定一条对角线</p><h2 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II</a></h2><p>和上面一题不同的地方是这题只需要求解的个数，感觉这题才应该是<code>Ⅰ</code>，不用求所有的解，貌似更加简单了？</p><p><strong>解法一</strong></p><p>直接套用上面的代码，没啥好说的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n<=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    col=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="comment">//row=new boolean[n];</span></span><br><span class="line">    dia1=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    dia2=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    dfs(n,<span class="number">0</span>,<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] col;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] dia1;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] dia2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> index,List<integer> lis)</integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==n) {</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//检测第index行第i列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!col[i] && !dia1[index-i+n-<span class="number">1</span>] && !dia2[i+index]) {</span><br><span class="line">            col[i]=<span class="keyword">true</span>;</span><br><span class="line">            dia1[index-i+n-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            dia2[index+i]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//不用添加到lis中</span></span><br><span class="line">            dfs(n,index+<span class="number">1</span>,lis);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            col[i]=<span class="keyword">false</span>;</span><br><span class="line">            dia1[index-i+n-<span class="number">1</span>]=<span class="keyword">false</span>;</span><br><span class="line">            dia2[index+i]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></n;i++)></span></pre></td></tr></tbody></table></figure></div><p>虽然提交了也是1ms，主要是这两题case都比较少，最大的case好像只到11，所以差距不是很明显，我这样做肯定不是这题的最优解，这题的最优解是利用<code>位图（bitmap）</code>作位运算，反正我不可能写出来就是了😂 <a href="http://www.ic-net.or.jp/home/takaken/e/queen/" target="_blank" rel="noopener">参考</a></p><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。<br>空白格用 <code>'.'</code> 表示。</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191012/jvSukv6RnXFL.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>一个数独</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191012/XgTokVUgo5Yy.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>答案被标成红色。</p><p><strong>Note:</strong></p><ul><li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>'.'</code> </li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><p><strong>解法一</strong></p><p>嗯，又是一道hard题，自己摸了半天没做出来，看了评论区做出来的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//三个约束规则</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] col=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] row=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] block=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (board==<span class="keyword">null</span> || board.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">9</span>;i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<<span class="number">9</span>;j++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][j]!=<span class="string">'.'</span>) {</span><br><span class="line">                col[i][board[i][j]-<span class="number">48</span>-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">                row[j][board[i][j]-<span class="number">48</span>-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//块号为 i/3*3+j/3</span></span><br><span class="line">                block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][board[i][j]-<span class="number">48</span>-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    dfs(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//private  static char[][] res=new char[9][9];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="comment">//从,i,j位置向后寻找'.', i>=9说明全部填充完了</span></span><br><span class="line">    <span class="keyword">while</span>(board[i][j]!=<span class="string">'.'</span>) {</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">9</span>) {</span><br><span class="line">            i++;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//over</span></span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">9</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//System.out.println(i+","+j);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val=<span class="number">0</span>;val<<span class="number">9</span>;val++) {</span><br><span class="line">        <span class="keyword">if</span> (!col[i][val] && !row[j][val] && !block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][val]) {</span><br><span class="line">            col[i][val]=<span class="keyword">true</span>;</span><br><span class="line">            row[j][val]=<span class="keyword">true</span>;</span><br><span class="line">            block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][val]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//尝试填充为 val+1</span></span><br><span class="line">            board[i][j]=(<span class="keyword">char</span>)(val+<span class="number">1</span>+<span class="number">48</span>);</span><br><span class="line">            <span class="comment">//尝试后面的'.',这里传进去还是i,j</span></span><br><span class="line">            <span class="comment">//大脑模拟下其实这个dfs过程也挺简单</span></span><br><span class="line">            <span class="keyword">if</span>(dfs(board,i,j)){<span class="comment">//这里会尝试所有解，失败后回溯</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                board[i][j]=<span class="string">'.'</span>;</span><br><span class="line">                col[i][val]=<span class="keyword">false</span>;</span><br><span class="line">                row[j][val]=<span class="keyword">false</span>;</span><br><span class="line">                block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][val]=<span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>比上面的N皇后要更复杂，同样也是带有约束的dfs回溯，我一开始写的方法主要是思路都错了，我想的和上面n皇后一样，一层一层的搜索最后n==9就结束，但是没考虑到一层其实不只有一个<code>空位</code>，同时还要注意回溯的时机，并不是dfs之后就回溯，用大脑模拟下这个递归其实就明白了，我觉得核心还是<code>找'.'那一步</code>，这一步确实没想到</p><blockquote><p>这题有一个简单版，<a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a> 挺简单的，懒得做了</p></blockquote><h2 id="529-扫雷游戏"><a href="#529-扫雷游戏" class="headerlink" title="529. 扫雷游戏"></a><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></h2><p>让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p><p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。</li><li>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的方块都应该被递归地揭露。</li><li>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</li><li>如果在此次点击中，若无更多方块可被揭露，则返回面板。</li></ol><p><strong>示例一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>]]</span><br><span class="line"></span><br><span class="line">Click : [<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'E'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'M'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Explanation:</strong></p><p><img alt="扫雷" data-src="https://i.loli.net/2019/11/18/B26DWk8CrhPFtHI.png" src="/img/loading.gif" class="lazyload"></p><p><strong>示例二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'E'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'M'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>]]</span><br><span class="line"></span><br><span class="line">Click : [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'E'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'X'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Explanation:</strong></p><p><img alt="扫雷" data-src="https://s2.ax1x.com/2019/11/18/MyccWT.png" src="/img/loading.gif" class="lazyload"></p><p><strong>解法一</strong></p><p>标准的DFS，还是挺有意思的，向8个方向扩展，遇到周围有地雷的就计数并且停止，会玩扫雷就会做😉</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{-<span class="number">1</span>,<span class="number">1</span>},{<span class="number">1</span>,-<span class="number">1</span>},{-<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,-<span class="number">1</span>},{-<span class="number">1</span>,-<span class="number">1</span>},{<span class="number">1</span>,<span class="number">1</span>}};</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) {</span><br><span class="line">    <span class="keyword">int</span> x=click[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> y=click[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (board[x][y]==<span class="string">'M'</span>) {</span><br><span class="line">        board[x][y]=<span class="string">'X'</span>;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">    dfs(board,x,y,visit);</span><br><span class="line">    <span class="keyword">return</span> board;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visit)</span></span>{</span><br><span class="line">    visit[x][y]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> count=getRoundBoom(board,x,y);</span><br><span class="line">    <span class="keyword">if</span>(count!=<span class="number">0</span>){</span><br><span class="line">        board[x][y]=(<span class="keyword">char</span>)(count+<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    board[x][y]=<span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">8</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isValid(board,nx,ny) && !visit[nx][ny] && board[nx][ny]!=<span class="string">'M'</span>) {</span><br><span class="line">            dfs(board,nx,ny,visit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRoundBoom</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">8</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isValid(board,nx,ny) && board[nx][ny]==<span class="string">'M'</span>) {</span><br><span class="line">            count++;</span><br><span class="line">        }   </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span>[][] board,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x>=<span class="number">0</span> && x<board.length && y>=<span class="number">0</span> && y<board[<span class="number">0</board[<span></board.length></span>].length;<br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695. 岛屿的最大面积</a></h2><p>给定一个包含了一些 0 和 1的非空二维数组 <code>grid</code> , 一个 <code>岛屿</code> 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0)</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的 <code>‘1’</code>。</p><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p>对于上面这个给定的矩阵, 返回 0</p><p><strong>注意:</strong> 给定的矩阵grid 的长度和宽度都不超过 50。</p><p><strong>解法一</strong></p><p>和上面 <a href="#200-岛屿数量">200题岛屿的数量</a>很类似，不过还是有所不同，这里要计算的是最大的面积</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">0</span>,-<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{-<span class="number">1</span>,<span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (grid==<span class="keyword">null</span> || grid.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<grid.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<grid[<span class="number">0</grid[<span></span>].length;j++) {</grid.length;i++)></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span> &&!visit[i][j]) {</span><br><span class="line">                <span class="keyword">int</span> t=dfs(grid,i,j,visit);</span><br><span class="line">                max=max>t?max:t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visit)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line">    visit[x][y]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<direction.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isValid(grid,nx,ny) && grid[nx][ny]==<span class="number">1</span> && !visit[nx][ny]) {</span><br><span class="line">            <span class="comment">//将4个方向的符合条件的数量加起来</span></span><br><span class="line">            temp+=dfs(grid,nx,ny,visit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x>=<span class="number">0</span> && x<grid.length && y>=<span class="number">0</span> && y<grid[<span class="number">0</grid[<span></grid.length></span>].length;</direction.length;i++)></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>最开始直接在dfs函数里面用count计数，居然还过了600多个case…..惊了，那种做法完全是错的，说实话有点不太习惯写有返回值的递归</p><h2 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></h2><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i] [j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="number">2</span> </span><br><span class="line">说明：已知学生<span class="number">0</span>和学生<span class="number">1</span>互为朋友，他们在一个朋友圈。</span><br><span class="line">第<span class="number">2</span>个学生自己在一个朋友圈。所以返回<span class="number">2</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">说明：已知学生<span class="number">0</span>和学生<span class="number">1</span>互为朋友，学生<span class="number">1</span>和学生<span class="number">2</span>互为朋友，所以学生<span class="number">0</span>和学生<span class="number">2</span>也是朋友，所以他们三个在一个朋友圈，返回<span class="number">1</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意：</strong></p><ul><li>N 在[1,200]的范围内。</li><li>对于所有学生，有M[i] [i] = 1。</li><li>如果有M[i] [j] = 1，则有M[j] [i] = 1。</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (M==<span class="keyword">null</span> || M.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<m.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) {</span><br><span class="line">            dfs(M,visit,i);</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//一共m.length个人</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M,<span class="keyword">boolean</span>[] visit,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="comment">//标记index号学生已经访问过</span></span><br><span class="line">    visit[index]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<m.length;i++) {< span><br><span class="line">        <span class="comment">//index和i是好朋友</span></span><br><span class="line">        <span class="keyword">if</span> (M[index][i]==<span class="number">1</span> && !visit[i]) {</span><br><span class="line">            <span class="comment">//递归标记i的好朋友,形成朋友圈</span></span><br><span class="line">            dfs(M,visit,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></m.length;i++)></span></m.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这题不知道为啥，一开始题目没搞明白。。。。去纠结那个矩阵去了，没理解好题目的意思，其实跟那个N*N的矩阵没啥关系，主要是N个人，对每个人进行dfs找到与他们相关的人，做好统计就ok，和上面的 200题也很类似</p><h2 id="1219-黄金矿工"><a href="#1219-黄金矿工" class="headerlink" title="1219. 黄金矿工"></a><a href="https://leetcode-cn.com/problems/path-with-maximum-gold/" target="_blank" rel="noopener">1219. 黄金矿工</a></h2><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><ul><li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li><li>矿工每次可以从当前位置向上下左右四个方向走。</li><li>每个单元格<strong>只能被开采（进入）一次</strong>。</li><li><strong>不得开采</strong>（进入）黄金数目为 0 的单元格。</li><li>矿工可以从网格中 <strong>任意一个</strong> 有黄金的单元格出发或者是停止。  </li></ul><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：</span><br><span class="line">[[<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>]]</span><br><span class="line">一种收集最多黄金的路线是：<span class="number">9</span> -> <span class="number">8</span> -> <span class="number">7</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">9</span>,<span class="number">0</span>,<span class="number">20</span>]]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：</span><br><span class="line">[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">9</span>,<span class="number">0</span>,<span class="number">20</span>]]</span><br><span class="line">一种收集最多黄金的路线是：<span class="number">1</span> -> <span class="number">2</span> -> <span class="number">3</span> -> <span class="number">4</span> -> <span class="number">5</span> -> <span class="number">6</span> -> <span class="number">7</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li>-<code>1 <= grid.length, grid[i].length <= 15</code></li><li><code>0 <= grid[i][j] <= 100</code></li><li>最多 25 个单元格中有黄金。 </li></ul><p><strong>解法一</strong></p><p>这题还是挺有意思的，填补了我一点二维平面回溯的空缺，其实也很简单（改了好几个小时还好意思说这种话😂）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,-<span class="number">1</span>},{-<span class="number">1</span>,<span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<grid.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<grid[<span class="number">0</grid[<span></span>].length;j++) {</grid.length;i++)></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]><span class="number">0</span>) {</span><br><span class="line">                max=Math.max(dfs(grid,i,j,visit),max);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//求出从x,y开始所能获得的最大的收益，记得回溯状态，后面的节点还需要遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visit)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> maxGlod=grid[x][y]; <span class="comment">//一开始这里写的0...排了半天的错</span></span><br><span class="line">    visit[x][y]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<direction.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isValid(grid,nx,ny) && !visit[nx][ny] && grid[nx][ny]><span class="number">0</span>) {</span><br><span class="line">            <span class="comment">//求向4个方向扩展的最大值</span></span><br><span class="line">            maxGlod=Math.max(dfs(grid,nx,ny,visit)+grid[x][y],maxGlod);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    visit[x][y]=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> maxGlod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x>=<span class="number">0</span> && x<grid.length && y>=<span class="number">0</span> && y<grid[<span class="number">0</grid[<span></grid.length></span>].length;</direction.length;i++)></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路其实也很简单，对每个有金矿的点进行dfs计算路径上的金矿和就ok了，但是这题有一个很关键的条件，不能回头，下过的金矿是不能第二次再进入的，不然这题就和前面的 [695. 岛屿最大面积](##695. 岛屿的最大面积)一样了，所以很显然这题是需要状态的回溯的，访问过的节点，后面的节点还是可能需要遍历的，最开始写的一个bug就是代码中提到的，那里一开始写的0…然后排错排了好长时间。。。菜啊</p></code></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode栈&amp;队列</title>
      <link href="/2019/10/01/leetcode-zhan-dui-lie/"/>
      <url>/2019/10/01/leetcode-zhan-dui-lie/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h2><p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="string">"()"</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="string">"()[]{}"</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="string">"(]"</span></span><br><span class="line">Output: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 4:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="string">"([)]"</span></span><br><span class="line">Output: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 5:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="string">"{[]}"</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这道题只要学过数据结构的肯定会做，典型的利用栈的题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(s.length()<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack<character> stack=<span class="keyword">new</span> Stack();</character></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++){< span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span> || s.charAt(i)==<span class="string">'{'</span> || s.charAt(i)==<span class="string">'['</span>){</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//注意这种情况，一开始就是])}</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">char</span> p=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>( (p==<span class="string">')'</span> && stack.pop()!=<span class="string">'('</span>) || (p==<span class="string">']'</span> && stack.pop()!=<span class="string">'['</span>) || (p==<span class="string">'}'</span> && stack.pop()!=<span class="string">'{'</span>)){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">}</span><br></s.length();i++){<></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>其实和上面的解法是一样的，只不过是用的stack是自己用数组简单封装的栈</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span><<span class="title">T</span>></span>{</span><br><span class="line"></span><br><span class="line">    T [] objValues=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        objValues= (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T obj)</span></span>{</span><br><span class="line">        objValues[++top]=obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (top<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> objValues[top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (top<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//覆盖</span></span><br><span class="line">        <span class="keyword">return</span> objValues[top--];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> top<<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>3ms，94%，比之前快了一点，去看了下Stack的源码，它的pop是真的删除，我的只是移动了指针，所以效率会高很多</p><blockquote><p>后面的题可能都会利用这个MyStack</p></blockquote><p><strong>解法三</strong></p><p>今天看面筋看到一个写这道题，要求O(1)的空间复杂度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(s.length()<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        s=s.replace(<span class="string">"{}"</span>,<span class="string">""</span>);</span><br><span class="line">        s=s.replace(<span class="string">"()"</span>,<span class="string">""</span>);</span><br><span class="line">        s=s.replace(<span class="string">"[]"</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (len==s.length()) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.equals(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>100ms，效率感人，感觉应该说的是这种做法吧，当然还可以写正则表达式来匹配，但是我不太会写。。。</p><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p> <strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span><br><span class="line">输出：[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：[<span class="string">"H"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"h"</span>]</span><br><span class="line">输出：[<span class="string">"h"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"H"</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>很久之前做的了，本来是想单独搞一个递归专题，感觉没啥必要就直接加到一起了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length<=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    reverseString(s,<span class="number">0</span>,s.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(l>=r){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span> temp=s[l];</span><br><span class="line">    s[l]=s[r];</span><br><span class="line">    s[r]=temp;</span><br><span class="line">    reverseString(s,++l,--r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h2><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+, -, *, /</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>]</span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: ((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>) = <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: (<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>)) = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="string">"10"</span>, <span class="string">"6"</span>, <span class="string">"9"</span>, <span class="string">"3"</span>, <span class="string">"+"</span>, <span class="string">"-11"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>, <span class="string">"*"</span>, <span class="string">"17"</span>, <span class="string">"+"</span>, <span class="string">"5"</span>, <span class="string">"+"</span>]</span><br><span class="line">输出: <span class="number">22</span></span><br><span class="line">解释: </span><br><span class="line">  ((<span class="number">10</span> * (<span class="number">6</span> / ((<span class="number">9</span> + <span class="number">3</span>) * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / (<span class="number">12</span> * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / -<span class="number">132</span>)) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * <span class="number">0</span>) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= (<span class="number">0</span> + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= <span class="number">17</span> + <span class="number">5</span></span><br><span class="line">= <span class="number">22</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>{</span><br><span class="line">    <span class="comment">//上面自己封装的Stack</span></span><br><span class="line">    MyStack<integer> stack=<span class="keyword">new</span> MyStack<>(tokens.length);</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<tokens.length;i++) {< span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.equals(tokens[i])){</span><br><span class="line">            stack.push(stack.pop()+stack.pop());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(tokens[i])){</span><br><span class="line">            <span class="keyword">int</span> rd1=stack.pop();</span><br><span class="line">            <span class="keyword">int</span> rd2=stack.pop();</span><br><span class="line">            stack.push(rd2-rd1);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(tokens[i])){</span><br><span class="line">            stack.push(stack.pop()*stack.pop());</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(tokens[i])){</span><br><span class="line">            <span class="keyword">int</span> div1=stack.pop();</span><br><span class="line">            <span class="keyword">int</span> div2=stack.pop();</span><br><span class="line">            stack.push(div2/div1);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            stack.push(Integer.valueOf(tokens[i]));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">}</span><br></tokens.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>12ms，90%，其实一开始看到这个题我是拒绝的，我以为又是啥数学题，然后仔细看了下发现挺简单的，思路就是利用栈，每次遇到符号就pop两个出来进行运算，然后再入栈，值得注意的地方就是减法和除法的顺序</p><h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></h2><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 / 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"/home/"</span></span><br><span class="line">输出：<span class="string">"/home"</span></span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"/../"</span></span><br><span class="line">输出：<span class="string">"/"</span></span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"/home//foo/"</span></span><br><span class="line">输出：<span class="string">"/home/foo"</span></span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"/a/./b/../../c/"</span></span><br><span class="line">输出：<span class="string">"/c"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 5：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"/a/../../b/../c//.//"</span></span><br><span class="line">输出：<span class="string">"/c"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 6：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：<span class="string">"/a//b////c/d//././/.."</span></span><br><span class="line">输出：<span class="string">"/a/b/c"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>{</span><br><span class="line">    MyStack<string> stack=<span class="keyword">new</span> MyStack<>(path.length());</string></span><br><span class="line">    StringBuilder str=<span class="keyword">new</span> StringBuilder(path);</span><br><span class="line">    <span class="comment">//这里划分出来有一部分是空的 ""</span></span><br><span class="line">    String[] s=path.split(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() && s[i].equals(<span class="string">".."</span>)) {</span><br><span class="line">            <span class="comment">//.. 回溯</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">"."</span>.equals(s[i]) && !<span class="string">""</span>.equals(s[i]) && !s[i].equals(<span class="string">".."</span>) ) {</span><br><span class="line">            <span class="comment">//普通的英文字符abcd</span></span><br><span class="line">            stack.push(s[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">    }</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<stack.size(); i++) {< span><br><span class="line">        res.append(<span class="string">"/"</span>+stack.get(i));   </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己封装的stack</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span><<span class="title">T</span>></span>{</span><br><span class="line"></span><br><span class="line">    T [] objValues=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        objValues= (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T obj)</span></span>{</span><br><span class="line">        objValues[++top]=obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (top<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> objValues[top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (top<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is isEmpty"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//覆盖</span></span><br><span class="line">        <span class="keyword">return</span> objValues[top--];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (index>top || index < <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"index is wrong"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> objValues[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> top<<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></stack.size();></span></s.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这题本来是很简单的，但是我钻到牛角尖去了，一直想着怎么在遍历过程中处理，写了一堆ifelse。。。还是太菜了啊，其实直接按照<code>"/"</code> 划分split字符串然后处理那个数组就可以了</p><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></h2><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>empty() – Return whether the stack is empty.</li></ul><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">MyStack stack = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);  </span><br><span class="line">stack.top();   <span class="comment">// returns 2</span></span><br><span class="line">stack.pop();   <span class="comment">// returns 2</span></span><br><span class="line">stack.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a queue – which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li><li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li><li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li></ul><p><strong>解法一</strong></p><p>很经典的题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayDeque<integer> queue=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>{</span><br><span class="line">        queue=<span class="keyword">new</span> ArrayDeque();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        <span class="comment">//除了新加入的元素，其他的元素都出队再入队，将新加入的元素推置队列头</span></span><br><span class="line">        <span class="keyword">while</span>(size-- ><span class="number">1</span>){</span><br><span class="line">            queue.add(queue.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">return</span>  queue.pop();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>很巧妙的做法，将元素前n-1个出队后再重新入队，<code>1 2 --> 2 1</code> 直接将堆顶推置队列头 ，将每次新加入的元素都放置队列头而不是队尾，这样实际上就完成了逆序的操作</p><p>这样push压栈时间复杂度<code>O(N)</code> ，<code>pop/peek</code> 时间复杂度<code>O(1)</code></p><p><strong>解法二</strong></p><p>适用于push频繁的stack</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>{</span><br><span class="line">   <span class="comment">//形式上q1是负责进栈 q2负责出栈</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList inQueue=<span class="keyword">new</span> LinkedList(); </span><br><span class="line">    <span class="keyword">private</span> LinkedList outQueue=<span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title">add</span><span class="params">(Object obj)</span></span>{</span><br><span class="line">        inQueue.add(obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// q1 ----> q2 留一个</span></span><br><span class="line">        <span class="keyword">while</span>(inQueue.size()><span class="number">1</span>){</span><br><span class="line">            outQueue.add(inQueue.poll());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//交换q1,q2的引用</span></span><br><span class="line">        LinkedList temp;</span><br><span class="line">        temp=inQueue;</span><br><span class="line">        inQueue=outQueue;</span><br><span class="line">        outQueue=temp;</span><br><span class="line">        <span class="keyword">return</span> outQueue.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">peek</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//q1 --->q2 留一个,最后一个不poll,最后poll</span></span><br><span class="line">        <span class="keyword">while</span>(inQueue.size()><span class="number">1</span>){</span><br><span class="line">            outQueue.add(inQueue.poll());</span><br><span class="line">            <span class="keyword">if</span>(inQueue.size()==<span class="number">1</span>){</span><br><span class="line">                outQueue.add(inQueue.peek());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//交换q1,q2的引用</span></span><br><span class="line">        LinkedList temp;</span><br><span class="line">        temp=inQueue;</span><br><span class="line">        inQueue=outQueue;</span><br><span class="line">        outQueue=temp;</span><br><span class="line">        <span class="keyword">return</span> outQueue.poll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>两个队列，push压栈时间复杂度<code>O(1)</code>，pop/push出栈时间复杂度<code>O(N)</code> ，出栈的时候将一个队列的前n-1个元素全部加入到另一个队列中作为缓存，然后将最后一个元素出栈，最后别忘了交换两个队列的引用，不然push的时候就会出问题，要保证<code>inQueue</code> 一直是入栈的队列，其中存放着所有的元素</p><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h2><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) – Push element x to the back of queue.</li><li>pop() – Removes the element from in front of queue.</li><li>peek() – Get the front element.</li><li>empty() – Return whether the queue is empty.</li></ul><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // returns 1</span><br><span class="line">queue.pop();   // returns 1</span><br><span class="line">queue.empty(); // returns false</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a stack – which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li><li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li><li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>{</span><br><span class="line"></span><br><span class="line">    Stack<integer> inStack=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    Stack<integer> outStack=<span class="keyword">null</span>;</integer></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack2Queue232</span><span class="params">()</span> </span>{</span><br><span class="line">        inStack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">        outStack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        s2s();</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        s2s();</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> outStack.isEmpty() && inStack.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">s2s</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span>(!inStack.isEmpty()) {</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            }</span><br><span class="line">        }     </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>很上面一题是姊妹题，需要注意的地方就是<code>s2s</code>的时候要确保stack2栈是空的才能push</p><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><p>push(x) – 将元素 x 推入栈中。</p></li><li><p>pop() – 删除栈顶的元素。</p></li><li><p>top() – 获取栈顶元素。</p></li><li><p>getMin() – 检索栈中的最小元素。</p></li></ul><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --> 返回 -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --> 返回 <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --> 返回 -<span class="number">2</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>利用辅助栈，同步的push和pop</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack<integer> stack=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack<integer> helpStack=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>{</span><br><span class="line">        stack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">        helpStack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (helpStack.isEmpty()) {</span><br><span class="line">            helpStack.push(x);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span> (helpStack.peek()>x) {</span><br><span class="line">                helpStack.push(x);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                helpStack.push(helpStack.peek());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        stack.pop();</span><br><span class="line">        helpStack.pop();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> helpStack.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>在上面的基础上进行空间的优化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack<integer> stack=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack<integer> helpStack=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>{</span><br><span class="line">        stack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">        helpStack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (helpStack.isEmpty()) {</span><br><span class="line">            helpStack.push(x);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (x<=helpStack.peek()) {</span><br><span class="line">            <span class="comment">//相等的也要入栈,不然不好控制后面出栈</span></span><br><span class="line">            helpStack.push(x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> top=stack.pop();</span><br><span class="line">        <span class="comment">//和辅助栈栈顶相同就出栈</span></span><br><span class="line">        <span class="keyword">if</span>(top==helpStack.peek()){</span><br><span class="line">            helpStack.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(stack.pop()==helpStack.peek()){</span></span><br><span class="line"><span class="comment">            helpStack.pop();</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> helpStack.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实这里有一个地方把我卡了一会儿，就是出栈的时候，我开始为了简洁if的条件写的</p><p><code>stack.pop()==helpStack.peek()</code> 然后卡在了一个case上，想了半天才意识到是<code>Integer</code>的问题，这里弹出来的是两个<code>Integer</code>并不会自动拆箱，而且值是不在 -128~127之间的，所以就false了</p><p><strong>解法三</strong></p><p>帅地上看见的解法，在栈中存一个diff差值，代表当前元素和入栈前的min的差值，空间复杂度为O(1)，但是这种做法限制比较多，比如数据的大小会有限制，同时貌似也无法做<code>peek()</code>操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack155_2</span></span>{</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack<integer> stack=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack155_2</span><span class="params">()</span> </span>{</span><br><span class="line">        stack=<span class="keyword">new</span> Stack<>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">            min=x;</span><br><span class="line">            stack.push(<span class="number">0</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">int</span> diff=x-min;</span><br><span class="line">            min=diff><span class="number">0</span>?min:x;</span><br><span class="line">            stack.push(diff);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> diff=stack.pop();</span><br><span class="line">        <span class="comment">//小于等于0说明 min就是当前真实的栈顶元素,也就是说 min-minPre=diff</span></span><br><span class="line">        min=diff<=<span class="number">0</span>?min-diff:min;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*public int top() {</span></span><br><span class="line"><span class="comment">        int diff=stack.peek();</span></span><br><span class="line"><span class="comment">        return diff<=0?min:diff-min;</span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题在上一篇<a href="http://imlgw.top/2019/09/01/leetcode-dong-tai-gui-hua/">dp专题</a>中有讲过，不过是dp的解法，这里主要记录BFS的解法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSquares2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    Queue<pair> queue=<span class="keyword">new</span> LinkedList<>();</pair></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(n,<span class="number">0</span>));</span><br><span class="line">    visit[n]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="keyword">int</span> num=pair.num;</span><br><span class="line">        <span class="keyword">int</span> step=pair.step;</span><br><span class="line">        <span class="comment">//nums=0说明找到了，并且一定是最短的</span></span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> step;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i*i<=num;i++) {</span><br><span class="line">            <span class="keyword">int</span> temp=num-i*i;</span><br><span class="line">            <span class="comment">//注意不要添加重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (!visit[temp]) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(temp,step+<span class="number">1</span>));</span><br><span class="line">                visit[temp]=<span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> step)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.num=num;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>30ms 90%，比dp的方式会快很多，思路就是将这个问题转换为求图的最短路径的问题，找到一个最短的从n到0的以平方数为差的路径</p><h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></h2><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is <span class="string">"hit"</span> -> <span class="string">"hot"</span> -> <span class="string">"dot"</span> -> <span class="string">"dog"</span> -> <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Explanation: The endWord <span class="string">"cog"</span> is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题其实很久以前就写过了，当时是看了啊哈算法的一些BFS算法然后仿照书上的写的，书上是C语言写的，所以最后我写的时候也按照C的格式去写了😅，写的贼啰嗦，现在又用”Java”的方式又重新写了一遍</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List<string> wordList)</string></span>     </span>{</span><br><span class="line">    <span class="comment">// 不存在</span></span><br><span class="line">    mark = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    Que[] que = <span class="keyword">new</span> Que[wordList.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 循环促使话述祖</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < que.length; i++) {</span><br><span class="line">        que[i] = <span class="keyword">new</span> Que();</span><br><span class="line">    }</span><br><span class="line">    que[tail].word = beginWord;</span><br><span class="line">    que[tail].step = <span class="number">1</span>;</span><br><span class="line">    tail++;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head < tail) {</span><br><span class="line">        <span class="comment">// 遍历字典</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < wordList.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (mark[i] == <span class="number">0</span> && cmp(wordList.get(i), que[head].word)) {</span><br><span class="line">                que[tail].word = wordList.get(i);</span><br><span class="line">                <span class="comment">//这里是从head开始的，所以应该是head的步数+1</span></span><br><span class="line">                que[tail].step=que[head].step+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 标记为已经走过</span></span><br><span class="line">                mark[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 统计最小步数</span></span><br><span class="line">               <span class="keyword">if</span> (que[tail].word.equals(endWord)) {</span><br><span class="line">                <span class="comment">//跳出循环</span></span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                tail++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 每次检查完一个单词就将其出队列</span></span><br><span class="line">        head++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> que[tail].step;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个函数判段没吃是否只变化了一个字母</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s1.length(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Que</span> </span>{</span><br><span class="line">    String word;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这就是当时写的解法，思路就是BFS，只不过写的复杂了</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List<string> wordList)</string></span>     </span>{</span><br><span class="line">    <span class="comment">//visit数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Queue<pair> queue=<span class="keyword">new</span> LinkedList<>();</pair></span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(beginWord,<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//int flag=0;</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="comment">// 统计最小步数,放在内循环中会快一点</span></span><br><span class="line">        <span class="comment">/*if (pair.word.equals(endWord)) {</span></span><br><span class="line"><span class="comment">            return pair.step;</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">        <span class="comment">// 遍历字典</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < wordList.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (!visit[i] && cmp(wordList.get(i),pair.word)) {</span><br><span class="line">                <span class="keyword">if</span> (wordList.get(i).equals(endWord)) {</span><br><span class="line">                    <span class="comment">//这里加1 是因为取的是pair的step</span></span><br><span class="line">                    <span class="comment">//到当前这个单词还要多走一步</span></span><br><span class="line">                    <span class="keyword">return</span> pair.step+<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(wordList.get(i),pair.step+<span class="number">1</span>));</span><br><span class="line">                <span class="comment">//标记为已经走过</span></span><br><span class="line">                visit[i] = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否只变化了一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s1.length(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) {</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count><span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Pair</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>{</span><br><span class="line">    String word;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String word,<span class="keyword">int</span> step)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.word=word;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>273ms，47%中规中矩的做法，连续写了好几题BFS的，总算是对BFS的板子有点熟悉了，这题还有两个可以优化的点 ① <em>双端BFS</em> ② _寻找下一个字符串的方式_，只不过我没咋看懂，等看懂了再来补充，那种方式时间好像可以缩减到 20ms内…..</p><blockquote><p>这题有个困难版本，需要打印出所有的最短序列，这个在我很久之前的一篇文章中也有讲，但是至今我也还没有AC，一直是TLE，现在回头看我之前的代码已经看不懂了。。。写的100多行，很复杂BFS+DFS的做法，可能是没处理好所以TLE了，感兴趣可以看看<a href="http://imlgw.top/2018/10/31/yi-dao-leetcode-yin-fa-de-can-an/#2-%E5%8A%A0%E5%BC%BA%E7%89%88-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-2">那篇文章</a></p></blockquote><h2 id="779-第K个语法符号"><a href="#779-第K个语法符号" class="headerlink" title="779. 第K个语法符号"></a><a href="https://leetcode-cn.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">779. 第K个语法符号</a></h2><p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code> with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p><p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Examples:</span><br><span class="line">Input: N = <span class="number">1</span>, K = <span class="number">1</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Input: N = <span class="number">2</span>, K = <span class="number">1</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Input: N = <span class="number">2</span>, K = <span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Input: N = <span class="number">4</span>, K = <span class="number">5</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">row <span class="number">2</span>: <span class="number">01</span></span><br><span class="line">row <span class="number">3</span>: <span class="number">0110</span></span><br><span class="line">row <span class="number">4</span>: <span class="number">01101001</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>Note:</strong></p><ol><li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li><li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li></ol><p><strong>解法一</strong></p><p>找规律，前半部分和后半部分是有一定规律的，把前六行都写出来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">第一行: <span class="number">0</span></span><br><span class="line">第二行: <span class="number">01</span></span><br><span class="line">第三行: <span class="number">01</span>|<span class="number">10</span></span><br><span class="line">第四行: <span class="number">01</span> <span class="number">10</span>|<span class="number">10</span> <span class="number">01</span></span><br><span class="line">第五行: <span class="number">01</span> <span class="number">10</span> <span class="number">10</span> <span class="number">01</span>|<span class="number">10</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span></span><br><span class="line">第六行: <span class="number">01</span> <span class="number">10</span> <span class="number">10</span> <span class="number">01</span> <span class="number">10</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span> | <span class="number">10</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span> <span class="number">01</span> <span class="number">10</span> <span class="number">10</span> <span class="number">01</span></span><br></pre></td></tr></tbody></table></figure></div><p>  N%2!=0 对称, 第K个等于 2^(N-1)-K+1<br>  N%2==0 互补对称</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(K==<span class="number">1</span> || N==<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(K==<span class="number">2</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span><<(N-<span class="number">1</span>); <span class="comment">//当前行长度</span></span><br><span class="line">    <span class="keyword">if</span>(K>len/<span class="number">2</span>){ <span class="comment">//大于1/2</span></span><br><span class="line">        <span class="comment">//结合上面的规律，找前半部分和自己等价的位置</span></span><br><span class="line">        <span class="keyword">if</span>(N%<span class="number">2</span>!=<span class="number">0</span>){ </span><br><span class="line">            K=len-K+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span>(K%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">                K=len-K+<span class="number">2</span>;  </span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                K=len-K;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//去上一行继续</span></span><br><span class="line">    <span class="keyword">return</span> kthGrammar(N-<span class="number">1</span>,K);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>时间复杂第O(N)，思路还算清晰，最开始没想到用<code>位运算</code>来算长度，用的<code>pow()</code>最后效率差不多，可能是底层做了优化。</p><p><strong>解法二</strong></p><p>这种解法实际上就是把整个序列看作一颗满二叉树，每个节点的值和父节点其实是有对应关系的，如果K是偶数那么就和父节点的值相反，否则就相同，所以我们可以递归的去找父节点对应的index的值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//01排列</span></span><br><span class="line"><span class="comment">//              0</span></span><br><span class="line"><span class="comment">//          /        \   </span></span><br><span class="line"><span class="comment">//      0                1</span></span><br><span class="line"><span class="comment">//    /   \            /    \</span></span><br><span class="line"><span class="comment">//  0       1        1       0</span></span><br><span class="line"><span class="comment">// / \     /  \     /  \    / \ </span></span><br><span class="line"><span class="comment">//0   1   1    0   1    0  0   1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (K==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//(K+1)/2是对应父节点的index</span></span><br><span class="line">    <span class="keyword">int</span> parent=kthGrammar(N-<span class="number">1</span>,(K+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    <span class="keyword">int</span> f_parent=-(parent-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (K%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> f_parent;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>时间复杂度依然是<code>O(N)</code> 但是比上面那种要更清晰明了</p><p><strong>解法三</strong></p><p>这个解法其实和上面的思路是一样的，都是利用父节点和K的奇偶来判断，其实仔细看上面的代码你会发现N其实并没有实际的意义，具体K的值只和K本身有关，下面的解法就没有用到N.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthGrammar3</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> r=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(K><span class="number">1</span>){</span><br><span class="line">        <span class="keyword">if</span> (K%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">            K=K/<span class="number">2</span>;</span><br><span class="line">            r=!r;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            K=(K+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题其实还有一种解法，利用二进制，对K做奇偶检验，貌似时间复杂度是O(1)。</p><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h2><p>实现 pow(<em>x</em>, <em>n</em>) ，即计算 x 的 n 次幂函数。</p><p><strong>解法一</strong></p><p>这里就要介绍一种快速幂算法了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(n<<span class="number">0</span>){</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">double</span> res=fastPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res*res*x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>核心思想就是 <code>x^n=(x^2/n)^2</code>，常规累乘的方式计算时间复杂度是O(N)因为要遍历所有的元素，但是其实知道了<code>x^n/2</code>之后 <code>x^n</code>就可以直接平方得到了不用继续遍历，整体时间复杂度为O(logN) </p><p>2019.8.20，又写了一遍，提交然后没过。看了下给的测试用例，最后一个给的n是 <code>-2^31</code> 也就是int整数的最小值，int类型的取值范围是 <code>-2^31 ~ 2^31-1</code> 而这个负值在这里取反之后会直接溢出最后得到的还是 <code>-2^31</code> ，所以这里这样写 if会执行两次，x就又会变回来，所以结果直接就是<code>Infinity</code>无穷大了，所以为了保证if只会执行一次可以将其封装一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(n<<span class="number">0</span>){</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fastPow(x,n);</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">double</span>  half=fastPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> half*half;</span><br><span class="line">    <span class="keyword">return</span> half*half*x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="5222-分割平衡字符串"><a href="#5222-分割平衡字符串" class="headerlink" title="5222. 分割平衡字符串"></a>5222. 分割平衡字符串</h2><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p><p>给出一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。</p><p>返回可以通过分割得到的平衡字符串的最大数量</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "RLRRLLRLRL"</span><br><span class="line">输出：4</span><br><span class="line">解释：s 可以分割为 "RL", "RRLL", "RL", "RL", 每个子字符串中都包含相同数量的 'L' 和 'R'。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "RLLLLRRRLR"</span><br><span class="line">输出：3</span><br><span class="line">解释：s 可以分割为 "RL", "LLLRRR", "LR", 每个子字符串中都包含相同数量的 'L' 和 'R'。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = "LLLLRRRR"</span><br><span class="line">输出：1</span><br><span class="line">解释：s 只能保持原样 "LLLLRRRR".</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= s.length <= 1000</code></li><li><code>s[i] = 'L' 或 'R'</code></li></ul><p><strong>解法一</strong></p><p>19.10.13的周赛的第1题，果然比赛和刷题还是不一样，差点没做出来。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s.length()%<span class="number">2</span>==<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack<character> stack=<span class="keyword">new</span> Stack<>();</character></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++){< span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() ){</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==stack.peek()) {</span><br><span class="line">                stack.push(s.charAt(i));    </span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">                    count++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></s.length();i++){<></span></pre></td></tr></tbody></table></figure></div><h2 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener">1249. 移除无效的括号</a></h2><p>给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。</p><p>你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li><li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li></ul><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"lee(t(c)o)de)"</span></span><br><span class="line">输出：<span class="string">"lee(t(c)o)de"</span></span><br><span class="line">解释：<span class="string">"lee(t(co)de)"</span> , <span class="string">"lee(t(c)ode)"</span> 也是一个可行答案。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"a)b(c)d"</span></span><br><span class="line">输出：<span class="string">"ab(c)d"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"))(("</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：空字符串也是有效的</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"(a(b(c)d)"</span></span><br><span class="line">输出：<span class="string">"a(b(c)d)"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= s.length <= 10^5</code></li><li><code>s[i]</code> 可能是 <code>'('</code>、<code>')'</code> 或英文小写字母 </li></ul><p><strong>解法一</strong></p><p>11.3周赛第三题，这题倒是没什么障碍，用栈就ok，不过我这里实现的不太好，replace时间复杂度略高，应该用一个数组做mark最后用StringBuilder做append应该效率会高很多</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    Stack<integer> stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)>=<span class="string">'a'</span> && s.charAt(i)<=<span class="string">'z'</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">                sb.replace(i,i+<span class="number">1</span>,<span class="string">"*"</span>);    </span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                stack.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>) {</span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">int</span> temp=stack.pop();</span><br><span class="line">        sb.replace(temp,temp+<span class="number">1</span>,<span class="string">"*"</span>);</span><br><span class="line">    }</span><br><span class="line">    String res=sb.toString().replace(<span class="string">"*"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a><a href="https://leetcode-cn.com/problems/score-of-parentheses/" target="_blank" rel="noopener">856. 括号的分数</a></h2><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p><ul><li>() 得 1 分。</li><li>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。</li><li>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</li></ul><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入： <span class="string">"()"</span></span><br><span class="line">输出： <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入： <span class="string">"(())"</span></span><br><span class="line">输出： <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入： <span class="string">"()()"</span></span><br><span class="line">输出： <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入： <span class="string">"(()(()))"</span></span><br><span class="line">输出： <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ol><li>S 是平衡括号字符串，且只含有 ( 和 ) 。</li><li>2 <= S.length <= 50</li></ol><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String S)</span> </span>{</span><br><span class="line">    Stack<integer> stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++){< span><br><span class="line">        <span class="keyword">if</span>(S.charAt(i)==<span class="string">'('</span>){</span><br><span class="line">            stack.push(-<span class="number">11111</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//遇到右括号,下面的分支都是处理 ")"</span></span><br><span class="line">            <span class="keyword">int</span> top=stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(top == -<span class="number">11111</span>){ <span class="comment">//栈顶是左括号，将 ( --> 1</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.push(<span class="number">1</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>; <span class="comment">//遇到数值了</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">                    <span class="keyword">int</span> temp=stack.pop();</span><br><span class="line">                    <span class="comment">//弹出去,直到遇到 "("就*2,其实就是把"(1"-->2</span></span><br><span class="line">                    <span class="keyword">if</span>(temp==-<span class="number">11111</span>){ </span><br><span class="line">                        sum*=<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    sum+=temp;</span><br><span class="line">                }</span><br><span class="line">                stack.push(sum);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) res+=stack.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></s.length();i++){<></span></pre></td></tr></tbody></table></figure></div><p>这种解法一开始也没想出来，其实这种就类似于消消乐游戏一样，就按照题目的逻辑来写，从左向右，栈中存标识左括号的数值，这里我用的<code>-11111</code> 表示<code>（</code> ，然后向右移动，一边移动一边将<code>（）</code>给消除掉，其实上面的逻辑自己走一边就通了</p><p><strong>解法二</strong></p><p>这个解法就带有点技巧性了，看懂上面的注释，下面的代码就很简单了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// (()(())) = 2*()+2*(())= (())+((()))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String S)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        <span class="keyword">if</span> (S.charAt(i)==<span class="string">'('</span>) {</span><br><span class="line">            k++; <span class="comment">//k用来计算括号的深度</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i-<span class="number">1</span>)==<span class="string">'('</span>) {</span><br><span class="line">                <span class="comment">//"()"闭合的时候计算一波</span></span><br><span class="line">                res+= <span class="number">1</span><<k;< span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></k;<></span></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></h2><p>给定两个<strong>没有重复元素</strong>的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>].</span><br><span class="line">输出: [-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字<span class="number">4</span>，你无法在第二个数组中找到下一个更大的数字，因此输出 -<span class="number">1</span>。</span><br><span class="line">    对于num1中的数字<span class="number">1</span>，第二个数组中数字<span class="number">1</span>右边的下一个较大数字是 <span class="number">3</span>。</span><br><span class="line">    对于num1中的数字<span class="number">2</span>，第二个数组中没有下一个更大的数字，因此输出 -<span class="number">1</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">2</span>,<span class="number">4</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].</span><br><span class="line">输出: [<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字<span class="number">2</span>，第二个数组中的下一个较大数字是<span class="number">3</span>。</span><br><span class="line">    对于num1中的数字<span class="number">4</span>，第二个数组中没有下一个更大的数字，因此输出 -<span class="number">1</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong></p><ol><li><code>nums1</code>和<code>nums2</code>中所有元素是唯一的。</li><li><code>nums1</code>和<code>nums2</code> 的数组大小都不超过1000。</li></ol><p><strong>解法一</strong></p><p>单调栈，很就之前在链表专题中做过一次 <a href="http://imlgw.top/2019/02/27/leetcode-lian-biao/#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9">链表的下一个更大节点</a> 但是没想起来，可能当时也没留下影响</p><p>这题其实还比原始的题加了一点难度，原始的题就是 num1==nums2的情况，那样就不需要HashMap记录了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) {</span><br><span class="line">    HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    Stack<integer> stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums2.length;i++) {< span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() && nums2[stack.peek()]<nums2[i]){< span><br><span class="line">            map.put(nums2[stack.pop()],nums2[i]);</span><br><span class="line">        }</span><br><span class="line">        stack.add(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums1.length;i++) {< span><br><span class="line">        res[i]=map.getOrDefault(nums1[i],-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums1.length;i++)></span></nums2[i]){<></span></nums2.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: [<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: 第一个 <span class="number">1</span> 的下一个更大的数是 <span class="number">2</span>；</span><br><span class="line">数字 <span class="number">2</span> 找不到下一个更大的数； </span><br><span class="line">第二个 <span class="number">1</span> 的下一个最大的数需要循环搜索，结果也是 <span class="number">2</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) {</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{};</span><br><span class="line">    }</span><br><span class="line">    Stack<integer> stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length*<span class="number">2</nums.length*<span></span>;i++) {<br><span class="line">        index=i>=nums.length?i%nums.length:i;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&&nums[stack.peek()]<nums[index]) {< span><br><span class="line">            res[stack.pop()]=nums[index];</span><br><span class="line">        }</span><br><span class="line">        stack.push(index);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums[index])></span></pre></td></tr></tbody></table></figure></div><p>和上面一样，只不过需要循环遍历一遍，我最开始的做法相当憨憨，copy了一个两倍的数组。。。还需要注意的就是 <code>-1</code>的处理</p><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h2><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) {</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="keyword">null</span> || T.length<=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack<integer> stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<t.length;i++) {< span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&&T[stack.peek()]<t[i]){< span><br><span class="line">            <span class="keyword">int</span> temp=stack.pop();</span><br><span class="line">            res[temp]=i-temp;</span><br><span class="line">        }</span><br><span class="line">        stack.push(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></t[i]){<></span></t.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>和上面两题一样，单调栈的解法，不过这题好像可以不用单调栈，可以从后向前递推</p><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img alt="leetCode" data-src="https://i.loli.net/2019/12/12/a7pVfNcYuIKFgwA.png" src="/img/loading.gif" class="lazyload"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img alt="leetCode" data-src="https://i.loli.net/2019/12/12/FAvMk3zWf4RheDi.png" src="/img/loading.gif" class="lazyload"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>和上面几道题一样，单调栈的解法，20ms，87%</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (heights==<span class="keyword">null</span> || heights.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack<integer> stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    <span class="keyword">int</span> maxArea= Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<heights.length;i++) {< span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){</span><br><span class="line">            <span class="comment">//当前的柱子小于栈顶,说明当前栈顶最多向右扩展到 i-1</span></span><br><span class="line">            <span class="keyword">int</span> cur=stack.pop();</span><br><span class="line">            <span class="comment">//为空说明向左无法扩展,标为-1不影响结果</span></span><br><span class="line">            <span class="keyword">int</span> left=stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">            <span class="comment">//这里其实是 (i-1)-(left+1)+1</span></span><br><span class="line">            maxArea=Math.max(maxArea,(i-left-<span class="number">1</span>)*heights[cur]);</span><br><span class="line">        }</span><br><span class="line">        stack.push(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//处理栈中剩下的元素,无法向右扩展,只能向左扩展</span></span><br><span class="line">    <span class="comment">//所以为了让所有的元素都能出栈,我们可以再数组的后面想象添加一个0(也可以直接在原数组中添加一个0)</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()){ </span><br><span class="line">        <span class="keyword">int</span> cur=stack.pop();</span><br><span class="line">        <span class="keyword">int</span> left=stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">        <span class="comment">//这一步很秀,在数组后面再想象一个0出来</span></span><br><span class="line">        <span class="comment">//让栈中元素向右扩张(heights.length-1)-(left+1)+1</span></span><br><span class="line">        maxArea=Math.max(maxArea,(heights.length-left-<span class="number">1</span>)*heights[cur]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">}</span><br></heights.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实就是利用单调栈遍历每一个柱子，<strong>找到每一个柱子左边和右边第一个比它大的元素</strong>，然后就可以直接根据这两个数据计算完全包含当前柱子的最大的矩形的面积。</p><p>例如: <code>3 4 5 4 3 6</code> </p><p>首先<code>3 4 5</code>都顺利的存入栈中，此时栈中元素为<code>【0，1，2】</code> ，当想存入下一个元素<code>i=3,h[i]=4</code>的时候，发现4比当前栈顶小，所以我们就可以开始计算<strong>栈中每个柱子</strong>可以构成的最大矩形的面积</p><ol><li>由于当前<strong><code>i</code></strong> 位置的元素是比栈顶小，那么就说明 <strong><code>i-1</code></strong> 位置的元素一定比当前栈顶元素大！也就是向右边最多扩展到<strong><code>i-1</code></strong>位置</li><li>由于单调栈的结构，当前栈顶的下一个栈中元素<strong><code>left</code></strong>，其实就是当前栈顶的左边最近的比它小的元素，所以<strong><code>left+1</code></strong>位置的元素一定是比当前栈顶元素大！，所以向左边最多扩展到 <strong><code>left+1</code></strong> 位置</li><li>上面其实还分析漏了一种情况，那就是栈顶和 <strong><code>i</code></strong> 位置元素相等的情况，第一点中提到的其实是 <strong><code>i</code></strong> 位置元素小于栈顶的情况，如果相等，那么向右能扩展到的位置还会是<strong><code>i-1</code></strong>么？显然不是，那我们如何处理这种情况呢？其实根本就不用处理，既然栈顶能<strong>向右</strong>扩展到 <strong><code>i</code></strong> 那么反过来，<strong><code>i</code></strong> 一样可以<strong>向左</strong>扩展到 栈顶位置，而向左扩展的<strong><code>left+1</code></strong>是准确的，不会有误差，所以我们只需要等待 <strong><code>i</code></strong>位置的元素弹出，然后就可以重新计算得到最大值，当然这里其实那个 <strong><code>heights[i]<=heights[stack.peek()]</code></strong> 中的等号也可以去掉，这样栈就不是严格单调的了，<strong><code>left+1</code></strong>也不再准确，但是此时 <strong><code>i</code></strong> 就准确了，所以我们可以等待<strong><code>left+1</code></strong> 弹栈之后再重新计算，总而言之，就是相等的情况是不用做额外的处理</li></ol><p>经过上面的分析，代码就好写多了，不过这里还有一个地方值得注意，就是处理栈中剩余的元素，其实比较好的方法是在数组的末尾加一个0，这样确保栈中所有的元素都可以出栈，不用额外的处理，java中没法直接向数组中push元素，所以我们就想象末尾有一个0，那么所有元素向左能扩展到的最远位置就是 <code>heights.length-1</code></p><p><strong>解法二</strong></p><p>分治，480ms，27%</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//分治 480ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (heights==<span class="keyword">null</span> || heights.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    largestRectangleArea(heights,<span class="number">0</span>,heights.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxArea=Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left>right) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> minIndex=left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left;i<=right;i++) {</span><br><span class="line">        minIndex=heights[i]<heights[minindex]?i:minindex;< span><br><span class="line">    }</span><br><span class="line">    maxArea=Math.max(heights[minIndex]*(right-left+<span class="number">1</span>),maxArea);</span><br><span class="line">    largestRectangleArea(heights,left,minIndex-<span class="number">1</span>);</span><br><span class="line">    largestRectangleArea(heights,minIndex+<span class="number">1</span>,right);</span><br><span class="line">}</span><br></heights[minindex]?i:minindex;<></span></pre></td></tr></tbody></table></figure></div><p>将数组区间以<code>minIndex</code>为分界线，分别求左边和右边的最大面积，时间复杂度<code>O(NlogN)</code></p><p><strong>解法三</strong></p><p>优化的分治 1ms，100%，没想到比单调栈还快。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (heights==<span class="keyword">null</span> || heights.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> largestRectangleArea(heights,<span class="number">0</span>,heights.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left>right) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> minIndex=left;</span><br><span class="line">    <span class="keyword">boolean</span> up=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> down=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left+<span class="number">1</span>;i<=right;i++) {</span><br><span class="line">        <span class="keyword">if</span> (heights[i]<heights[i-<span class="number">1</heights[i-<span></span>]) {<br><span class="line">            up=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (heights[i]>heights[i-<span class="number">1</span>]) {</span><br><span class="line">            down=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        minIndex=heights[i]<heights[minindex]?i:minindex;< span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (up) {</span><br><span class="line">        <span class="keyword">int</span> maxArea=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=left;i<=right;i++) {</span><br><span class="line">            maxArea=Math.max(maxArea,(right-i+<span class="number">1</span>)*heights[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (down) {</span><br><span class="line">        <span class="keyword">int</span> maxArea=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=right;i>=left;i--) {</span><br><span class="line">            maxArea=Math.max(maxArea,(i-left+<span class="number">1</span>)*heights[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(heights[minIndex]*(right-left+<span class="number">1</span>),Math.max(largestRectangleArea(heights,minIndex+<span class="number">1</span>,right),largestRectangleArea(heights,left,minIndex-<span class="number">1</span>)));</span><br><span class="line">}</span><br></heights[minindex]?i:minindex;<></span></pre></td></tr></tbody></table></figure></div><p>其实相比于上面的分治，就是多了一步判断当前区间是否有序，因为有序的话就可以直接遍历得到区间的最大矩形，不用再递归做分治，我这里做了两个有序的判断，不知道是不是有的多余，我看的评论都只有一个</p><h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></h2><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>特意在做了上面一题后没有马上做这一题，下面的是第二天下午做的，还行，没忘记😂，就是写的有点难看</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//没写好,写的麻烦了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangleSilly</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//初始化height数组,在末尾添加一个元素(默认0)让所有元素可以出栈</span></span><br><span class="line">    <span class="keyword">int</span>[][] height=<span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<matrix[<span class="number">0</matrix[<span></span>].length;i++) {<br><span class="line">        height[<span class="number">0</span>][i]=matrix[<span class="number">0</span>][i]-<span class="number">48</span>; <span class="comment">//初始化第一层</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> max=maxArea(height[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//记录每一层的height</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<matrix.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<matrix[<span class="number">0</matrix[<span></span>].length;j++) {</matrix.length;i++)></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]==<span class="string">'1'</span> && matrix[i-<span class="number">1</span>][j] ==<span class="string">'1'</span>) {</span><br><span class="line">                height[i][j]=height[i-<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                height[i][j]=matrix[i][j]-<span class="number">48</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        max=Math.max(max,maxArea(height[i]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>{</span><br><span class="line">    Stack<integer> stack=<span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<height.length;i++) {< span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() && height[stack.peek()]>=height[i]){</span><br><span class="line">            <span class="keyword">int</span> cur=stack.pop();</span><br><span class="line">            <span class="keyword">int</span> left=stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">            <span class="comment">// (i-1)-(left+1)+1</span></span><br><span class="line">            max=Math.max(max,(i-left-<span class="number">1</span>)*height[cur]);</span><br><span class="line">        }</span><br><span class="line">        stack.push(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></height.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实计算height有一点动态规划的意思，我上面相当于写了个二维的动态规划</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//初始化height数组,在末尾添加一个元素(默认0)让所有元素可以出栈</span></span><br><span class="line">    <span class="keyword">int</span>[] height=<span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录每一层的height</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<matrix.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<matrix[<span class="number">0</matrix[<span></span>].length;j++) {</matrix.length;i++)></span><br><span class="line">            height[j]=matrix[i][j]==<span class="string">'1'</span>?height[j]+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        max=Math.max(max,maxArea(height));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>maxArea</code>可以直接采用上面84题的分治</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入AQS源码解析（一）</title>
      <link href="/2019/09/24/abstractqueuedsynchronizer/"/>
      <url>/2019/09/24/abstractqueuedsynchronizer/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="AbstractQueuedSynchronized"><a href="#AbstractQueuedSynchronized" class="headerlink" title="AbstractQueuedSynchronized"></a>AbstractQueuedSynchronized</h2><p><code>AbstractQueuedSynchronized</code> 简称AQS，这个类是整个并发包的基础工具类， ReentrantLock、CountDownLatch、Semaphore、FutureTask 等并发工具类底层都是通过它来实现的</p><p>AQS定义了两种资源共享的方式：</p><ul><li>Exclusive：独占式，只有一个线程能获取资源并执行，比如ReentrantLock。</li><li>Share：共享式，多个线程获取资源，多个线程可以同时执行，比如CountDownLatch，ReentrantReadWriteLock的ReadLock等</li></ul><h3 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>主要的就是这三个volatile修饰的Node对象，还有一些对应的偏移量(用于CAS的)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment"> * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment"> * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment"> * CANCELLED.</span></span><br><span class="line"><span class="comment"> * 头节点，可以理解为当前持有锁的节点</span></span><br><span class="line"><span class="comment"> * 在分析的过程中不要将它算作队列的一部分！它只是一个空节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment"> * method enq to add new wait node.</span></span><br><span class="line"><span class="comment"> * 尾节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> * 同步状态，0代表没有被占用，1代表被一个线程占用，>1 代表被同一个线程多次占用（可重入）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></tbody></table></figure></div><h4 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="comment">//共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">//取消抢锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="comment">//代表当前节点的后续节点需要被unparking，也就是说后继节点状态是parking</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">//在condition上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的那些状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前驱节点    </span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">     * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">     * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">     * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">     * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">     * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">     * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">     * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">     * mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>{</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node() {    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) {     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) { <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="ReentrantLock分析"><a href="#ReentrantLock分析" class="headerlink" title="ReentrantLock分析"></a>ReentrantLock分析</h2><p>我们知道ReentrantLock内部有两个锁，一个是公平锁(FairSync)🔒，一个是非公平锁(NonFairSync)🔒，这两个锁都是独占锁，两者实现的差异其实并不大，我们先从<code>公平锁</code>开始说起。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &&</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc < <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock()"></a>Lock()</h3><p>🔔 <strong>这里我们为了模拟真实的情况，我们假设有两个线程<code>Thread0</code> 和<code>Thread1</code> 过来执行了<code>Lock()</code> 方法，且<code>Thread0</code> 比<code>Thread1</code> 要先执行。</strong></p><p><code>Lock()</code>方法中调用了父类的<code>acquire(1)</code></p><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>首先尝试tryAcquire(1)，这个tryLock()在AQS中没有具体实现是交给子类去实现的，所以这里就会调用FairSync的，tryAquire(1)</p><h4 id="tryAquire"><a href="#tryAquire" class="headerlink" title="tryAquire()"></a>tryAquire()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) { <span class="comment">//0代表还没有线程占用</span></span><br><span class="line">        <span class="comment">//判断有没有前驱节点（除head节点外），没有则进行CAS设置同步状态获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() && compareAndSetState(<span class="number">0</span>, acquires)) { </span><br><span class="line">            <span class="comment">//设置当前线程为独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//到这里就说明已经有线程占用了，所以下面是为了重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">        <span class="comment">//这里不用担心并发的问题，因为是独占锁，同时只有一个线程会到达这里</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc < <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors()"></a>hasQueuedPredecessors()</h4><p>公平锁和非公平锁的tryAcquire方法区别就在这里，这个方法就是判断有没有前驱节点(不包含头节点head，也就是)存在，有的话为了保证公平性就是需要等待，返回true。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 头不等于尾，并且队列的第一个节点所持有线程非当前线程返回true</span></span><br><span class="line">    <span class="keyword">return</span> h != t &&</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>💡 到这里我们分析下<code>Thread0</code> 和<code>Thread1</code> 的执行情况</p><p>🔸 首先<code>Thread0</code>先执行了<code>tryAcquire(1)</code>  没有任何阻碍，执行成功直接retrurn</p><p>🔸 <code>Thread1</code> 此时有多种情况：</p><ul><li><p>还没有获取state ，<code>Thread0</code>执行完后获取State==1 ，由于是独占锁直接return false ，获取锁失败。</p></li><li><p>已经<code>getState()==0</code>了，执行<code>hasQueuedPredecessors</code> 方法，注意，此时head和tail都还没有初始化，都还是null（官方的注释中也提到head和tail是 lazily initialized ）所以这里会直接 return false，然后继续执行CAS，由于前面<code>Thread0</code> 已经将state设置为了 1 ，所以这里CAS肯定失败了，最终<code>Thread1</code>的tryAcquire失败返回false。</p></li></ul><p>🔸 既然<code>tryAcquire()</code> 失败了，那<code>Thread1</code> 就会转头继续执行后面的方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>首先执行的就是<code>AddWaiter()</code> </p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h4><p>这个方法的作用就是将Thread和mode包装成Node然后添加到链表尾部然后返回这个Node</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>{</span><br><span class="line">    <span class="comment">//将当前线程和模式封装进Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//如果尾节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//将node连接在当前tail后面</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//cas设置当前tail为node</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) {</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 其实前面看似会有并发的问题其实并没有</span></span><br><span class="line">    <span class="comment">// 上面抢锁失败的线程会直接进入enq方法自旋重新设置，直到成功</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>💡 根据前面分析head和tail都还没有初始化都还是null，所以这里会直接进入 <code>enq()</code>方法</p><h4 id="enq"><a href="#enq" class="headerlink" title="enq()"></a>enq()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 可以看到这里是一个循环，因为head和tail都还是空的所以这里进入第一个循环，CAS设置一个空的Node()为头节点head，然后将tail也指向这个head，到这里head和tail才算是初始化完成了(lazily initialized )。</p><p>🔸 循环，进入else，这里就将当前node连接到tail后面并且利用CAS自旋设置tail为当前node也就是包含<code>Thread1</code> 的node，然后return 当前节点的前驱节点(这里返回值并没有用到)。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>下一步就是执行<code>acquireQueued()</code></p><p>❓ <strong>为什么不直接在构造器里面就初始化头节点head？而要采用懒加载的方式？</strong></p><blockquote><p>CLH queues need a dummy header node to get started. Butwe don’t create them on <strong>construction</strong>, because it would be wasted  effort if there is <strong>never contention</strong>. Instead, the nodeis constructed and head and tail pointers are set up <strong>on first contention</strong>.</p></blockquote><p>以上摘自<strong>Doug Lea</strong> 大师的注释解释，根据我们的上面的分析，其实我们也看到了，第一个线程<code>Thread0</code> 过来的时候并没有去初始化head，后面的线程<code>Thread1</code>过来的时候 有了竞争才初始化了这个头节点head，如果直接初始化这个head，然后又没有锁竞争，这个head节点就被浪费了。 大师就是大师，太强了 😮</p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">//获取当前节点的前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前置节点是head就尝试去获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head && tryAcquire(arg)) {</span><br><span class="line">                <span class="comment">//设置头节点为当前节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">//发生异常取消抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>💡 因为前置节点是head，所以这里作为队列第一个可以去尝试获取锁，可以看到这里是个死循环，会一直尝试获取锁，其实类似与CAS的自旋，但是相比CAS自旋又有很大不同，它并不会一直自旋，详细可以继续往下看。</p><p>🔸 前面传递过来的node前继节点正好就是head，所以执行tryAcquire() 但是由于<code>Thread0</code> 还没有释放锁所以这里仍然失败。</p><p>🔸 进入第二个if 执行 <code>shouldParkAfterFailedAcquire(p,node)</code></p><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire()"></a>shouldParkAfterFailedAcquire()</h4><p>看名字就知道是干啥的了，获取失败是否Park？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>{</span><br><span class="line">    <span class="comment">//前置节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//前置节点状态为-1，代表当前节点的后续节点需要被挂起</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws > <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 前驱节点 waitStatus大于0，说明前驱节点取消了排队。</span></span><br><span class="line">        <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">        <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus<=0的节点，</span></span><br><span class="line">        <span class="comment">// 简单说，就是为了找个正常的前驱节点，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，就无法唤醒你了</span></span><br><span class="line">        <span class="comment">// 同时这个操作也会将那些 ws>0 的节点移除掉</span></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        } <span class="keyword">while</span> (pred.waitStatus > <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//设置前驱节点状态为 -1</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意这个里面回剔除不正常的节点，为下面的唤醒操作考虑</p><p>💡 分析<code>Thread1</code>，我们先看看当前队列的状态</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190809/jOs2WA3R7lGR.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>🔸 因为前面的操作并没有对state进行操作，所以这里会直接进入最后的else，设置前驱节点的状态为 <code>SIGNAL</code></p><p>然后renturn  false回到acquireQueued的内循环</p><p>🔸 再次尝试获取锁，<code>Thread0</code> 仍然没有释放锁，失败，再次进入shouldParkAfterFailedAcquire，这一次由于已经将前继节点的状态设置为<code>SIGNAL</code> 所以直接return true，进入后面的 <code>parkAndCheckInterrupt()</code> 方法</p><p><strong>此时状态变为</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190809/pQ5NOkN5mQTY.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>到这里我们的线程<code>Thread1</code>就会被阻塞住，也不会继续自旋获取锁了。</p><blockquote><p>LockSupport.park()实际上调用的是Unsafe提供的指令属于<code>线程阻塞原语</code>，可以理解为二元信号量（只有一个permit），这个方法也会响应Interrupt  <a href="https://segmentfault.com/a/1190000008420938" target="_blank" rel="noopener">参考</a></p></blockquote><p>🔔 <strong>假设此时又有一个线程<code>Thread2</code>过来了，并且<code>Thread0</code> 依然没有释放锁</strong></p><p>🔸 tryAcquire失败</p><p>🔸addWaiter()， 将<code>Thread2</code>和模式包装成Node添加到队尾（这个时候就不会进入enq了，因为tail此时为<code>Thread1</code>已经不为空了）然后返回包含<code>Thread2</code>的节点，队列状态变为：</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190809/yniIvx1sgpXa.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>🔸acquireQueued()，根据上面的状态图，这里前置节点并不是head，直接进入shouldParkAfterFailedAcquire()</p><p>🔸shouldParkAfterFailedAcquire()，明显前驱节点状态并不是<code>SIGNAL</code> 而是0，所以直接利用CAS设置前驱节点为<code>SIGNAL</code>  状态变为：</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190809/R7GmOQ4V8ESm.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>回到 <code>acquireQueued()</code> 继续自旋</p><p>🔸 前置节点不是head，调用shouldParkAfterFailedAcquire(NodeT1，mode)，成功，调用parkAndCheckInterrupt阻塞，至此，<code>Thread1</code>，<code>Thread2</code> 都在这里park住了。</p><h3 id="unLock"><a href="#unLock" class="headerlink" title="unLock()"></a>unLock()</h3><p>🔔 继续上面的模拟，此时<code>Thread0</code>释放锁 ，调用<code>unlock()</code> 方法，unlock()会调用AQS中的<code>release(1)</code>方法</p><h4 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        <span class="comment">//获取头节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//头节点不为空，并且头节点的waitStatus不是0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> && h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//unpark后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>首先执行<code>tryRelease(1)</code> ，和<code>tryAcquire()</code> 一样，这个方法最后是交给子类去实现的</p><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">    <span class="comment">//同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="comment">//解锁线程不是当前线程，解铃还须系铃人</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//和上面一样这里不用担心并发的问题，因为是独占锁，同时只有一个线程会到达这里</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//不为0则代表被重入了，需要多次release直到0才会释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>tryRelease()成功继续执行后面的语句，看一下当前AQS队列的状态</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190809/R7GmOQ4V8ESm.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>🔸 头节点head ! =null 并且head.waitState不是0，执行unparkSuccessor().</p><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a>unparkSuccessor()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws < <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果当前节点的ws小于0就设置为0，允许失败</span></span><br><span class="line">        <span class="comment">//其实是独占锁的话这里肯定不会失败，因为只有一个线程</span></span><br><span class="line">        <span class="comment">//release执行完之后，这个节点就会被移除掉。然后被GC</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//后继节点为空，或者已经撤销了，取消抢锁（1>0）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus > <span class="number">0</span>) {</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从后往前遍历找到正数第一个waitStatus<0的</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> && t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus <= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//然后释放它</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 <code>Thread1</code> 被<code>unpark()</code> 继续执行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>返回<code>Thread1</code>的 中断标志位，并复原为false，结束<code>parkAndCheckInterrupt()</code>方法，再次回到<code>acquireQueued()</code> 的循环中执行第一个if</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line">    <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="keyword">if</span> (p == head && tryAcquire(arg)) {</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted; <span class="comment">//返回中断状态</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 由于<code>Thread0</code> 已经释放锁，同步状态已经变为0，<code>Thread1</code> 可以直接<code>tryAcquire</code>获取到锁，然后设置头节点为当前节点，将之前的head节点<strong>移除</strong>，返回中断状态，由于之前park期间没有被中断直接<code>return false</code>，acquire成功！！！ <code>Thread1</code> 获得锁！！！</p><p>❓ <strong>为什么要从后往前遍历？</strong></p><blockquote><p>这里看了一些博客介绍，大概有两个说法，一个是在<code>enq()</code> 方法里面，先设置的<code>node.prev = pred;</code>再执行的CAS最后执行的<code>t.next = node;</code> CAS成功后next也许还没有设置成功，从前往后遍历有可能找不到这个刚加入的节点；其次，在<code>cancelAcquire(node);</code> 的最后一步有一个<code>node.next=node</code>的操作，如果这个时候从前往后遍历会导致死循环。</p></blockquote><p>❓ <strong>从后往前遍历找到最前面第一个waitStatus<0的节点，这个操作如果返回的是个中间节点怎么办？</strong></p><blockquote><p>不要怕，我们继续执行，首先它是个中间节点而且是公平锁，它有前驱节点，unpark后肯定获取不到锁(公平锁需要检测是否有前驱节点)，然后执行<code>shouldParkAfterFailedAcquire()</code>，还记得这个方法里面的一个操作么？？如果前驱节点状态>0，他就会清除这些不正常的节点，返回false，不park自旋，下一次循环这个节点在获取锁就可以获取到了，妙哉！！！</p></blockquote><p>注意<strong>setHead</strong>是这样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">//设置线程为null</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>; <span class="comment">//设置前驱为空</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>此时队列状态变为：</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190809/wFDlbQTu417I.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>再往后就是重复前面的过程啦。</p><h3 id="非公平锁公平锁区别"><a href="#非公平锁公平锁区别" class="headerlink" title="非公平锁公平锁区别"></a>非公平锁公平锁区别</h3><p>上面是介绍的公平锁，所谓的公平就是先来后到FIFO。</p><p>我们来看一下非公平锁的lock和nonfairTryAcquire()的实现，这两个锁的区别其实就是这两个方法。</p><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到非公平锁<code>lock()</code>的时候，不管三七二十一先CAS试一下能不能获取到锁，获取到就直接返回</p><h4 id="nonfairTryAcquire"><a href="#nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire()"></a>nonfairTryAcquire()</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc < <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>对比公平锁的实现，会发现少了<code>hasQueuedPredecessors()</code> 这个方法，所以如果前面<code>lock()</code> 的时候没有CAS成功，到这里后如果之前持有锁的线程释放了锁，它又会再次尝试CAS获取锁，这里其实就体现了非公平锁的特点，<strong>先等待锁的线程不一定能先获取到锁，中间允许有人<code>"插队"</code></strong>，如果这一次还是失败了，就会和公平锁一样老老实实去等待队列中排队</p><p>一般而言，非公平锁的性能会比公平锁好，而非公平锁可能会导致排在后面的线程饥饿</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190810/6FEWGydOmVzm.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>《Java并发编程之美》</strong></p><p><a href="https://javadoop.com/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a></p><p><a href="https://blog.csdn.net/pfnie/article/details/53191892" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码剖析（六）- 深刻解析与模拟线程竞争资源</a></p><p><a href="https://segmentfault.com/a/1190000008420938" target="_blank" rel="noopener">[浅谈Java并发编程系列（八）—— LockSupport原理剖析]</a></p><p><a href="https://brightloong.github.io/2018/06/21/Java%E5%90%8C%E6%AD%A5%E5%99%A8%E2%80%94%E2%80%94AQS%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Java同步器——AQS学习</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode查找</title>
      <link href="/2019/09/15/leetcode-cha-zhao/"/>
      <url>/2019/09/15/leetcode-cha-zhao/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: [<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">9</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) {</span><br><span class="line">    Set<integer> s1=<span class="keyword">new</span> HashSet<>();</integer></span><br><span class="line">    ArrayList<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a:nums1 ) {</span><br><span class="line">        s1.add(a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums2.length;i++) {< span><br><span class="line">        <span class="keyword">if</span>(s1.contains(nums2[i])){</span><br><span class="line">            res.add(nums2[i]);</span><br><span class="line">            s1.remove(nums2[i]);<span class="comment">//别忘了remove掉</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] res2=<span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<res.size();i++) {< span><br><span class="line">        res2[i]=res.get(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res2;</span><br><span class="line">}</span><br></res.size();i++)></span></nums2.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>没啥好说的，这种题确实不难，仔细想想就可以</p><h2 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶:</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><p><strong>解法一</strong></p><p>这题和上面的区别就是需要输出所有的交集，重复的也算，所以可以用map的结构记录字符出现的次数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) {</span><br><span class="line">    HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums1.length;i++) {< span><br><span class="line">        map.put(nums1[i],map.getOrDefault(nums1[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    ArrayList<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums2.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums2[i])) {</span><br><span class="line">            <span class="keyword">if</span> (map.get(nums2[i])!=<span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//有交集</span></span><br><span class="line">                res.add(nums2[i]); <span class="comment">//添加到结果中</span></span><br><span class="line">                map.put(nums2[i],map.get(nums2[i])-<span class="number">1</span>); <span class="comment">//map映射减一</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> []res2=<span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<res2.length;i++) {< span><br><span class="line">        res2[i]=res.get(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res2;</span><br><span class="line">}</span><br></res2.length;i++)></span></nums2.length;i++)></span></nums1.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>思路也很直白，和上一题的做法类似</p><p><strong>进阶</strong></p><p><strong>Q1:</strong> 排好序的话就可以直接利用双指针，两个指针分别指向两个数组的头，相等就加入list，不相等就移动小的哪一个，直到有一个指针走到末尾</p><p><strong>Q2:</strong> 这个就很明显了，肯定先把小的哪一个用map映射起来，这样map查找的效率会更高 ？</p><p><strong>Q3:</strong> 这个参考英文版的 <a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/discuss/82243/Solution-to-3rd-follow-up-question" target="_blank" rel="noopener">讨论区</a> </p><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"rat"</span>, t = <span class="string">"car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>你可以假设字符串只包含小写字母。</li></ul><p><strong>进阶:</strong></p><ul><li>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s.length()!=t.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        freq[s.charAt(i)]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,match=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a:freq) {</span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="number">0</span>){</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<t.length();i++) {< span><br><span class="line">        <span class="keyword">if</span>(freq[t.charAt(i)]><span class="number">0</span>){</span><br><span class="line">            freq[t.charAt(i)]--;</span><br><span class="line">            <span class="keyword">if</span>(freq[t.charAt(i)]==<span class="number">0</span>){</span><br><span class="line">                match++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> match==count;</span><br><span class="line">}</span><br></t.length();i++)></span></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>这里其实空间还可以优化，题目说了字符串只包含小写字符所以只需要26个int就行了，可以在freq操作的时候 <code>-'A'</code> 优化空间</p><p><strong>进阶</strong></p><p>字符包含<code>unicode</code> 的话如果再使用int数组就不合适了，这个范围会变得很大，更加通用的方式是采用<code>HashMap</code></p><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></h2><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p><strong>示例:</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">19</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: </span><br><span class="line"><span class="number">12</span> + <span class="number">92</span> = <span class="number">82</span></span><br><span class="line"><span class="number">82</span> + <span class="number">22</span> = <span class="number">68</span></span><br><span class="line"><span class="number">62</span> + <span class="number">82</span> = <span class="number">100</span></span><br><span class="line"><span class="number">12</span> + <span class="number">02</span> + <span class="number">02</span> = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] nums=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">        nums=String.valueOf(sum).toCharArray();</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">            sum+=(nums[i]-<span class="number">48</span>)*(nums[i]-<span class="number">48</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (sum==<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>找到了规律，所有不快乐的数(😅，都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环，可以直接在sum和这些值相等的时候就return我懒得写那么多，比较取巧但是效率还是挺高的</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] nums=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=n;</span><br><span class="line">    HashSet<integer> set=<span class="keyword">new</span> HashSet<>();</integer></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">        nums=String.valueOf(sum).toCharArray();</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">            sum+=(nums[i]-<span class="number">48</span>)*(nums[i]-<span class="number">48</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (set.contain(sum)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            set.add(sum);    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这种做法就比较常规，也是符合这篇主题<strong>查找</strong>的解法，代码比较简单就不啰嗦了</p><h2 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">290. 单词规律</a></h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: pattern = <span class="string">"abba"</span>, str = <span class="string">"dog cat cat dog"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:pattern = <span class="string">"abba"</span>, str = <span class="string">"dog cat cat fish"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: pattern = <span class="string">"aaaa"</span>, str = <span class="string">"dog cat cat dog"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: pattern = <span class="string">"abba"</span>, str = <span class="string">"dog dog dog dog"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong><br>你可以假设 <code>pattern</code> 只包含小写字母， <code>str</code> 包含了由单个空格分隔的小写字母</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>{</span><br><span class="line">    HashMap<character,string> map=<span class="keyword">new</span> LinkedHashMap<>();</character,string></span><br><span class="line">    String[] strs=str.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">char</span>[] p=pattern.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (strs.length!=p.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<p.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(p[i])) {</span><br><span class="line">            <span class="keyword">if</span> (!map.get(p[i]).equals(strs[i])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//这里直接和前一个比较的，正确做法是用map.containsValue判断是否已经添加</span></span><br><span class="line">            <span class="comment">/*if (strs[i].equals(strs[i-1])) {</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsValue(strs[i])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;           </span><br><span class="line">            }</span><br><span class="line">            map.put(p[i],strs[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></p.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>很简单的题，需要对两个字符串的模式进行匹配，借助Hash表直接将两个String进行一对一的映射，既然要匹配那么<code>同一个key字符对应的value字符肯定是一样的</code>，还有一点需要注意的是在遇到一个新的key字符的时候，需要判断对应位置的value字符出现过没有，出现过就直接return false，这一点第一遍的时候没考虑到，<code>不同的key字符对应的value字符肯定是不一样的</code></p><blockquote><p>因为第一次没考虑到第二种情况，提交后竟然跑过了<code>31/33</code> 个case，然后就感觉这题case可能有点问题，然后自己写了个错的算法居然也跑过了，具体的代码在上面的注释中，感兴趣的可以去试试，我已经提交case了但是还没回应我</p></blockquote><h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">205. 同构字符串</a></h2><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"egg"</span>, t = <span class="string">"add"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"foo"</span>, t = <span class="string">"bar"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"paper"</span>, t = <span class="string">"title"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>你可以假设 s 和 t 具有相同的长度。</li></ul><p><strong>解法一</strong></p><p>这题和上面一模一样，Hash表的解法就不写了，这题都是单个的字符，可以不用Hash表，可以用数组优化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic2</span><span class="params">(String s, String t)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s.length()!=t.length()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] key=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span>[] value=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        <span class="keyword">int</span> cs=s.charAt(i);</span><br><span class="line">        <span class="keyword">int</span> ct=t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(key[cs]!=<span class="number">0</span>){ <span class="comment">//cs出现过</span></span><br><span class="line">            <span class="keyword">if</span> (key[cs]!=ct) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{<span class="comment">//cs没出现过</span></span><br><span class="line">            <span class="keyword">if</span> (value[ct]!=<span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            key[cs]=ct;</span><br><span class="line">            value[ct]=cs;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>💬 同样的，这题和上面的290一样，case也有问题，直接和前一个字符比较就可以过</p><h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 <code>0 ≤ N ≤ 500</code> 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [ <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">B = [-<span class="number">2</span>,-<span class="number">1</span>]</span><br><span class="line">C = [-<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">D = [ <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) -> A[<span class="number">0</span>] + B[<span class="number">0</span>] + C[<span class="number">0</span>] + D[<span class="number">1</span>] = <span class="number">1</span> + (-<span class="number">2</span>) + (-<span class="number">1</span>) + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2</span>. (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) -> A[<span class="number">1</span>] + B[<span class="number">1</span>] + C[<span class="number">0</span>] + D[<span class="number">0</span>] = <span class="number">2</span> + (-<span class="number">1</span>) + (-<span class="number">1</span>) + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题其实看数据规模就知道应该写一个什么样复杂度的算法了<code>0~500</code>，暴力的话会很恐怖<code>O(N^4)</code>，这里可以考虑将其中一个放到hash表中，然后遍历其他的3个，时间复杂度优化到了<code>O(N^3)</code>，但是时间复杂度还是很恐怖，所以可以考虑将两个数组的和放到hash表中，这样就可以将时间复杂度优化到<code>O(N^2)</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>{</span><br><span class="line">    HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<c.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<d.length;j++) {< span><br><span class="line">            <span class="keyword">int</span> key=C[i]+D[j];</span><br><span class="line">            map.put(key,map.getOrDefault(key,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<a.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<b.length;j++) {< span><br><span class="line">            <span class="keyword">int</span> key=A[i]+B[j];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(-key)){</span><br><span class="line">                res+=map.get(-key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></b.length;j++)></span></a.length;i++)></span></d.length;j++)></span></c.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="451-根据字符出现频率排序"><a href="#451-根据字符出现频率排序" class="headerlink" title="451. 根据字符出现频率排序"></a><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. 根据字符出现频率排序</a></h2><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">"tree"</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">"eert"</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="string">'e'</span>出现两次，<span class="string">'r'</span>和<span class="string">'t'</span>都只出现一次。</span><br><span class="line">因此<span class="string">'e'</span>必须出现在<span class="string">'r'</span>和<span class="string">'t'</span>之前。此外，<span class="string">"eetr"</span>也是一个有效的答案。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">"cccaaa"</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">"cccaaa"</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="string">'c'</span>和<span class="string">'a'</span>都出现三次。此外，<span class="string">"aaaccc"</span>也是有效的答案。</span><br><span class="line">注意<span class="string">"cacaca"</span>是不正确的，因为相同的字母必须放在一起。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">"Aabb"</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">"bbAa"</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，<span class="string">"bbaA"</span>也是一个有效的答案，但<span class="string">"Aabb"</span>是不正确的。</span><br><span class="line">注意<span class="string">'A'</span>和<span class="string">'a'</span>被认为是两种不同的字符。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    HashMap<character,integer> map=<span class="keyword">new</span> HashMap<>();</character,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    ArrayList<hashmap.entry> list=<span class="keyword">new</span> ArrayList<>();</hashmap.entry></span><br><span class="line">    <span class="keyword">for</span>(HashMap.Entry entry:map.entrySet()){</span><br><span class="line">        list.add(entry);</span><br><span class="line">    }</span><br><span class="line">    list.sort((e1,e2)->(Integer)e2.getValue()-(Integer)e1.getValue());</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < list.size(); i++) {</span><br><span class="line">        Integer value = (Integer)list.get(i).getValue();</span><br><span class="line">        <span class="keyword">while</span> (value><span class="number">0</span>){</span><br><span class="line">            res.append(list.get(i).getKey());</span><br><span class="line">            value--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>这题其实也是TopK问题，直接的想法就是用hashMap统计各个字符出现的个数，然后排序再拼接为结果，其实这题一开始是TLE了的，一开始没注意直接用的String拼接的，效率很低，改用StringBuilder后就过了，虽然效率还是很低 138ms，垫底</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> String <span class="title">frequencySort2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        freq[s.charAt(i)]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] freq_bak=freq.clone();</span><br><span class="line">    Arrays.sort(freq);</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//从大到小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">255</span>; i>=<span class="number">0</span> && freq[i]!=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<<span class="number">255</span>;j++) {</span><br><span class="line">            <span class="comment">//找到原数组中对应的字符</span></span><br><span class="line">            <span class="comment">//只要出现次数一样的就行了</span></span><br><span class="line">            <span class="keyword">if</span>(freq_bak[j]==freq[i]){</span><br><span class="line">                <span class="comment">//根据freq_bak[j]构造结果</span></span><br><span class="line">                <span class="keyword">while</span>(freq_bak[j]><span class="number">0</span>){</span><br><span class="line">                    res.append((<span class="keyword">char</span>)j);</span><br><span class="line">                    freq_bak[j]--;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>15ms，90% 其实思路和上面是一样的，都是统计数量后进行排序，然后重建字符串，但是用数组的方式明显会比HashMap效率会更高的多，后面的两层循环都是在常数时间内，主要是重建字符串和排序消耗时间，时间复杂度应该是<code>O(NlogN)</code></p><p><strong>解法三</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> String <span class="title">frequencySort3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    ArrayList<character> [] bucket=<span class="keyword">new</span> ArrayList[s.length()+<span class="number">1</span>];</character></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        freq[s.charAt(i)]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        <span class="keyword">if</span> (bucket[freq[s.charAt(i)]]==<span class="keyword">null</span>) {</span><br><span class="line">            bucket[freq[s.charAt(i)]]=<span class="keyword">new</span> ArrayList<>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//每个元素只进入一次</span></span><br><span class="line">        <span class="keyword">if</span> (!bucket[freq[s.charAt(i)]].contains(s.charAt(i))) {</span><br><span class="line">            bucket[freq[s.charAt(i)]].add(s.charAt(i));</span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">    <span class="comment">//printArray(bucket);</span></span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=bucket.length-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="comment">//过滤0</span></span><br><span class="line">        <span class="keyword">if</span> (bucket[i]==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//出现i次的字符list</span></span><br><span class="line">        ArrayList<character> temp=bucket[i];</character></span><br><span class="line">        <span class="comment">//遍历出现次数相同的list()</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<temp.size();j++) { < span><br><span class="line">            <span class="comment">//遍历出现的次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>;count<i;count++) {< span><br><span class="line">                res.append(temp.get(j));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></i;count++)></span></temp.size();j++)></span></s.length();i++)></span></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>50ms，50% 这个是根据 <a href="http://imlgw.top/2019/05/04/leetcode-shu-zu-tag/#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">前k个高频元素</a> 中桶排序的解法来的，当然这里并不是最优解，只是一种思路，其实写起来还是挺麻烦的，时间复杂度略高，主要是在桶排序的时候添加元素做不到O(N)需要判断元素是否添加，一个元素只能在list中添加一次，否则后面重建字符串的时候就会有问题</p><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母</li><li>不考虑答案输出的顺序</li></ul><p><strong>解法一</strong></p><p>算是暴力法了，借助上面的同构题思路来遍历判断</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<string>> groupAnagrams(String[] strs) {</list<string></span><br><span class="line">    ArrayList<list<string>> res=<span class="keyword">new</span> ArrayList<>();</list<string></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<strs.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"7"</span>==strs[i]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        ArrayList<string> group=<span class="keyword">new</span> ArrayList<string>();</string></string></span><br><span class="line">        group.add(strs[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j<strs.length;j++) {< span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"7"</span>==strs[j]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isAnagram(strs[i],strs[j])){</span><br><span class="line">                group.add(strs[j]);</span><br><span class="line">                <span class="comment">//有分组了</span></span><br><span class="line">                strs[j]=<span class="string">"7"</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        res.add(group);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String str1,String str2)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(str1.length()!=str2.length()){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<str1.length();i++) {< span><br><span class="line">        freq[str1.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<str2.length();i++) {< span><br><span class="line">        freq[str2.charAt(i)-<span class="string">'a'</span>]--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<freq.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (freq[i]!=<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></freq.length;i++)></span></str2.length();i++)></span></str1.length();i++)></span></strs.length;j++)></span></strs.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>可以看到里面有一个<code>7</code> 其实没什么含义就是为了表示这个字符已经有分组了，这里一开始我是用的equals来比较的这个7结果超时了，然后换成了==勉强跑过了，可能是个例，因为我后来用boolean数组也没跑过。。。</p><blockquote><p>这里用==可以比较的原因可能是strs和字面量 “7”都在字符常量池中，但是这里并不建议这样比较，这里可以说是个反例了，比较字符串请用<code>equals</code> ！！！</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<string>> groupAnagrams(String[] strs) {</list<string></span><br><span class="line">    ArrayList<list<string>> res=<span class="keyword">new</span> ArrayList<>();</list<string></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[strs.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<strs.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (flag[i]) <span class="keyword">continue</span>;</span><br><span class="line">        ArrayList<string> group=<span class="keyword">new</span> ArrayList<string>();</string></string></span><br><span class="line">        group.add(strs[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j<strs.length;j++) {< span><br><span class="line">            <span class="keyword">if</span>(flag[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(isAnagram(strs[i],strs[j])){</span><br><span class="line">                group.add(strs[j]);</span><br><span class="line">                flag[j]=<span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        res.add(group);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></strs.length;j++)></span></strs.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>利用排序结果来作为key，将排序结果相同的str映射到一起</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//排序解法</span></span><br><span class="line"><span class="keyword">public</span> List<list<string>> groupAnagrams(String[] strs) {</list<string></span><br><span class="line">    HashMap<string,list<string>> map=<span class="keyword">new</span> HashMap<>();</string,list<string></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<strs.length;i++) {< span><br><span class="line">        <span class="keyword">char</span>[] strs_i=strs[i].toCharArray();</span><br><span class="line">        <span class="comment">//排序，将结果作为key</span></span><br><span class="line">        Arrays.sort(strs_i);</span><br><span class="line">        String key=String.valueOf(strs_i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)){</span><br><span class="line">            <span class="comment">//存在同构的key，直接添加进去</span></span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//不存在就创建一个，然后将自己添加进去</span></span><br><span class="line">            map.put(key,<span class="keyword">new</span> ArrayList<>());</span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());</span><br><span class="line">}</span><br></strs.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>时间复杂度<code>O(NKlogK)</code>，K为字符数组中最长的字符串，<code>O(KlogK)</code> 是给这个字符串排序的结果</p><p><strong>解法三</strong></p><p>根据出现频次构成的字符串作为key，比如<code>aba</code>以及所有的异位词都会被映射为<code>2#1#</code> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<string>> groupAnagrams(String[] strs) {</list<string></span><br><span class="line">    HashMap<string,list<string>> map=<span class="keyword">new</span> HashMap<>();</string,list<string></span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<strs.length;i++) {< span><br><span class="line">        <span class="comment">//Arrays.fill(freq,0);</span></span><br><span class="line">        <span class="comment">//统计字符出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<strs[i].length();j++) {< span><br><span class="line">            freq[strs[i].charAt(j)-<span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//构建唯一映射的key</span></span><br><span class="line">        StringBuilder key=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//这个其实类似桶排序,依次取abcde...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<<span class="number">26</span>;j++) {</span><br><span class="line">            key.append(freq[j]);</span><br><span class="line">            <span class="comment">//这个#很关键,为了防止重复,因为有的字符可能出现两位数的次数,仅仅对比数字是无法确定的</span></span><br><span class="line">            key.append(<span class="string">"#"</span>);</span><br><span class="line">            <span class="comment">//重置为0方便后面重复使用</span></span><br><span class="line">            freq[j]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        String skey=key.toString();</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(skey)){</span><br><span class="line">            map.get(skey).add(strs[i]);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            map.put(skey,<span class="keyword">new</span> ArrayList());</span><br><span class="line">            map.get(skey).add(strs[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());</span><br><span class="line">}</span><br></strs[i].length();j++)></span></strs.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>45ms，21% 时间复杂度<code>O(NK)</code> K为字符数组中最长的字符串的长度，很玄学，讲道理应该不会这么慢，看了leetcode上前几名跟我的差不多，开始做的时候直接用 <code>StringBuilder</code> 对象作为了key结果肯定不对，StringBuilder没有覆盖equals方法，key永远不会相等，每次都是新的key</p><p><strong>解法四</strong></p><p><strong>算术基本定理</strong>，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<string>> groupAnagrams(String[] strs) {</list<string></span><br><span class="line">    HashMap<integer, list<string>> hash = <span class="keyword">new</span> HashMap<>();</integer,></span><br><span class="line">    <span class="comment">//每个字母对应一个质数</span></span><br><span class="line">    <span class="keyword">int</span>[] prime = { <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span> };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < strs.length; i++) {</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//累乘得到 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < strs[i].length(); j++) {</span><br><span class="line">            key *= prime[strs[i].charAt(j) - <span class="string">'a'</span>];</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(key)) {</span><br><span class="line">            hash.get(key).add(strs[i]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            List<string> temp = <span class="keyword">new</span> ArrayList<string>();</string></string></span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            hash.put(key, temp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList<list<string>>(hash.values());</list<string></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>时间复杂度<code>O(NK)</code>，强的8行</p><blockquote><p>分析完上面三种解法后其实很同意得出这题的关键：<code>给同组的异位词找到一个相同的映射key</code>，尽量的缩短求这个映射的时间就可优化整个算法</p></blockquote><h2 id="447-回旋镖的数量"><a href="#447-回旋镖的数量" class="headerlink" title="447. 回旋镖的数量"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. 回旋镖的数量</a></h2><p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 <code>(i, j, k)</code> ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（<strong>需要考虑元组的顺序</strong>）</p><p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 <code>[-10000, 10000]</code> 中。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个回旋镖为 [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]] 和 [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<points.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<points.length;j++) {< span><br><span class="line">            <span class="keyword">if</span> (i!=j){</span><br><span class="line">                <span class="keyword">int</span> dis=dis(points[i],points[j]);</span><br><span class="line">                map.put(dis,map.getOrDefault(dis,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//C2m 组合问题</span></span><br><span class="line">        <span class="keyword">for</span> (Integer count:map.values()) {</span><br><span class="line">            <span class="keyword">if</span> (count><span class="number">1</span>) {</span><br><span class="line">                res+=count*(count-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        map.clear();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">0</span>]-b[<span class="number">0</span>])*(a[<span class="number">0</span>]-b[<span class="number">0</span>])+(a[<span class="number">1</span>]-b[<span class="number">1</span>])*(a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">}</span><br></points.length;j++)></span></points.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>看一下给的数据量<code>500</code>就知道复杂度只能是<code>O(N^2)</code> 的，用Hash表统计到当前点的距离相同的点有多少个，然后利用组合数求多少种组合，一开始并没有想到这种方法，我想的是利用坐标系的对称来做，太菜了</p><p>这里还有个小细节，一开始将HashMap的创建放在内循环中，发现效率很低，300ms左右，然后将创建HashMap移出去后用clear清空，瞬间快了100ms左右，创建HashMap的成本果然还是挺大的</p><p>这题其实还可以减少内循环的数量，</p><h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">217. 存在重复元素</a></h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>借助Hash表，很简单的题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    HashSet<integer> set=<span class="keyword">new</span> HashSet<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实还可以优化下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    HashSet<integer> set=<span class="keyword">new</span> HashSet<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!set.add(nums[i])) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><code>set.add()</code> 本身就带有返回值，可以减少很多判断，这题还有一个进阶版 <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a> 也不难，我放到 <a href="http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou-tag/#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2">滑动窗口专题</a> 中去了</p><h2 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a></h2><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 <code>nums [i]</code> 和 <code>nums [j]</code> 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 k</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span>, t = <span class="number">0</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">1</span>, t = <span class="number">2</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>], k = <span class="number">2</span>, t = <span class="number">3</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这里其实可以算难题了，通过率只有20%，利用Java中提供的TreeMap，有顺序而且插入和删除等操作效率都很高（logN），然后查找指定范围的元素，看符不符合题目要求</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">    TreeSet<integer> set=<span class="keyword">new</span> TreeSet<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//大于nums[i]的最小元素</span></span><br><span class="line">        Integer ceiling=set.ceiling(nums[i]);</span><br><span class="line">        <span class="comment">//小于nums[i]的最大元素</span></span><br><span class="line">        Integer floor=set.floor(nums[i]);</span><br><span class="line">        <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">long</span> temp1=Long.valueOf(nums[i])+Long.valueOf(t);</span><br><span class="line">        <span class="keyword">long</span> temp2=Long.valueOf(nums[i])-Long.valueOf(t);</span><br><span class="line">        <span class="keyword">if</span>((ceiling!=<span class="keyword">null</span> && ceiling<=temp1) || (floor!=<span class="keyword">null</span> && floor>=temp2)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size()>k) {</span><br><span class="line">            <span class="comment">//移除左边界</span></span><br><span class="line">            set.remove(nums[i-k]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>72ms，5%左右，整体时间复杂度<code>O(NlogN)</code> </p><p><strong>解法二</strong></p><p>看了下评论区，发现其实可以直接比较两个边界，这样可以少一次查找的操作，效率有很大提升</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>{</span><br><span class="line">    TreeSet<long> set=<span class="keyword">new</span> TreeSet<>();</long></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//大于nums[i]-t的最小元素</span></span><br><span class="line">        Long ceil=set.ceiling((<span class="keyword">long</span>)nums[i]-(<span class="keyword">long</span>)t);</span><br><span class="line">        <span class="keyword">if</span>(ceil!=<span class="keyword">null</span> && ceil<=(<span class="keyword">long</span>)nums[i]+(<span class="keyword">long</span>)t) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        set.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size()>k) {</span><br><span class="line">            set.remove((<span class="keyword">long</span>)nums[i-k]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>43ms，56%左右，依然要注意溢出的问题</p><h2 id="前缀和相关"><a href="#前缀和相关" class="headerlink" title="前缀和相关"></a><em>前缀和相关</em></h2><h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p><strong>示例 1 :</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">2</span> , [<span class="number">1</span>,<span class="number">1</span>] 与 [<span class="number">1</span>,<span class="number">1</span>] 为两种不同的情况。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明 :</strong></p><ul><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li></ul><p><strong>解法一</strong></p><p>前缀和 + hash表</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    HashMap<integer,integer> map = <span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    map.put(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//初始化头哨兵,避免下标转换</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        <span class="comment">//-1 -1 1 | 0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*sum>=k && */</span>map.containsKey(sum-k)) {</span><br><span class="line">            res+=map.get(sum-k);</span><br><span class="line">        }</span><br><span class="line">        map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>我们将各个位置的前缀和作为键，这个前缀和在<strong>当前位置之前出现的次数作为键</strong> (这一点保证了连续，不会找到后面去)</p><p>然后我们的目标就是找到和为k区间有多少个，区间和利用前缀和可以直接算出，也就是 </p><p><code>sum[i~j] = sum[j] -sum[i]= k</code> 然后这个问题就可以转换为，当我们遍历到某个元素的时候，我们在map中查找前缀和为<code>sum[j] - k</code>的元素有几个，这样就可以得到区间和为k的区间有多少个！</p><p>值得注意的地方就是，需要添加一个初始的<code>sum=0</code>的值，避免下标的转换</p><p>画个图就像下面这样：</p><p><img alt="img" data-src="http://static.imlgw.top/blog/20191104/ECiyYqso8i2K.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h2><p>给你一个整数数组 nums 和一个整数 k。</p><p>如果某个子数组中恰好有 k 个奇数数字，我们就认为这个子数组是<strong>「优美子数组」</strong>。</p><p>请返回这个数组中「优美子数组」的数目。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：包含 <span class="number">3</span> 个奇数的子数组是 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 和 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= nums.length <= 50000</code></li><li><code>1 <= nums[i] <= 10^5</code></li><li><code>1 <= k <= nums.length</code></li></ul><p><strong>解法一</strong></p><p>11.3 周赛第二题，没做出来，以为是滑动窗口，滑了半天没滑出来，后来看了解答知道了是利用前缀和 + Hash，其实和上面一题是类似的，相当于上一题的进阶</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (nums[i]%<span class="number">2</span>==<span class="number">1</span>) {</span><br><span class="line">            sum++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//题目说了都是正数，所以可以优化下</span></span><br><span class="line">        <span class="keyword">if</span> (sum>=k && map.containsKey(sum-k)) {</span><br><span class="line">            res+=map.get(sum-k);</span><br><span class="line">        }</span><br><span class="line">        map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实这里就是把奇数都看作 1，偶数都看作0，这样问题就变成了求和为k的区间个数有多少个，然后在根据上面的前缀和+Hash表，就可以很容易的得到答案，还有一点就是题目说了数据都是正数，所以在判断的时候可以加一个<code>sum>=k</code> 来减少一点判断，当然这题题目指定了数据的范围，所以还可以直接用数组做map映射</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//HashMap<integer,integer> map=new HashMap<>();</integer,integer></span></span><br><span class="line">    <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">    map[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (nums[i]%<span class="number">2</span>==<span class="number">1</span>) {</span><br><span class="line">            sum++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum>=k) {</span><br><span class="line">            res+=map[sum-k];</span><br><span class="line">        }</span><br><span class="line">        map[sum]++;</span><br><span class="line">        <span class="comment">//System.out.println(sum+":"+map[sum]);</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="1282-用户分组"><a href="#1282-用户分组" class="headerlink" title="1282. 用户分组"></a><a href="https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to/" target="_blank" rel="noopener">1282. 用户分组</a></h2><p>有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。</p><p>你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：groupSizes = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">5</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">解释： </span><br><span class="line">其他可能的解决方案有 [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>],[<span class="number">5</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">3</span>]] 和 [[<span class="number">5</span>],[<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]]。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：groupSizes = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[[<span class="number">1</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>groupSizes.length == n</code></li><li><code>1 <= n <= 500</code></li><li><code>1 <= groupSizes[i] <= n</code></li></ul><p><strong>解法一</strong></p><p>12.8周赛的题，我是模拟做的，看了别人的做法还是感觉这种比较优雅</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> groupThePeople(<span class="keyword">int</span>[] groupSizes) {</list<integer></span><br><span class="line">    HashMap<integer,list<integer>> map=<span class="keyword">new</span> HashMap<>();</integer,list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> LinkedList<>();</list<integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<groupsizes.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(groupSizes[i])) {</span><br><span class="line">            List<integer> list=<span class="keyword">new</span> LinkedList();</integer></span><br><span class="line">            map.put(groupSizes[i],list);</span><br><span class="line">        }</span><br><span class="line">        List<integer> gl=map.get(groupSizes[i]);</integer></span><br><span class="line">        gl.add(i);</span><br><span class="line">        <span class="keyword">if</span> (gl.size()==groupSizes[i]) {</span><br><span class="line">            res.add(gl);</span><br><span class="line">            map.remove(groupSizes[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></groupsizes.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>时间复杂度<code>O(N)</code></p><p><strong>解法二</strong></p><p>模拟的解法，时间复杂度<code>O(N^2)</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List<list<integer>> groupThePeople(<span class="keyword">int</span>[] groupSizes) {</list<integer></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[groupSizes.length];</span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> LinkedList<>();</list<integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<groupsizes.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (visit[i]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        List<integer> list= <span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">        list.add(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j<groupsizes.length;j++) {< span><br><span class="line">            <span class="keyword">if</span> (visit[j]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (list.size()==groupSizes[i]) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (groupSizes[j]==groupSizes[i]) {</span><br><span class="line">                list.add(j);</span><br><span class="line">                visit[j]=<span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        res.add(list);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></groupsizes.length;j++)></span></groupsizes.length;i++)></span></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机(三)</title>
      <link href="/2019/09/05/shen-ru-li-jie-java-xu-ni-ji-san/"/>
      <url>/2019/09/05/shen-ru-li-jie-java-xu-ni-ji-san/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><blockquote><p>这一篇主要记录JVM相关的Class文件结构</p></blockquote><h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p> Class文件是一组以<strong>8个字节</strong>为基础单位的二进制流，根据Java虚拟机规范，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数和表</strong> </p><p><strong>无符号数</strong></p><p>无符号数属于基本的数据类型，以u1，u2，u4，u8来分别表示1，2，4，8个字节大小的无符号数，无符号数用来描述数字，索引引用，数量值，或者按照UTF-8编码构成字符串值</p><p><strong>表（数组）</strong></p><p>表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性的以<code>_info</code> 结尾，表用于描述有程池关系的复合结构的数据，整个Class文件本质上就是一张表</p><h3 id="Class文件整体结构"><a href="#Class文件整体结构" class="headerlink" title="Class文件整体结构"></a>Class文件整体结构</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ClassFile{</span><br><span class="line">    <span class="function">u4                  <span class="title">magic</span><span class="params">(魔数<span class="number">0xCAFFBABE</span>)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">minor_version</span><span class="params">(次版本号)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">major_version</span><span class="params">(主版本号)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">constant_pool_count</span><span class="params">(常量池个数)</span></span></span><br><span class="line"><span class="function">    cp_info             <span class="title">constant_pool</span><span class="params">(常量池表)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">access_flags</span><span class="params">(类或接口的访问权限)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">this_class</span><span class="params">(类名)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">super_class</span><span class="params">(父类名)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">interfaces_count</span><span class="params">(接口个数)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">interfaces</span><span class="params">(接口名)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">fields_count</span><span class="params">(字段个数)</span></span></span><br><span class="line"><span class="function">    field_info          <span class="title">fields</span><span class="params">(字段表)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">methods_count</span><span class="params">(方法数)</span></span></span><br><span class="line"><span class="function">    method_info         <span class="title">methods</span><span class="params">(方法表)</span></span></span><br><span class="line"><span class="function">    u2                  <span class="title">attributes_count</span><span class="params">(附加属性个数)</span></span></span><br><span class="line"><span class="function">    attribute_info      <span class="title">attributes</span><span class="params">(附加属性表)</span></span></span><br><span class="line"><span class="function">}</span></span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>在网上看了<a href="https://www.infoq.cn/article/Secrets-of-the-Bytecode-Ninjas" target="_blank" rel="noopener">国外的大佬</a>的一张图，挺有意思的<img alt="mark" data-src="http://static.imlgw.top/blog/20190902/4JDgENgQ9eIo.png?imageslim" src="/img/loading.gif" class="lazyload"></p></blockquote><p><strong>魔数和Class文件的版本</strong></p><p>每个Class文件的<strong>头4个字节</strong>称为魔数，他唯一的作用是确定这个文件是否为一个能被虚拟机接收的Class文件，这个值为<code>0xCAFFBABE</code> ，紧跟着魔数的<strong>4个字节</strong>存储的是Class文件的版本号，高版本的JDK能兼容低版本的字节码，而低版本JVM的无法兼容高版本的Class文件</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧跟着版本号之后的就是常量池入口，一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作Class文件的资源仓库，比如说Java类中定义的方法和变量信息，都是存储在常量池中，常量池中主要存储的两类常量：</p><ul><li><strong>字面量：</strong> 文本字符串，Java中声明为final的常量值等</li><li><strong>符号引用：</strong>类和接口的全限定名，字段的名称和描述符，方法的名称和描述符等</li></ul><blockquote><p>关于符号引用，其实在之前的文章中有介绍过，Java代码在编译的时候并不像C++/C一样有连接的步骤，而是在虚拟机加载Class文件的时候进行<strong>动态链接</strong>，也就是说，在Class文件中不会保存各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用无法直接被虚拟机使用，当虚拟机运行的时候，需要从常量池中获得对应得符号引用，在类创建或运行得时候解析，翻译到具体的内存地址中。</p></blockquote><h3 id="常量池项目类型"><a href="#常量池项目类型" class="headerlink" title="常量池项目类型"></a>常量池项目类型</h3><p>常量池的每一项都是一个表，JDK1.7之前一共有11种<strong>结构不同</strong>的表结构，也就是下面的11种，JDK1.7之后为了更好的支持动态语言的调用，又额外的增加了3种（CONSTANT_MethodHandle_info，CONSTANT_MethodType_info，CONSTANT_InvokeDynamic_info）这些表结构都有一个共同的特点，<strong>表开始的第一位都是一个<code>u1</code>类型的标志位<code>tag</code>，目的就是区分这个常量属于那种类型的常量</strong>，后面的内容都各有各的结构，<code>index</code>代表的是常量池中的对应的常量索引，<code>bytes</code>代表的就是字节数据</p><h3 id="cp-info"><a href="#cp-info" class="headerlink" title="cp_info"></a>cp_info</h3><p><img alt="常量池表结构" data-src="http://static.imlgw.top/blog/20190829/vjjWxwvrt0qg.png" src="/img/loading.gif" class="lazyload"></p><p>这张表上的数据不用记住，用的时候知道去哪里查就行了（虽然用的机会很少😂），下面我们编译一段代码，看一下字节码长啥样</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🎯<strong>编译完成后用16进制的编译器(winHex)打开Class文件</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190901/EOnrpm9sx8wE.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>⚡ 这里前面的4个字节<code>0xCAFEBABE</code> 代表的就是魔数，后面的4个字节<code>0x00000034</code>代表的就是版本号，再往后2个字节<code>0x0018</code>就是常量池的入口，对应的就是常量池的大小（constant_pool_count），转换为10进制就是24，但是实际上并不是24个，常量池计数是从1而不是0开始的，设计者将0位置的项空出来目的是为了表示后面某些指向常量池的索引值的数据在特定情况下表示<strong>不引用任何一个常量池项目</strong>（大师就是大师，各种细节都能考虑到）</p><p>⚡ 再往后看，<code>0x0A</code>，这个就是我们前面说的<code>tag</code>标志位，转换为10进制就是<code>10</code> ，查一下表对应的常量类型是<code>CONSTANT_Methodref_info</code>，紧跟着的两个字节<code>0x0004</code>是一个<code>index</code>类型的数据，指向声明方法描述符<code>CONSTANT_Class_info</code> 的索引项，也就是常量池的第4项，再往后两个字节<code>0x0014</code>代表的就是指向类型描述符<code>CONSTANT_NameAndType</code>的索引项，也就是常量池的第20项</p><p>这里我们就不一一的去分析了，我们借助<code>javap</code> 来看看反编译的结果和我们分析的是不是一致的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Last modified <span class="number">2019</span>-<span class="number">9</span>-<span class="number">1</span>; size <span class="number">485</span> bytes</span><br><span class="line">  MD5 checksum e8148a01ff25087c42827d62a9b827b0</span><br><span class="line">  Compiled from <span class="string">"Test1.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jvmstudy</span>.<span class="title">classfile_stu</span>.<span class="title">Test1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object."<init>":()V</init></span><br><span class="line">   #2 = Fieldref           #3.#21         // jvmstudy/classfile_stu/Test1.a:I</span><br><span class="line">   #3 = Class              #22            // jvmstudy/classfile_stu/Test1</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               <init></init></span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Ljvmstudy/classfile_stu/Test1;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               Test1.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // "<init>":()V</init></span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               jvmstudy/classfile_stu/Test1</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span> jvmstudy.classfile_stu.Test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."<init>":()V</init></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         6: putfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ljvmstudy/classfile_stu/Test1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ljvmstudy/classfile_stu/Test1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: iload_1</span><br><span class="line">         2: putfield      #2                  // Field a:I</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ljvmstudy/classfile_stu/Test1;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>     a   I</span><br><span class="line">}</span><br><span class="line">SourceFile: <span class="string">"Test1.java"</span></span><br></pre></td></tr></tbody></table></figure></div><p>可以看到和我们分析结果是一致的，那这个<code>Methodref</code>是表示的那个方法呢？其实根据反编译的结果也可以看出来，这个方法是我们默认的无参构造方法</p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x00 01</td><td>是否为Public类型</td></tr><tr><td>ACC_FINAL</td><td>0x00 10</td><td>是否被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x00 20</td><td>是否允许使用invokespecial字节码指令的新语义．jdk1.0.2之后都为真</td></tr><tr><td>ACC_INTERFACE</td><td>0x02 00</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x04 00</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x10 00</td><td>标志这个类并非由用户代码产生</td></tr><tr><td>ACC_ANNOTATION</td><td>0x20 00</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>０x40 00</td><td>标志这是一个枚举</td></tr></tbody></table><p>在常量池结束之后，紧接着的<strong>两个字节</strong>代表访问标志（<code>access_flags</code>），这个标志用于识别类或接口层次的访问信息，包括：这个Class是接口还是方法?是否定义为public类型？是否定义为abstract？等，两个字节16个标志位，可以表示2^16种状态，但是当前只定义了8个标志位没有使用到的一律要求为0</p><p>还是参考上面的字节码，常量池是图中从<code>0A~74</code> 的紫色部分，紧跟着后面的两个字节<code>0x0021</code>对应的就是访问标志位，也就是 <code>ACC_PUBLIC | ACC_SUPER</code> 的值</p><h2 id="类索引，父类索引接口索引集合"><a href="#类索引，父类索引接口索引集合" class="headerlink" title="类索引，父类索引接口索引集合"></a>类索引，父类索引接口索引集合</h2><p>类索引(<code>this_class</code>)和父类索引(<code>super_class</code>)都是一个u2类型的数据，而接口索引集合(<code>interfaces</code>)是一组<code>u2</code> 类型的<strong>数据的集合</strong>，Class文件中由这三项数据来表示这个类的继承关系</p><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引、父类索引和接日索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串</p><p>我们接着上面的字节码文件分析，紧接着访问标志符后面的u2是<code>0x0003</code> 也就是<code>this_class</code>在常量池中的索引，再往后的<code>0x0004</code>对应的就是<code>super_class</code>在常量池的索引<code>0x0000</code> 说明没有父接口，后面的集合也就没有了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object."<init>":()V</init></span><br><span class="line">   #2 = Fieldref           #3.#21         // jvmstudy/classfile_stu/Test1.a:I</span><br><span class="line">   #3 = Class              #22            // jvmstudy/classfile_stu/Test1</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               <init></init></span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Ljvmstudy/classfile_stu/Test1;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               Test1.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // "<init>":()V</init></span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               jvmstudy/classfile_stu/Test1</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br></pre></td></tr></tbody></table></figure></div><p>结合反编译的结果，常量池第三项和第四项都对应了一个<code>CONSTANT_Class_info</code>的索引常量，其最终指向了一个<code>CONSTANT_Utf8_info</code> 的常量，这个常量的值就是我们的<code>this_class</code>和<code>super_class</code> 的全限定名</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>紧跟着上面类索引等信息后面的<code>u2</code>类型的数据<code>0x0001</code>就是代表的<code>fields_count</code>，这里只有一个字段a所以这里是<code>1</code></p><h3 id="field-info"><a href="#field-info" class="headerlink" title="field_info"></a>field_info</h3><p>字段表（<code>field_info</code>）用于描述接口或者类中声明的变量。字段（<code>field</code>）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</p><p>字段的各种修饰符其实都是个布尔值，要么有要么没有，所以很好表示适合用标志位来表示，但是字段的类型，名字这些就很难固定</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>前三项分别代表，访问修饰符，名字的索引以及_描述符_（<strong>对字段来说就是字段的类型</strong>）的索引，这三项就可以构成一个字段的完整的信息了，这里我们重点看的也是前三项的信息，字段修饰符<code>access_flags</code>其实和类中的<code>access_flags</code> 类似，只不过可以设置的修饰符不太一样</p><p><strong>字段访问标志</strong></p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生的</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否enum</td></tr></tbody></table><p>🎯<strong>继续接着上面的类索引分析</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190902/s5dWhYXNIuxq.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>⚡<code>0x0001</code> 对应<code>fields_count</code>，值为1字段的数量为 1，后面的<code>field_info</code>数量为1</p><p>⚡<code>0x0002</code> 对应字段的<code>access_flags</code>，为<code>ACC_PRIVATE</code></p><p>⚡<code>0x0005</code> 对应字段的名字的索引，在常量池中的第5项，结合上面反编译的结果第5项为  <code>#5 = Utf8    a</code></p><p>⚡<code>0x0006</code> 对应字段的描述符索引，在常量池中第6项，为<code>#6 = Utf8   I</code></p><p>到这里其实我们就可以推断出这个变量的定义为 <code>private int a</code></p><blockquote><p>字段表集合中不会列出从超类或者父接口中继承而来的字段，但是有可能会列出原本Java代码中没有的字段，比如内部类中自动添加指向外部类的字段。从所周知，在<strong>Java</strong>中字段是不能重载的，只要两个字段的名字是不能一样的，必须使用不同的名称，注意，这是<strong>Java的语言规范</strong>，其实在Class字节码来讲，只要两个字段的描述符不一样，重名就是合法的。</p></blockquote><p>再往后两个字节<code>0x0000</code>代表<code>attributes_count</code>，其值为0所以后面的属性表就没有了，如果这里将字段改为<code>static final int a</code> 那么<code>attributes_count</code> 将为1，后面会多出一条指向常量池<code>ConstantValue</code>数据的index(下文会演示)</p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>紧跟着字段表之后的u2类型的数据 <code>0x0003</code>代表的就是<code>method_count</code> ，值为3代表有三个方法，这里面包含了JVM自动生成的默认无参数构造器方法，所以是3个</p><h3 id="method-info"><a href="#method-info" class="headerlink" title="method_info"></a>method_info</h3><p>方法表的结构其实和字段表的结构是一样的</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>但是具体的<code>access_flags</code> 和<code>attributes</code>集合不太一样</p><p><strong>方法访问标志</strong></p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x00 01</td><td>方法是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x00 02</td><td>方法是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x00 04</td><td>方法是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x00 08</td><td>方法是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x00 10</td><td>方法是否为final</td></tr><tr><td>ACC_SYHCHRONRIZED</td><td>0x00 20</td><td>方法是否为synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x00 40</td><td>方法是否是由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x00 80</td><td>方法是否接受参数</td></tr><tr><td>ACC_NATIVE</td><td>0x01 00</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x04 00</td><td>方法是否为abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x08 00</td><td>方法是否为strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x10 00</td><td>方法是否是有编译器自动产生的</td></tr></tbody></table><p>🎯<strong>我们继续接着上面的字段表后面分析</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190902/BuNVfOyD3mJy.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>⚡<code>0x0003</code> 方法表的入口，代表<code>methods_count</code> 方法的数量，值为3，有三个方法（包括了编译器自动生成的<code><init></init></code>方法）</p><p>⚡ <code>0x0001</code> 第一个方法的访问标志值，代表<code>ACC_PUBLIC</code></p><p>⚡ <code>0x0007</code> 方法名的<code>name_index</code>，值为7代表常量池中第7项常量，结合反编译的结果其值为</p><p><code>#7 = Utf8  <init></init></code>  也就是我们的实例构造方法（编译器自动帮我们生成的）</p><p>⚡ <code>0x0008</code> 方法描述符的<code>descriptor_index</code> ，值为8代表常量池中第8项常量，其值为</p><p><code>#8 = Utf8  ()V</code>  自动生成的无参构造器的描述</p><p>⚡ <code>0x0001</code> 方法属性表(<code>attribute_info</code>)的入口，代表<code>attributes_count</code> ，值为1代表有一个属性表</p><p>⚡ <code>0x0009</code> 属性名称的索引，常量池中为 <code>#9 = Utf8   Code</code>说明此属性是方法的字节码描述，也就是方法中的代码</p><blockquote><p>在方法表中，如果子类没有重写父类的方法就不会出现父类的方法信息，但是会出现编译器自动添加的方法，最典型的就是<code><clinit></clinit></code>和<code><init></init></code>，这里并没有 静态变量的赋值和静态语句块所以并没有生成<code><clinit></clinit></code> 方法，另外一点和上面字段表的一样，Java语言中重载是不能以返回值来界定的，但是在Class文件格式中，只要描述符不一致，就是可以共存的，而方法的描述符就包括了参数列表和返回值</p></blockquote><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>属性表（attribute_info），Class文件，字段表，方法表中可以携带自己的属性表，说有attribute_info的前两项都是u2类型的<code>attribute_name_index</code>和u4类型的<code>attribute_length</code>分别代表属性名字的索引和属性值的大小 ，Java虚拟机中预定义了一些属性，这些属性都各有各的含义和结构</p><table><thead><tr><th align="left">属性名称</th><th>使用位置</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Code</td><td>方法表</td><td align="left">Java 代码编译成的字节码指令</td></tr><tr><td align="left">ConstantValue</td><td>字段表</td><td align="left">final 关键字定义的常量值</td></tr><tr><td align="left">Deprecated</td><td>类、方法表、字段表</td><td align="left">被声明为 <code>deprecated</code> 的方法和字段</td></tr><tr><td align="left">Exceptions</td><td>方法表</td><td align="left">方法抛出的异常</td></tr><tr><td align="left">EnclosingMethod</td><td>类文件</td><td align="left">仅当一个类为局部类或匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td align="left">InnerClasses</td><td>类文件</td><td align="left">内部类列表</td></tr><tr><td align="left">LineNumberTable</td><td>Code 属性</td><td align="left">Java 源码的行号与字节码指令的对应关系</td></tr><tr><td align="left">LocalVariableTable</td><td>Code 属性</td><td align="left">方法的局部变量描述</td></tr><tr><td align="left">StackMapTable</td><td>Code 属性</td><td align="left">JDK 6 新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td></tr><tr><td align="left">Signature</td><td>类、方法表、字段表</td><td align="left">JDK 5 新增的属性，用于支持泛型情况下的方法签名，在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。由于 Java 的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息</td></tr><tr><td align="left">SourceFile</td><td>类文件</td><td align="left">记录源文件名称</td></tr><tr><td align="left">SourceDebugExtension</td><td>类文件</td><td align="left">JDK 6 新增属性，用于存储额外的调试信息。譬如在进行 JSP 文件调试时，无法通过 Java 堆栈来定位到 JSP 文件的行号，JSR-45 规范为这些非 Java 语言编写，却需要编译成字节码并运行在 Java 虚拟机中的程序提供了一个进行调试的标准机制，使用该属性就可以存储这个标准所新加入的调试信息</td></tr><tr><td align="left">Synthetic</td><td>类、方法表、字段表</td><td align="left">表示方法或字段是由编译器自动生成的</td></tr><tr><td align="left">LocalVariableTypeTable</td><td>类</td><td align="left">JDK 5 新增属性，它使用特征签名代替描述符，为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td align="left">RuntimeVisibleAnnotations</td><td>类、方法表、字段表</td><td align="left">JDK 5 新增属性，为动态注解提供支持。该属性指明哪些注解是运行时（实际上运行时就是进行反射调用）可见的</td></tr><tr><td align="left">RuntimeInvisibleAnnotations</td><td>类、方法表、字段表</td><td align="left">JDK 5 新增属性，与 <code>RuntimeVisibleAnnotations</code> 作用相反，用于指明哪些注解运行时不可见</td></tr><tr><td align="left">RuntimeVisibleParameterAnnotations</td><td>方法表</td><td align="left">JDK 5 新增属性，作用与 <code>RuntimeVisibleAnnotations</code> 作用相似，只不过作用对象为方法参数</td></tr><tr><td align="left">RuntimeInvisibleParameterAnnotations</td><td>方法表</td><td align="left">JDK 5 新增属性，作用与 <code>RuntimeInvisibleAnnotations</code> 作用相似，只不过作用对象为方法参数</td></tr><tr><td align="left">AnnotationDefault</td><td>方法表</td><td align="left">JDK 5 新增属性，用于记录注解类元素的默认值</td></tr><tr><td align="left">BootstrapMethods</td><td>类文件</td><td align="left">JDK 7 新增属性，用于存储 <code>invokedynamic</code> 指令引用的引导方法限定符</td></tr></tbody></table><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>Java程序方法体中的代码经过Javac编译器处理过后，最终变为字节码指令存储在Code属性内</p><p>Code属性出现在<strong>方法表的属性集合</strong>中，但是并非所有的方法表都必须存在这个Code属性，<strong>像接口和抽象类中的方法就不存在Code属性</strong></p><p><strong>Code属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>max_stack</td><td>1</td></tr><tr><td>u2</td><td>max_locals</td><td>1</td></tr><tr><td>u4</td><td>code_length</td><td>1</td></tr><tr><td>u1</td><td>code</td><td>code_length</td></tr><tr><td>u2</td><td>exception_table_length</td><td>1</td></tr><tr><td>exception_info</td><td>exception_table</td><td>exception_table_length</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attributes_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>🎯<strong>紧接着上面的方法表分析</strong></p><p><em>这里分析的还是方法表第一个方法（<code><init></init></code>）所携带的属性表</em></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190904/Gd5cWl6Yr84x.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>⚡ <code>0x0009</code> 对应<code>attribute_name_index</code>，属性名称的索引，常量池中为 <code>#9 = Utf8   Code</code>说明此属性是方法的字节码描述，也就是方法中的代码</p><p>⚡ <code>0x00000038</code> 代表<code>attribute_length</code> 顾名思义就是属性值的长度，这里是56（不包含attribute_name_index和attribute_length）</p><p>⚡<code>0x0002</code>代表<code>max_stack</code> 操作数栈（Operand Stacks）深度的最大值，虚拟机运行的时候会根据这个值来分配栈帧（StackFrame）中的操作栈深度</p><p>⚡<code>0x0001</code>代表<code>max_locals</code> 代表了<strong>局部变量表</strong>所需的存储空间，这里的内存分配单位是<code>Slot</code></p><blockquote><p><code>Slot</code>是虚拟机为局部变量分配内存所使用的最小单位，对于byte，char，float，int，short，boolean等长度不超过32位的数据类型，每个局部变量占用一个<code>Slot</code> ，但是对于double和long等64位的数据类型则需要两个<code>Slot</code> </p><p>方法参数（包括实例方法中的this引用），trycatch语句中catch中定义的异常，方法体中定义的局部变量 都需要使用局部变量表来存放，但是最后并不是把所有这些局部变量占用的<code>Slot</code>加起来就是<code>max_locals</code> 因为<strong>局部变量表中的Slot是可以复用的</strong>，当代码执行超过一个局部变量的作用域时，这个变量占用的Slot就可以被其他局部变量所使用，所以编译器会根据作用域来分配<code>Slot</code> 给各个局部变量使用</p></blockquote><p>⚡<code>0x0000000A</code>u4类型的<code>code_length</code> 代表的就是字节码的长度，这里是10，说明后面有10个字节长度的字节码指令流</p><p>⚡u1类型的<code>code</code> 就是具体用字节码指令，每个指令都是一个u1的单字节指令，也就是说最多有256个指令，目前Java虚拟机已经定义了其中约200条编码值对应的指令，这里有连续的10个单字节指令，构成了<code><init></init></code>方法的字节码指令</p><p>⚡<code>0x0000</code>代表<code>exception_table_length</code> 异常表的长度，这里<code><init></init></code>方法没有异常抛出所以为0</p><p>⚡ <code>exception_info</code>类型的<code>exception_table</code> 异常表，存放处理异常的信息（try-catch中的异常），前面的长度为0所以这里不存在这一项数据</p><p><strong>异常表结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>end_pc</td><td>1</td></tr><tr><td>u2</td><td>handler_pc</td><td>1</td></tr><tr><td>u2</td><td>catch_type</td><td>1</td></tr></tbody></table><p>每个exception_table表项由start_pc，end_pc，handler_pc，catch_type（指向常量池中CONSTANT_Class_info类型的常量）组成</p><p>当字节码在start_pc到end_pc之间出现了类型为catch_type或者其子类的异常，就转到handler_pc行继续执行，当catch_type为0时表示处理所有的异常</p><p>⚡<code>0x0002</code> 代表<code>attributes_count</code> 是<code>Code</code> 属性表的<strong>附加属性</strong>的入口（一层套一层啊😂），值为2意味着附加属性表的数量为2</p><h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>这个就是上面<strong><code><init></init></code>方法Code属性附加的第一个属性</strong>，这个属性用于描述Java源代码行号和字节码行号（偏移量）之间的对应关系，他并不是运行的必须属性，但是默认会生成到Class文件中，可以使用<code>-g:none</code>或<code>-g:lines</code>取消生成这个属性，取消之后程序抛异常的时候不会显示出错的行号，并且在调试的时候，也无法按照源码行来设置断点，其结构如下表</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>line_number_table_length</td><td>1</td></tr><tr><td>line_number_info</td><td>line_number_table</td><td>line_number_table_length</td></tr></tbody></table><p>🎯<strong>我们再接着上面的Code属性的属性表分析，看看Code的属性表是啥</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190904/O7MuBcPXNPKT.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>⚡<code>0x000A</code> attributes_info的第一项，对应的是atttibute的名字的索引，常量池中对应第10项的索引是 </p><p> <code>#10 = Utf8   LineNumberTable</code> 说明这个属性是LineNumberTable属性，然后根据上面给出的表格继续分析</p><p>⚡<code>0x0000000A</code> 对应attribute_length，说明该属性值长度为10</p><p>⚡<code>0x0002</code>对应line_number_table_length，说明有两处对应关系</p><p>⚡ 后面紧跟的字节就对应的<code>line_number_table</code> 该属性又有两个属性，分别为<code>start_pc</code>和<code>line_number</code>两个u2类型的数据项，前者是字节码行号，后者是源码行号，前面line_number_table_length为2，所以这里后面有两个line_number_table</p><h3 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h3><p>这个就是上面<strong><code><init></init></code> 方法Code属性附加的第二个属性</strong>，这个属性主要用于描述<strong>栈帧中局部变量表</strong>中的变量和Java源代码中定义的变量之间的关系，没有这项属性当在其他地方使用该方法的时候关于参数的名称都会丢失，最典型的就是IDE中有时候反编译一些框架的代码就会看见一些方法参数什么的都是arg0，arg1什么的</p><p><strong>LocalVariableTable属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>local_variable_table_length</td><td>1</td></tr><tr><td>local_variable_info</td><td>local_variable_table</td><td>local_variable_table_length</td></tr></tbody></table><p>🎯 <strong>我们接着上面的LineNumberTable属性分析<code>LocalVariableTable</code></strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190905/TafXz1oMkG4d.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>⚡<code>0x000B</code>和之前所有的attributes_info一样，这个第一项代表该属性的名字在常量池的索引值，这里对应常量池第11项 <code>#11 = Utf8   LocalVariableTable</code> </p><p>⚡<code>0x0000000C</code> 对应attribute_length，说明该属性值长度为12</p><p>⚡<code>0x0001</code>对应local_variable_table_length，值为1说明只有一个局部变量</p><blockquote><p>其实到现在我们分析的属性表都还是在分析这个类的第一个方法，JVM自动生成的<code><init></init></code>方法所对应的属性表，而这个<code><init></init></code>很明显是没有参数的，是一个无参的空构造器，那么问题来了，这里的局部变量是从哪里来的？为什么不是0？</p><p>其实这很好解释，平常编码的时候大家肯定都使用过<code>this</code> 这个关键字，通过这个关键字可以在实例方法中拿到当前的实例对象，这个1代表其实就是这个<code>this</code>，在Javac编译的时候会将对this的访问转换为对一个方法参数的访问，而这个方法参数会在运行这个实例方法的时候由JVM自动的传入，所以局部变量表中至少会存在一个指向当前实例的局部变量</p></blockquote><p>我们继续分析后面的<code>local_variable_info</code> </p><p><strong>local_variable_info属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>index</td><td>1</td></tr></tbody></table><p>⚡<code>0x0000</code> 代表<code>start_pc</code>，这个局部变量的生命周期开始的字节码偏移量</p><p>⚡<code>0x000A</code>代表<code>length</code>代表这个局部变量其作用范围覆盖的长度</p><p>⚡<code>0x000C</code>代表<code>name_index</code> 是这个局部变量的名字索引，指向常量池中第12项常量 <code>#12 = Utf8   this</code>符合我们前面的分析</p><p>⚡<code>0x000D</code>代表<code>decriptor_index</code> 局部变量描述符（对变量来说就是变量的类型）的索引，指向常量池第13项常量</p><p><code>#13 = Utf8    Ljvmstudy/classfile_stu/Test1;</code> 当前实例对象的<strong>全限定名</strong></p><p>⚡<code>0x0000</code> 对应<code>index</code> 代表这个局部变量在<strong>栈帧局部变量表</strong>中Slot的位置</p><blockquote><p>_<strong>⏳ 到这里我们的方法表的第一个方法<code><init></init></code>的Code属性就结束了，由于<code><init></init></code>方法不包含其他的属性所以<code><init></init></code>方法在字节码中也已经结束了</strong>_，后面的方法就不再逐个字节的分析了，都是一样的，主要的是要搞清楚这些属性的层级和包含关系，不要搞混了</p></blockquote><h3 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h3><p><code>Exceptions</code> 属性和上面Code属性是平级的，和Code属性附带的<code>exception_table</code>并不是一个东西，不要搞混了，Exceptions属性的作用是列举出方法中可能抛出的受检查异常，也就是方法描述时在<code>throws</code>关键字后面列举的异常，结构如下</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_exceptions</td><td>1</td></tr><tr><td>u2</td><td>exception_index_table</td><td>number_of_exceptions</td></tr></tbody></table><p><code>number_of_exceptions</code>表示可能抛出多少种受检查异常，每种异常都是一个<code>exception_index_table</code> 很明显这个是一个索引，指向常量池中对应的Exception的描述符</p><p>这里我们的<code><init></init></code> 方法并没有抛出异常，所以这一项属性并不存在，那我们找一个有异常的来看看</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> bbbb = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> aaaa = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List<integer> list=<span class="keyword">null</span>;</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">        bbbb = a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException</span>{</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            x=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>  x;</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            x=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            x=<span class="number">3</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deprecatedMethod</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190905/uG5AQrVoHphH.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>可以看到<code>exception_table</code> 里面记录了这个方法的异常处理表，也就是<code>try-catch</code>里面的异常处理，这也是Java代码的一部分，编译器使用了异常处理表去处理异常和finally机制，在jdk1.4之前使用的是简单的跳转指令来实现，而Exceptions属性和Code平级，只是列举了一些可能抛出的异常</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Exceptions:</span><br><span class="line">  <span class="keyword">throws</span> java.lang.ArithmeticException</span><br></pre></td></tr></tbody></table></figure></div><h2 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h2><p>这个属性是属于Class文件的属性，很明显是用来记录生成这个Class文件的源代码名称，其值指向一个CONSTANT_Utf8_info的索引，值就是源文件的名字</p><h2 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h2><p>这个属性在前一篇 <a href="http://imlgw.top/2019/08/17/shen-ru-li-jie-java-xu-ni-ji-er/#%E5%87%86%E5%A4%87">类加载器</a> 中提到过， <code>ConstantValue</code>属性的作用是通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量（类变量）可以使用这项属性</p><p>如果<strong>同时使用final和static来修饰一个变量</strong>，并且这个变量的数据类型是基本类型或者<code>java.lang.String</code>的话，就生成<code>ConstantValue</code>属性，用于在<strong>准备阶段</strong>给变量赋初始值，如果这个变量没有被final修饰或者并非基本类型及字符串，则在准备阶段会被初始化为默认的零值，在<code><clinit></clinit></code>方法中进行真正的初始化</p><p><strong>依然是上面Exceptions的Demo</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190905/U8zwbs2c0n8a.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>可以看到<code>aaaa</code> 这个常量字段附带了 <code>ConstantValue</code> 属性其值就是指向常量池中99的一个索引</p><blockquote><p>🎯 后面还有一些属性就不再详细介绍了</p><p>Signature用来记录泛型的信息，StackMapTable用来验证字节码，BootstarapMethods用来保存动态调用的引导方法限定符，Deprecated和Synthetic两个boolean属性……</p></blockquote><h2 id="Synchnorized字节码分析"><a href="#Synchnorized字节码分析" class="headerlink" title="Synchnorized字节码分析"></a>Synchnorized字节码分析</h2><p><strong>synchnorized</strong>关键字可以用来修饰方法体，或者方法体内的代码块，修饰方法体的时候同步是隐式的，无需通过字节码指令来控制，它实现在方法调用和返回中，为了看到字节码的变化，这里我们不讨论这种（两种方式的底层实现其实还是一样的）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            a = x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>编译后利用工具查看setA方法内生成的字节码指令（省略了次要的一些信息）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0           <span class="comment">//对象引用this入栈</span></span><br><span class="line"><span class="number">1</span>: dup             <span class="comment">//复制栈顶元素(this)</span></span><br><span class="line"><span class="number">2</span>: astore_2          <span class="comment">//将栈顶元素(this)存入局部变量表Slot索引为2的位置</span></span><br><span class="line"><span class="number">3</span>: monitorenter      <span class="comment">//以栈顶元素(this)为锁进入同步块</span></span><br><span class="line"><span class="number">4</span>: iload_1         <span class="comment">//局部变量Slot 1位置的元素(x)入栈</span></span><br><span class="line">5: invokestatic  #2  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">8: putstatic     #3  // Field a:Ljava/lang/Integer; 用x给a赋值</span><br><span class="line"><span class="number">11</span>: aload_2          <span class="comment">//局部变量表Slot 2元素(this)入栈</span></span><br><span class="line"><span class="number">12</span>: monitorexit      <span class="comment">//退出同步</span></span><br><span class="line"><span class="number">13</span>: goto          <span class="number">21</span> <span class="comment">//跳转到21行结束</span></span><br><span class="line"><span class="number">16</span>: astore_3         <span class="comment">//到这里说明异常了，将栈顶元素（异常对象）存入局部变量表Slot 3位置</span></span><br><span class="line"><span class="number">17</span>: aload_2          <span class="comment">//局部变量表Slot 2元素(this)位置入栈</span></span><br><span class="line"><span class="number">18</span>: monitorexit      <span class="comment">//退出同步</span></span><br><span class="line"><span class="number">19</span>: aload_3          <span class="comment">//局部变量表Slot 3位置元素入栈</span></span><br><span class="line"><span class="number">20</span>: athrow           <span class="comment">//抛出异常</span></span><br><span class="line"><span class="number">21</span>: <span class="keyword">return</span>           <span class="comment">//方法正常返回</span></span><br><span class="line">Exception table:</span><br><span class="line">    from    to  target type</span><br><span class="line">       <span class="number">4</span>    <span class="number">13</span>    <span class="number">16</span>   any</span><br><span class="line">      <span class="number">16</span>    <span class="number">19</span>    <span class="number">16</span>   any</span><br></pre></td></tr></tbody></table></figure></div><p>最开始没有学字节码的时候一直很纳闷为啥有两个<code>monitorexit</code> ，现在算是明白了，这是为了保证synchnorized在方法异常的情况下仍然可以正常的释放锁，而不至于导致锁泄露，这也是比较推荐使用synchnorized的原因之一</p><p>通过字节码可以看到，编译器为我们自动的生成了一个异常表，也就是前面Code属性中携带的exception_table属性，如果在指定的程序段内发生异常，会按照异常表指定的target进行跳转，无论如何都会释放这个锁</p><h2 id="总结-amp-参考"><a href="#总结-amp-参考" class="headerlink" title="总结 & 参考"></a>总结 & 参考</h2><p>这一部分主要记录了Class字节码的文件结构相关的内容，也算是是逐个字节的分析了一遍，收获还是挺大的，对JVM平台的理解又加深了，当然这一篇也是给下一篇<strong>虚拟机节码的执行引擎</strong>做铺垫</p><p><strong><em>《深入理解Java虚拟机》——周志明</em></strong></p></body></html>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Class结构 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode动态规划</title>
      <link href="/2019/09/01/leetcode-dong-tai-gui-hua/"/>
      <url>/2019/09/01/leetcode-dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="number">1</span> step + <span class="number">1</span> step</span><br><span class="line"><span class="number">2</span>. <span class="number">2</span> steps</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="number">3</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="number">1</span> step + <span class="number">1</span> step + <span class="number">1</span> step</span><br><span class="line"><span class="number">2</span>. <span class="number">1</span> step + <span class="number">2</span> steps</span><br><span class="line"><span class="number">3</span>. <span class="number">2</span> steps + <span class="number">1</span> step</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>没啥好说的，可以说是最经典的dp题了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairsDp</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> []dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<=n;i++) {</span><br><span class="line">        dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Rob house <span class="number">1</span> (money = <span class="number">1</span>) and then rob house <span class="number">3</span> (money = <span class="number">3</span>).</span><br><span class="line">             Total amount you can rob = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">12</span></span><br><span class="line">Explanation: Rob house <span class="number">1</span> (money = <span class="number">2</span>), rob house <span class="number">3</span> (money = <span class="number">9</span>) and rob house <span class="number">5</span> (money = <span class="number">1</span>).</span><br><span class="line">             Total amount you can rob = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>简单的dp题，dp方程很容易得到，<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  Max[i]=max(nums[i-2]+nums[i],nums[i-1])</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> []dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>]=nums[<span class="number">1</span>]>nums[<span class="number">0</span>]?nums[<span class="number">1</span>]:nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i<nums.length;i++) {< span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[i-<span class="number">1</span>];</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>时间空间都是O(N)，需要注意边界条件，这题还有另一种写法，空间复杂度是O(1)的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Max[i]=max(pre+nums[i],cur);  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> pre= <span class="number">0</span>; <span class="comment">//前一天</span></span><br><span class="line">    <span class="keyword">int</span> cur= <span class="number">0</span>; <span class="comment">//当天，其实就是为了保存前后两天的dp[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> temp=cur;</span><br><span class="line">        cur=Math.max(pre+nums[i],cur);</span><br><span class="line">        <span class="comment">//向后走</span></span><br><span class="line">        pre=temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>与上一题相比房屋都围成一圈了，其实围成一圈也就说明<code>nums[0]</code>和<code>nums[len-1]</code>不能同时偷，所以就可以分两种情况分别求最大值，然后求最终的最大值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">2</span>){</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums,<span class="number">1</span>,n),rob(nums,<span class="number">0</span>,n-<span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>; <span class="comment">//前一家最大值</span></span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>; <span class="comment">//当前最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start;i<end;i++) {< span><br><span class="line">        <span class="keyword">int</span> temp=cur;</span><br><span class="line">        cur=Math.max(pre+nums[i],cur);</span><br><span class="line">        pre=temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br></end;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">1</span>]</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">/ \</span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">    \   \ </span><br><span class="line">     <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">7</span> </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">7</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">/ \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">4</span> + <span class="number">5</span> = <span class="number">9</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>暴力递归，应该还是写得出来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//AC了,但是效率很低</span></span><br><span class="line"><span class="comment">//可以用hashMap缓存一下每个节点rob的值,但是没必要</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tryRob(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryRob</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span> && root.right==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//偷取当前节点</span></span><br><span class="line">    <span class="keyword">int</span> res=root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) {</span><br><span class="line">        res+=tryRob(root.left.left)+tryRob(root.left.right);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) {</span><br><span class="line">        res+=tryRob(root.right.left)+tryRob(root.right.right);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//不偷当前节点</span></span><br><span class="line">    <span class="keyword">int</span> res2=<span class="number">0</span>;</span><br><span class="line">    res2=tryRob(root.left)+tryRob(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res,res2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>看评论区说是啥树状dp ? 知识盲区了hahaha</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] res=tryRob(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//树形dp???</span></span><br><span class="line"><span class="comment">//看的懂，但是肯定写不出来 。。。。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] tryRob(TreeNode root) {</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] left=tryRob(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right=tryRob(root.right);</span><br><span class="line">    <span class="comment">//不包含当前节点的最大值</span></span><br><span class="line">    dp[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//包含当前节点的最大值</span></span><br><span class="line">    dp[<span class="number">1</span>]=left[<span class="number">0</span>]+right[<span class="number">0</span>]+root.val;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>不是我吹，就这样的题目，再遇见多少次我都写不出来这样的解（笑</p><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h2><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明</strong>：每次只能向下或者向右移动一步。</p><p><strong>示例</strong>:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></tbody></table></figure></div><p>很经典的DP题。</p><p>递推公式：<code>dp[i][j]  = grid[i][j] + Math.min(dp[i-1][j],dp[i][j-1])</code></p><p>dp[i] [j] 为每个格子到<code>左上角</code>最短路径 ，每隔格子到右上角的最小距离等于，左边格子最小值和上边格子最小值的最小值加上当前格子的值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<grid.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<grid[<span class="number">0</grid[<span></span>].length;j++) {</grid.length;i++)></span><br><span class="line">            <span class="comment">//第一行</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> && j!=<span class="number">0</span>){</span><br><span class="line">                dp[i][j]=grid[i][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span> && j==<span class="number">0</span>){</span><br><span class="line">                dp[i][j]=grid[i][j]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span> && j!=<span class="number">0</span>){</span><br><span class="line">                dp[i][j]=grid[i][j]+Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i][j]=grid[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190818/DfwXk3ObWxX8.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>说明：</strong>m 和 n 的值均不超过 100。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 向右 -> 向右 -> 向下</span><br><span class="line"><span class="number">2</span>. 向右 -> 向下 -> 向右</span><br><span class="line"><span class="number">3</span>. 向下 -> 向右 -> 向右</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>动态规划解法</strong></p><p>这题算是我第一道自己做出来的DP题了，虽然和上面的一题一样的思路，但是还是挺开心的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(m<<span class="number">0</span>||n<<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<m;j++) {< span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&&j!=<span class="number">0</span>){</span><br><span class="line">                dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span> && i!=<span class="number">0</span>){</span><br><span class="line">                dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(j!=<span class="number">0</span>&&i!=<span class="number">0</span>){</span><br><span class="line">                dp[i][j]=dp[i][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">}</span><br></m;j++)></span></n;i++)></span></pre></td></tr></tbody></table></figure></div><p>时间复杂度<code>O(m*n)</code>，空间复杂度<code>O(m*n)</code>可以看出来完全是按照前一题的模板来的，代码写的不好，可以把 if-else合并起来，这题空间复杂度其实还可以优化成 O(m)或O(n)的，按行来向下走</p><p><strong>空间复杂度优化</strong></p><p><img alt="leetCode题解" data-src="http://static.imlgw.top/blog/20190824/7uacSvsRMaWq.png?imageslim" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(m<<span class="number">0</span>||n<<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>); <span class="comment">//第一行，第一列均为 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<m;i++) { <span class="comment">//一行一行向下走</m;i++)></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<n;j++) {< span><br><span class="line">            <span class="comment">//这里的dp[j]和dp[j-1]分别就代表了 上边 和 左边的元素</span></span><br><span class="line">            dp[j]=dp[j]+dp[j-<span class="number">1</span>]; <span class="comment">//求每一行每个元素的dp值</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>]; <span class="comment">//最后一行最后一个dp值就是结果</span></span><br><span class="line">}</span><br></n;j++)></span></pre></td></tr></tbody></table></figure></div><p><strong>组合数公式</strong></p><p>这题其实就是我们初中还是高中学的排列组合的问题，机器人一共走<code>m+n-2</code> 步，向下会走<code>m-1</code> 步，向下会走<code>n-1</code> 步，所以实际上就是求一个组合数的结果 <code>C(n-1，m+n-2)</code> ，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(m<<span class="number">0</span>||n<<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> step=m+n-<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> down=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=down;i++) {</span><br><span class="line">        res=res*(step-down+i)/i; <span class="comment">//递推</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190818/DfwXk3ObWxX8.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>说明：</strong>m 和 n 的值均不超过 100。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 向右 -> 向右 -> 向下 -> 向下</span><br><span class="line"><span class="number">2</span>. 向下 -> 向下 -> 向右 -> 向右</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>看到这种路径的题，首先想到的可能是递归回溯</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//dfs回溯 , TLE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction={{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">1</span>,<span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid==<span class="keyword">null</span> || obstacleGrid.length<=<span class="number">0</span> || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span>[][] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">    dfs(obstacleGrid,visit,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid,<span class="keyword">boolean</span>[][] visit,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="comment">//!=1 是为了coner case</span></span><br><span class="line">    <span class="keyword">if</span> (x==obstacleGrid.length-<span class="number">1</span> && y==obstacleGrid[<span class="number">0</span>].length-<span class="number">1</span> && obstacleGrid[x][y]!=<span class="number">1</span>) {</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<direction.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> nx=x+direction[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny=y+direction[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx<obstaclegrid.length && ny<obstaclegrid[<span class="number">0</obstaclegrid.length></span>].length && !visit[nx][ny] && obstacleGrid[nx][ny] !=<span class="number">1</span>) {</direction.length;i++)></span><br><span class="line">            visit[nx][ny]=<span class="keyword">true</span>;</span><br><span class="line">            dfs(obstacleGrid,visit,nx,ny);</span><br><span class="line">            visit[nx][ny]=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>结果很惨，TLE了，只跑了不到一半的case就TLE了</p><p><strong>解法二</strong></p><p>动态规划的解法，其实和上面一题是一样的，只不过需要注意障碍物位置的dp值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid==<span class="keyword">null</span> || obstacleGrid.length<=<span class="number">0</span> || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<obstaclegrid.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j<obstaclegrid[<span class="number">0</obstaclegrid[<span></span>].length;j++) {</obstaclegrid.length;i++)></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j]==<span class="number">1</span>) {</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> && j==<span class="number">0</span>) {</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span> && j!=<span class="number">0</span>){</span><br><span class="line">                dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span> && i!=<span class="number">0</span>) {</span><br><span class="line">                dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[obstacleGrid.length-<span class="number">1</span>][obstacleGrid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>和上面一样也可以进行空间上的优化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//一维dp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid==<span class="keyword">null</span> || obstacleGrid.length<=<span class="number">0</span> || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//以行为单位向下走</span></span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<obstaclegrid.length;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j<obstaclegrid[<span class="number">0</obstaclegrid[<span></span>].length;j++) {</obstaclegrid.length;i++)></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j]==<span class="number">1</span>) {</span><br><span class="line">                dp[j]=<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span> && j!=<span class="number">0</span>){ <span class="comment">//第一行</span></span><br><span class="line">                dp[j]=dp[j-<span class="number">1</span>];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span> && j!=<span class="number">0</span>){ </span><br><span class="line">                dp[j]=dp[j]+dp[j-<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//每一行第一列的dp[j]=dp[j],和上一行的第一列保持一致就行</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[obstacleGrid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定 nums = [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">2</span>, -<span class="number">1</span>]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -> <span class="number">1</span></span><br><span class="line">sumRange(<span class="number">2</span>, <span class="number">5</span>) -> -<span class="number">1</span></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">5</span>) -> -<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>你可以假设数组不可变。</li><li>会多次调用 sumRange 方法。</li></ul><p><strong>解法一</strong></p><p>这题其实一开始就是想的缓存一下之前调用产生的值，没有理解到这题的要点。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums!=<span class="keyword">null</span> && nums.length><span class="number">0</span>) {</span><br><span class="line">            sums=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">            sums[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<sums.length;i++) {< span><br><span class="line">                sums[i]=sums[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> sums[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sums[j]-sums[i-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></sums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这题关键有两个地方，一个是 <code>sumRange(i , j) = sumRange(0, j)-sumRange(0, i-1)</code> ，另一个关键就是在构造器里面将所有的 <code>sumRange(0 , i)</code> 给预先求出来，这样在后面的调用时时间复杂度就是<code>O(1)</code>的了。</p><p>这里求<code>sumRange(0, i)</code>的过程就是一个很简单的dp.</p><hr><h2 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/" target="_blank" rel="noopener">413. 等差数列划分</a></h2><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，以下数列为等差数列:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span></span><br><span class="line"><span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span></span><br><span class="line"><span class="number">3</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">9</span></span><br></pre></td></tr></tbody></table></figure></div><p>以下数列不是等差数列。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<q<n 。< p></q<n></p><p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p><p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。</p><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p><p> <strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">返回: <span class="number">3</span>, A 中有三个子等差数组: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] 以及自身 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。</span><br></pre></td></tr></tbody></table></figure></div><p>dp的题啊，答案一看就明白，就是自己想不到。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(A.length<<span class="number">3</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//dp[i]=dp[i-1]+1;</span></span><br><span class="line">    <span class="keyword">int</span> []dp=<span class="keyword">new</span> <span class="keyword">int</span>[A.length]; <span class="comment">//以 A[i] 结尾的等差数列有多少个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<a.length;i++) {< span><br><span class="line">        <span class="keyword">if</span>(A[i]-A[i-<span class="number">1</span>]==A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>]){</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<dp.length;i++) {< span><br><span class="line">        res+=dp[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></dp.length;i++)></span></a.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>就是没想到要对以当前元素结尾的动态数组数量做dp，当然上面的做法的空间还可以优化成O(1)的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices2</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(A.length<<span class="number">3</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//dp[i]=dp[i-1]+1;</span></span><br><span class="line">    <span class="keyword">int</span> dp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<a.length;i++) {< span><br><span class="line">        <span class="keyword">if</span>(A[i]-A[i-<span class="number">1</span>]==A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>]){</span><br><span class="line">            dp=dp+<span class="number">1</span>;</span><br><span class="line">            res+=dp;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            dp=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></a.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>只需要根据上一次的dp值更新就行，如果break等差数列，就置为0</p><hr><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></h2><p>给定一个正整数 n，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong> 你可以假设 n 不小于 2 且不大于 58。</p><p><strong>解法一</strong></p><p>别问，问就是暴力</p><p><img alt="leetCode题解97wgl" data-src="http://static.imlgw.top/blog/20190822/BKqmfoXMVq3Q.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>递推式：</strong> <code>F(n) = max {i * F(n - i)}，i = 1，2，...，n - 1</code>  </p><p>穷举每一种分解情况，求最大值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<n;j++) {< span><br><span class="line">        <span class="comment">//第一个Max求最大值，第二个Max主要是为了考虑 只分两个数就是最大值的情况（<=7的情况）</span></span><br><span class="line">        res=Math.max(res, Math.max((n-j)*j,integerBreak(n-j)*j));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></n;j++)></span></pre></td></tr></tbody></table></figure></div><p>需要注意的就是第二个Max 别忘了<strong>只分为两个数就到达最大值</strong>的情况，比如n<=7的时候，<code>integerBreak(n-j)*j)</code>  至少是三个，下面的DP也是一样的要注意别忘了两个数的情况</p><p>递归的时间复杂度应该是<code>O(N!)</code> ，后面的case会超时，其实很明显，递归过程中会有很多的重复计算所以可以采用记忆化递归缓存一下之前的值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  Integer[] cache=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//只顶向下,记忆化递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> breakInteger(n);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">breakInteger</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cache[n]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<n;j++) {< span><br><span class="line">        res=Math.max(res, Math.max((n-j)*j,breakInteger(n-j)*j));</span><br><span class="line">    }</span><br><span class="line">    cache[n]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></n;j++)></span></pre></td></tr></tbody></table></figure></div><p>这样的解法是可以AC的，缓存之前计算的结果，避免了重复的计算</p><p><strong>解法二</strong></p><p>动态规划，结合上面的递归得到<code>递推方程</code></p><p><code>dp[i] = max(dp[i]，max(dp[ i-j ] * j ，(i-j) * j));</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">integerBreak2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> [] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span>; <span class="comment">//0,1不考虑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>;i<=n;i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<i;j++) {< span><br><span class="line">            dp[i]=Math.max(dp[i],Math.max(dp[i-j]*j,(i-j)*j));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></i;j++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法三</strong></p><p>打板找规律，笔试的时候能直接一眼看出来规律的肯定优先找规律了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">integerBreak3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] base={<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>};</span><br><span class="line">    <span class="keyword">if</span>(n<=<span class="number">7</span>){</span><br><span class="line">        <span class="keyword">return</span> base[n-<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>]=base[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">3</span>]=base[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">4</span>]=base[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">5</span>]=base[<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">6</span>]=base[<span class="number">4</span>];</span><br><span class="line">    dp[<span class="number">7</span>]=base[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">8</span>;i<=n;i++) {</span><br><span class="line">        dp[i]=dp[i-<span class="number">3</span>]*<span class="number">3</span>; <span class="comment">//N>7之后 dp[N]=dp[N-3]*3</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法四</strong></p><p>数学分析，其实分析一下会发现，只有2和3是分解后值比<strong>本身还要小</strong>的，4分解后相等，这样一分析，从整体上来看其实就清楚了，只要分到2或者3的时候就不再分就行了，此时的值一定是最大值，如果2，3继续分值就会减小</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] base={<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>};</span><br><span class="line">    <span class="keyword">if</span>(n<=<span class="number">4</span>){</span><br><span class="line">        <span class="keyword">return</span> base[n-<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n>=<span class="number">5</span>){</span><br><span class="line">        res*=<span class="number">3</span>;</span><br><span class="line">        n-=<span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">    res*=n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>动态规划，不容易啊，自己推出了DP方程，没看答案，其实也借鉴了上一题的思路</p><p><code>dp[i] =min(dp[i]，dp[i-j*j]+1)</code> </p><p>其实也是将整数拆分，不过拆分的时候按照 <strong>完全平方数</strong> 来拆分，完全平方数的肯定是 1所以最后要加个 1</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=n;i++) {</span><br><span class="line">        dp[i]=Integer.MAX_VALUE; <span class="comment">//dp[i]初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;i>=j*j;++j){</span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>50%左右，看了下时间复杂度应该是 <code>O(N^1.5)</code>  还是挺高的（评论区用Py的都超时了）</p><p><strong>解法二</strong></p><p>BFS，将数字按照完全平方数连接为一个图，然后BFS求一个从n到0的最短的路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    Queue<pair> queue=<span class="keyword">new</span> LinkedList<>();</pair></span><br><span class="line">    <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(n,<span class="number">0</span>));</span><br><span class="line">    visit[n]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">        Pair pair=queue.poll();</span><br><span class="line">        <span class="keyword">int</span> num=pair.num;</span><br><span class="line">        <span class="keyword">int</span> step=pair.step;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> step;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i*i<=num;i++) {</span><br><span class="line">            <span class="keyword">int</span> temp=num-i*i;</span><br><span class="line">            <span class="keyword">if</span> (!visit[temp]) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair(temp,step+<span class="number">1</span>));</span><br><span class="line">                visit[temp]=<span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> step)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.num=num;</span><br><span class="line">        <span class="keyword">this</span>.step=step;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题最快的做法应该是利用 <strong>四平方和定理</strong> 我也不太清楚，所以暂时先不研究这种做法</p><h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">'A'</span> -> <span class="number">1</span></span><br><span class="line"><span class="string">'B'</span> -> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'Z'</span> -> <span class="number">26</span></span><br></pre></td></tr></tbody></table></figure></div><p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"12"</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 它可以解码为 <span class="string">"AB"</span>（<span class="number">1</span> <span class="number">2</span>）或者 <span class="string">"L"</span>（<span class="number">12</span>）。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"226"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 它可以解码为 <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>哇，这题我吐了，好不容易看出来了递推公式，被边界给整死了。。。面向测试用例编程。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s.startsWith(<span class="string">"0"</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] s_nums=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        s_nums[i]=Integer.valueOf(s.charAt(i)-<span class="number">48</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp =<span class="keyword">new</span> <span class="keyword">int</span>[s_nums.length];</span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<s_nums.length;j++) {< span><br><span class="line">        <span class="keyword">if</span>(s_nums[j]==<span class="number">0</span> && s_nums[j-<span class="number">1</span>]==<span class="number">0</span> || (s_nums[j]==<span class="number">0</span> && s_nums[j-<span class="number">1</span>]><span class="number">2</span>)){</span><br><span class="line">            <span class="comment">//直接return</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>( s_nums[j]==<span class="number">0</span> || s_nums[j-<span class="number">1</span>]==<span class="number">0</span> || (j<s_nums.length-<span class="number">1</s_nums.length-<span></span> &&s_nums[j+<span class="number">1</span>]==<span class="number">0</span>)){</s_nums.length;j++)></span><br><span class="line">            <span class="comment">//为了处理 12120这种情况</span></span><br><span class="line">            res*=dp[j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s_nums[j-<span class="number">1</span>]*<span class="number">10</span>+s_nums[j]<=<span class="number">26</span>){</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>){</span><br><span class="line">                dp[j]=<span class="number">2</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[j]=dp[j-<span class="number">1</span>]+dp[j-<span class="number">2</span>];    </span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//划分点。。。</span></span><br><span class="line">            res*=dp[j-<span class="number">1</span>];</span><br><span class="line">            dp[j-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            dp[j]=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//最后一段</span></span><br><span class="line">    res*=dp[s_nums.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>首先要推出这题的递推公式，我也是在纸上画了半天才看出来，如果这个数组前后两个元素之和都是小于26的那么这一段的编码方式就是一个<strong>斐波拉契数列</strong> ，也就是 <code>dp[i]=dp[i-1]+dp[i-2]</code></p><p>80%左右，这题其实一开始并不是这样做的，我觉得我开始的思路还是挺好的，将字符串分段，当前一个和后一个无法合并的时候就作为一个分界点，最后将每一段的编码方式相乘就是结果了。</p><p>但是 ！！！ 我忽略了0这个东西了，这题后面给的case里面都是带有0的！！！！处理这个边界处理了一上午终于跑过了。。。代码也没什么好说的，写的太烂了，这种代码没啥意义，都是走一步看一步。</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s.startsWith(<span class="string">"0"</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] s_nums=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        s_nums[i]=Integer.valueOf(s.charAt(i)-<span class="number">48</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<=s.length();i++) {</span><br><span class="line">        <span class="keyword">int</span> a=s_nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="number">0</span>){</span><br><span class="line">            <span class="comment">//到这里dp[i]==0,没有初始化,默认就是0</span></span><br><span class="line">            <span class="comment">//其实等价于dp[i]=dp[i-1],延续前一个字符的状态</span></span><br><span class="line">            dp[i]+=dp[i-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s_nums[i-<span class="number">2</span>]==<span class="number">0</span>){</span><br><span class="line">            <span class="comment">//如果前前一个字符为0那么就不用dp了,保持i-1的状态就OK</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前前一个字符和</span></span><br><span class="line">        <span class="keyword">int</span> b=s_nums[i-<span class="number">2</span>]*<span class="number">10</span>+s_nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(b<=<span class="number">26</span>){</span><br><span class="line">            dp[i]+=dp[i-<span class="number">2</span>]; <span class="comment">//上下这两个dp必须执行一个否则最后就 return 0</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[s_nums.length];</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>这种写法就清晰多了，分析各种情况，dp代表截至字符的编码方式</p><p>💬  <code>s_num[i-1]!=0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] <=26</code>  </p><p>类似于 <strong>112</strong>  这样的，这就是正常dp的情况符合斐波拉契数列</p><p>💬  <code>s_num[i-1]==0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] <=26</code></p><p>类似于 <strong>102</strong> 这样的，这样就直接<code>继承 dp[i-2]的状态</code>就行了，相当于<code>dp[i]=dp[i-2]</code></p><p>💬  <code>s_num[i-1]!=0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1] >26</code></p><p>类似于 <strong>132</strong> 这样的，这样就直接<code>继承 dp[i-2]的状态</code>就行了，相当于<code>dp[i]=dp[i-2]</code></p><p>💬 <code>s_num[i-1]!=0 && s_num[i-2]==0 && s_num[i-2]+s_num[i-1] <=26</code></p><p>类似于 <strong>…012</strong>这样的，<code>dp[i]=dp[i-1]</code></p><p>💬 <code>s_num[i-1]==0 && s_num[i-2]==0</code> 或者<code>s_num[i-1]==0 && s_num[i-2]!=0 && s_num[i-2]+s_num[i-1]>26</code></p><p>类似于<strong>00</strong> 和<strong>30</strong> 这样的， 这样就代表这个字符串无法编码了 <strong>dp[i]=0</strong> 最后返回的就是0</p><hr><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span> </span><br><span class="line">解释: 最长的上升子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，它的长度是 <span class="number">4</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(n2) 。</li><li>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</li></ul><p><strong>解法一</strong></p><p>LIS，这题好像在很多地方见到过了，还是要好好理解下，<strong>dp[i]表示以当前元素结尾的最长上升子序列的长度</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//Arrays.fill(dp,1);</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        dp[i]=<span class="number">1</span>; <span class="comment">//初始化dp[i]=1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<i;j++) {< span><br><span class="line">            <span class="keyword">if</span>(nums[i]>nums[j]){</span><br><span class="line">                <span class="comment">//遍历i之前的元素,找一个最大的dp[j]+1</span></span><br><span class="line">                dp[i]=Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<dp.length;i++) {< span><br><span class="line">        res=res>dp[i]?res:dp[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></dp.length;i++)></span></i;j++)></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>一开始题目就没看清楚就开始做，以为是连续的，心想这不是O(N)的么，为啥要我写O(N^2)的🤣 </p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190824/86VLMN8VWcpI.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>灵魂画手，其实也是一道很简单的DP(然而我还是没想出来)，但是时间复杂度比较高O(N^2)，可以优化成O(NlogN)</p><p><strong>解法二</strong></p><p><code>贪心+二分</code>  这个贪心还是有点骚的，核心思想：</p><p><strong>如果前面的数越小，后面接上一个随机数，就会有更大的可能性构成一个更长的“上升子序列”。</strong></p><p>而<code>tail[i]</code> 中存储长度为 <code>i + 1</code> 的最长递增子序列的最后一个元素，所以最后len就是整个数组的最长上升子序列，更多题解可以 参考<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">LeetCode题解</a> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] tail = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">int</span> index=binarySearch(tail,len,num); </span><br><span class="line">        <span class="comment">//最难理解的就是这一步，直接替换了原数组里面的对应的元素</span></span><br><span class="line">        <span class="comment">//按照贪心的规则,将index位置的元素变小，或者添加到队尾</span></span><br><span class="line">        tail[index] = num;</span><br><span class="line">        <span class="keyword">if</span> (index == len) {</span><br><span class="line">            len++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回target可以插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l<=r){</span><br><span class="line">        <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target<nums[mid]){< span><br><span class="line">            r=mid-<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(target>nums[mid]){</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br></nums[mid]){<></span></pre></td></tr></tbody></table></figure></div><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><p><strong>解法一</strong></p><p>动态规划递推的解法，没啥好说的，这题其实还有一道姊妹题，要求出最大子序列，不仅仅是最大值，<a href="(http://imlgw.top/2019/07/20/leetcode-hua-dong-chuang-kou-tag/#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC)">我放到了滑动窗口专题中</a> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//这次是直接在Web上写的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//一开始没处理好Wa了一发</span></span><br><span class="line">    <span class="keyword">int</span> max=dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++){< span><br><span class="line">        <span class="keyword">if</span>(dp[i-<span class="number">1</span>]<=<span class="number">0</span>){</span><br><span class="line">            dp[i]=nums[i];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        }</span><br><span class="line">        max=Math.max(max,dp[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>根据二维改一维</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> dp1=nums[<span class="number">0</span>],dp2=<span class="number">0</span>,max=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (dp1<=<span class="number">0</span>) {</span><br><span class="line">            dp2=nums[i];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            dp2=dp1+nums[i];</span><br><span class="line">        }</span><br><span class="line">        dp1=dp2;</span><br><span class="line">        max=Math.max(max,dp2);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>感觉一维的不用去理解含义，能根据二维改出来就ok了，重点是理解多维的</p><h2 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">646. 最长数对链</a></h2><p>给出 <code>n</code> 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p><p>现在，我们定义一种跟随关系，当且仅当 <code>b < c</code> 时，数对<code>(c, d)</code> 才可以跟在 <code>(a, b)</code> 后面。我们用这种形式来构造一个数对链。</p><p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><p><strong>示例 :</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 最长的数对链是 [<span class="number">1</span>,<span class="number">2</span>] -> [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意：</strong></p><ul><li>给出数对的个数在 [1, 1000] 范围内。</li></ul><p><strong>解法一</strong></p><p>动态规划</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>{</span><br><span class="line">    Arrays.sort(pairs,(a,b)->a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[pairs.length];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<pairs.length;i++) {< span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<i;j++) {< span><br><span class="line">            <span class="keyword">if</span> (pairs[i][<span class="number">0</span>]>pairs[j][<span class="number">1</span>]) {</span><br><span class="line">                dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        res=res>dp[i]?res:dp[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></i;j++)></span></pairs.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>注意这里没有要求顺序，所以先给他排个序，然后再进行DP，如果不排序很难dp，dp[i]表示当前数对能构成的最长链，dp过程和上面的最长上升子序列相同</p><p><strong>解法二</strong></p><p>贪心，也是最优解，同样先排序，不过是按照第二个元素来排序，核心思想</p><p><code>每次都在列表中找第二个元素最小的数对依次组成链，最后得到的一定是最长的链</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>{</span><br><span class="line">    Arrays.sort(pairs,(a,b)->a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tail=pairs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<pairs.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (pairs[i][<span class="number">0</span>]>tail) {</span><br><span class="line">            res++;</span><br><span class="line">            tail=pairs[i][<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pairs.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法三</strong></p><p>也就是上面说的分治法，分治法在这里并不是最优解，时间复杂度<code>O(NlogN)</code>，但是思路还是很巧妙，首先也是讲数组一分为二，然后最大序列和就有三种情况    </p><ol><li>全在左边</li><li>全在右边</li><li>跨中点，两边都有</li></ol><p>然后统计三个值得最大值，递归子过程求解，代码就不写了，后面想起来有时间再补</p><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">17</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 这个序列包含几个长度为 <span class="number">7</span> 摆动序列，其中一个可为[<span class="number">1</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">16</span>,<span class="number">8</span>]。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶:</strong></p><ul><li>你能否用 O(n) 时间复杂度完成此题?</li></ul><p><strong>解法一</strong></p><p>O(N^2 )动态规划，dp[i]代表目前为止以 nums[i]结尾的最长的<code>上升摇摆序列</code>，down[i]代表目前为止以nums[i]结尾的最长的<code>下降摇摆序列</code>，后面过程就和上面的<code>LIS</code>的解法类似了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> []up=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">    <span class="keyword">int</span> []down=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        up[i]=<span class="number">1</span>; down[i]=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<i;j++) {< span><br><span class="line">            <span class="keyword">if</span>(nums[i]>nums[j]){</span><br><span class="line">                <span class="comment">//找一个最大的下降沿</span></span><br><span class="line">                up[i]=Math.max(up[i],down[j]+<span class="number">1</span>);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]<nums[j]){< span><br><span class="line">                <span class="comment">//找一个最大的上升沿</span></span><br><span class="line">                down[i]=Math.max(down[i],up[j]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(up[nums.length-<span class="number">1</span>],down[nums.length-<span class="number">1</span>]);</span><br><span class="line">}</span><br></nums[j]){<></span></i;j++)></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>线性动态规划，其实上面的循环找最大操作有点多余，如果<code>nums[i]>nums[i-1]</code> 那么以nums[i]为上升沿结尾（摆动上升）的最长摇摆序列 <code>up[i]=down[i-1]+1</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> []up=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> []down=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    up[<span class="number">0</span>]=down[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span>(nums[i]>nums[i-<span class="number">1</span>]){</span><br><span class="line">            up[i]=down[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            down[i]=down[i-<span class="number">1</span>];</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]<nums[i-<span class="number">1</nums[i-<span></span>]){</nums.length;i++)></span><br><span class="line">            down[i]=up[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            up[i]=up[i-<span class="number">1</span>];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//相等的时候别忘了继承前面的状态</span></span><br><span class="line">            down[i]=down[i-<span class="number">1</span>];</span><br><span class="line">            up[i]=up[i-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(up[nums.length-<span class="number">1</span>],down[nums.length-<span class="number">1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我感觉能写出O(1)的前提是先写出O(N)的，写出O(N)的之后再改成O(1)会比较简单</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> up=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> down=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (nums[i]>nums[i-<span class="number">1</span>]) {</span><br><span class="line">            up=down+<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (nums[i]>nums[i-<span class="number">1</span>]){</span><br><span class="line">            down=up+<span class="number">1</span>;</span><br><span class="line">        }<span class="comment">//else就是不变</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(up,down);</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h2><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="number">3</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation:</span><br><span class="line">Given n = <span class="number">3</span>, there are a total of <span class="number">5</span> unique BST<span class="string">'s:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   1         3     3      2      1</span></span><br><span class="line"><span class="string">    \       /     /      / \      \</span></span><br><span class="line"><span class="string">     3     2     1      1   3      2</span></span><br><span class="line"><span class="string">    /     /       \                 \</span></span><br><span class="line"><span class="string">   2     1         2                 3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这个解法实际上来自 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> generateTree(<span class="number">1</span>,n).size();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List<treenode> <span class="title">generateTree</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></treenode></span>{</span><br><span class="line">    List<treenode> res=<span class="keyword">new</span> ArrayList<>();</treenode></span><br><span class="line">    <span class="keyword">if</span> (start>end) {</span><br><span class="line">        res.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start;i<=end;i++) {</span><br><span class="line">        List<treenode> left=generateTree(start,i-<span class="number">1</span>);</treenode></span><br><span class="line">        List<treenode> right=generateTree(i+<span class="number">1</span>,end);</treenode></span><br><span class="line">        <span class="keyword">for</span> (TreeNode l:left) {</span><br><span class="line">            <span class="keyword">for</span> (TreeNode r:right) {</span><br><span class="line">                TreeNode currentNode=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                currentNode.left=l;</span><br><span class="line">                currentNode.right=r;</span><br><span class="line">                res.add(currentNode);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种写法很明显过不了这题，时间复杂度太高了，但是这个方法可以求出所有的BST集合。</p><p><strong>解法二</strong></p><p>动态规划，<code>dp[i]</code>代表长度为 <code>i</code> 的递增序列构成的不同的BST的数量（序列从<code>1 到 i</code> 递增）</p><p>递推公式: <code>dp[i]=dp[i-1]* dp[n-i]</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n<=<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> []dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<=n;i++) { <span class="comment">//控制序列长度 直到我们求得 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<=i;j++) { <span class="comment">//控制根的选择</span></span><br><span class="line">            <span class="comment">//累加和，j为根节点 dp[j-1]代表左子树数量，dp[i-j]代表右子树数量</span></span><br><span class="line">            dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>以 <code>i</code> 位置元素为根节点，可以得出可能的 BST数量为，<code>[1 ~ i-1]</code> 可以构成的BST数量 乘以  <code>[i+1，n]</code>可以构成的BST数量，也就是<em>左子树  *  右子树</em>  ，再推广到整个序列的BST总数，其实也就是 <strong>以每个元素为根节点构成的BST的数量之和</strong> ，需要理解的地方就是<code>dp[i]</code> 的含义，明确本题中<code>dp[i]</code> 其实<strong>只和长度 <code>i</code>有关</strong>而和内容无关，比如1，2，3和4，5，6所能构成的BST数量其实是相同的</p><p><strong>解法三</strong></p><p>卡塔兰数，递推式 <code>Gn+1 =2(2n+1)/ n+2  *  Gn</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> C = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < n; ++i){</span><br><span class="line">        C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) /(i + <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) C;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0 </p><blockquote><p>最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用</p></blockquote><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abcde"</span>, text2 = <span class="string">"ace"</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">"ace"</span>，它的长度为 <span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abc"</span>, text2 = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">"abc"</span>，它的长度为 <span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abc"</span>, text2 = <span class="string">"def"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>2019.10.19力扣终于有这题了，重新来做一遍，这题也就是经常说的LCS，dp的经典问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[A.length()+<span class="number">1</span>][B.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=A.length();i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<=B.length();j++) {</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(i-<span class="number">1</span>)==B.charAt(j-<span class="number">1</span>)) {</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[A.length()][B.length()];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实看见这种什么最长的多半和dp有关系，这题只要明白几个要点就可以推出dp方程</p><ul><li><p><code>dp[i][j]</code> 代表A序列前<code>i</code>个字符（记为<code>Ai</code>）， 和B序列前<code>j</code>个字符（记为<code>Bj</code>） 的LCS</p></li><li><p>两层for循环遍历两个序列，当<code>A[i]==B[j]</code>的时候，LCS长度就会增加 1，进而得到dp方程</p><p><code>dp[i][j]=dp[i-1][j-1]+1</code>   dp[i-1] [j-1]代表的就是不包含<code>Ai/Bj</code>的<code>Ai-1</code>和<code>Bj-1</code> 的LCS</p></li><li><p><code>A[i]!=B[j]</code>的时候就有两种情况了，首先<code>A[i]</code>和<code>B[j]</code>已经<strong>不可能同时出现在最终的LCS里面</strong>了，所以我们考虑另外的两种情况<code>dp[i][j-1]</code>和<code>dp[i-1][j]</code>取个最大值</p></li></ul><p>除此之外，还有一个值得注意的小细节，这里循环都是从1开始的，这样就不用处理初始值，如果从0开始的话，处理初始情况（i，j=0的情况）会比较麻烦……</p><p><strong>解法二</strong></p><p>2019.10.19重写了一种记忆化递归的方法，没有dp快，但是思路其实是类似的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(text2==<span class="keyword">null</span> || text1==<span class="keyword">null</span> || text1.length()<=<span class="number">0</span> ||text2.length()<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> len1=text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2=text2.length();</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[len1][len2];</span><br><span class="line">    <span class="keyword">return</span> lcs(text1,len1-<span class="number">1</span>,text2,len2-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//lcs定义: 求text1[0,a]和text2[0,b]的最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String text1, <span class="keyword">int</span> a,String text2,<span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(a==-<span class="number">1</span> || b==-<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[a][b]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[a][b];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (text1.charAt(a)==text2.charAt(b)) {</span><br><span class="line">        cache[a][b]=lcs(text1,a-<span class="number">1</span>,text2,b-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> cache[a][b];</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        cache[a][b]=Math.max(lcs(text1,a-<span class="number">1</span>,text2,b),lcs(text1,a,text2,b-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> cache[a][b];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p>自顶向下的最小路径和为 <code>11</code>（即，2 + 3 + 5 + 1 = 11）。</p><p><strong>说明：</strong></p><p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分</p><p><strong>解法一</strong></p><p>二维dp，emmm，一开始写成贪心了。。贪心明显是错的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//dp做法 O(N^2)空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List<list<integer>> triangle)</list<integer></span> </span>{</span><br><span class="line">    <span class="keyword">int</span> rows=triangle.size();</span><br><span class="line">    <span class="comment">//dp[i][j]代表的是每i层第j个元素到最底层的最短距离</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[rows+<span class="number">1</span>][rows+<span class="number">1</span>]; <span class="comment">//row+1</span></span><br><span class="line">    <span class="comment">/*for (int i=0;i<triangle.get(rows-1).size();i++) {< span></triangle.get(rows-1).size();i++)></span><br><span class="line"><span class="comment">        //给最后一行赋初始值</span></span><br><span class="line"><span class="comment">        dp[rows-1][i]=triangle.get(rows-1).get(i);</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    for (int i=rows-2;i>=0;i--) {</span></span><br><span class="line"><span class="comment">        for (int j=0;j<triangle.get(i).size();j++) {< span></triangle.get(i).size();j++)></span><br><span class="line"><span class="comment">            //核心递推式 dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle(i)(j)</span></span><br><span class="line"><span class="comment">            dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+triangle.get(i).get(j);</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line">    <span class="comment">//直接从最后一行开始,这样就不用手动给最后一行赋初始值了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=rows-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<triangle.get(i).size();j++) {< span><br><span class="line">            <span class="comment">//核心递推式 dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle(i)(j)</span></span><br><span class="line">            dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br></triangle.get(i).size();j++)></span></span></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>记忆化递归，也很快</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal2</span><span class="params">(List<list<integer>> triangle)</list<integer></span> </span>{</span><br><span class="line">    <span class="comment">//用Integer比较好,方便判空</span></span><br><span class="line">    Integer [][] cache=<span class="keyword">new</span> Integer[triangle.size()][triangle.size()];</span><br><span class="line">    <span class="keyword">return</span> minimumTotal(triangle,<span class="number">0</span>,<span class="number">0</span>,cache);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List<list<integer>> triangle,<span class="keyword">int</span> cen,<span class="keyword">int</span> index,Integer[][]cache)</list<integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cache[cen][index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[cen][index];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cen==triangle.size()-<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> triangle.get(cen).get(index);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left=minimumTotal(triangle,cen+<span class="number">1</span>,index,cache);</span><br><span class="line">    <span class="keyword">int</span> right=minimumTotal(triangle,cen+<span class="number">1</span>,index+<span class="number">1</span>,cache);</span><br><span class="line">    <span class="keyword">return</span> cache[cen][index]=triangle.get(cen).get(index)+(left<right?left:right);< span><br><span class="line">}</span><br></right?left:right);<></span></pre></td></tr></tbody></table></figure></div><p><strong>解法三</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//dp O(N)空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List<list<integer>> triangle)</list<integer></span> </span>{</span><br><span class="line">    <span class="keyword">int</span> rows=triangle.size();</span><br><span class="line">    <span class="comment">//dp[i]代表的是每一层第i个元素到最底层的最短距离</span></span><br><span class="line">    <span class="comment">//上面二维dp实际上也只和下一层的状态有关,所以我们可以重复的使用这个数组保存每一层的状态</span></span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[rows+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=rows-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<triangle.get(i).size();j++) {< span><br><span class="line">            <span class="comment">//到这里其实Math.min()里面的都是上一次循环的结果</span></span><br><span class="line">            <span class="comment">//也就是下一层的,对应当前j位置左右两个相邻节点的最小距离</span></span><br><span class="line">            dp[j]=Math.min(dp[j+<span class="number">1</span>],dp[j])+triangle.get(i).get(j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">}</span><br></triangle.get(i).size();j++)></span></pre></td></tr></tbody></table></figure></div><p>O(N)空间复杂度，只和下面那一层的每一个元素的dp[i]有关，所以可以直接改成一维dp</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你<strong>最多只允许完成一笔交易</strong>（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span>-<span class="number">1</span> = <span class="number">5</span>  ，注意利润不能是 <span class="number">7</span>-<span class="number">1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>非动态规划的思路，还是挺简单的，求个最大的差值就ok，因为只能买一次</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//非递归的思路</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> min=Integer.MAX_VALUE,max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<prices.length;i++) {< span><br><span class="line">        <span class="comment">//当天价格减去 *之前* 价格最低的买入时机</span></span><br><span class="line">        max=Math.max(max,prices[i]-min);</span><br><span class="line">        <span class="comment">//统计价格最低的买入时机</span></span><br><span class="line">        min=Math.min(min,prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>既然是动态规划的题，自然得写个动态规划的版本</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]= -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实改成一维的就和上面的一模一样了</p><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。<strong>你可以尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>正常的思路（非动态规划），注意审题，上面的只能买一次，这里是不限制次数的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (prices[i]>prices[i-<span class="number">1</span>]) {</span><br><span class="line">            ans+=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这里的代码还是很有迷惑性的，实际上分了三种情况，有两种合并了</p><blockquote><p><strong>单独交易日</strong>：明天比今天价格高，今天买，明天卖</p><p><strong>连续上涨交易日</strong>：开始的第一天买 , 涨停的最后一天卖最有利，或者也可以转换成说<code>除了第一天，每天都卖了又买</code>，也就是<code>pn-p1 = (p2-p1)+(p3-p2)+....(pn-pn-1)</code>  很自然的就转换成了单独交易日的情况<br><strong>连续下降交易日</strong>：不买卖最有利</p></blockquote><p>如果还是不明白可以看看官方的图</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191017/Wpsvs09EmnmF.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>A->D是一段连续上涨日，<code>D-A的差值</code> 就是A->D各个相邻节点差值之和</p><p><strong>解法二</strong></p><p>我们的主角，动态规划</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//dp的思路</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>第一眼看可能觉得看不懂，熟悉了就知道了，其实都是套路，股票题特有的套路，先考虑题目有几种状态，这题说了不限制次数，那么就不考虑次数的问题，然后剩下的状态就是：那一天，和是否持有股票，所以我们用一个二维的数组来表述这两种状态 比如<code>dp[i][0]</code> 则代表第i天不持有股票的最大收益，<code>dp[i][1]</code>则代表第i天持有股票的最大收益，然后我们再看看状态转换的过程</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191017/J7tfvKDvqC2b.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>其实无非就是这两个状态之间的转换，然后根据这个状态转换的过程就可以很轻易的写出我们的状态转换方程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br></pre></td></tr></tbody></table></figure></div><p>不过这里其实也很容易就可以改成一唯的dp，空间复杂度变为O(1)，因为当天的最大收益只和前一天的最大收益相关，两个变量就是足够表示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> hlod=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> empty=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        <span class="comment">//保存前一天的状态</span></span><br><span class="line">        <span class="keyword">int</span> temp=empty;</span><br><span class="line">        empty=Math.max(empty,hlod+prices[i]);</span><br><span class="line">        hlod=Math.max(hlod,temp-prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> empty;</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>这里我又发现了leetcode的case有问题，我开始没有缓存前一天的empty值，直接将empty带到hold去了，结果还过了。。。不过我懒得去想case了，反正提交了leecode也不会理我😅</p><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></h2><p>给定一个整数数组 <code>prices</code>，其中第 i 个元素代表了第 i 天的股票价格 ，非负整数 fee 代表了交易股票的手续费用</p><p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: prices = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>], fee = <span class="number">2</span></span><br><span class="line">输出: <span class="number">8</span></span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">在此处卖出 prices[<span class="number">3</span>] = <span class="number">8</span></span><br><span class="line">在此处买入 prices[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">在此处卖出 prices[<span class="number">5</span>] = <span class="number">9</span></span><br><span class="line">总利润: ((<span class="number">8</span> - <span class="number">1</span>) - <span class="number">2</span>) + ((<span class="number">9</span> - <span class="number">4</span>) - <span class="number">2</span>) = <span class="number">8</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意:</strong></p><ul><li><code>0 < prices.length <= 50000.</code></li><li><code>0 < prices[i] < 50000.</code></li><li><code>0 <= fee < 50000.</code></li></ul><p><strong>解法一</strong></p><p>我起了，一枪秒了，有什么好说的？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">        dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>改为O(1)空间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//改为O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> empty=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hold=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> temp=empty;</span><br><span class="line">        empty=Math.max(empty,hold+prices[i]-fee);</span><br><span class="line">        hold=Math.max(hold,temp-prices[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> empty;</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 </p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)</li></ul><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>依然是上面题的升级版，相比上一题又多了个限制条件，加了cd，买卖一次后有一天的cd，当天不能再买</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//dp[i][0] 代表第i天不持有股票的最大利润</span></span><br><span class="line">    <span class="comment">//dp[i][1] 代表第i天持有股票的最大利润</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        <span class="comment">//这些玩意想起还是蛮打脑阔的</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//dp[i][1]=Math.max(i<2?-prices[i]:dp[i-2][0]-prices[i],dp[i-1][1]);</span></span><br><span class="line">        <span class="comment">//这里i<2就是第一次循环，i=1,也就是第二天持有股票，所以肯定是首次买股票，直接初始化为 -prices[1]</span></span><br><span class="line">        <span class="comment">//昨天有股票，或者昨天冷冻前天卖出</span></span><br><span class="line">        dp[i][<span class="number">1</span>]=Math.max(i<<span class="number">2</span>?-prices[<span class="number">1</span>]:dp[i-<span class="number">2</span>][<span class="number">0</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>评论区很多的解法都是用了三个状态数组，相比这种多了一个 冷冻期的最大值，感觉挺迷惑的。。。虽然结果是对的，但是总时感觉别扭，所以我们还是按照上面的思路，用两个状态表示，状态转换图和上面是一样的</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20191017/J7tfvKDvqC2b.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>当天持有股票的最大收益，就是你当天买股票，或者rest啥也不干延续前一天的状态，两者的最大值</p><p>这里和上面不同的就是从<code>不持有股票</code> 到<code>持有股票</code>（也就是买股票）的情况， 因为有冷冻期的存在，<strong>所以你当天买股票的最大值不再是昨天不持有股票的最大值，而是前天不持有股票的最大值</strong></p><p><strong>解法三</strong></p><p>改为空间复杂度O(1)的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span> || prices.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> hold=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> empty=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//前一天买出的最大收益</span></span><br><span class="line">    <span class="keyword">int</span> prePre=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<prices.length;i++) {< span><br><span class="line">        <span class="keyword">int</span> temp=empty;</span><br><span class="line">        empty=Math.max(hold+prices[i],empty);</span><br><span class="line">        hold=Math.max(i<<span class="number">2</span>?-prices[<span class="number">1</span>]:prePre-prices[i],hold);</span><br><span class="line">        <span class="comment">//到这里pre就变成了前一天</span></span><br><span class="line">        prePre=temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> empty;</span><br><span class="line">}</span><br></prices.length;i++)></span></pre></td></tr></tbody></table></figure></div><blockquote><p>看了下评论区还是蛮多争议的，感觉这里根据dp[i-2]转换有点不好理解，然后翻了翻评论区看见了大神的回答</p><p><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></p><p><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code></p><p>添加 “冷冻期” 条件后，买入的前一天是不能卖的，而<code>dp[i-1][0] - prices[i]</code>并不能确保 <code>i-1天不卖出</code>   </p><p>所以进一步拆解<code>dp[i-1][0]</code>， 套用上面的转换方程可以得到</p><p><code>dp[i-1][0] = max(dp[i-2][0], dp[i-2][1] + prices[i-1])</code> </p><p>再带入原式子，则可以得到</p><p><code>dp[i][1] = max(dp[i-1][1], max(dp[i-2][0], dp[i-2][1] + prices[i-1]) - prices[i])</code></p><p>其中<code>dp[i-2][1] + prices[i-1]</code> 代表着 <code>“i-1发生了卖出行为”</code>，有违题意，应予删除，得下式，最终和上面的状态转换方程一致</p><p><code>dp[i][1] = max(dp[i-1][1], max(dp[i-2][0]) - prices[i])</code></p><p>这样一证明就很清楚了</p></blockquote><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h2><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>*<em>示例 1: *</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: </span><br><span class="line">horse -> rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -> rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -> ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line">intention -> inention (删除 <span class="string">'t'</span>)</span><br><span class="line">inention -> enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line">enention -> exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line">exention -> exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line">exection -> execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>很经典的动态规划的问题，做之前看了动态规划的思路，然后很快写出了递归的解法。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer[][] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>{</span><br><span class="line">    cache=<span class="keyword">new</span> Integer[word1.length()][word2.length()];</span><br><span class="line">    <span class="keyword">return</span> minDistance(word1,word1.length()-<span class="number">1</span>,word2,word2.length()-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归的定义: word1[0,idx1] 和 word2[0,idx2] 的最短编辑距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1,<span class="keyword">int</span> idx1,String word2,<span class="keyword">int</span> idx2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (idx1<<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> idx2+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (idx2<<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> idx1+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[idx1][idx2]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[idx1][idx2];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (word1.charAt(idx1) == word2.charAt(idx2)) {</span><br><span class="line">        <span class="keyword">return</span> cache[idx1][idx2]=minDistance(word1,idx1-<span class="number">1</span>,word2,idx2-<span class="number">1</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> cache[idx1][idx2]=<span class="number">1</span>+Math.min(minDistance(word1,idx1-<span class="number">1</span>,word2,idx2),Math.min(minDistance(word1,idx1,word2,idx2-<span class="number">1</span>),minDistance(word1,idx1-<span class="number">1</span>,word2,idx2-<span class="number">1</span>)));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>核心的递推公式就是 </p><p><code>minDis(i,j)=minDis(i-1,j-1)  word1[i]==word2[j]</code></p><p><code>minDis(i,j)=min(minDis(i-1,j),minDis(i,j-1),minDis(i-1,j-1))+1  word1[i]!=word2[j]</code></p><p>第一个公式好说，相等时候就别动，延续之前的状态，关键是第二个，不相等的时候，简单来说就是求对应的三种操作增，删，改的最小值，但是这里，第二种删的操作，这里要想清楚，其实word1删除一个其实就等价于word2增加一个，所以是<code>minDis(i,j-1)</code>，虽然题目说的是从word1转换为word2，但是其实结果都是一样的，这个转换的过程其实是可逆的</p><p><strong>解法二</strong></p><p>标准的动态规划写法，感觉还是上面的记忆化递归好写，动态规划要考虑的边界比递归要多</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance2</span><span class="params">(String word1, String word2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (word1.length()<=<span class="number">0</span> || word2.length()<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> word2.length()==<span class="number">0</span>?word1.length():word2.length();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=word2.length();i++) {</span><br><span class="line">        dp[<span class="number">0</span>][i]=i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=word1.length();i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i<=word1.length();i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<=word2.length();j++) {</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>)) {</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i][j]=<span class="number">1</span>+Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">1269. 停在原地的方案数</a></h2><p>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。</p><p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p><p>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。</p><p>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：steps = <span class="number">3</span>, arrLen = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="number">3</span> 步后，总共有 <span class="number">4</span> 种不同的方法可以停在索引 <span class="number">0</span> 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例  2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：steps = <span class="number">2</span>, arrLen = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">2</span> 步后，总共有 <span class="number">2</span> 种不同的方法可以停在索引 <span class="number">0</span> 处。</span><br><span class="line">向右，向左</span><br><span class="line">不动，不动</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：steps = <span class="number">4</span>, arrLen = <span class="number">2</span></span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= steps <= 500</code></li><li><code>1 <= arrLen <= 10^6</code></li></ul><p><strong>解法一</strong></p><p>11.24 的周赛最后一题，很可惜没做出来。。。要是把这题放在第三题我可能就做出来了。。。。还是菜啊</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> mod=<span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">long</span>[][] dp=<span class="keyword">new</span> <span class="keyword">long</span>[steps+<span class="number">1</span>][steps+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=steps;i++) {</span><br><span class="line">        <span class="comment">//i步能达到的最大距离就是i,所以我们这里取一个最小值</span></span><br><span class="line">        <span class="keyword">int</span> k=Math.min(i,arrLen-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<=k;j++) {</span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">0</span>) {</span><br><span class="line">                dp[i][j]=(dp[i-<span class="number">1</span>][j+<span class="number">1</span>]+dp[i-<span class="number">1</span>][j])%mod;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (j<k) {< span><br><span class="line">                dp[i][j]=(dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j+<span class="number">1</span>]+dp[i-<span class="number">1</span>][j])%mod;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i][j]=(dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j])%mod;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)dp[steps][<span class="number">0</span>];</span><br><span class="line">}</span><br></k)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>我比较喜欢的记忆化递归😁，10ms甚至比上面还快一点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mod=<span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cache</span></span><br><span class="line">Long[][] cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> maxIndex=Math.min(steps,arrLen-<span class="number">1</span>);</span><br><span class="line">    cache=<span class="keyword">new</span> Long[steps+<span class="number">1</span>][maxIndex+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)dfs(steps,<span class="number">0</span>,maxIndex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> index,<span class="keyword">int</span> maxIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (steps==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> index==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index<<span class="number">0</span> || index > maxIndex )  {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache[steps][index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[steps][index];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//steps一直在递减,steps最多走到steps位置</span></span><br><span class="line">    <span class="comment">//为了节约时间可以在这里优化下</span></span><br><span class="line">    maxIndex=Math.min(steps,maxIndex);</span><br><span class="line">    <span class="comment">//不动</span></span><br><span class="line">    <span class="keyword">long</span> res=dfs(steps-<span class="number">1</span>,index,maxIndex);</span><br><span class="line">    <span class="comment">//向右</span></span><br><span class="line">    res+=dfs(steps-<span class="number">1</span>,index-<span class="number">1</span>,maxIndex);</span><br><span class="line">    <span class="comment">//向左</span></span><br><span class="line">    res+=dfs(steps-<span class="number">1</span>,index+<span class="number">1</span>,maxIndex);</span><br><span class="line">    <span class="keyword">return</span> cache[steps][index]=res%mod;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152. 乘积最大子序列"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子序列</a></h2><p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [-<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 结果不能为 <span class="number">2</span>, 因为 [-<span class="number">2</span>,-<span class="number">1</span>] 不是子数组。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>自己最开始自己写出来的脑瘫dp</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp1=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span>[] dp2=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    dp1[<span class="number">0</span>]=nums[<span class="number">0</span>]>=<span class="number">0</span>?nums[<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    dp2[<span class="number">0</span>]=nums[<span class="number">0</span>]>=<span class="number">0</span>?<span class="number">0</span>:nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max=nums[<span class="number">0</span>]><span class="number">0</span>?dp1[<span class="number">0</span>]:dp2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++){< span><br><span class="line">        <span class="keyword">if</span> (nums[i]><span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i-<span class="number">1</span>]<<span class="number">0</span>) {</span><br><span class="line">                dp1[i]=dp1[i-<span class="number">1</span>]!=<span class="number">0</span>?nums[i]*dp1[i-<span class="number">1</span>]:nums[i];</span><br><span class="line">                dp2[i]=dp2[i-<span class="number">1</span>]*nums[i];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(nums[i-<span class="number">1</span>]><span class="number">0</span>){</span><br><span class="line">                dp1[i]=dp1[i-<span class="number">1</span>]*nums[i];</span><br><span class="line">                dp2[i]=dp2[i-<span class="number">1</span>]!=<span class="number">0</span>?nums[i]*dp2[i-<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp1[i]=nums[i];</span><br><span class="line">                dp2[i]=<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (nums[i]<<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i-<span class="number">1</span>]<<span class="number">0</span>) {</span><br><span class="line">                dp1[i]=dp2[i-<span class="number">1</span>]*nums[i];</span><br><span class="line">                dp2[i]=dp1[i-<span class="number">1</span>]!=<span class="number">0</span>?dp1[i-<span class="number">1</span>]*nums[i]:nums[i];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(nums[i-<span class="number">1</span>]><span class="number">0</span>){</span><br><span class="line">                dp1[i]=dp1[i-<span class="number">1</span>]!=<span class="number">0</span>?nums[i]*dp2[i-<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">                dp2[i]=dp1[i-<span class="number">1</span>]*nums[i];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp1[i]=<span class="number">0</span>;</span><br><span class="line">                dp2[i]=nums[i];</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            dp1[i]=<span class="number">0</span>;</span><br><span class="line">            dp2[i]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//System.out.println(dp1[i]+","+dp2[i]);</span></span><br><span class="line">        max=Math.max(max,dp1[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    //     -2  2  3   -4        </span></span><br><span class="line"><span class="comment">    //dp1:  0  2  6   48        </span></span><br><span class="line"><span class="comment">    //dp2: -2 -4 -12 -24 </span></span><br><span class="line"><span class="comment">    //</span></span><br><span class="line"><span class="comment">    // 2 -5   -2  -4   3</span></span><br><span class="line"><span class="comment">    // 2  0   20   8   24</span></span><br><span class="line"><span class="comment">    // 0 -10  -2  -80 -240</span></span><br><span class="line"><span class="comment">*/</span></span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><p>不想解释太多，虽然过了，但是确实有点蠢</p><p><strong>解法二</strong></p><p><code>max[i],min[i]</code> 代表的就是以<code>nums[i]</code> 结尾的<strong>最大</strong>乘积和<strong>最小</strong>乘积</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] min=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span>[] max=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> res=max[<span class="number">0</span>]=min[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        max[i]=Math.max(nums[i]*min[i-<span class="number">1</span>],Math.max(nums[i],nums[i]*max[i-<span class="number">1</span>]));</span><br><span class="line">        min[i]=Math.min(nums[i]*min[i-<span class="number">1</span>],Math.min(nums[i],nums[i]*max[i-<span class="number">1</span>]));</span><br><span class="line">        res=Math.max(res,max[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>为什么要记录最小乘积相信不需要我多说了吧，其实只要想清楚一点就ok，每个位置的<code>max[i]</code>其实只有三种来源（纸上写写就明白了）</p><ul><li><p><code>nums[i] >= 0</code> 并且<code>max[i-1] > 0</code>，<code>max[i] = max[i-1] * nums[i]</code></p></li><li><p><code>nums[i] >= 0</code> 并且<code>max[i-1] < 0</code>，此时如果和前边的数累乘的话，会变成负数，所以<code>max[i] = nums[i]</code></p></li><li><p><code>nums[i] < 0</code>，如果是负数就不应该再和前面<code>max[i]</code>相乘，而是考虑<code>min[i]</code></p><ul><li><code>当min[i-1] < 0，max[i] = min[i-1] * nums[i]</code></li><li><code>当min[i-1] >= 0，max[i] = nums[i]</code></li></ul><p>然后我们直接求这三种情况的最大值就ok了，不用考虑那些分支，我上面的第一种解法其实就是考虑了所有分支，结果才写出了那样的dp， <code>min[i]</code> 的过程和上面一样，就不赘述</p></li></ul><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>递推公式：<code>dp[i][j]=1+min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])</code>  嗯，想不到就很可惜</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//这里+1处理边界</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=m;i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<=n;j++) {</span><br><span class="line">            <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">'1'</span>) {</span><br><span class="line">                dp[i][j]=<span class="number">1</span>+Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]));</span><br><span class="line">                max=Math.max(max,dp[i][j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max*max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题还有个需要注意的地方就是边界的处理，这里实现的代码中<code>dp[i][j]</code> 其实表示的是以 <code>matrix[i-1][j-1]</code> 作为右下角结尾的正方形的最大边长，这样的话就不用考虑上下两条边的边界case，相当于在dp数组上下边界之外又加了一层 0</p><blockquote><p>到这里我也大致明白了一些动态规划的题目的递推写法为都是从1开始了，比如上面的编辑距离</p></blockquote><h2 id="1277-统计全为-1-的正方形子矩阵"><a href="#1277-统计全为-1-的正方形子矩阵" class="headerlink" title="1277. 统计全为 1 的正方形子矩阵"></a><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/" target="_blank" rel="noopener">1277. 统计全为 1 的正方形子矩阵</a></h2><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：matrix =</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释： </span><br><span class="line">边长为 <span class="number">1</span> 的正方形有 <span class="number">10</span> 个。</span><br><span class="line">边长为 <span class="number">2</span> 的正方形有 <span class="number">4</span> 个。</span><br><span class="line">边长为 <span class="number">3</span> 的正方形有 <span class="number">1</span> 个。</span><br><span class="line">正方形的总数 = <span class="number">10</span> + <span class="number">4</span> + <span class="number">1</span> = <span class="number">15</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">边长为 <span class="number">1</span> 的正方形有 <span class="number">6</span> 个。 </span><br><span class="line">边长为 <span class="number">2</span> 的正方形有 <span class="number">1</span> 个。</span><br><span class="line">正方形的总数 = <span class="number">6</span> + <span class="number">1</span> = <span class="number">7</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li><code>1 <= arr.length <= 300</code></li><li><code>1 <= arr[0].length <= 300</code></li><li><code>0 <= arr[i][j] <= 1</code></li></ul><p><strong>解法一</strong></p><p>12.1的周赛题目，其实先做的上面的最大正方形，然后发现这一题和上面的一样。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> [][]dp=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<=m;i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j<=n;j++) {</span><br><span class="line">            <span class="keyword">if</span> (matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="number">1</span>) {</span><br><span class="line">                dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]))+<span class="number">1</span>;</span><br><span class="line">                res+=dp[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>一摸一样，理解一点就ok，<strong>以<code>matrix[i][j]</code> 为右下角的最大正方形的边长，就是以这个点为右下角的正方形的数量！！！</strong></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机（二）</title>
      <link href="/2019/08/17/shen-ru-li-jie-java-xu-ni-ji-er/"/>
      <url>/2019/08/17/shen-ru-li-jie-java-xu-ni-ji-er/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><blockquote><p>这一篇主要讲JVM的类加载机制，本来很久之前就写了，但是这几天又重新学习了一遍，纠正了之前很多错误的观点，然后又补充了很多东西</p></blockquote><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p><strong>前言：</strong></p><p>​    在Java语言中，类型的加载，连接和初始化过程都是在<strong>运行期间</strong>完成的，这与那些在<strong>编译期间</strong>需要进行链接工作的语言（C/C++）不同，这样毫无疑问会增加类加载的性能开销，但是会为Java提供高度的灵活性，Java天生可以动态扩展的就是依赖于运行时期<strong>动态加载和动态链接</strong>这个特点实现的，比如一个接口，完全可以在运行时期动态的指定其具体的实现类。又或者用户可以通过类加载器让一个本地的引用运行时从其他地方（网络等）加载一个二进制的流作为程序代码的一部分。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190418/em4YNNmXXmho.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="①加载"><a href="#①加载" class="headerlink" title="①加载"></a>①加载</h3><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象</li></ul><h4 id="类加载的最终产物"><a href="#类加载的最终产物" class="headerlink" title="类加载的最终产物"></a>类加载的最终产物</h4><blockquote><p>类加载的最终产物是位于堆中的<code>Class</code>对象</p></blockquote><p>《深入理解Java虚拟机》里面介绍的JVM内存结构(p39)</p><p><img alt="JVM内存结构" data-src="http://static.imlgw.top///20190417/yk2bzxILsCpL.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>堆（Heap）</strong>：最大的一块区域，线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。</p><blockquote><p>The Java Virtual Machine has a <em>heap</em> that is <code>shared</code> among <code>all</code> Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.</p><p>The heap is created on virtual machine <code>start-up</code>. Heap storage for objects is reclaimed by an automatic storage management system (known as a <em>garbage collector(GC)</em>); </p><p>摘自  <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3" target="_blank" rel="noopener">官方文档</a></p></blockquote><p><strong>方法区（Method Area）</strong>：又称为<code>非堆</code>，线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。</p><blockquote><p>The Java Virtual Machine has a <em>method area</em> that is <code>shared</code> among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the <strong>run-time constant pool</strong>, <strong>field</strong> and <strong>method data</strong>, and the code for methods and constructors, including the special methods (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>) used in class and instance initialization and interface initialization.</p></blockquote><p><strong>运行时常量池(run-time constant pool)</strong>：</p><p>是方法区的一部分，用于存放编译期生成的各种字面量”123”，”LGW” 等字符串常量池，和符号引用。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，运行期间也能将新的常量放入池中。如String.intern()方法。</p><p><strong>方法栈（JVM Stack）</strong>：</p><p>线程私有。存储局部变量表、操作栈、动态链接、方法出口，<code>对象指针</code>。</p><p><strong>本地方法栈（Native Method Stack）</strong>：</p><p>线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。</p><p><strong>程序计数器（Program Counter Register）</strong>：</p><p>线程私有，它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。</p><h4 id="加载类的方式"><a href="#加载类的方式" class="headerlink" title="加载类的方式"></a>加载类的方式</h4><ul><li>本地磁盘 classpath</li><li>内存中加载 ，动态代理？RPC?</li><li>通过网络加载.class</li><li>从zip，jar中加载</li><li>数据库中提取.class</li><li>动态编译</li></ul><h3 id="②连接"><a href="#②连接" class="headerlink" title="②连接:"></a>②连接:</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>文件格式验证</strong></p><ul><li><p>是否以魔数<code>0xCAFEBABE</code>（咖啡宝贝）开头</p></li><li><p>主、次版本号是否在当前虚拟机处理范围之内</p></li><li><p>常量池中的常量中是否有不被支持的常量类型（检查常量tag标志）</p></li><li><p>…..</p></li></ul><p><strong>元数据验证</strong></p><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求</p><p><strong>字节码验证</strong></p><p>主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</p><p>由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在 JDK 1.6 之后的 Javac 编译器和 Java 虚拟机中进行了一项优化，给方法体的 Code 属性的属性表中增加了一项名为” StackMapTable” 的属性, 只需要检查StackMapTable属性中的记录是否合法皆可以了</p><p><strong>符号引用验证</strong></p><p>符号引用的校验发生在虚拟机将<code>符号引用</code>转化为<code>直接引用</code>的时候，这个转化动作将在连接的第三阶段—-<strong>解析</strong>阶段中发生，通常需要校验以下内容：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述以及简单名称说描述的方法和字段。</li><li>符号引用中的类，字段，方法的访问性是否可以被当前类访问</li><li>…….</li></ul><p>如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为类的<strong>静态变量</strong>分配内存，并初始化为默认值</p><table><thead><tr><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>boolean</td><td>false</td></tr><tr><td>char</td><td>‘/u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>🎯 当然并不是所有情况下都会初始化为零值，如果字段表的属性中有<code>ConstantValue</code> ，准备阶段就会直接初始化为这个这个<code>ConstantValue</code>属性的值</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将<strong>常量池</strong>内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。</p><ul><li><strong>符号引用：</strong> 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候能无歧义的定位到目标中就行。</li><li><strong>直接引用：</strong> 直接引用可以是直接指向目标的指针，相对偏移量或者一个能间接定位到目标的句柄。</li></ul><p>除 <code>invokedynamic</code>(动态语言支持) 指令以外，虚拟机实现可以对第一次解析的结果进行缓存。</p><p>解析动作主要针对类或接口、字段解析、类方法解析、接口方法解析、方法类型解析、方法句柄解析和调用点限定符 7 类符号引用进行。</p><p>关于这个也可以看看R大的回答 <a href="https://www.zhihu.com/question/30300585/answer/51335493" target="_blank" rel="noopener">JVM符号引用转换直接引用的过程 </a>( 吹爆我R大 😁</p><h3 id="③初始化："><a href="#③初始化：" class="headerlink" title="③初始化："></a>③初始化：</h3><p>初始化阶段就是执行<code>类构造器<clinit></clinit></code>方法的过程</p><h4 id="类构造器-lt-client-gt"><a href="#类构造器-lt-client-gt" class="headerlink" title="类构造器<client>"></a>类构造器<client></client></h4><p>💡<code><clinit></clinit></code>方法是由编译器自动收集类中的所有<strong>类变量的赋值</strong>动作和<strong>静态语句块</strong>（static块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定的</strong>，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块<strong>可以赋值</strong>，但是<strong>不能访问</strong>（比如print）</p><p>💡 和<strong>实例构造器</strong><code><init></init></code> 不同，不需要显式的去调用父类的构造器，虚拟机会保证子类的<code><clinit></clinit></code>方法执行之前，父类的<code><clinit></clinit></code>方法已经执行完毕，因此虚拟机中第一个被执行的<code><clinit></clinit></code> 一定是Object类</p><p>💡<code><clinit></clinit></code> 方法对于类或者接口来说并不是必须的，如果类中没有静态语句块也没有静态变量的<strong>赋值</strong>操作，那么编译器可以不为这个类生成<code><clinit></clinit></code> 方法</p><p>💡 对于接口，不能使用static块，但是可以有静态变量的赋值操作。子类接口的<code><clinit></clinit></code>方法调用并不保证父接口的<code><clinit></clinit></code>方法被先调用，只有用到父接口的静态变量的时候，父接口<code><clinit></clinit></code>方法才会被调用。接口的实现类在初始化时也一样不会执行接口的<code><clinit></clinit></code>方法。</p><p>💡 虚拟机会保证一个类的<code><clinit></clinit></code>方法在多线程环境中被正确地加锁、同步。如果一个线程的<code><clinit></clinit></code>方法调用时间过长，就可能造成多个线程阻塞。Demo如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitThreadTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(()-><span class="keyword">new</span> SimpleObj()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-><span class="keyword">new</span> SimpleObj()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-><span class="keyword">new</span> SimpleObj()).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleObj</span></span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean init=<span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" i will be init"</span>);</span><br><span class="line">            <span class="keyword">while</span> (init.get()){</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"i am finished"</span>);</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="为类的静态变量赋予正确的初始值"><a href="#为类的静态变量赋予正确的初始值" class="headerlink" title="为类的静态变量赋予正确的初始值"></a>为类的静态变量赋予正确的初始值</h4><p>下面这个Demo很经典，可以帮助我们理解类加载的过程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon ins=<span class="keyword">new</span> SingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span></span>{</span><br><span class="line">        x++;y++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getIns</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleTon singleTon=getIns();</span><br><span class="line">        System.out.println(singleTon.x);</span><br><span class="line">        System.out.println(singleTon.y);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如果不熟悉类加载的过程可能一眼就觉得应该是（1，1），其实不然，结合上面的加载过程分析</p><p>🔺 首先加载连接，然后执行准备工作，在执行完<strong>准备阶段</strong>工作后三个静态变量都有了<strong>默认的初始值</strong>，然后进入初始化阶段</p><p>🔺 <code><clinit></clinit></code>初始化阶段会按顺序<strong>从上往下</strong>依次赋予正确的初始值，所以<strong>先执行</strong>了<code>new Singleton()</code>给<code>ins</code>赋初始值，会调用它的构造器，然后x，y都++变为1，<strong>再然后</strong>就会给x，y赋予正确的初始值，x初始值为0，而y没有初始值所以就是（0，1）</p><h3 id="Class对象在哪里？"><a href="#Class对象在哪里？" class="headerlink" title="Class对象在哪里？"></a>Class对象在哪里？</h3><p>先说结论，Class对象和其他普通的Java对象一样都是存放在堆中的。</p><p>存放在方法区的是类的元数据(InstanceKlass，包括类的常量池( constant pool)  ，域(Field)信息  ，方法(Method)信息 ，除了常量外的所有静态(static)变量 等)，<code>java.lang.Class实例</code>并不负责记录真正的类元数据，而只是对VM内部的<code>InstanceKlass</code>对象的一个包装供Java的反射访问用，在《深入理解Java虚拟机》一书里面说的存放在方法区中应该是有问题的。</p><p><strong>类(静态)变量存放在哪里</strong></p><p>从JDK 1.3到JDK 6的HotSpot VM，静态变量保存在类的元数据（InstanceKlass）的末尾(永久代)。而从JDK 7开始的HotSpot VM，静态变量则是保存在类的Java镜像（java.lang.Class实例）的末尾，也就是堆中</p><p>参考 R大 <a href="https://www.zhihu.com/question/50258991" target="_blank" rel="noopener">知乎回答</a> </p><h2 id="Java程序对类的使用方式"><a href="#Java程序对类的使用方式" class="headerlink" title="Java程序对类的使用方式"></a>Java程序对类的使用方式</h2><p>所有的java虚拟机实现必须在每个类或接口被java程序<strong>首次主动使用</strong>时才<strong>初始化</strong>它们</p><h3 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h3><ul><li>创建类的实例（new）</li><li>对某个类或接口的静态变量进行读写（getstatic，putstatic）</li><li>调用类的静态方法（invokestatic）</li><li>反射某个类 （Class.forName()也可以设置不初始化类）</li><li>初始化子类时会先初始化父类</li><li>启动类 java HelloWorld  包含main函数的类</li><li>Jdk1.7的动态语言支持</li></ul><h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p>除了上面 7 个之外，其它的都是被动使用，<strong>不会初始化类</strong>，下面的Demo有几个很容易出错的的例子</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader_study.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassActiveUse</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"main is init"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//System.out.println(Obj.t);</span></span><br><span class="line">        <span class="comment">//Obj.getObj();</span></span><br><span class="line">        <span class="comment">//Class.forName("classloader_study.Obj");</span></span><br><span class="line">        <span class="comment">//System.out.println(ObjChild.age);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父类会被初始化 通过子类调用父类的静态变量，子类不会初始化但是会被加载 </span></span><br><span class="line">        <span class="comment">//1. System.out.println(ObjChild.n);</span></span><br><span class="line">        <span class="comment">//不会初始化 定义应用数组也不会初始化类，但是会加载类</span></span><br><span class="line">        <span class="comment">//2. Obj [] arrays=new Obj[10]; </span></span><br><span class="line">        <span class="comment">//不会初始化 常量会在编译期间放到常量池中不会初始化类也不会加载，子类加载也一样</span></span><br><span class="line">        <span class="comment">//3. System.out.println(Obj.t); </span></span><br><span class="line">        <span class="comment">//Obj会被初始化   final修饰的复杂化类型再编译期间无法计算得到，会初始化类</span></span><br><span class="line">        <span class="comment">//4. System.out.println(Obj.x); </span></span><br><span class="line">        <span class="comment">// 类加载器去加载</span></span><br><span class="line">        <span class="comment">//5. ClassLoader.loadClass();</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> t=<span class="number">10</span>;  <span class="comment">//编译期间就已经确定了就是10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n=<span class="number">111</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> x=<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>); <span class="comment">//值不是常量，运行期间才会确定</span></span><br><span class="line">    <span class="keyword">static</span> { </span><br><span class="line">        System.out.println(<span class="string">"Obj is init"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getObj</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"NULL"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjChild</span> <span class="keyword">extends</span> <span class="title">Obj</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Child is init"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span></span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>⚡new 一个Obj数组的时候，<strong>会加载</strong>Obj类，<strong>不会初始化</strong>Obj对象，但是会导致另一个类的初始化: <code>Lclassloader_study.misc.Obj</code>  这个类就代表了一个元素类型为Obj的一维数组，数组中应有的属性length和方法clone()都是在这个类实现的，这个类是由JVM在运行期间动态的为我们生成的，这个动作由<code>anewarray</code> 指令触发，而基本类型的数组由 <code>newarray</code> 指令触发。</p><p>⚡ final修饰的常量会在<strong>编译期间</strong>就放到调用这个变量的方法的类的常量池中，既不会加载也不会初始化，这一点可以通过反编译<code>ClassActiveUse</code> 看的到，两个类不存在任何关系了，甚至可以在编译完成后<code>将Obj的class文件删掉</code>仍然可以执行，但是后面的另一个final常量很明显在<strong>编译期间无法确定值</strong>，只有在运行期间才能回去到值，所以会加载并初始化类</p><p>⚡ 对接口的初始化和对类的初始化有一点不同，接口也有初始化过程，接口和类真正有区别是在上面主动使用的第5点，在<strong>子接口被加载的时候并不要求其父接口全部完成了初始化</strong>，只有在真正使用到父接口的时候才会初始化，这一点可以参考前文的 <a href="#③初始化：">类构造器部分</a></p><blockquote><p><code>-XX:+TraceClassLoading</code> 可以用来追踪类的加载信息并且打印出来</p></blockquote><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p><strong>如果直接使用句柄访问</strong>，java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象数据与类型数据各自的具体地址信息，如下图所示。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190418/FRA9GB31iiXH.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>如果使用直接指针访问</strong>，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如下图所示，每个对象都有一个自己Class对象的引用(<code>getClass</code>)</p><p><img alt="mark" data-src="http://static.imlgw.top///20190418/1OtoI6wkivdz.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。HotSpot虚拟机使用的是直接指针访问的方式。句柄来访问的情况也十分常见。</p><h2 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>虚拟机设计团队把加载阶段中的 <code>“通过一个类的全限定名来获取描述此类的二进制字节流”</code> 这个动作被放到Java虚拟机外部去实现，以便于让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为 <code>“类加载器”</code></p></blockquote><p> 类加载器并不需要等到某个类被 “首次使用” 时才加载它，这一点从前面讲解的 <a href="#被动使用">被动使用的例子</a> 哪里就看得出来</p><p>JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载它，如果在预先加载的过程中遇到了class文件缺失或者存在错误，类加载器必须在程序<strong>首次主动使用</strong>该类时才报告错误（LinkageError错误）</p><p> 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p><img alt="JVM类加载器" data-src="http://static.imlgw.top///20190419/pKeI6Bx6lbcX.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>根（Bootstrap）类加载器</strong></p><p>该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承 java.lang.ClassLoader类(c/c++实现的)。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</span><br><span class="line">D:\java\jre\lib\resources.jar;D:\java\jre\lib\rt.jar;D:\java\jre\lib\sunrsasign.jar;D:\java\jre\lib\jsse.jar;D:\java\jre\lib\jce.jar;D:\java\jre\lib\charsets.jar;D:\java\jre\lib\jfr.jar;D:\java\jre\classes</span><br></pre></td></tr></tbody></table></figure></div><p><strong>扩展（Extension）类加载器</strong></p><p>它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre.lib.ext子目录（扩展目录）下加载类库，如果把用户创建的<strong>JAR</strong>文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是 java.lang.ClassLoader类的子类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>)); <span class="comment">//java.ext.dirs属性</span></span><br><span class="line">D:\java\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br></pre></td></tr></tbody></table></figure></div><p><strong>系统（System）类加载器</strong></p><p>也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，它是用户自定义的类加载器的<code>默认父加载器</code>。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">D:\java\jre\lib\charsets.jar;D:\java\jre\lib\deploy.jar;</span><br><span class="line">D:\java\jre\lib\ext\access-bridge-<span class="number">64</span>.jar;</span><br><span class="line">D:\java\jre\lib\ext\cldrdata.jar;</span><br><span class="line">D:\java\jre\lib\ext\dnsns.jar;</span><br><span class="line">D:\java\jre\lib\ext\jaccess.jar;</span><br><span class="line">D:\java\jre\lib\ext\jfxrt.jar;</span><br><span class="line">D:\java\jre\lib\ext\localedata.jar;</span><br><span class="line">D:\java\jre\lib\ext\nashorn.jar;</span><br><span class="line">D:\java\jre\lib\ext\sunec.jar;</span><br><span class="line">D:\java\jre\lib\ext\sunjce_provider.jar;</span><br><span class="line">D:\java\jre\lib\ext\sunmscapi.jar;</span><br><span class="line">D:\java\jre\lib\ext\sunpkcs11.jar;</span><br><span class="line">D:\java\jre\lib\ext\zipfs.jar;</span><br><span class="line">D:\java\jre\lib\javaws.jar;</span><br><span class="line">D:\java\jre\lib\jce.jar;</span><br><span class="line">D:\java\jre\lib\jfr.jar;</span><br><span class="line">D:\java\jre\lib\jfxswt.jar;</span><br><span class="line">D:\java\jre\lib\jsse.jar;</span><br><span class="line">D:\java\jre\lib\management-agent.jar;</span><br><span class="line">D:\java\jre\lib\plugin.jar;</span><br><span class="line">D:\java\jre\lib\resources.jar;</span><br><span class="line">D:\java\jre\lib\rt.jar;</span><br><span class="line">C:\WorkSpace\concurrent_package\out\production\concurrent_package;</span><br><span class="line">C:\JetBrains\IntelliJ IDEA <span class="number">2018.1</span><span class="number">.4</span>\lib\idea_rt.jar</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>其实所谓的父子加载器并不是继承的父子关系，而是包含的关系，子加载器中包含一个父加载器的引用</p></blockquote><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p><strong>先看下JDK的ClassLoader(1.8)源码</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class<!--?--> loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">           <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">           Class<!--?--> c = findLoadedClass(name);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">               <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">               <span class="keyword">try</span> {</span><br><span class="line">                   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">                       c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                   } <span class="keyword">else</span> {</span><br><span class="line">                       <span class="comment">//没有父加载器就交给根加载器</span></span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   }</span><br><span class="line">               } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">                   <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                   <span class="comment">// to find the class.</span></span><br><span class="line">                   <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                   <span class="comment">//需要子类去实现</span></span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (resolve) {</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p>这是ClassLoader类加载类的方法，可以看到中间有一段 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(parent!=<span class="keyword">null</span>){  c = parent.loadClass(name, <span class="keyword">false</span>);}</span><br></pre></td></tr></tbody></table></figure></div><p>这就是<strong>双亲委派机制</strong>的实现，委托父类，让父类去加载，父类(根加载器)没有就会再层层下降如果有一个加载成功就会成功返回，除此之外还调用了一个没有实现的<code>findClass</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class<!--?--> findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>也就是说想自定义类加载器的话就得重写<code>findClass</code>方法，实际上这个<code>findClass</code>才是类加载的核心，真正加载Class文件转换为CLass实例的就是<code>findClass</code>方法， <code>loadClass()</code>只是实现加载的逻辑，比如<strong>双亲委派机制</strong></p><p><strong>实现一个简易的ClassLoader</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line">    <span class="comment">//将字节码放到这个路径下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DIR = <span class="string">"D:\\ClassLoaderTest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String dir = DEFAULT_DIR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDir</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDir</span><span class="params">(String dir)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.dir = dir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassLoaderName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> classLoaderName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xx.xx.xx.xx.xx.AAA</span></span><br><span class="line"><span class="comment">     * xx/xx/xx/xx/xx/.AAA.class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class<!--?--> findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        String classPath = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        File classFile = <span class="keyword">new</span> File(dir, classPath + <span class="string">".class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!classFile.exists()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"The class "</span> + name + <span class="string">" not found under "</span> + dir);</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//字节码文件的字节流</span></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = loadClassBytes(classFile);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"load the class "</span> + name + <span class="string">" failed"</span>);</span><br><span class="line"><span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将文件流转换为字节流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassBytes(File classFile) {</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile)) {</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            }</span><br><span class="line">            baos.flush();</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class，前提是Class文件是合法的。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的需要加载的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"MyObject static is init"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试自定义的ClassLoader</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>{</span><br><span class="line">        MyClassLoader loader=<span class="keyword">new</span> MyClassLoader(<span class="string">"Resolmi"</span>);</span><br><span class="line">        <span class="comment">//Class<!--?--> aClass = loader.loadClass("classloader_study.myClassLoader.MyObject");</span></span><br><span class="line">        Class<!--?--> aClass = Class.forName(<span class="string">"classloader_study.myClassLoader.MyObject"</span>, <span class="keyword">true</span>, loader);</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line"></span><br><span class="line">        Object obj=aClass.newInstance();</span><br><span class="line">        Method hello = aClass.getMethod(<span class="string">"Hello"</span>, <span class="keyword">null</span>);</span><br><span class="line">        hello.invoke(obj, <span class="keyword">new</span> Object[]{});</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里直接<code>loadClass</code>或者<code>Class.forName()</code>都可以，通常我们的forName()都是默认用的<strong>AppClassLoader</strong>也就是系统加载器，但是我们也可以把我们的自定义加载器传递进去。</p><blockquote><p>tip: loadClass 不会初始化类，不属于上面提到的6种主动使用的方式，属于被动使用，Class.forName 第二个参数就是控制是否初始化</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">MyObject <span class="keyword">static</span> is init</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classloader_study</span>.<span class="title">myClassLoader</span>.<span class="title">MyObject</span></span></span><br><span class="line"><span class="class"><span class="title">classloader_study</span>.<span class="title">myClassLoader</span>.<span class="title">MyClassLoader</span>@74<span class="title">a14482</span></span></span><br><span class="line"><span class="class"><span class="title">Hello</span> <span class="title">World</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>如果使用了<code>ide</code>的话，这里很有可能编译器帮你自动编译了，也就是在你的classpath里面已经有字节码文件了，所以就直交给AppClassLoader加载了，所以需要将classpath里面的删掉，将字节码拷贝到你自定义的classLoader指定的目录里面。</p><h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>即在类加载的时候，系统会判断当前类是否已经被加载，如果被加载，就会直接返回可用的类，否则就会尝试加载，在尝试加载时，会先请求双亲处理，如果双亲请求失败，则会自己加载</p><p>这里光看几个内置的ClassLoader可能还不太清晰这里用我们自定义的Loader来试试</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InstantiationException, ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//loader1的加载目录是D:\\ClassLoaderTest（默认的）</span></span><br><span class="line">        MyClassLoader loader1=<span class="keyword">new</span> MyClassLoader(<span class="string">"Resolmi-father"</span>);</span><br><span class="line">        <span class="comment">//设置loader1为loader2的父加载器</span></span><br><span class="line">        MyClassLoader loader2=<span class="keyword">new</span> MyClassLoader(loader1,<span class="string">"Resolmi2-son"</span>);</span><br><span class="line">        <span class="comment">//这个类存放在 D:\\ClassLoaderTest\\classloader_study\\myClassLoader 下面</span></span><br><span class="line">        Class<!--?--> aClass = loader2.loadClass(<span class="string">"classloader_study.myClassLoader.MyObject"</span>);</span><br><span class="line">        <span class="comment">//设置Loader2的加载目录，这是个空目录，下面什么都没有</span></span><br><span class="line">        loader2.setDir(<span class="string">"D:\\ClassLoaderTest2"</span>);</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">        System.out.println(((MyClassLoader)aClass.getClassLoader()).getClassLoaderName());</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>控制台打印如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classloader_study</span>.<span class="title">myClassLoader</span>.<span class="title">MyObject</span></span></span><br><span class="line"><span class="class"><span class="title">classloader_study</span>.<span class="title">myClassLoader</span>.<span class="title">MyClassLoader</span>@74<span class="title">a14482</span></span></span><br><span class="line"><span class="class"><span class="title">Resolmi</span>-<span class="title">father</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>我们用<code>Loader2</code>去加载类，但是这个类的加载目录是空的，然后我们指定<code>Loader2</code> 的父加载器为<code>Loader1</code>而<code>loader1</code> 得加载路径就是要加载得类的路径，可以看到这个这个类最终还是被加载出来了，而且是被 <code>loader1</code>加载出来的，也就是<code>loader2</code>把加载任务委托给了父加载器<code>loader1</code>,然后层层委托再回到<code>loader1</code>，由它加载。</p><p>到这里可能会有疑问，为什么要用双亲委派模式？这样走一圈多慢啊，其实这样做主要有两个方面的原因</p><p>💡 提高系统安全性，使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。对于一些系统核心类，用户自定义的不起作用了，因为都会交给<code>BootStrapLoader</code>去加载，比如自定义了一个java.lang.String的类，然后在加载的时候经过层层委派最后会交给 <code>BootStrapLoader</code>去加载然后返回，所以你自定义的String根本没有加载的机会，这样就避免了用户篡改Java核心的类</p><p>💡 避免重复加载，父Loader已经加载过的类，子Loader就不用再加载了，比如<code>Object类</code>这个类在<code>rt.jar</code>下，所以无论是在哪种环境下，最终都会交给<code>BootStrapClassLoader</code>去加载这个类，加载得到的都是同一个<code>Object类</code>，如果不采用双亲委派机制，让各个Loader自己加载那么可能加载出来的就会有很多个Object类（不是同一个Object类，下面会说到）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br></pre></td></tr></tbody></table></figure></div><h3 id="加密解密类加载器"><a href="#加密解密类加载器" class="headerlink" title="加密解密类加载器"></a>加密解密类加载器</h3><p>本质上和上面的没什么区别，就是多了解密的功能，这里首先用加密工具类加密class</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptUtil</span> </span>{</span><br><span class="line"><span class="comment">//相当于密钥</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ENCRYPT_FACTOR = (<span class="keyword">byte</span>) <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EncryptUtil</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(String source, String target)</span> <span class="keyword">throws</span> FileNotFoundException </span>{</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream in= <span class="keyword">new</span> FileInputStream(source); FileOutputStream out = <span class="keyword">new</span> FileOutputStream(target)) {</span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span> ((data=in.read())!=-<span class="number">1</span>){</span><br><span class="line">                out.write(data^ENCRYPT_FACTOR);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>{</span><br><span class="line">        encrypt(<span class="string">"D:\\ClassLoaderTest\\classloader_study\\myClassLoader\\MyObject.class"</span>,<span class="string">"D:\\ClassLoaderTest\\classloader_study\\myClassLoader\\MyObject2.class"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>然后用加密解密类加载器加载这个类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecryptClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String DEFAULT_DIR = <span class="string">"D:\\ClassLoaderTest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String dir = DEFAULT_DIR;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecryptClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecryptClassLoader</span><span class="params">(ClassLoader parent)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class<!--?--> findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        String classPath = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        File classFile = <span class="keyword">new</span> File(dir, classPath + <span class="string">".class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!classFile.exists()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"没找到对应的类文件 ："</span> + dir);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = loadClassByte(classFile);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"加载失败"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassByte(File classFile) {</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream in = <span class="keyword">new</span> FileInputStream(classFile); ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) {</span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span> ((data=in.read())!=-<span class="number">1</span>){</span><br><span class="line">                <span class="comment">//主要就是这里发生了变化，异或了0xff</span></span><br><span class="line">                baos.write(data^<span class="number">0xff</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDir</span><span class="params">(String dir)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.dir = dir;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>当然结果是加载成功啦😋，这里如果用其他的类加载器加载，或者把0xff那里去掉，就会报如下错误</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassFormatError: Incompatible magic value <span class="number">889275713</span> in <span class="class"><span class="keyword">class</span> <span class="title">file</span> <span class="title">classloader_study</span>/<span class="title">myClassLoader</span>/<span class="title">MyObject</span></span></span><br><span class="line"><span class="class"><span class="title">at</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">ClassLoader</span>.<span class="title">defineClass1</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">at classloader_study.myClassLoader.MyClassLoader.findClass(MyClassLoader.java:<span class="number">64</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at classloader_study.encryption_study.ClassLoaderTest.main(ClassLoaderTest.java:<span class="number">15</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>这个异常是链接阶段验证的错误，是上面提到的<code>defineClass()</code>抛出来的，因为你加了密，JVM在加载这个二进制流的时候就无法识别了自然就无法加载。</p><h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p><strong>覆盖loadClass()</strong></p><p>要打破双亲委派机制主要就是要覆盖<code>loadClass()</code>方法，自己定义加载类的方式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class<!--?--> loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">    Class<!--?--> clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让父加载器加载java核心的包，因为有些类是继承的Java内部的核心类比如Object类</span></span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"java."</span>)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ClassLoader system = ClassLoader.getSystemClassLoader();</span><br><span class="line">            <span class="comment">//这里仍然是委托上级</span></span><br><span class="line">            clazz = system.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//自己先找</span></span><br><span class="line">        clazz = findClass(name);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//找不到就交给父加载器</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span> && getParent() != <span class="keyword">null</span>) {</span><br><span class="line">        getParent().loadClass(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实就是自己先找，找不到才会交给父加载器，然后一个需要注意的就是你想加载的这个类可能继承了Java内部核心的类像<code>Object</code>类，然后要加载子类就要先加载它的父类，而你的这个包里面肯定是加载不到这些Java内部的核心类的，所以这些还是得交给上层的加载器去加载。</p><p><strong>测试效果</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClassLoaderTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>{</span><br><span class="line">        SimpleClassLoader simpleClassLoader = <span class="keyword">new</span> SimpleClassLoader();</span><br><span class="line">        Class<!--?--> aClass = simpleClassLoader.loadClass(<span class="string">"classloader_study.break_parent.SimpleObject"</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意这里在<code>classpath</code>里面是有这个类的字节码文件的，按照双亲委托机制应该由AppClassLoader去加载</p><p><img alt="mark" data-src="http://static.imlgw.top///20190420/5Nc0S6OoIa2D.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>但是仍然是由我们的SimpleClassLoader加载的，说明我们成功了打破了双亲委派机制（貌似Tomcat也是这种加载机制，有时间看看Tomcat的类加载器）</p><p><strong>面试题</strong></p><p>❓ <strong>能不能自己写个类比如<code>java.lang.String</code>去覆盖Java的<code>String</code>？如果不覆盖<code>loadClass()</code>方法使用双亲委托肯定是不行，但是既然上面已经打破了双亲委托那是不是就可以了呢？</strong></p><p><code>Talk is cheap，show me the code</code> 试试就知道了</p><p>先准备一个String类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/18 12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"i am init"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">250</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>编译好之后放到我们自定义的<code>ClassLoader</code>的目录下，然后将我们<code>loadClass()</code>方法加载核心包的地方注释掉（不然还是会交给父加载器去加载）然后为了表示是我们自定义的<code>ClassLoader</code>加载的我们把classpath里面的字节码文件也删掉。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>{</span><br><span class="line">       SimpleClassLoader simpleClassLoader = <span class="keyword">new</span> SimpleClassLoader();</span><br><span class="line">       Class<!--?--> aClass = simpleClassLoader.loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line">       System.out.println(aClass.getClassLoader());</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p>然后就会看到如下的<code>SecurityException</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">at classloader_study.break_parent.SimpleClassLoader.findClass(SimpleClassLoader.java:<span class="number">52</span>)</span><br><span class="line">at classloader_study.break_parent.SimpleClassLoader.loadClass(SimpleClassLoader.java:<span class="number">77</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:<span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>其实Java为了安全，自定义类取名不能取<code>java.*</code>等核心包名开头，在<code>preDefineClass</code>里面做了检查，所以即使你打破了双亲委托机制你依然不能去覆盖Java的核心类（肯定不行啊😄）。</p><p>其实这里后来了解了<code>Unsafe</code>后也尝试用<code>Unsafe</code> 去加载这个类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class<!--?--> findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        Unsafe unsafe=UnsafeTest.getUnsafe();</span><br><span class="line">        String classPath = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        File classFile = <span class="keyword">new</span> File(dir, classPath + <span class="string">".class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!classFile.exists()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"The class "</span> + name + <span class="string">" found under "</span> + dir);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = loadClassBytes(classFile);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"load the class "</span> + name + <span class="string">" failed"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unsafe.defineClass(<span class="keyword">null</span>,classBytes,<span class="number">0</span>,classBytes.length,SimpleClassLoader.<span class="keyword">this</span>,<span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>loadClass</code> 同上，尝试加载你会发现 会提示找不到<code>Object</code> 类，嗯？已经在加载父类了，难不成还真可以？这里其实已经和上面的方法不同了，上面的方法是不会进入到加载父类的环节的，直接在加载前就被检测了包名然后GG了，随后我在<code>loadClass</code> 中让系统加载器去加载Object类，再次尝试加载</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at sun.misc.Unsafe.defineClass(Native Method)</span><br><span class="line">at classloader_study.break_parent.SimpleClassLoader.findClass(SimpleClassLoader.java:<span class="number">57</span>)</span><br><span class="line">at classloader_study.break_parent.SimpleClassLoader.loadClass(SimpleClassLoader.java:<span class="number">83</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:<span class="number">7</span>)</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">at classloader_study.break_parent.SimpleClassLoaderTest.main(SimpleClassLoaderTest.java:<span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>还是熟悉的味道😂 <code>defineClass</code>虚拟机本地方法抛了异常</p><h3 id="类加载器细节深入"><a href="#类加载器细节深入" class="headerlink" title="类加载器细节深入"></a>类加载器细节深入</h3><p><strong>定义加载器&初始加载器</strong></p><p>⚡真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正<code>完成类的加载</code>工作是通过调用 <code>defineClass(findClass)</code>来实现的；而<code>启动</code>类的加载过程是通过调用 <code>loadClass</code>来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：<strong>一个类的定义加载器是它引用的其它类的初始加载器</strong>。如类 <code>com.example.Outer</code>引用了类 <code>com.example.Inner</code>，则由类 <code>com.example.Outer</code>的<strong>定义加载器</strong>负责启动类 <code>com.example.Inner</code>的加载过程。</p><p><strong>命名空间&运行时包</strong></p><blockquote><p>每个类都有自己的命名空间，命名空间由<code>该加载器及所有父加载器所加载的类</code>组成，<code>子加载器的命名空间包含所有父加载器的命名空间</code>，因此子加载器可以加载的类可以看就按父加载器加载的类，例如系统类加载器可以看见根加载器加载的类。由父加载器加载的类看不见子加载器加载的类，如果两个类之间没有直接或者间接的父子关系，那么他们各自加载的类相互不可见</p></blockquote><p>⚡数组类的Class不是由类加载器加载的，是由JVM在运行期间动态生成的，但是通过<code>getClassLoader</code>返回的类加载器和数组的元素的类加载器是一样的，原生的类型比如<code>int</code> 之类的没有类加载器返回的是null</p><p>⚡每个类加载器都有其自己的命名空间，命名空间由该加载器和其所有父类加载器所加载的类组成，同一份字节码两个不同的类加载器加载出来的不是同一个类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InstantiationException, ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//注意这里的ClassLoader要么利用前面的打破了双亲委托机制的，要么把classpath里面字节码的删掉。</span></span><br><span class="line">        MyClassLoader loader1=<span class="keyword">new</span> MyClassLoader(<span class="string">"Resolmi1"</span>);</span><br><span class="line">        MyClassLoader loader2=<span class="keyword">new</span> MyClassLoader(<span class="string">"Resolmi2"</span>);</span><br><span class="line">        Class<!--?--> aClass2 = loader2.loadClass(<span class="string">"classloader_study.myClassLoader.MyObject"</span>);</span><br><span class="line">        Class<!--?--> aClass1 = loader1.loadClass(<span class="string">"classloader_study.myClassLoader.MyObject"</span>);</span><br><span class="line">        <span class="comment">//两个不同的加载器（没有父子关系）加载同一个类加载出来的不是同一个</span></span><br><span class="line">        System.out.println(aClass1.hashCode()); <span class="comment">//2133927002</span></span><br><span class="line">        System.out.println(aClass2.hashCode()); <span class="comment">//1836019240</span></span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>⚡<strong>父类加载器</strong>无法访问<strong>子类加载器</strong>加载的类，而<strong>子加载器</strong>可以访问到<strong>父加载器</strong>所加载的类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>{</span><br><span class="line">        <span class="comment">//使用上面自定义的ClassLoader</span></span><br><span class="line">        MyClassLoader loader=<span class="keyword">new</span> MyClassLoader(<span class="string">"Resolmi"</span>);</span><br><span class="line">        Class<!--?--> aClass = loader.loadClass(<span class="string">"classloader_study.myClassLoader.Parent"</span>);</span><br><span class="line">        <span class="comment">//创建实例</span></span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Parent类</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Parent is load by"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        Hello();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//父加载器访问子加载器加载的类</span></span><br><span class="line">        System.out.println(<span class="string">"Parent can see the "</span> + Sub<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Sub类</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"Sub is load by"</span>+<span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> Parent(); <span class="comment">//构造Parent类</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>做完了这些工作之后，编译代码，然后将classpath中的<code>Parent.class</code>拷贝到自定义的ClassLoader路径下面，然后删掉classpath中的<code>Parent.class</code> ，然后运行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Sub is load byclassloader_study.myClassLoader.MyClassLoader@<span class="number">74</span>a14482</span><br><span class="line">Parent is load bysun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NoClassDefFoundError: classloader_study/myClassLoader/Sub</span><br><span class="line">at classloader_study.myClassLoader.Parent.Hello(Parent.java:<span class="number">15</span>)</span><br><span class="line">at classloader_study.myClassLoader.Parent.<init>(Parent.java:<span class="number">10</span>)</init></span><br><span class="line">at classloader_study.myClassLoader.Sub.<init>(Sub.java:<span class="number">10</span>)</init></span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">423</span>)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:<span class="number">442</span>)</span><br><span class="line">at classloader_study.myClassLoader.ClassLoaderTest.main(ClassLoaderTest.java:<span class="number">14</span>)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: classloader_study.myClassLoader.Sub</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">349</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">... <span class="number">9</span> more</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到，我们的<code>Sub</code> 是由我们自定义的<code>MyClassLoader</code> 加载的，因为我们删掉了Classpath中的字节码，而在自定义的路径中有所以最后还是由我们的 <code>MyClassLoader</code> 加载了，所以我们的<code>Parent</code>类首先也会由我们的<code>自定义类加载器MyClassLoader</code>去作为<strong>初始加载器</strong>加载，由于我们的Classpath中还有字节码文件，所以在双亲委派机制下<code>Sub类</code> 最终由<code>AppClassLoader</code>加载 ，两个类由不同的类加载器加载，然后我们在<code>Parent</code> 类中试图访问<code>Sub</code> 类，结果抛出了<code>ClassNotFoundException</code>  和<code>NoClassDefFoundError</code> 异常</p><p>❓ <strong>那我们反过来在<code>Sub</code>类中访问 <code>Parent</code> 类会发生什么，改造一下Parent和Sub</strong></p><p><strong>Parent类</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Parent is load by"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">//Hello();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//父加载器访问子加载器加载的类</span></span><br><span class="line">        System.out.println(<span class="string">"Parent can see the "</span> + Sub<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Sub类</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"Sub is load by"</span>+<span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> Parent(); <span class="comment">//构造Sub类</span></span><br><span class="line">        <span class="comment">//访问父加载器加载的类</span></span><br><span class="line">        System.out.println(<span class="string">"Sub can see "</span>+Parent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>和上面一样删掉Classpath中Sub类的class文件没然后运行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">findclass is invoke MyClassLoader is loadclassloader_study.myClassLoader.Sub</span><br><span class="line">Sub is load byclassloader_study.myClassLoader.MyClassLoader@<span class="number">74</span>a14482</span><br><span class="line">Parent is load bysun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">Sub can see <span class="class"><span class="keyword">class</span> <span class="title">classloader_study</span>.<span class="title">myClassLoader</span>.<span class="title">Parent</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br></pre></td></tr></tbody></table></figure></div><p>没有任何问题，由此就可以证明我们上面的结论是正确的。</p><p>❓ <strong>面试题：如何让一个类的static代码块执行两次</strong></p><p>用不同的类加载器去加载这个类，至于为什么应该不用我多说了吧。</p><p><strong>类的卸载和ClassLoader的卸载</strong></p><blockquote><p> 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中<strong>始终不会被卸载</strong>，Java虚拟机本身会引用这些类加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象始终是可达的。</p></blockquote><p>⚡JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）</p><ul><li>该类所有的实例都已经被GC。</li><li>加载该类的ClassLoader实例已经被GC。(Class对象里面有对ClassLoader的引用)</li><li>该类的java.lang.Class对象没有在任何地方被引用。</li></ul><p>GC的时机我们是不可控的，那么同样的我们对于Class的卸载也是不可控的，使用<code>-XX:+TraceClassUnloading</code> 或者jvisualvm可以看到类的卸载</p><h2 id="线程上下文加载器-TCCL"><a href="#线程上下文加载器-TCCL" class="headerlink" title="线程上下文加载器(TCCL)"></a>线程上下文加载器(<strong>TCCL</strong>)</h2><p>​    在说TCCL之前不得不说一下另一个话题，SPI（Service Provider Interface，SPI）服务提供接口，由第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 <strong>Java 核心库</strong>来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进<strong>类路径</strong>（classpath）里。SPI接口中的代码经常需要加载具体的实现类。</p><blockquote><p>为什么要使用SPI?  SPI是JDK内置的一种<strong>服务提供发现机制</strong>。这样做的好处主要是为了解耦，实现动态替换，减少硬编码（比如jdk1.6之前的Class.forName(“XXXX”) ）面向接口编程，在很多开源框架中都有体现，比如Dubbo，Spring等</p></blockquote><p>那么问题来了，<code>SPI的接口</code>是Java核心库的一部分位于<code>rt.jar</code>中，是由<strong>根加载器</strong>(Bootstrap Classloader)来加载的，而<code>SPI的实现类</code>是一般是第三方的提供的，位于<code>classpath</code>目录中，而<strong>根加载器</strong>很明显是无法直接加载到这个目录下的SPI 的实现类的 (双亲委派)，那<code>SPI</code>是如何自动加载到实现类的呢？</p><p>为了解决这个问题，虚拟机提供了<strong>线程上下文加载器（TCCL）</strong>配合<code>ServiceLoader</code>来帮助上层加载器加载类，<code>TCCL</code>破坏了“双亲委派模型”，可以在执行过程中切换为<code>TCCL</code> 来加载第三方的SPI实现类，抛弃双亲委派机制，使程序可以逆向使用类加载器。<strong>TCCL</strong>默认是系统类加载器，也可以通过<code>setContextClassLoader</code>去设置</p><h3 id="JDBC源码案例分析"><a href="#JDBC源码案例分析" class="headerlink" title="JDBC源码案例分析"></a>JDBC源码案例分析</h3><p>翻到了最开始学JDBC的时候写的代码😄</p><p><img alt="JDBC" data-src="http://static.imlgw.top///20190420/K4uQf6h5czDb.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>贾琏欲执事</strong>，可以看到第一步还是加载并且初始化驱动，前面已经提到这一步其实没有必要了，jdk1.6之后因为ServiceLoader，SPI机制的出现，就不用再显示的加载驱动，但是正如上面所说<code>Driver</code>只是个接口存放于<code>rt.jar</code> 中，由根加载器所加载，那SPI是怎么自动的加载到<code>mysql</code>的<code>Driver</code>实例的呢？😕</p><p>我们一步步的来看，首先<code>DriverManager.getConnection()</code>这里，<code>getConnection</code>是个静态方法，调用它就会先执行<code>DriverManager</code>类的静态代码块，而静态代码块里面主要执行的就是<code>loadInitialDrivers()</code></p><h3 id="loadInitialDrivers-源码"><a href="#loadInitialDrivers-源码" class="headerlink" title="loadInitialDrivers()源码"></a>loadInitialDrivers()源码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>{</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction<string>() {</string></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        drivers = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">    <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">    <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">    <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line"><span class="comment">// 如果驱动正确打包为jar就会用ServiceLoader去加载它</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction<void>() {</void></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">/****************************************************/</span></span><br><span class="line"><span class="comment">/*ServiceLoad工具类，注意这个ServiceLoad的加载器，默认就是TCCL*/</span></span><br><span class="line">            ServiceLoader<driver> loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</driver></span><br><span class="line">            <span class="comment">/****************************************************/</span></span><br><span class="line">            <span class="comment">/*在这里会获取到一个Drivers的迭代器，但是其实还没有开始加载类*/</span></span><br><span class="line">            Iterator<driver> driversIterator = loadedDrivers.iterator();</driver></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">             * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">             * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">             * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">             * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">             * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">             * and load the service.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">             * if driver not available in classpath but it's</span></span><br><span class="line"><span class="comment">             * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) {</span><br><span class="line">                    <span class="comment">//迭代的过程中通过next反射加载并初始化这个驱动字节码</span></span><br><span class="line">                    <span class="comment">//没有接收返回的数据库驱动实例</span></span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span>(Throwable t) {</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);</span><br><span class="line"><span class="comment">//加载Jdk中的驱动实例（虽然我并不知道是什么）总之我们第三方的驱动已经加载好了</span></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">""</span>)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">":"</span>);</span><br><span class="line">    println(<span class="string">"number of Drivers:"</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">            Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到中间有一行很关键的代码</p><p> <code>ServiceLoader<driver> loadedDrivers = ServiceLoader.load(Driver.class);</driver></code></p><p>这就是我上面所提到的 <code>ServiceLoader</code> </p><blockquote><p>对于SPI机制，JDK提供了<code>java.util.ServiceLoader</code>工具类，在使用某个服务接口时，它可以帮助我们查找该服务接口的实现类，加载和初始化，前提条件是基于它的约定：当服务的提供者提供了服务接口的一种实现之后，在<code>jar</code>包的<code>META-INF/services/</code>目录里同时创建一个以<code>服务接口命名的文件</code>。该文件里就是实现该服务接口的具体实现类（去解压看看那些jar包就可以看见这些信息o(<em>￣▽￣</em>)ブ）</p></blockquote><h3 id="ServiceLoader类源码"><a href="#ServiceLoader类源码" class="headerlink" title="ServiceLoader类源码"></a>ServiceLoader类源码</h3><p>为了节约篇幅删掉了一些注释，发现其实整个类也没多少行大概2，3百行的样子，需要注意这个类并不是线程安全的，所以使用的时候需要注意</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span><<span class="title">S</span>> <span class="keyword">implements</span> <span class="title">Iterable</span><<span class="title">S</span>> </span>{</span><br><span class="line"><span class="comment">//目录前缀就是从这里来的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现类Service</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class<s> service;</s></span><s><br><span class="line"></span><br><span class="line">    <span class="comment">// The class loader used to locate, load, and instantiate providers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The access control context taken when the ServiceLoader is created</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cached providers, in instantiation order</span></span><br><span class="line">    <span class="comment">// 按照实例的顺序，来缓存服务提供者避免重复的加载，具体可以看下面的iterator方法</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap<string,s> providers = <span class="keyword">new</span> LinkedHashMap<>();</string,s></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The current lazy-lookup iterator</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>{</span><br><span class="line">        providers.clear();</span><br><span class="line">        <span class="comment">//初始化懒加载迭代器</span></span><br><span class="line">        lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class<s> svc, ClassLoader cl)</s></span><s> </s></span><s>{</s></span><s><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">        loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Class<!--?--> service, String msg, Throwable cause)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(service.getName() + <span class="string">": "</span> + msg,</span><br><span class="line">                                            cause);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Class<!--?--> service, String msg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(service.getName() + <span class="string">": "</span> + msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Class<!--?--> service, URL u, <span class="keyword">int</span> line, String msg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        fail(service, u + <span class="string">":"</span> + line + <span class="string">": "</span> + msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse a single line from the given configuration file, adding the name</span></span><br><span class="line">    <span class="comment">// on the line to the names list.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parseLine</span><span class="params">(Class<!--?--> service, URL u, BufferedReader r, <span class="keyword">int</span> lc,</span></span></span><br><span class="line"><span class="function"><span class="params">                          List<string> names)</string></span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        String ln = r.readLine();</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ci = ln.indexOf(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">if</span> (ci >= <span class="number">0</span>) ln = ln.substring(<span class="number">0</span>, ci);</span><br><span class="line">        ln = ln.trim();</span><br><span class="line">        <span class="keyword">int</span> n = ln.length();</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> ((ln.indexOf(<span class="string">' '</span>) >= <span class="number">0</span>) || (ln.indexOf(<span class="string">'\t'</span>) >= <span class="number">0</span>))</span><br><span class="line">                fail(service, u, lc, <span class="string">"Illegal configuration-file syntax"</span>);</span><br><span class="line">            <span class="keyword">int</span> cp = ln.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isJavaIdentifierStart(cp))</span><br><span class="line">                fail(service, u, lc, <span class="string">"Illegal provider-class name: "</span> + ln);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i < n; i += Character.charCount(cp)) {</span><br><span class="line">                cp = ln.codePointAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!Character.isJavaIdentifierPart(cp) && (cp != <span class="string">'.'</span>))</span><br><span class="line">                    fail(service, u, lc, <span class="string">"Illegal provider-class name: "</span> + ln);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!providers.containsKey(ln) && !names.contains(ln))</span><br><span class="line">                names.add(ln);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lc + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Iterator<string> <span class="title">parse</span><span class="params">(Class<!--?--> service, URL u)</span></string></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader r = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList<string> names = <span class="keyword">new</span> ArrayList<>();</string></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            in = u.openStream();</span><br><span class="line">            r = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in, <span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) >= <span class="number">0</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException x) {</span><br><span class="line">            fail(service, <span class="string">"Error reading configuration file"</span>, x);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) r.close();</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) in.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException y) {</span><br><span class="line">                fail(service, <span class="string">"Error closing configuration file"</span>, y);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> names.iterator();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private inner class implementing fully-lazy provider lookup</span></span><br><span class="line">    <span class="comment">// 看名字就知道了，懒迭代器，在迭代的时候才真正的加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span><<span class="title">S</span>></span></span><br><span class="line"><span class="class">    </span>{</span><br><span class="line"></span><br><span class="line">        Class<s> service;</s></span><s><br><span class="line">        ClassLoader loader;</span><br><span class="line">        Enumeration<url> configs = <span class="keyword">null</span>;</url></span><br><span class="line">        Iterator<string> pending = <span class="keyword">null</span>;</string></span><br><span class="line">        String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class<s> service, ClassLoader loader)</s></span><s> </s></span><s>{</s></span><s><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">            <span class="keyword">this</span>.loader = loader;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                } <span class="keyword">catch</span> (IOException x) {</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) {</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            }</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line"><span class="comment">//迭代器的next</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class<!--?--> c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//利用TCCL加载实现类，但是不初始化</span></span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException x) {</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) {</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//newInstance()初始化了对应的实现类</span></span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                <span class="comment">//放到providers中</span></span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                PrivilegedAction<boolean> action = <span class="keyword">new</span> PrivilegedAction<boolean>() {</boolean></boolean></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>{ <span class="keyword">return</span> hasNextService(); }</span><br><span class="line">                };</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                PrivilegedAction<s> action = <span class="keyword">new</span> PrivilegedAction<s>() {</s></s></span><s><s><br><span class="line">                    <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextService(); }</span><br><span class="line">                };</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lazily loads the available providers of this loader's service.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  An iterator that lazily loads providers for this loader's</span></span><br><span class="line"><span class="comment">     *          service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator<s> <span class="title">iterator</span><span class="params">()</span> </s></span><s>{</s></span><s><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator<s>() {</s></span><s><br><span class="line"></span><br><span class="line">            Iterator<map.entry<string,s>> knownProviders</map.entry<string,s></span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重载的ServiceLoad */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <s> <span class="function">ServiceLoader<s> <span class="title">load</span><span class="params">(Class<s> service,</s></span></s></span></s></span><s><s><s><br><span class="line"><span class="function"><span class="params">                                            ClassLoader loader)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader<>(service, loader);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//DriverManage里面就是调用的这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <s> <span class="function">ServiceLoader<s> <span class="title">load</span><span class="params">(Class<s> service)</s></span><s> </s></s></span><s><s>{</s></s></s></span><s><s><s><br><span class="line">        <span class="comment">//拿到了TCCL</span></span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">//调用上面重载的ServiceLoad方法</span></span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <s> <span class="function">ServiceLoader<s> <span class="title">loadInstalled</span><span class="params">(Class<s> service)</s></span><s> </s></s></span><s><s>{</s></s></s></span><s><s><s><br><span class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">        ClassLoader prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="keyword">null</span>) {</span><br><span class="line">            prev = cl;</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, prev);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"java.util.ServiceLoader["</span> + service.getName() + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></s></s></s></s></s></s></s></s></s></s></s></s></s></s></s></s></s></pre></td></tr></tbody></table></figure></div><blockquote><p>首先我们要明白一点，<code>Driver接口</code>，<code>DriverManage类</code>，以及<code>ServiceLoader</code>都是由<strong>根加载器</strong>去加载的(如果不相信的话可以用TraceClassLoading去查看)，所以在<code>ServiceLoader</code>中也是无法直接加载具体得实现类的</p></blockquote><p>前面<code>loadInitialDriver()</code> 调用的就是这里的 <code>ServiceLoader.load(Class<s> service)</s></code><s> 方法，这个方法中悄悄的拿到了<code>TCCL</code> ，而TCCL在<code>Launcher</code> 类（系统加载器和扩展加载器都是在Launcher中实现的）中默认设置成了系统加载器，具体可以去看一下源码这里我就不展开了，然后调用另一个重载的构造方法将<code>TCCL</code> 传递进去，最终调用了 <code>reload()</code>方法</s></p><s><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>{</span><br><span class="line">    providers.clear();</span><br><span class="line">    <span class="comment">//初始化懒加载迭代器</span></span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p> 在这个方法中首先清空服务提供者(providers)缓存，然后初始化了一个<code>LazyIterator</code> 看名字就知道是啥意思了，其实到这里仍然没有任何具体的加载动作，因为这里采用的是按需加载，也就是懒加载，在迭代的时候才会去加载类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span><<span class="title">S</span>></span>{</span><br><span class="line">Class<s> service;</s></span><s><br><span class="line">    ClassLoader loader;</span><br><span class="line">    Enumeration<url> configs = <span class="keyword">null</span>;</url></span><br><span class="line">    Iterator<string> pending = <span class="keyword">null</span>;</string></span><br><span class="line">    String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class<s> service, ClassLoader loader)</s></span><s> </s></span><s>{</s></span><s><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">        <span class="keyword">this</span>.loader = loader;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//拿到接口全名</span></span><br><span class="line">                String fullName = PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            } <span class="keyword">catch</span> (IOException x) {</span><br><span class="line">                fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) {</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//解析</span></span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        }</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="comment">//迭代器的next</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class<!--?--> c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//具体加载类的地方就是在这里</span></span><br><span class="line">            <span class="comment">//利用前面传进来的TCCL加载实现类，但是不初始化类</span></span><br><span class="line">            c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException x) {</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) {</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//newInstance()实例化对应的实现类</span></span><br><span class="line">            S p = service.cast(c.newInstance());</span><br><span class="line">            <span class="comment">//put到providers中</span></span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                 x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> hasNextService();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            PrivilegedAction<boolean> action = <span class="keyword">new</span> PrivilegedAction<boolean>() {</boolean></boolean></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>{ <span class="keyword">return</span> hasNextService(); }</span><br><span class="line">            };</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> nextService();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            PrivilegedAction<s> action = <span class="keyword">new</span> PrivilegedAction<s>() {</s></s></span><s><s><br><span class="line">                <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextService(); }</span><br><span class="line">            };</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></s></s></s></s></pre></td></tr></tbody></table></figure></div><p>🔸 可以看到在迭代器的<code>nextService()</code> 中才开始利用的<code>Class.forName()</code> 加载的具体实现类，而这个加载器正器正是前面<code>reload</code>传递过来的 <code>TCCL</code> 也就是默认的系统类加载器</p><p>🔸 随后在紧跟的try语句中通过 <code>newInstance()</code> 实例化了具体的实现类(MySql的驱动) ，然后put进providers队列并且返回实例化的实现类，但是在<code>loadInitialDrivers</code>中并没有接收这个返回，那他这里实例化是什么用意呢？</p><p>我们回到<code>getConnection()</code> 方法</p><h3 id="getConnection-源码"><a href="#getConnection-源码" class="headerlink" title="getConnection()源码"></a>getConnection()源码</h3><p>前面的静态方法调用完毕驱动已经加载，下面就是获取数据库连接了.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">    String user, String password)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) {</span><br><span class="line">        info.put(<span class="string">"user"</span>, user);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span>) {</span><br><span class="line">        info.put(<span class="string">"password"</span>, password);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// Reflection.getCallerClass()调用者的Class对象</span></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>一般获取连接都是调用的上面这个方法，这个方法最终会调用另一个重载的方法，同时传入一个调用者的Class对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String url, java.util.Properties info, Class<!--?--> caller)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When callerCl is null, we should check the application's</span></span><br><span class="line"><span class="comment">     * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">     * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">     * can be loaded from here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//Caller就是调用者的CLass也就是我们的应用代码类</span></span><br><span class="line">    <span class="comment">//获取到我们应用类的类加载器</span></span><br><span class="line">    ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(DriverManager<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">        <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">        <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//如果为空就，获取线程线下文加载器</span></span><br><span class="line">            callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(url == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"The url cannot be null"</span>, <span class="string">"08001"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"DriverManager.getConnection(\""</span> + url + <span class="string">"\")"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    SQLException reason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历这个registeredDrivers里面都是DriverInfo</span></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) {</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="comment">//检查加载驱动的加载器是不是调用者的类加载器</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="comment">//获取连接</span></span><br><span class="line">                Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">"getConnection returning "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (SQLException ex) {</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="keyword">null</span>) {</span><br><span class="line">                    reason = ex;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="keyword">null</span>)    {</span><br><span class="line">        println(<span class="string">"getConnection failed: "</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"getConnection: no suitable driver found for "</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"No suitable driver found for "</span>+ url, <span class="string">"08001"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 可以看到中间有一个foreach循环，遍历<code>registeredDrivers</code>，这是个<code>CopyOnWriteArrayList</code> 这个类看名字就知道存放的是已经注册的<code>Drivers</code> 实现类，那这些实现类是什么时候注册进来的呢？回到我们之前抛出的一个问题，在<code>ServiceLoader</code>的迭代器中加载了具体的类之后进行了实例化，但是<code>DriverManager</code> 中并没有接收这个实例，我们来看一下具体的驱动实现类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.cj.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//注册到DriverManager中去</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException var1) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 相信看到这里大家就明白了，前面初始化这个类的作用就是为了能触发这个<strong>静态代码块</strong>，进而执行registerDriver()方法进行注册，真是妙啊👏一环套一环</p><p>🔸 还有一个需要注意的地方就是这里注册的虽然是个空的Driver类，但是别忘了它还有个父类NonRegisteringDriver</p><p>这个类才是真正的实现类具体的<code>connect()</code> 等方法都是在这个里面实现的，而Driver继承了它的方法</p><p>🔸 在遍历<code>registeredDrivers</code> 的时候还调用了一个<code>isDriverAllowed(aDriver.driver, callerCL)</code> 方法这个方法第一个参数就是驱动的实现类，第二个参数就是前面获取到的<strong>调用者的类加载器</strong> ，作用就是通过利用传进来的加载器尝试加载这个类，然后判断是不是同一个类，（众所周知不同的加载器因为命名空间的存在，即使加载同一份字节码文件得到的也不是一个类） 如果是就允许加载，否则不允许，为啥要这样做呢？其实还是因为命名空间的问题，因为有了SPI的机制，你<strong>加载初始化这个实现类的加载器</strong>(TCCL)和最终去<strong>调用实现类的方法的类的加载器</strong>有可能不是同一个，因为程序员可以很容易的将TCCL修改成其他的类加载器，如果不保证一致的话后面就会出现<code>ClassCastException</code>等异常 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(driver != <span class="keyword">null</span>) {</span><br><span class="line">        Class<!--?--> aClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            aClass =  Class.forName(driver.getClass().getName(), <span class="keyword">true</span>, classLoader);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">         result = ( aClass == driver.getClass() ) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>当高层提供了统一接口让低层去实现（面向接口编程，解耦），同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。</p><h2 id="Jar-Hell"><a href="#Jar-Hell" class="headerlink" title="Jar Hell"></a>Jar Hell</h2><p>Jar包地狱，<a href="https://www.hidennis.tech/2016/05/30/what-is-jar-hell/" target="_blank" rel="noopener">参考</a></p><p>这个问题其实可以通过<code>OSGI</code>等组件化框架来解决，使用OSGI可以完美解决这个问题，OSGI是基于模块（Bundle）驱动的，每个模块都有属于自己的classpath和类加载器，模块之间通过包暴露和引入进行关联，每个模块有着自己独立的生命周期，我们可以动态地对模块进行加载、卸载、更新。如此看来，OSGI可以用一句话描述，就是一个为Java提供的动态模块化的系统。但是OSGI太过复杂，实用性并不强</p><p><a href="http://hellojava.info/?p=152" target="_blank" rel="noopener">阿里架构师对OSGI的评价</a></p><p>这里我主要想说的是怎么在代码中利用类加载器来检测Jar Hell</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarHell</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="keyword">try</span> {  </span><br><span class="line">            Enumeration<url> urls = Thread.currentThread().getContextClassLoader().getResources(<span class="string">"org/apache/log4j/Logger.class"</span>);  </url></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) {  </span><br><span class="line">                URL url = urls.nextElement();  </span><br><span class="line">                System.out.println(url);  </span><br><span class="line">            }  </span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        }  </span><br><span class="line">       </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样就可以找到classpath中冲突的jar包，当然通过idea的工具会更方便 😂</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机》</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code4" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></p></s></body></html>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机（一）</title>
      <link href="/2019/08/11/shen-ru-li-jie-java-xu-ni-ji-yi/"/>
      <url>/2019/08/11/shen-ru-li-jie-java-xu-ni-ji-yi/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>本文在 <a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=minor-gc-%e5%92%8c-full-gc" target="_blank" rel="noopener">CyC大佬</a> 的博客基础之上做了一些扩充改编（ 改编不是乱编，戏说不是胡说，今年下半年…….🐵</p><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190817/rTyjnrafmg3Q.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li><p>程序计数器是一块较小的内存空间，它可以看成当前线程执行的字节码的行号指示器</p></li><li><p>程序计数器位于线程独占去</p></li><li><p>如果线程执行的是Java方法，这个计数齐记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是native方法，这个计数器的值为undefined</p></li><li><p>此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 </p></li></ul><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><img alt="CyC" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" src="/img/loading.gif" class="lazyload"></p><p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java -Xss2M HackTheJavaCopy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure></div><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>所有对象实例以及数组都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆大致分成两块：</p><ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li></ul><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>Java虚拟机规范中将其描述为堆的一个逻辑部分，但是它还有一个别名就叫做<code>非堆</code>，而在HotSpot中则称之为<code>永久代（Permanent Generation）</code>。</p><p>这一块主要用于存放<strong>已被加载的类信息（类的版本，字段，方法，接口）</strong>、<strong>运行时常量池</strong>、<strong>静态变量</strong>、即时编译器(JIT)编译后的代码等数据。</p><p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p><code>HotSpot</code> 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，<strong>静态变量和字符串常量池等被放入堆中</strong>。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，<strong>Class 文件中的常量池</strong>（编译器生成的<strong>字面量</strong>和<strong>符号引用</strong>）会在<strong>类加载后</strong>被放入这个区域</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</p><blockquote><p>When the intern method is invoked, if the pool already contains a string equal to this {@code String} object as determined by the {@link #equals(Object)} method, then the string from the pool is returned. Otherwise, this {@code String} object is added to the pool and a reference to this {@code String} object is returned.</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//s1 s2存放在局部变量表中</span></span><br><span class="line">        <span class="comment">// abc 存放在常量池中（字节码常量）</span></span><br><span class="line">        String s1=<span class="string">"abc"</span>;</span><br><span class="line">        String s2=<span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1==s2); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//new出来的一定是在堆内存中</span></span><br><span class="line">        String s3=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1==s3); <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//运行时常量,intern将字符串添加到常量池中并且返回一个引用</span></span><br><span class="line">        System.out.println(s1==s3.intern()); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//颠覆认知的</span></span><br><span class="line">        <span class="comment">//实际上这里创建了两个字符串对象，一个在堆中，一个在常量池中</span></span><br><span class="line">        System.out.println(s3==s3.intern()); <span class="comment">//false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>关于String常量池 参考可以这篇 <a href="https://blog.csdn.net/qq_34115899/article/details/86583262" target="_blank" rel="noopener">文章</a></p><p>或这一篇<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">美团技术团队</a></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190811/JcRnzxY4HN5q.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为<code>“指针碰撞”</code>（Bump the Pointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<code>“空闲列表”</code>（Free List）。选择哪种分配方式由<code>Java堆是否规整</code>决定，而Java堆是否规整又由所采用的<code>垃圾收集器是否带有压缩整理功能决定</code>。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>创建对象的时候需要修指针指向的位置，在并发情况下这并不是线程安全的，虚拟机可以采用CAS加上失败重试（自旋）的方式保证更新操作的原子性，但是这样会影响性能，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<code>本地线程分配缓冲</code>（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的FLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p><h3 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a><strong>对象结构</strong></h3><h4 id="Object-Header"><a href="#Object-Header" class="headerlink" title="Object Header"></a>Object Header</h4><p>对象头包括两部分</p><p><strong>自身运行时数据（Mark Word）</strong>比如 对象哈希值，对象分带年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，另一部分就是<strong>类型指针</strong></p><h4 id="InstanceData"><a href="#InstanceData" class="headerlink" title="InstanceData"></a>InstanceData</h4><p>实例数据，是对象真正存储的有效信息，也是在程序中定义的各个类型字段的内容，无论是从父类继承下来的还是在之类种定义的，都需要记录下来。</p><h4 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a><strong>Padding</strong></h4><p>这一部分并不是必须的，其实就是用于内存对齐的，HotSpot自动内存管理系统要求对象起始地址必须是8个字节的整数倍，也就是对象大小必须是8的整数倍，如果不够则需要填充这部分就是Padding</p><h3 id="HotSpot源码"><a href="#HotSpot源码" class="headerlink" title="HotSpot源码"></a>HotSpot源码</h3><p>找到了openJdk的Java8对应的创建对象的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/6a0ead6dc6db/src/share/vm/interpreter/bytecodeInterpreter.cpp" target="_blank" rel="noopener">源码</a>，大概1966行左右</p><h2 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h2><h3 id="堆结构分代"><a href="#堆结构分代" class="headerlink" title="堆结构分代"></a>堆结构分代</h3><p>Java虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念（JDK1.8之后为metaspace替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，而且HotSpot也有取消永久代的趋势，在JDK 1.7中HotSpot已经开始了“去永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。</p><p><strong>新生代（Young Generation）</strong></p><p>新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。</p><p><strong>老年代（Old Generationn）</strong></p><p>在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</p><p><strong>永久代（Permanent Generationn）</strong></p><p>永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</p><h3 id="堆结构分代的意义"><a href="#堆结构分代的意义" class="headerlink" title="堆结构分代的意义"></a>堆结构分代的意义</h3><p>　　Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（<code>对HotSpot虚拟机而言</code>），这就是JVM的内存分代策略。<br>　　堆内存是虚拟机管理的内存中最大的一块，也是<code>垃圾回收最频繁</code>的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率。<br>　　有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在<code>老年代</code>中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集主要是针对<code>堆和方法区</code>进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h3 id="判断一个对象是否可以被回收"><a href="#判断一个对象是否可以被回收" class="headerlink" title="判断一个对象是否可以被回收"></a>判断一个对象是否可以被回收</h3><p>在堆中存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收的时候，第一件事情就是要确定这些对象之中那些还“活着”，那些已经“死去”（不会再被使用）</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h4><p>给对象加上一个引用计数器，每当有一个地方引用它的时候，计数器值就加1，引用失效的时候就减一，计数器为0的对象就是不可能再被使用的。</p><p>但是在主流的Java虚拟机中都没有使用引用计数器来进行内存管理，主要的原因就是它很难解决循环引用的问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面的代码中 <code>Test a</code>  和<code>Test b</code> 互相引用，在后续将两个对象引用赋为null后两个对象的引用计数器仍然不为0，导致无法回收这两个对象。</p><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a><strong>可达性分析法</strong></h4><p>以 <code>GC Roots</code> 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收，Java 虚拟机使用该算法来判断对象是否可被回收。</p><p>Java语言中可以作为GC Root的对象包括下面几种</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h4 id="OopMap，安全点，安全区"><a href="#OopMap，安全点，安全区" class="headerlink" title="OopMap，安全点，安全区"></a>OopMap，安全点，安全区</h4><p>采用可达性分析法首先就找找到那些是<code>GC Root</code>，目前主要有两种查找 GC Roots 的方法：</p><p>💡<strong>保守式 GC</strong>：遍历方法区和栈区查找，无法使用复制算法，除非采用<code>句柄访问对象的方式</code>但效率不高，无法准确区分是不是引用（指针）类型的变量</p><p>💡<strong>准确式 GC</strong>：与保守式GC相对的就是准确式GC，就是我们准确的知道，某个位置上面是否是指针，对于java来说，就是知道对于某个位置上的数据是什么类型的，这样就可以判断出所有的位置上的数据是不是指向GC堆的引用，包括栈和寄存器里的数据。HotSpot则是通过 <code>OopMap</code> 数据结构来记录在对象内的什么偏移量上是什么类型的数据</p><p>很明显，保守式 GC 的成本太高。准确式 GC 的优点就是能够让虚拟机快速定位到 GC Roots。</p><p>对应 <code>OopMap</code> 的位置即可作为一个<code>Safe Point</code>（安全点）。</p><p><strong>什么是安全点？</strong></p><p>OopMap的作用是为了在GC的时候，快速进行可达性分析，所以OopMap并不需要一发生改变就去更新这个映射表。只要这个<code>更新在GC发生之前</code>就可以了。所以OopMap只需要在预先选定的一些位置上记录变化的OopMap就行了。这些特定的点就是<code>SafePoint</code>（安全点）。由此也可以知道，程序并不是在所有的位置上都可以进行GC的，只有在达到这样的安全点才能暂停下来进行GC。</p><p><strong>安全点的选取</strong></p><p>在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的<code>"Stop-The-World"</code>，因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。</p><p>安全点意味着在这个点时，所有<code>工作线程的状态是确定</code>的，JVM 就可以安全地执行 GC 。</p><p>安全点的选取一般在以下几个位置，避免程序过长时间执行。</p><ul><li><p>循环的末尾</p></li><li><p>方法临返回前</p></li><li><p>调用方法之后</p></li><li><p>抛异常的位置</p></li></ul><p><strong>安全区</strong></p><p>​    安全点的使用似乎解决了OopMap计算的效率的问题，但是这里还有一个问题。安全点需要程序自己跑过去，那么对于那些已经停在路边休息或者看风景的程序（比如那些处在Sleep或者Blocked状态的线程），他们可能并不会在很短的时间内跑到安全点去。所以这里为了解决这个问题，又引入了安全区域的概念。</p><p>​    安全区域很好理解，就是在程序的一段代码片段中并<code>不会导致引用关系发生变化</code>，也就不用去更新OopMap表了，那么在这段代码区域内任何地方进行GC都是没有问题的。这段区域就称之为安全区域。线程执行的过程中，如果进入到安全区域内，就会标志自己已经进行到安全区域了。那么虚拟机要进行GC的时候，发现该线程已经运行到安全区域，就不会管该线程的死活了。所以，该线程在脱离安全区域的时候，要<code>自己检查</code>系统是否已经完成了GC或者根节点枚举（这个跟GC的算法有关系），如果完成了就继续执行，如果未完成，它就必须等待收到可以安全离开安全区域的Safe Region的信号为止。</p><p><strong>中断方式</strong></p><p>在程序需要GC的时候怎么让所有线程到达安全点中断然后进行GC ?</p><ul><li><p>抢断式中断：抢断式中断就是在GC的时候，让所有的线程都中断，如果这些线程中发现中断地方不在安全点上的，就恢复线程，让他们重新跑起来，直到跑到安全点上。（现在几乎没有虚拟机采用这种方式）</p></li><li><p>主动式中断：主动式中断在GC的时候，不会主动去中断线程，仅仅是设置一个标志，当程序运行到安全点时就去轮训该位置，发现该位置被设置为真时就自己中断挂起。所以轮训标志的地方是和安全点重合的，另外创建对象需要分配内存的地方也需要轮询该位置。</p></li></ul><h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>方法区（HotSpot中的永久代），在Java规范中并没有要求虚拟机对该区域进行垃圾回收，这个区域的垃圾回收效率要远低于在<code>堆中</code> </p><p>回收的主要对象：</p><ul><li>废弃常量</li><li>无用的类(Class对象)</li></ul><p>判断一个常量是否是废弃常量，只要没有任何对象引用常量池中的常量，该常量就可以回收。</p><p>判断一个类是不是无用的类条件则比较苛刻。</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><p>满足了上述条件虚拟机才<strong>可以</strong> 对其进行回收，但是这也并不是必然的。</p><h4 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize()"></a>Finalize()</h4><p>这个方法忘了就好😁</p><p>当一个对象可被回收时，如果重写该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 提供了四种强度不同的引用类型。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure></div><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference<object> sf = <span class="keyword">new</span> SoftReference<object>(obj);<br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联Copy to clipboardErrorCopied</span></span><br></object></object></span></pre></td></tr></tbody></table></figure></div><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference<object> wf = <span class="keyword">new</span> WeakReference<object>(obj);<br><span class="line">obj = <span class="keyword">null</span>;Copy to clipboardErrorCopied</span><br></object></object></span></pre></td></tr></tbody></table></figure></div><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来创建虚引用。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference<object> pf = <span class="keyword">new</span> PhantomReference<object>(obj, <span class="keyword">null</span>);<br><span class="line">obj = <span class="keyword">null</span>;</span><br></object></object></span></pre></td></tr></tbody></table></figure></div><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h4><p><img alt="CyC" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" src="/img/loading.gif" class="lazyload"></p><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p><p>在清除阶段，会遍历整个堆进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 <code>“空闲链表”</code> 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p><p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p><p>详细可以参考 <a href="http://www.ituring.com.cn/book/tupubarticle/10955" target="_blank" rel="noopener">垃圾回收的算法与实现</a></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img alt="CyC" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" src="/img/loading.gif" class="lazyload"></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是<code>只使用了内存的一半</code>。</p><p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块<code>较大的 Eden</code> 空间和<code>两块较小的 Survivor 空间</code>，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，<code>最后清理 Eden 和使用过的那一块 Survivor。</code></p><p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要<code>依赖于老年代进行空间分配担保</code>，也就是借用老年代的空间存储放不下的对象。</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h4><p>复制算法在对象存活率较高的时候就要进行很多的复制操作，效率将会变低，老年代也没有额外的空间做担保，所以老年代一般不能直接使用这种算法。</p><p><img alt="CyC" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" src="/img/loading.gif" class="lazyload"></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><ul><li><p>不会产生内存碎片</p></li><li><p>需要移动大量对象，处理效率比较低。</p></li></ul><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>分代收集顾名思义就是分代来收集，针对不同的代执行不同的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：少量存活对象，采用复制算法只需要付出少量的复制成本就可以完成收集。</li><li>老年代使用：存活率高没有担保，采用标记 - 清除 或者 标记 - 整理 算法，</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190813/3f2uQGV4SjI4.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><strong>Serial（串行）</strong>收集器是最基本、发展历史最悠久的收集器，它是采用<code>复制算法</code>的<code>新生代收集器</code>，曾经（JDK 1.3.1之前）是虚拟机<code>新生代</code>收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是<strong>它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）</strong>。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。</p><p>下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190813/03PTqvGk6jdy.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>为了消除或减少工作线程因内存回收而导致的停顿，HotSpot虚拟机开发团队在JDK 1.3之后的Java发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着Serial收集器已经“老而无用”，实际上到现在为止，它依然是<strong>HotSpot虚拟机运行在Client模式下的默认的新生代收集器</strong>。它也有着优于其他收集器的地方：<strong>简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</strong></p><p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p><code>ParNew</code>收集器就是Serial收集器的多线程版本，它也是一个<code>新生代收集器</code>。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。</p><p>ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190813/NDuVa0QjwwYM.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，<code>除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作</code>，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。</p><p>ParNew 收集器在<code>单CPU的环境</code>中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在多CPU环境下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用<code>-XX:ParallerGCThreads</code>参数设置。</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p><code>Parallel Scavenge</code>收集器也是一个并行的多线程<code>新生代收集器</code>，它也使用<code>复制算法</code>。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。</p><blockquote><p><strong>吞吐量</strong>：CPU用于运行用户代码的时间和CPU消耗的总时间（CPU执行时间+垃圾收集时间）的比值</p><p><strong>单线程与多线程</strong>：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</p><p><strong>并行（Parallel）</strong>：指多条垃圾收集线程同时执行，但是此时用户线程仍然处于等待状态，也就是说和用户线程是串行的。</p><p><strong>并发（Concurrent）</strong>：并发指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以并行的方式执行。</p></blockquote><p><code>停顿时间越短就越适合需要与用户交互的程序</code>，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在<code>后台运算而不需要太多交互的任务</code>。</p><p><code>Parallel Scavenge</code>  提供了两个参数用于较精确控制吞吐量</p><ul><li><p><code>-XX:MaxGCPauseMills</code> 控制最大垃圾收集停顿时间</p></li><li><p><code>-XX:GCTimeRatio</code> 直接设置吞吐量大小</p></li></ul><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数<code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为<code>GC自适应的调节策略（GC Ergonomics）</code>。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别</p><p>另外值得注意的一点是，Parallel Scavenge收集器<code>无法与CMS收集器配合使用</code>，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。</p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器的老年代版本，同样是单线程，使用标记整理算法</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190813/y1H9NyikWogV.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这个收集器的主要意义是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用（下面会介绍）。</li></ul><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>是 Parallel Scavenge 收集器的老年代版本。</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190813/itz21ThRoKAD.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器</p><h4 id="CMS收集器（Concurrent-Mark-Sweep）"><a href="#CMS收集器（Concurrent-Mark-Sweep）" class="headerlink" title="CMS收集器（Concurrent Mark Sweep）"></a>CMS收集器（Concurrent Mark Sweep）</h4><p>并发的老年代收集器，Mark Sweep 指的是标记 - 清除算法，它的运作相对前面几种来说要更加复杂一些，整体分为4哥步骤</p><ul><li><strong>初始标记</strong>：仅仅是标记一下GC Root能直接关联到的对象，速度很快，需要停顿</li><li><strong>并发标记</strong>：进行GC Root Tracing的过程，它在整个回收过程中耗时最长，不需要停顿，</li><li><strong>重新标记</strong>：为了<code>修正</code>并发标记阶段程序继续运行导致标记变化的那一部分对象的标记记录，需要停顿</li><li><strong>并发清除</strong>：不需要停顿</li></ul><p>在整个过程中耗时最长的<code>并发标记</code>和<code>并发清除</code>过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190813/zJiEhyXRjfTO.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>缺点</strong></p><ul><li><p>对CPU资源非常敏感 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受，后面出现了<code>i-CMS</code>让GC线程和用户线程交替运行，但是表现很一般已被弃用。</p></li><li><p>无法处理<code>浮动垃圾</code>，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存给用户线程使用，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够用户线程运行，就会出现 <code>Concurrent Mode Failure</code>，jdk1.6之后虚拟机会临时启用 Serial Old 来替代 CMS。</p></li><li><p>标记-清除算法导致的空间碎片 CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发<code>Full GC</code></p></li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190814/o8sxTPY30GnJ.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190814/3olH4WWVEysA.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个<code>优先列表</code>，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>但是即使是这样分了Region垃圾回收器就一定会以Region为单位分配么？显然是不可能的，Region不可能完全独立，一个对象分配在Region中并不是只能被当前Region部分引用，而是可以与整个Java堆的任意对象发生引用关系，这样在做可达性分析的时候岂不是仍然需要遍历整个堆? 这个问题并不是只在G1中存在，其他收集器也会存在，只是G1这样划分之后问题更加突出了，在<code>G1收集器</code>中每个 Region 都有一个 Remembered Set，用来记录该 Region 对象<code>的引用对象</code>所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ul><li><strong>初始标记（Initial Marking）</strong> 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。</li><li><strong>并发标记（Concurrent Marking）</strong> 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li><li><strong>最终标记（Final Marking）</strong> 为了修正在<code>并发标记期间</code>因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要<code>停顿线程</code>，但是可并行执行。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong> 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，<code>但是因为只回收一部分Region，时间是用户可控制的</code>，而且停顿用户线程将大幅度提高收集效率。</li></ul><p><strong>特点</strong></p><ul><li><strong>并行与并发</strong> G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li><strong>分代收集</strong> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li><li><strong>空间整合</strong> G1从整体来看是基于<code>“标记-整理”</code>算法实现的收集器，从局部（两个Region之间）上来看是基于<strong>“复制”</strong>算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong> 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><h4 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h4><p>GC(Garbage Collection)是Java虚拟机中一个很重要的组成部分，在很多情况下我们都需要查看它的日志，下面内容就是介绍如何查看GC日志。</p><p>可选参数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 <span class="number">2013</span>-<span class="number">05</span>-<span class="number">04</span>T21:<span class="number">53</span>:<span class="number">59.234</span>+<span class="number">0800</span>）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试类</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * vm参数 ：-XX:+PrintGCDetails 输出GC的详细日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]; <span class="comment">//10M</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        GCTest gcTest = <span class="keyword">new</span> GCTest();</span><br><span class="line">        gcTest=<span class="keyword">null</span>; <span class="comment">//for gc</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"GC Test"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>控制台打印结果</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">12902</span>K-><span class="number">712</span>K(<span class="number">38400</span>K)] <span class="number">12902</span>K-><span class="number">720</span>K(<span class="number">125952</span>K), <span class="number">0.3622244</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.36</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 712K->0<span class="title">K</span><span class="params">(<span class="number">38400</span>K)</span>] [ParOldGen: 8K->638<span class="title">K</span><span class="params">(<span class="number">87552</span>K)</span>] 720K->638<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, [Metaspace: 3438K->3438<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0103044 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">GC Test</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">38400</span>K, used <span class="number">998</span>K [<span class="number">0x00000000d5e00000</span>, <span class="number">0x00000000d8880000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">33280</span>K, <span class="number">3</span>% used [<span class="number">0x00000000d5e00000</span>,<span class="number">0x00000000d5ef9b20</span>,<span class="number">0x00000000d7e80000</span>)</span><br><span class="line">  from space <span class="number">5120</span>K, <span class="number">0</span>% used [<span class="number">0x00000000d7e80000</span>,<span class="number">0x00000000d7e80000</span>,<span class="number">0x00000000d8380000</span>)</span><br><span class="line">  to   space <span class="number">5120</span>K, <span class="number">0</span>% used [<span class="number">0x00000000d8380000</span>,<span class="number">0x00000000d8380000</span>,<span class="number">0x00000000d8880000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">87552</span>K, used <span class="number">638</span>K [<span class="number">0x0000000081a00000</span>, <span class="number">0x0000000086f80000</span>, <span class="number">0x00000000d5e00000</span>)</span><br><span class="line">  object space <span class="number">87552</span>K, <span class="number">0</span>% used [<span class="number">0x0000000081a00000</span>,<span class="number">0x0000000081a9fb68</span>,<span class="number">0x0000000086f80000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3446</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br></pre></td></tr></tbody></table></figure></div><p><code>PSYoungGen</code> 看见这个其实就猜的到了，Parallel Scavenge收集器收集的新生代，代表GC的区域和收集器。下面的<code>ParOldGen</code>对应的就是Parallel Old的老年代 ，PSYoungGen后面紧跟的 <code>12902K->712K(38400K)</code> 则代表 <code>GC前该区域已经使用的容量 -> GC后该区域已使用的容量（该区域总容量）</code>  ，而方括号外面的部分则代表 <code>GC前Java堆已使用量 -> GC后Java堆已使用量（Java堆中容量）</code> 。</p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><ul><li><strong>Minor GC</strong>：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li><strong>Full GC</strong>：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多，出现Full GC通常会伴随着Minor GC，但是并不一定有时候也会直接进行Full GC。</li></ul><p>对象的内存分配，往大的方向讲就是在堆上分配内存（也有可能被JIT拆散并间接的在栈上分配），对象主要分配在新生代的<code>Eden</code> 区上，如果启动了<code>本地线程分配缓冲</code>（TLAB） 会优先在TLAB上分配，少数情况也会直接分配在老年代中，分配的规则不是确定的，取决于垃圾收集器的组合以及虚拟机相关的参数的设置。</p><blockquote><p>-Xms  初始Heap大小</p><p>-Xmx  java heap最大值 </p><p>-Xmn  Young generation的heap大小</p></blockquote><h4 id="对象优先分配在Eden上"><a href="#对象优先分配在Eden上" class="headerlink" title="对象优先分配在Eden上"></a>对象优先分配在Eden上</h4><p>大多数情况，对象会直接在新生代Eden上分配。当Eden区没有足够的区域进行分配的时候，虚拟机将会发起一次<code>Minor GC</code> 。</p><p>下面我们通过代码来感受一下这个过程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1M= <span class="number">1024</span>*<span class="number">1024</span>; <span class="comment">//1m</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">        -verbose:gc</span></span><br><span class="line"><span class="comment">        -Xms20M 限制Java堆大小20M不可扩展</span></span><br><span class="line"><span class="comment">        -Xmx20M</span></span><br><span class="line"><span class="comment">        -Xmn10M 10M分配给新生代</span></span><br><span class="line"><span class="comment">        -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">byte</span>[] alloc1,alloc2,alloc3,alloc4;</span><br><span class="line">        alloc1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1M];</span><br><span class="line">        alloc2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1M];</span><br><span class="line">        alloc3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1M];</span><br><span class="line">        System.out.println(<span class="string">"GC Test"</span>); <span class="comment">//发生GC</span></span><br><span class="line">        alloc4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>*_1M];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>控制台打印</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">GC Test</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">8002</span>K-><span class="number">696</span>K(<span class="number">9216</span>K)] <span class="number">8002</span>K-><span class="number">6840</span>K(<span class="number">19456</span>K), <span class="number">0.0028974</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 696K->0<span class="title">K</span><span class="params">(<span class="number">9216</span>K)</span>] [ParOldGen: 6144K->6783<span class="title">K</span><span class="params">(<span class="number">10240</span>K)</span>] 6840K->6783<span class="title">K</span><span class="params">(<span class="number">19456</span>K)</span>, [Metaspace: 3439K->3439<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0042088 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">9216</span>K, used <span class="number">3154</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K, <span class="number">38</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff914930</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">10240</span>K, used <span class="number">6783</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space <span class="number">10240</span>K, <span class="number">66</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff29fc88</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3446</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br></pre></td></tr></tbody></table></figure></div><p>在<code>alloc4</code>的时候 发现空间已经不足以装下了，所以进行了一次Minor GC，随后GC掉了YoungGen大概6M的空间，但是这些对象大于<code>from</code> 和<code>to</code> 两块<code>Survivor</code> 区域无法直接存入所以通过分配担保进入老年代中，可以看到后面老年代66%的占用存放的就是这几个对象。GC结束后，<code>alloc4</code> 也顺利的进入的<code>Eden</code> </p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓的大对象其实就是需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串以及数组，比如我上面代码中的byte数组，经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”这些大对象，所以应该避免产生“朝生夕死”的短命大对象。</p><p>虚拟机提供了一个  <code>-XX: PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配（只对Serial和ParNew两款收集器有效，Parallel一般不用设置）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1M= <span class="number">1024</span>*<span class="number">1024</span>; <span class="comment">//1m</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">        -verbose:gc</span></span><br><span class="line"><span class="comment">        -Xms20M 限制Java堆大小20M不可扩展</span></span><br><span class="line"><span class="comment">        -Xmx20M</span></span><br><span class="line"><span class="comment">        -Xmn10M 10M分配给新生代</span></span><br><span class="line"><span class="comment">        -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">byte</span>[] alloc1,alloc2,alloc3,alloc4;</span><br><span class="line">        alloc1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">9</span>*_1M];</span><br><span class="line">        System.out.println(<span class="string">"GC Test"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>控制台打印</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">GC Test</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">9216</span>K, used <span class="number">2022</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K, <span class="number">24</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff7f9990</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">10240</span>K, used <span class="number">9216</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space <span class="number">10240</span>K, <span class="number">90</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff500010</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3447</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这个对象几乎全部被放到了老年代里面，老年代占用率 90%</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机为对象定义年龄计数器 Age，对象在 Eden 出生并经过 Minor GC 依然存活并且能被Survivor容纳的话，将移动到 Survivor 中，年龄就增加 1 岁，对象在Survivor区域每熬过一次 Minor GC年龄就增加一岁，当他的年龄增加到一定程度（默认为15岁），就会将它移动到老年代中（很形象有没有 😁）<br><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</p><h4 id="动态年龄判定"><a href="#动态年龄判定" class="headerlink" title="动态年龄判定"></a>动态年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 <code>Survivor</code> 中<code>相同年龄</code>所有对象大小的总和大于 <code>Survivor 空间的一半</code>，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的<code>连续空间</code>是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代<br>最大可用的连续空间是否<code>大于</code>历次晋升到老年代对象的<code>平均大小</code>，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC，如果出现了担保失败，那就只好发起一次<code>Full GC</code>  ，绕的圈子是最大的，但是一般情况下这个开关还是默认打开的，避免产生太多的Full GC，JDK1.6之后这个参数就被废掉了，<code>只要老年代的连续空间大于新生代总空间或者每次晋升的平均大小就进行Minor GC否则进行Full GC</code></p><h4 id="Full-GC触发条件"><a href="#Full-GC触发条件" class="headerlink" title="Full GC触发条件"></a>Full GC触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间快满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下情况：</p><p><strong><em>调用 System.gc()</em></strong><br>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><p><strong><em>老年代空间不足</em></strong><br>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。<br>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数<br>调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对<br>象进入老年代的年龄，让对象在新生代多存活一段时间。</p><p><strong><em>空间分配担保失败</em></strong><br>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><p><strong><em>JDK 1.7 及以前的永久代空间不足</em></strong><br>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据<br>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也<br>会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。<br>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><p><strong><em>Concurrent Mode Failure</em></strong><br>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>周志明《深入理解Java虚拟机》</strong></p><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=minor-gc-%e5%92%8c-full-gc" target="_blank" rel="noopener">CYC大佬的博客🙏</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自旋锁，CLH锁，MCS锁</title>
      <link href="/2019/08/10/zi-xuan-suo-clh-suo-mcs-suo/"/>
      <url>/2019/08/10/zi-xuan-suo-clh-suo-mcs-suo/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁(spin lock)是一个典型的对临界资源的互斥手段，自旋锁是基于CAS原语的，所以它是轻量级的同步操作，它的名称来源于它的特性。自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。由于自旋锁只不进行线程状态的改变（挂起线程），所以当线程竞争不激烈时，它的响应速度极快（因为<code>避免了线程调度的上下文切换</code>）。自旋锁适用于锁保护的临界区很小的情况，线程竞争不激烈的场景下。如果线程之间竞争激烈或者临界区的操作特别耗时，那么线程的自旋操作就会耗费大量的cpu资源，所以这种情况下性能就会下降明显。</p><h3 id="简单自旋锁"><a href="#简单自旋锁" class="headerlink" title="简单自旋锁"></a>简单自旋锁</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSpinLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> AtomicReference<thread> owner = <span class="keyword">new</span> AtomicReference<thread>();</thread></thread></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 如果锁未被占用，则设置当前线程为锁的拥有者</span></span><br><span class="line">        <span class="comment">// 后面解锁的就只能是当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (!owner.compareAndSet(<span class="keyword">null</span>, currentThread)) {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 只有锁的拥有者才能释放锁</span></span><br><span class="line">        owner.compareAndSet(currentThread, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>缺点</strong></p><ul><li><p>CAS操作需要硬件的配合（现代处理器大多都支持）</p></li><li><p>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重（这是由于Atomic的volatile变量导致的，同时这也是必须的）</p></li><li><p>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。</p></li></ul><h3 id="Ticket-Lock"><a href="#Ticket-Lock" class="headerlink" title="Ticket Lock"></a>Ticket Lock</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 服务号</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger ticketNum = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 排队号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 首先原子性地获得一个排队号</span></span><br><span class="line">        <span class="keyword">int</span> myTicketNum = ticketNum.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要当前服务号不是自己的就不断轮询</span></span><br><span class="line">        <span class="keyword">while</span> (serviceNum.get() != myTicketNum) {</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> myTicketNum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">int</span> myTicket)</span> </span>{</span><br><span class="line">        <span class="comment">// 解锁后只有拥有该线程的下一个排队号线程才能加锁,保证了公平性,不会有插队的情况</span></span><br><span class="line">        <span class="keyword">int</span> next = myTicket + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只有当前线程拥有者才能释放锁</span></span><br><span class="line">        serviceNum.compareAndSet(myTicket, next);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>缺点</strong></p><p>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</p><h3 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h3><p>CLH的发明人是：Craig，Landin and Hagersten，三个人的名字合称</p><p>CLH锁是一种基于隐式链表（节点里面没有next指针）的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>; <span class="comment">// 默认是在等待锁</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater<clhlock, clhnode> UPDATER = AtomicReferenceFieldUpdater</clhlock,></span><br><span class="line">            . newUpdater(CLHLock.class, CLHNode .class , "tail" );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(CLHNode currentThreadNode)</span> </span>{</span><br><span class="line">        <span class="comment">//获取之前的尾结点, 然后将自己设置为尾节点</span></span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet( <span class="keyword">this</span>, currentThreadNode);</span><br><span class="line">        <span class="keyword">if</span>(preNode != <span class="keyword">null</span>) {<span class="comment">//已有线程占用了锁，进入自旋</span></span><br><span class="line">            <span class="keyword">while</span>(preNode.isLocked ) {</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(CLHNode currentThreadNode)</span> </span>{</span><br><span class="line">        <span class="comment">// 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。</span></span><br><span class="line">        <span class="comment">// 尝试设置尾节点为自己, 传入的期望值是自己,成功就代表队列中只有它一个</span></span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="keyword">this</span>, currentThreadNode, <span class="keyword">null</span>)) {</span><br><span class="line">            <span class="comment">// 还有后续线程</span></span><br><span class="line">            currentThreadNode.isLocked = <span class="keyword">false</span> ;<span class="comment">// 改变状态，让后续线程结束自旋</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里用到了<code>原子字段更新器</code>，让tail变量可以具有CAS的功能，具体可以参考之前的文章<a href="http://imlgw.top/2019/04/22/cas-yu-yuan-zi-bian-liang/#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8">CAS与原子变量</a></p><p><strong>缺点</strong></p><p>先说一下<code>NUMA</code>和<code>SMP</code>两种处理器结构<br>SMP(Symmetric Multi-Processor)，即对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。SMP的优点是<code>能够保证内存一致性</code>，缺点是这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。常用的PC机就属于这种。</p><p>NUMA(Non-Uniform Memory Access)非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，<code>访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度</code>，这也是非一致存储访问NUMA的由来。NUMA优点是可以较好地解决原来SMP系统的扩展问题，缺点是由于访问远地内存的延时远远超过本地内存，因此当CPU数量增加时，系统性能无法线性增加。</p><p><strong>CLH锁的缺点是在NUMA系统结构下性能很差，在这种系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，在SMP架构下能够保证内存一致性所以自旋判断较快</strong></p><h3 id="MCS锁"><a href="#MCS锁" class="headerlink" title="MCS锁"></a>MCS锁</h3><p>MCS Spinlock是一种基于显式链表（节点里面拥有next指针）的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，由直接前驱负责通知其结束自旋（与CLH自旋锁不同的地方，不在轮询前驱的状态，而是由前驱主动通知），从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。而MCS是在自己的结点的locked域上自旋等待。正因为如此，它解决了CLH在NUMA系统架构中获取locked域状态内存过远的问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/10 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSLock</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSNode</span> </span>{</span><br><span class="line">        <span class="comment">//持有后继者的引用</span></span><br><span class="line">        <span class="keyword">volatile</span> MCSNode next;</span><br><span class="line">        <span class="comment">// 默认是在等待锁</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> block = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> MCSNode tail;<span class="comment">// 指向最后一个申请锁的MCSNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater<mcslock, mcsnode> UPDATER = AtomicReferenceFieldUpdater</mcslock,></span><br><span class="line">            .newUpdater(MCSLock.class, MCSNode.class, "tail");</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(MCSNode currentThreadMcsNode)</span> </span>{</span><br><span class="line">        <span class="comment">//更新tail为最新加入的线程节点，并取出之前的节点（也就是当前节点的前驱）</span></span><br><span class="line">        MCSNode predecessor = UPDATER.getAndSet(<span class="keyword">this</span>, currentThreadMcsNode);</span><br><span class="line">        <span class="keyword">if</span> (predecessor != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//连接在tail的尾部</span></span><br><span class="line">            predecessor.next = currentThreadMcsNode;</span><br><span class="line">            <span class="comment">//轮询自己的isLocked属性</span></span><br><span class="line">            <span class="keyword">while</span> (currentThreadMcsNode.block) {</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//前驱节点为空直接获取锁,自己是第一个</span></span><br><span class="line">            currentThreadMcsNode.block = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(MCSNode currentThreadMcsNode)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (currentThreadMcsNode.block) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//判断是不是只有一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (currentThreadMcsNode.next == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//CAS 将tail设置为空</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATER.compareAndSet(<span class="keyword">this</span>, currentThreadMcsNode, <span class="keyword">null</span>)) {</span><br><span class="line">                <span class="comment">// 设置成功返回，没有其他线程等待锁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//CAS更新tail失败,有线程抢先一步执行lock更新了tail</span></span><br><span class="line">                <span class="comment">//但是可能还没有连接在 之前的tail(当前节点)后</span></span><br><span class="line">                <span class="keyword">while</span> (currentThreadMcsNode.next == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">//等待 predecessor.next = currentThreadMcsNode执行</span></span><br><span class="line">                    <span class="comment">//否则后面会报NPE</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//修改后继者的isLocked,通知后继者结束自旋</span></span><br><span class="line">        currentThreadMcsNode.next.block = <span class="keyword">false</span>;</span><br><span class="line">        currentThreadMcsNode.next = <span class="keyword">null</span>;<span class="comment">// for GC</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>传统的<code>Spin lock</code> 和 <code>Ticket Lock</code>都在同一个共享变量上竞争（例如SimpleSpinLock中的owner、Ticket Lock中的serviceNum），这样对给CPU保证缓存一致性带来的压力比较大，每次读写都需要同步到所有的线程，而MCS和CLH最大的优化点在于把上述同一个点上的竞争分散到队列的每个节点中去了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列</title>
      <link href="/2019/08/07/zu-sai-dui-lie/"/>
      <url>/2019/08/07/zu-sai-dui-lie/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p><strong>非阻塞队列中的几个主要方法：</strong></p><ul><li><p><code>add(E e)</code>:将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常</p></li><li><p><code>remove()</code>:移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常</p></li><li><p><code>offer(E e)</code>：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false</p></li><li><p><code>poll()</code>：移除并获取队首元素，若成功，则返回队首元素；否则返回null</p></li><li><p><code>peek()</code>：获取队首元素，若成功，则返回队首元素；否则返回null</p></li></ul><p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。</p><p><strong>阻塞队列中的几个主要方法：</strong></p><p>阻塞队列包括了非阻塞队列中的大部分方法，上面列举的5个方法在阻塞队列中都存在，但是要注意这5个方法在阻塞队列中都进行了<strong>同步措施</strong>。除此之外，阻塞队列提供了另外4个非常有用的方法：</p><ul><li><p><code>put(E e)</code>方法用来向队尾存入元素，如果队列满，则等待</p></li><li><p><code>take()</code>方法用来从队首取元素，如果队列为空，则等待</p></li><li><p><code>offer(E e,long timeout, TimeUnit unit)</code>方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true</p></li><li><p><code>poll(long timeout, TimeUnit unit)</code>方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果没取到，则返回null；否则返回取得的元素</p></li></ul><h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><ul><li><strong>ArrayBlockingQueue</strong> ：一个由数组结构组成的有界阻塞队列。</li><li><strong>LinkedBlockingQueue</strong> ：一个由链表结构组成的有界阻塞队列。</li><li><strong>PriorityBlockingQueue</strong> ：一个支持优先级排序的无界阻塞队列。</li><li><strong>DelayQueue</strong>：一个使用优先级队列实现的无界阻塞队列。</li><li><strong>SynchronousQueue</strong>：一个不存储元素的阻塞队列。</li><li><strong>LinkedTransferQueue</strong>：一个由链表结构组成的无界阻塞队列。</li><li><strong>LinkedBlockingDeque</strong>：一个由链表结构组成的双向阻塞队列。</li></ul><blockquote><p>除了这几个外还有一个 <code>ScheduledThreadPoolExecutor.DelayedWorkQueue</code>这个其实是DelayQueue的优化</p></blockquote><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：</p><p><code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);</code></p><p>访问者的公平性是使用可重入锁实现的</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue是一个用链表实现的<strong>有界</strong>阻塞队列。此队列按照先进先出的原则对元素进行排序。</p><p>容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被<br>设置为 Integer.MAX_VALUE ，成为了无界队列。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue是一个支持优先级的无界队列。底层采用数组实现了二叉堆，相比PriorityQueue其实就是将默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>这个队列还是挺有意思的，DelayQueue是一个支持延时获取元素的无界阻塞队列。内部使用PriorityQueue来存储元素。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中<strong>取出</strong>元素。我们可以将DelayQueue运用在以下应用场景：</p><ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取(删除)元素时，表示缓存有效期到了。</li><li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。</li></ul><p>队列中的Delayed必须实现compareTo来指定元素的顺序。比如让延时时间最长的放在队列的末尾。实现代码如下：</p><p><strong>如何实现Delayed接口</strong></p><p>我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类。这个类实现了Delayed接口。</p><p>然后使用getDelay可以查询当前元素还需要延时多久，代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为getDelay时可以指定任意单位，一旦以纳秒作为单位，而延时的时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。</p><p><strong>如何实现延时队列</strong></p><p>延时队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedEle</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> delayTime; <span class="comment">//延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> expire;  <span class="comment">//到期时间</span></span><br><span class="line">    <span class="keyword">private</span> String data;   <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedEle</span><span class="params">(<span class="keyword">long</span> delay, String data)</span> </span>{</span><br><span class="line">        delayTime = delay;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        expire = System.currentTimeMillis() + delay;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剩余时间=到期时间-当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.expire - System.currentTimeMillis() , TimeUnit.MILLISECONDS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先队列里面优先级规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>{</span><br><span class="line">        <span class="comment">//根据delay时间</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) -o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"DelayedElement{"</span>);</span><br><span class="line">        sb.append(<span class="string">"delay="</span>).append(delayTime);</span><br><span class="line">        sb.append(<span class="string">", expire="</span>).append(expire);</span><br><span class="line">        sb.append(<span class="string">", data='"</span>).append(data).append(<span class="string">'\''</span>);</span><br><span class="line">        sb.append(<span class="string">'}'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/7 17:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        DelayQueue<delayedele> delayQueue = <span class="keyword">new</span> DelayQueue<delayedele>();</delayedele></delayedele></span><br><span class="line"></span><br><span class="line">        DelayedEle element1 = <span class="keyword">new</span> DelayedEle(<span class="number">3000</span>,<span class="string">"lgw"</span>);</span><br><span class="line">        DelayedEle element2 = <span class="keyword">new</span> DelayedEle(<span class="number">3000</span>,<span class="string">"top"</span>);</span><br><span class="line"></span><br><span class="line">        delayQueue.offer(element1);</span><br><span class="line">        delayQueue.offer(element2);</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(l);</span><br><span class="line">        element1 =  delayQueue.take();</span><br><span class="line">        System.out.println(System.currentTimeMillis()-l);</span><br><span class="line"></span><br><span class="line">        System.out.println(element1);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 测试结果</span></span><br><span class="line"><span class="comment"> *  1565176036796</span></span><br><span class="line"><span class="comment"> *  3016</span></span><br><span class="line"><span class="comment"> *  DelayedElement{delay=3000, expire=1565176039796, data='lgw'}</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue 和 ArrayBlockingQueue。</p><blockquote><p>线程池工厂方法 <strong>newCachedThreadPool</strong> 底层就是用的Synchronized</p></blockquote><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>TransferQueue相比SynchronousQueue用处更广、更好用，因为你可以决定是使用BlockingQueue的方法（译者注：例如put方法）还是确保一次传递完成（译者注：即transfer方法）。在队列中已有元素的情况下，调用transfer方法，可以确保队列中被传递元素之前的所有元素都能被处理。<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html" target="_blank" rel="noopener">Doug Lea说</a>从功能角度来讲，LinkedTransferQueue实际上是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。</p><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列LinkedTransferQueue多了tryTransfer和transfer方法。</p><p>LinkedTransferQueue与SynchronousQueue中公平模式的实现TransferQueue是一样的，队列中存放的不是数据，而是操作（取出数据的操作take和放入数据的操作put）队列中既可以存放take操作也可以存放put操作，但是队列中不能同时存在两种不同的操作，因为不同的操作会触发队列进行配对（操作出队）。</p><p><strong>transfer方法</strong>。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (haveData && (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {                            <span class="comment">// restart on append race</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) { <span class="comment">// find & match first node</span></span><br><span class="line">            <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">            Object item = p.item;</span><br><span class="line">            <span class="keyword">if</span> (item != p && (item != <span class="keyword">null</span>) == isData) { <span class="comment">// unmatched</span></span><br><span class="line">                <span class="keyword">if</span> (isData == haveData)   <span class="comment">// can't match</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (p.casItem(item, e)) { <span class="comment">// match</span></span><br><span class="line">                    <span class="keyword">for</span> (Node q = p; q != h;) {</span><br><span class="line">                        Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                        <span class="keyword">if</span> (head == h && casHead(h, n == <span class="keyword">null</span> ? q : n)) {</span><br><span class="line">                            h.forgetNext();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }                 <span class="comment">// advance and retry</span></span><br><span class="line">                        <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                            (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                            <span class="keyword">break</span>;        <span class="comment">// unless slack < 2</span></span><br><span class="line">                    }</span><br><span class="line">                    LockSupport.unpark(p.waiter);</span><br><span class="line">                    <span class="keyword">return</span> LinkedTransferQueue.<e>cast(item);</e></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            Node n = p.next;</span><br><span class="line">            p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (how != NOW) {                 <span class="comment">// No matches available</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">            <span class="comment">//（1）尝试添加到链表尾部</span></span><br><span class="line">            Node pred = tryAppend(s, haveData);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">            <span class="comment">//（2）等待消费者消费</span></span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>（1）代码是试图把存放当前元素的s节点作为tail节点。（2）代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。</p><p><strong>tryTransfer方法</strong>。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。</p><p>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p><p><strong>实例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> juc_study.collection.blocking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedTransferQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedTransferQueueDemo</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> LinkedTransferQueue<string> lnkTransQueue = <span class="keyword">new</span> LinkedTransferQueue<string>();</string></string></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ExecutorService exService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> LinkedTransferQueueDemo().<span class="keyword">new</span> Producer();</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> LinkedTransferQueueDemo().<span class="keyword">new</span> Consumer();</span><br><span class="line">        exService.execute(producer);</span><br><span class="line">        exService.execute(consumer);</span><br><span class="line">        exService.shutdown();</span><br><span class="line">    }</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">3</span>;i++){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"Producer is waiting to transfer..."</span>);</span><br><span class="line">                    lnkTransQueue.transfer(<span class="string">"A"</span>+i);</span><br><span class="line">                    System.out.println(<span class="string">"producer transfered element: A"</span>+i);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">3</span>;i++){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"Consumer is waiting to take element..."</span>);</span><br><span class="line">                    String s= lnkTransQueue.take();</span><br><span class="line">                    System.out.println(<span class="string">"Consumer received Element: "</span>+s);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是Jdk的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以初始化队列的容量，用来防止其再扩容时过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/bzhangpoorman/blog/3044802" target="_blank" rel="noopener">并发容器学习—LinkedTransferQueue</a></p><p><a href="https://blog.csdn.net/YJian2008/article/details/16951811" target="_blank" rel="noopener">阻塞队列之LinkedTransferQueue</a></p><p><a href="https://www.jianshu.com/p/2659eb72134b" target="_blank" rel="noopener">并发队列-无界阻塞延迟队列DelayQueue原理探究</a></p><p><a href="http://ifeve.com/blocking-queues/" target="_blank" rel="noopener">并发编程网</a></p><p><a href="http://ifeve.com/java-transfer-queue/" target="_blank" rel="noopener">Java 7中的TransferQueue</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入ThreadPoolExecutor源码</title>
      <link href="/2019/07/30/executor-kuang-jia/"/>
      <url>/2019/07/30/executor-kuang-jia/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="深入ThreadPoolExecutor源码"><a href="#深入ThreadPoolExecutor源码" class="headerlink" title="深入ThreadPoolExecutor源码"></a>深入ThreadPoolExecutor源码</h2><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190802/wTkHh1NbyM8K.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这里主要要说的是 <code>ThreadPoolExecutor</code>类</p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>打开源码映入眼帘的就是这几个字段和方法，对应的就是线程池的一些运行状态和相关方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//控制线程池中数量和状态的字段,用AtomicInteger保存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//count bit顾名思义就是 workerCount的位数，这里是29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//1<<29 -1 == 1111....1111(29个1) 线程数(workerCount)上限 大约5亿</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> << COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//高三位存放状态，相应的低29位就是workerCount</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> << COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> << COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> << COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> << COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> << COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 拆解ctl获取状态和数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>{ <span class="keyword">return</span> c & ~CAPACITY; }</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>{ <span class="keyword">return</span> c & CAPACITY; }</span><br><span class="line"><span class="comment">// 拼接状态和数量得到ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>{ <span class="keyword">return</span> rs | wc; }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="状态转换过程"><a href="#状态转换过程" class="headerlink" title="状态转换过程"></a>状态转换过程</h4><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190802/EWlphYbCMVjv.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>💡 <strong>RUNNING</strong> ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p><p>💡 <strong>SHUTDOWN</strong>：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 <code>RUNNING</code> 状态时，调用 <code>shutdown()</code>方法会使线程池进入到该状态。（<code>finalize()</code> 方法在执行过程中也会调用shutdown()方法进入该状态）</p><p>💡 <strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 <code>RUNNING</code> 或 <code>SHUTDOWN</code> 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态</p><p>💡 <strong>TIDYING</strong>：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态</p><p>💡 <strong>TERMINATED</strong>：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</p><p>进入<code>TERMINATED</code>的条件如下：</p><ul><li>线程池不是RUNNING状态；</li><li>线程池状态不是TIDYING状态或TERMINATED状态；</li><li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li><li>workerCount为0；</li><li>设置TIDYING状态成功。</li></ul><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>再往下，就会看见一些很重要的成员变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//任务缓存队列，存放待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue<runnable> workQueue; </runnable></span><br><span class="line"><span class="comment">//可重入锁，线程池主要的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//线程集合(线程池的workers集合)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet<worker> workers = <span class="keyword">new</span> HashSet<worker>();</worker></worker></span><br><span class="line"><span class="comment">//对应的条件变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition(); </span><br><span class="line"><span class="comment">//用来记录线程池中曾经出现过的最大线程数，和线程池容量没有关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//用来记录已经执行完毕的任务个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount; </span><br><span class="line"><span class="comment">//工厂方法，用来创建线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory; </span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; </span><br><span class="line"><span class="comment">//线程闲置时候的最大存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime; </span><br><span class="line"><span class="comment">//是否允许核心线程闲置的时候超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut; </span><br><span class="line"><span class="comment">//核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize; </span><br><span class="line"><span class="comment">//最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize; </span><br><span class="line"><span class="comment">//默认的拒绝策略：AbortPolicy直接拒绝并抛异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br></pre></td></tr></tbody></table></figure></div><h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p> <strong>源码分析</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程池的状态和线程数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) < corePoolSize) { <span class="comment">//workerCount小于核心线程数量</span></span><br><span class="line">        <span class="comment">//将任务添加到workers中，第二个参数代表是否根据corePoolSize来添加线程，false则根据maxPoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//添加失败，重新获取ctl</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面添加到workers中失败，有可能是核心线程不够用了或者线程池不是运行状态</span></span><br><span class="line">    <span class="comment">//如果线程池是Running状态 尝试添加任务到阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) && workQueue.offer(command)) {</span><br><span class="line">        <span class="comment">//添加到等待队列成功，重新获取ctl</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//如果线程池不是Running状态就从等待队列中remove这个任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) && remove(command))</span><br><span class="line">            reject(command); <span class="comment">//采用拒绝策略拒绝该任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//线程池Running但是没有线程</span></span><br><span class="line">            <span class="comment">//创建一个线程但是不传入Runnable(已经在阻塞队列中了)</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//两种情况</span></span><br><span class="line">    <span class="comment">//1. 线程池不是Running状态并且command不为null，addWorker会直接false然后拒绝这个任务</span></span><br><span class="line">    <span class="comment">//2. 添加到workQueue(阻塞队列)失败，也就是 queue满了，可能是需要扩容了</span></span><br><span class="line">    <span class="comment">//   所以后面的参数是false，添加失败也会直接拒绝</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里要理解addWorker的第二个参数，true则代表当前线程池的<strong>上界</strong>仍然是corePoolSize，后面的addWorker会根据上界来判断是否增加线程，false则代表<strong>上界</strong>是maximumPoolSize，这一点在后面的分析中会看到。</p><p><strong>Executor大致执行流程</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190803/j3xQrmOkc3Kl.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker()"></a>addWorker()</h3><p><code>addWorker()</code> 的作用就是创建线程(Worker)并且添加到Workers集合中，然后启动线程</p><p><strong>源码分析</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>{</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rs>=SHUTDOWN说明不是RUNNING状态</span></span><br><span class="line">        <span class="keyword">if</span> (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == <span class="keyword">null</span> &&!workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//如果大于可允许的最大线程数，或者大于当前的线程池的上界，直接false</span></span><br><span class="line">            <span class="comment">//上面传入的第二个参数的作用体现出来了，为true上界则是corePoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//利用CAS自增 增大workCount线程数，成功后就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//CAS失败，重新获取ctl</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//判断还是不是Running状态(能到这里说明rs==Running状态)，不是的话就跳出去重新来过</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            <span class="comment">// CAS失败并且还是Running状态，继续自旋尝试自增</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//线程是否启动，以及线程是否添加</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//创建一个Worker(对线程的封装)</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"><span class="comment">//是RUNNING状态 或者 是SHUTDOWN状态且没有提交任务(SHUTDOWN状态还可以执行阻塞队列的任务)</span></span><br><span class="line">                <span class="keyword">if</span> (rs < SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN && firstTask == <span class="keyword">null</span>)) {</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//添加到工作集中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s > largestPoolSize)</span><br><span class="line">                        largestPoolSize = s; <span class="comment">//记录最大值</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>; <span class="comment">//添加成功</span></span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                <span class="comment">//启动线程，执行Worker的run方法</span></span><br><span class="line">                t.start(); </span><br><span class="line">                workerStarted = <span class="keyword">true</span>; <span class="comment">//启动成功</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="comment">//启动失败，回滚workers并尝试关闭线程池</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 首先判断当前线程池的状态是否适合继续addWorker，分析这里的if条件，RUNNING不会false ，STOP，TIDYING，TERMINATED直接false，SHUTDOWN状态如果firstTask为空 阻塞队列中还有任务的时候不会false，其他情况都false。</p><p>🔸 获取当前的workerCount判断是否超过了当前的上界，这里就用到了第二个参数</p><p>🔸 然后利用CAS自旋增加workerCount</p><p>🔸 创建Worker对象，获取mainLock并加锁，因为workers是HashSet并不是线程安全的</p><p>🔸 再次获取线程池转台并判断是否合法，合法就添加到workers中，然后在finally块中释放锁</p><p>🔸 根据前面的workerAdded 判断是否启动线程</p><p>🔸 在最终的finally块中根据是否启动成功来决定是否回滚</p><h3 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed()"></a>addWorkerFailed()</h3><p>启动失败，回滚之前的添加操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//从workers中移除</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//减少workerCount</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">//尝试关闭线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>封装了线程对象，线程池维护的就是这些worker</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask; <span class="comment">//传入的任务</span></span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) {</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 设置状态为 -1</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//根据工厂方法创建线程</span></span><br><span class="line">        <span class="comment">//将Worker传递进去，作为Thread的参数</span></span><br><span class="line">        <span class="comment">//new Thread(Worker worker);</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="comment">// 是否获取到了锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">        <span class="comment">//利用CAS设置state</span></span><br><span class="line">        <span class="comment">//很明显这里是个不可重入的独占锁，具体可以对比ReentrantLock的实现方法</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br><span class="line">            <span class="comment">//保存当前的持有锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放锁设置state=0</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">        <span class="comment">//设置独占锁线程为空</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>{ acquire(<span class="number">1</span>); } <span class="comment">//最终会调用tryAcquire(1);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>{ <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>{ release(<span class="number">1</span>); } <span class="comment">//最终会调用tryRelease(1);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>{ <span class="keyword">return</span> isHeldExclusively(); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打断已经启动的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() >= <span class="number">0</span> && (t = thread) != <span class="keyword">null</span> && !t.isInterrupted()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                t.interrupt();</span><br><span class="line">            } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里可以看到Worker继承了AQS并且实现了Runnable接口，然后借助AQS实现了一个<code>独占的不可重入的锁</code>，其实这也是很巧妙的一点（这里我和博客上的理解有点出入）。</p><p>到这里大家肯定会有疑问，为什么这里要实现AQS然后实现一个锁？既然要又为什么要实现一个不可重入的，而不直接使用<code>ReentrantLock</code> 那不是更加方便么？？除此之外还有一个小细节就是构造器里面为什么<code>setState(-1)</code>  这样不就获取不到锁了么？？</p><p>其实这是为了后面<code>shutdown</code>的时候<code>interruptIdleWorkers</code>能判断出线程是否在工作，从而打断那些空闲的线程。如果使用可重入锁的话就无法通过<code>tryLock()</code> 来判断线程是否在工作。而<code>setState(-1)</code> 则是为了防止在任务没有开始前被打断</p><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker()"></a>runWorker()</h3><p>在上面<code>AddWorker()</code>最后添加成功后会启动Worker线程，而在worker线程中run方法又会调用一个<code>runWorker()</code>方法，这里就是具体执行任务的地方</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>{</span><br><span class="line">    <span class="comment">//当前执行线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">//拿到任务</span></span><br><span class="line">    Runnable task = w.firstTask; </span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//前面构造worker的时候设置了state=-1</span></span><br><span class="line">    <span class="comment">//设置state为0，tryRelease(1)</span></span><br><span class="line">    <span class="comment">//其实这样是为了在这之前不会被打断（还没有开始执行任务）</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>; <span class="comment">//是否因为异常而退出？</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//task为空就从阻塞队列中拿任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//加锁，但是这个锁不会和其他的Worker互斥，这个锁只是用来判断worker是否在工作</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &&</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &&</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">//打断当前执行线程wt</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//空方法交给子类去实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task.run(); <span class="comment">//执行任务</span></span><br><span class="line">                } <span class="keyword">catch</span> (RuntimeException x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Error x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">//空方法交给子类去实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++; <span class="comment">//完成任务数++</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>; <span class="comment">//下面的收尾工作会根据这个判断是否调整线程数</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        processWorkerExit(w, completedAbruptly); <span class="comment">//收尾工作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 首先获取了参数传递进来的worker携带的任务</p><p>🔸 然后执行了w.unlock()，实际上这里就对应了上面Worker类构造器中的setState(-1)，正因为前面设置了state为 -1 所以在unlock()之前，获得锁的CAS操作肯定都会失败，当然这也是为了在任务启动前不会被打断，所以在这里unlock()就又将state设置为了0 也就表示可以通过CAS获得锁了，也可以被shutdown打断了。</p><p>🔸 然后这个线程就会执行worker中的任务，如果worker中任务为空就会从阻塞队列中获取任务</p><p>🔸 获取到任务后进入循环先进行 lock() 操作，这就代表已经开始执行任务了，这个时候shutdown就无法发送中断信号中断这个线程执行 (注意这个lock并不会和其他的worker互斥，因为每个Worker都是新new出来的，完全不相关的，他们的state状态都是独立的)</p><p>🔸 <code>runStateAtLeast(ctl.get(), STOP)</code> 返回<code>ctl.get() >= STOP</code>  ，判断线程池是否正在关闭如果是就打断该线程，如果不是需要确保线程不是Interrupt状态</p><p><code>If pool is stopping, ensure thread is interrupted;  if not, ensure thread is not interrupted.</code></p><p>🔸<code>beforeExecute()</code> 和<code>afterExecute()</code> 都是空方法交给子类去实现的。</p><p>🔸 到finally块里面就代表这个工作线程已经快要结束了，<code>processWorkerExit()</code>  就是处理一些”后事”的</p><h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h3><p>这个方法就是用来从阻塞队列中获取任务的，如果 <code>getTask()</code> 返回null，在<code>runWorker()</code> 里面接收到<code>null</code> 后就会<strong>跳出循环</strong>进而执行<code>finally</code> 块里面的<code>processWorkerExit()</code> 。而这也就意味着这个线程<code>执行结束</code>了，不会在执行任务了，剩下的就是等待JVM回收这个线程。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//是否超时？和keepAliveTime相关</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 如果线程池状态为SHUTDOWN并且任务队列没任务 或者 线程状态>=STOP</span></span><br><span class="line">        <span class="keyword">if</span> (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 是否允许线程超时 允许核心线程超时(主动超时)？ 或者wc大于了核心线程数(被动超时)</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc > corePoolSize;</span><br><span class="line"><span class="comment">//此时需要回收多余的线程</span></span><br><span class="line">        <span class="keyword">if</span> ((wc > maximumPoolSize || (timed && timedOut))</span><br><span class="line">            && (wc > <span class="number">1</span> || workQueue.isEmpty())) {</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">//cas减少线程数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//返回null</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//cas失败 继续循环</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//根据timed判断是限时获取还是直接获取</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take(); <span class="comment">//阻塞的获取</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//没获取到，超时了</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException retry) {</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸 获取线程池状态，如果线程池状态为SHUTDOWN并且任务队列没任务 或者 线程状态>=STOP 就通过CAS自旋减少线程数，然后返回null</p><p>🔸 判断是否允许当前线程获取任务超时，如果允许核心线程超时就代表所有线程都会超时限制，又或者是当前线程数超过了核心线程数，也就是经过了扩容，所以核心线程之外的线程都是有超时限制的。</p><p>🔸 如果 ① wc超过最大线程数  ②没超过最大线程数，但是超时了并且此时wc>1(留一个处理任务)③没超过最大线程数，但是超时了并且阻塞队列为空，此时需要回收多余的线程</p><p>🔸 根据timed选取从阻塞队列中获取任务的方式，要么是限时获取的poll或者一直阻塞的take，获取到了之后返回</p><h3 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit()"></a>processWorkerExit()</h3><p>看名字就知道是一个收尾的方法，执行线程结束后的一些必要收尾工作。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        <span class="comment">//如果是因为异常而退出则 getTask() 没有机会去调整线程数所以需要在这里调整</span></span><br><span class="line">        decrementWorkerCount();  <span class="comment">// wc--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//完成任务总数+=该worker完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//移除出线程集workers</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取ctl</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) {</span><br><span class="line">        <span class="comment">//非异常结束</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) {</span><br><span class="line">            <span class="comment">//最小值根据是否允许核心线程超时来判断</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> && ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>; <span class="comment">//如果最小为0并且任务队列不为空则保证线程池中至少有一个线程执行这些任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) >= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//1.异常结束，新增加一个线程到线程池,相当于替换了异常的线程</span></span><br><span class="line">        <span class="comment">//2.非异常结束，工作线程小于核心线程，增加线程，确保在不允许核心线程超时的情况下线程数不小于corePoolSize</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>runStateLessThan</code>  c < STOP 返回true就说明是<code>SHUTDOWN</code> 或者<code>RUNNING</code> ，到这里该工作线程（Worker）的生命周期就结束了。</p><h3 id="工作线程的生命周期"><a href="#工作线程的生命周期" class="headerlink" title="工作线程的生命周期"></a>工作线程的生命周期</h3><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190803/NbjiMxDqJlu4.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate()"></a>tryTerminate()</h3><p>在上面的处理收尾工作的<code>processWorkerExit()</code> 的时候中间调用了一个 <code>tryTerminate()</code> 方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//如果是在RUNNING状态 直接return</span></span><br><span class="line">        <span class="comment">//如果已经是TIDYING或者TERMINATED状态 直接return</span></span><br><span class="line">        <span class="comment">//如果是SHUTDOWN状态并且阻塞队列中还有任务 直接return</span></span><br><span class="line">        <span class="comment">//return就说明线程池还不到关闭的时候</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//到这里就说明要么是STOP状态，要么是SHUTDOWN状态阻塞队列也没任务了</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) { <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">//中断一个空闲的worker线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wc==0 没有线程存活了</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//CAS自旋 修改线程池状态为TIDYING</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    terminated(); <span class="comment">//空方法,交给子类去实现的</span></span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">//设置状态为 TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//唤醒termination上awiat的线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里最后的<code>termination.signalAll()</code> 实际上是唤醒的<code>awaitTermination()</code> 方法阻塞的线程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos <= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//限时等待</span></span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//CAS自旋设置线程池状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//打断idle(空闲)的worker</span></span><br><span class="line">        interruptIdleWorkers(); </span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里关键的就是这个打断空闲线程的操作。</p><h3 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers()"></a>interruptIdleWorkers()</h3><p>打断空闲的worker，这里的空闲线程其实指的就是在阻塞队列上获取不到任务而阻塞的线程</p><p>经过上面的分析我们知道Worker会不断的从阻塞队列中去拿任务也就是 <code>getTask()</code> 方法，如果阻塞队列为空就会阻塞住 直到有任务提交到阻塞队列中，或者执行线程被中断。</p><p>这里我们是要SHUTDOWN那阻塞队列中肯定是不会再有任务提交，所以<code>take()</code> 会阻塞住，所以我们就只能通过打断执行线程的方式来打断<code>take()</code> 操作，否则会一直阻塞，线程池无法关闭。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); <span class="comment">//加锁，因为Wokers是HashSet是线程不安全的</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) {</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//没有被打断并且没有在工作(空闲)</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() && w.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">//打断Worker里面的线程</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    w.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//只打断一个就直接break</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>🔸首先获取了mainLock保证了workers的线程安全避免产生并发修改异常。</p><p>🔸然后遍历workers，打断那些没有被打断并且没有工作的线程，那这里怎么知道线程是不是在工作呢？</p><p>别忘了前面提到的Worker类借助AQS实现了一个<code>不可重入</code>的<code>lock</code> 方法，而在worker执行任务的时候会执行 <code>lock</code> 加锁，所以在这里<code>tryLock()</code> 如果返回<code>true</code>则说明 并没有在工作可以打断，反之如果正在工作<code>tryLock()</code> 不可重入，无法获取到自己持有的锁返回false，所以线程肯定是在工作状态所以不应该打断，这些线程会在执行完任务后自行了断，因为线程池状态已经设置为<code>SHUTDOWN</code> 当然前提是这些任务是<strong>可终止的</strong></p><p>🔸打断后释放<code>tryLock()</code>获取到的锁</p><p>🔸如果只打断一个就直接break，否则就继续下一轮循环</p><p>🔸释放mianLock</p><blockquote><p>瞎猜: 这里可以通过getState判断线程状态但是有可能在执行任务的过中阻塞</p></blockquote><h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h3><p>和上面的shutdown()一样都是用来关闭线程池的但是看方法名就知道这个比较粗暴，shutdownNow立刻马上关闭，一点情面都不给😂，虽然说是打断所有的线程但是毕竟使用的是<code>Interrupt</code> ，也许别人正在执行的线程根本就不会理你😂，所以在提交任务的时候要对任务进行正确的interrupt响应，或者确保线程不会一直阻塞否则线程池就无法正常关闭</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<runnable> <span class="title">shutdownNow</span><span class="params">()</span> </runnable></span>{</span><br><span class="line">    List<runnable> tasks;</runnable></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//CAS自旋设置状态为STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//打断所有的线程包括正在工作的线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//排干阻塞队列，因为已经STOP了不会再执行队列里面的任务了</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//尝试关闭线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="interruptWorkers"><a href="#interruptWorkers" class="headerlink" title="interruptWorkers()"></a>interruptWorkers()</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            <span class="comment">//打断所有启动的线程</span></span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>打断了所有的启动的线程，即使他们可能不会响应这个Interrupted信号，但是由于线程池状态已经变为了STOP，所以他们也活不长了(当然前提是执行的任务是可以结束的)，在下一次获取任务的时候就会直接return 。</p><h2 id="ThreadPoolExecutor使用"><a href="#ThreadPoolExecutor使用" class="headerlink" title="ThreadPoolExecutor使用"></a>ThreadPoolExecutor使用</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue<runnable> workQueue,</runnable></span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize < <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize <= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize < corePoolSize ||</span><br><span class="line">        keepAliveTime < <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实从中也可以看出对各个参数的一些限制。</p><p><strong>corePoolSize：</strong>核心池的大小，这个参数与后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。<code>默认情况下</code>，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中</p><p><strong>maximumPoolSize：</strong>线程池最大线程数，它表示在线程池中最多允许创建多少个线程</p><p><strong>keepAliveTime</strong>：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当<code>线程池中的线程数大于corePoolSize时</code>，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize：即当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize，但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0，这些内容其实在上面的深入源码中都有过分析。</p><p><strong>unit：</strong>参数keepAliveTime的时间单位</p><p><strong>workQueue</strong>：一个阻塞队列，用来存储等待执行的任务，这个参数的选择会对线程池的运行过程产生重大影响</p><p><strong>threadFactory</strong>：线程工厂，主要用来创建线程(根据传进来的Runnable/Callable)</p><p><strong>handler</strong>：表示当拒绝处理任务时的策略，有以下四种取值</p><ul><li><strong>ThreadPoolExecutor.AbortPolicy</strong> 丢弃任务并抛出RejectedExecutionException异常。 </li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong> 也是丢弃任务，但是不抛出异常。 </li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong> 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>  由调用线程处理该任务 </li></ul><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p><code>shutdown()</code>  <code>shutdownNow()</code> ，上面已经分析过了，就不再过多介绍了。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>上面的构造器中一共有7个参数，可见要构造一个线程池并非那么容易，所以jdk 在<code>Executors</code> 类中为我们提供了一些工厂方法，可以直接构造一些特定的线程池。</p><p><strong>newCachedThreadPool()</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue<runnable>());</runnable></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到<code>core</code>为0，最大值为<code>Integer.MAX_VALUE</code>，任务队列使用的<code>SynchronousQueue</code> ，这个队列是一个很奇葩的阻塞队列，实际上它不是一个真正的队列，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作，只有两个都准备好的时候才不会阻塞，所以它内部不会为队列元素维护空间，也就是说并不会缓存任务，一旦提交了(put)任务，要么就由空闲线程去执行(take)，要么创建一条新线程去执行(take)。</p><p><strong>newFixedThreadPool()</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue<runnable>());</runnable></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到，最大值和core都是 <code>nThread</code> ，也就是最多<code>nThread</code>个线程，阻塞队列采用 <code>LinkedBlockQueue</code> </p><p><strong>newSingleThreadExecutor()</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue<runnable>()));</runnable></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>等价于<code>newFixedThreadPool(1)</code> ，但是这里的返回值经过了一层包装 返回的不再是<code>ThreadPoolExecutor</code> 也就是不会再有那些扩展的monitor方法</p><blockquote><p>A wrapper class that exposes only the ExecutorService methods  of an ExecutorService implementation.</p></blockquote><p>类似的方法其实还有一些，像<code>newWorkStealingPool</code> 等，感兴趣可以自己去查一查。</p><p>其实这里阿里巴巴Java开发规范并不建议使用工厂方法创建线程</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190806/lMVPdlPqEPNO.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>所以建议还是通过构造器的方式去创建线程，这样也更加灵活更加可控。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发工具包</title>
      <link href="/2019/07/24/bing-fa-gong-ju-bao/"/>
      <url>/2019/07/24/bing-fa-gong-ju-bao/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>结合前面的知识，我们知道<code>Thread.join()</code>可以实现一个线程等待另一个线程<code>结束</code>再执行，但是有时候我们可能并不需要等到另一个线程结束，只需要等待特定的操作结束后就可以，可能有人会说可以通过<code>wait/notify</code>模型来实现，但是其实我们可以采用更加方便的工具类也就是 <code>java.util.concurrent.CountDownLatch</code>。</p><table><thead><tr><th>Constructor and Description</th></tr></thead><tbody><tr><td><code>CountDownLatch(int count)</code>   构造一个以给定计数 <code>CountDownLatch</code> CountDownLatch。</td></tr></tbody></table><p><strong>案例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random=<span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor=Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  CountDownLatch latch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">int</span>  []data=query();</span><br><span class="line">        <span class="comment">//构造器的参数代表需要执行的先决条件的数量</span></span><br><span class="line">        latch=<span class="keyword">new</span> CountDownLatch(data.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <data.length ; i++) {< span><br><span class="line">            executor.execute(<span class="keyword">new</span> SimpleRunnable(data,i,latch));</span><br><span class="line">        }</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="comment">//异步关闭</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"all of works done "</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> []data;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleRunnable</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> index, CountDownLatch latch)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.latch=latch;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">2000</span>));</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> value=data[index];</span><br><span class="line">            <span class="keyword">if</span> (value%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">                data[index]=<span class="number">2</span>*value;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                data[index]=<span class="number">10</span>*value;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" finished"</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query(){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line">    }</span><br><span class="line">}</span><br></data.length></span></pre></td></tr></tbody></table></figure></div><p><code>CountDownLatch</code>内部维护了一个未执行操作的计数器 <code>count</code>这个count需要通过构造器传入，CountDownLatch 实例的countdown方法每执行一次<code>count</code> 就会减一 ，在<code>count</code> 减为0之前<code>await</code> 方法的执行线程会被暂停，</p><p>直到<code>count</code>减为0的时候才会被唤醒继续执行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/24 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest2</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <<span class="number">10</span>; i++) {</span><br><span class="line">                data=i;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"data:"</span>+data);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>CountDownLatch传入的count为4，循环执行了10次，结果是多少？当然是4了，当减为0的时候await调用就会返回不会再等待，后面即使count已经减为0再减也没有什么意义。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>await()</code>   导致当前线程等到锁存器计数到零，除非线程是 interrupted 。</td></tr><tr><td><code>boolean</code></td><td><code>await(long timeout,  TimeUnit unit)</code>  使当前线程等待直到锁存器计数到零为止，除非线程为 interrupted或指定的等待时间过去。</td></tr><tr><td><code>void</code></td><td><code>countDown()</code>   减少锁存器的计数，如果计数达到零，释放所有等待的线程。</td></tr><tr><td><code>long</code></td><td><code>getCount()</code>   返回当前计数。</td></tr><tr><td><code>String</code></td><td><code>toString()</code>   返回一个标识此锁存器的字符串及其状态。</td></tr></tbody></table><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>有时候多个线程可能需要相互等待对方执行到某一步然后再执行下一步。生活中就有很多这样的情形？比如相约爬山：大家约定好集合的地点然后等所有人到达指定的集合地点后再一起去，先到达的人需要等待后到达的人，只有所有人到齐后才会出发去爬山。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/24 15:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicbarrierTest1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"t1 finished"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">"other thread is done too"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">catch</span> (BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                System.out.println(<span class="string">"t2 finished"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">"other thread is done too"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">catch</span> (BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面的代码就体现了这种情况，两个线程开始先分别做各自的事情，然后到达一个点之后，需要相互等待，先到达的等待后到达的，上面的例子中很显然 <code>t1</code> 先到达它需要等待<code>t2</code> 到达后才能继续运行。</p><p>同时，如果外界是想要知道这个CyclicBarrier的任务执行情况可以在构造函数中加入一个回调的<code>Runnable</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,()->{</span><br><span class="line">    System.out.println(<span class="string">"t1,t2 both arrived"</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div><p>这样的方式还是很优雅的。</p><p>如果细心的话其实你还会发现相比上面的CountDown多了一个BrokenBarrierException，我们来看看doc</p><p>如果有线程正在waiting而 Barrier已经被reset了</p><blockquote><p>If the barrier is {@link #reset} while any thread is waiting</p><p>or if the barrier {@linkplain #isBroken is broken} when</p><p>{@code await} is invoked, or while any thread is waiting, then</p><p>{@link BrokenBarrierException} is thrown.</p></blockquote><p>如果某一个线程在waiting的时候被打断了，那么其他的waiting线程将会抛出这个异常</p><blockquote><p>If any thread is {@linkplain Thread#interrupt interrupted} while waiting</p><p>then all other waiting threads will throw</p><p>{@link BrokenBarrierException} and the barrier is placed in the broken</p><p>state.</p></blockquote><p><strong>源码解析</strong></p><p><code>CyclicBarrier</code>并没有借助AQS而是利用<code>Condition</code>条件变量来实现的，关于<code>Condition</code>后面会介绍。</p><p><strong>doAwait()</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count; <span class="comment">//和countDownLatch类似</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {  <span class="comment">// tripped 所有线程都抵达了</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand; </span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run(); <span class="comment">//执行构造器中传入的CallBack</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration(); <span class="comment">//下一个轮回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos > <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException ie) {</span><br><span class="line">                <span class="keyword">if</span> (g == generation && ! g.broken) {</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed && nanos <= <span class="number">0L</span>) {</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p> <strong>nextGeneration()</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll(); <span class="comment">//唤醒这个barrier上所有的等待线程，trip是一个condition</span></span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties; <span class="comment">//count复位</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实也可以用CountDownLatch实现和CyclicBarrier类似的功能，这里就不再演示。</p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>await()</code>   等待所有 parties到达屏障，并且在这个障碍上调用<code>await</code> 。</td></tr><tr><td><code>int</code></td><td><code>await(long timeout,  TimeUnit unit)</code>  等待所有 parties已经在此屏障上调用  <code>await</code> ，或指定的等待时间过去。</td></tr><tr><td><code>int</code></td><td><code>getNumberWaiting()</code>   返回目前正在等待的线程的数量。</td></tr><tr><td><code>int</code></td><td><code>getParties()</code>   返回parties</td></tr><tr><td><code>boolean</code></td><td><code>isBroken()</code>   查询这个障碍是否处于Broken</td></tr><tr><td><code>void</code></td><td><code>reset()</code>   将屏障重置为初始状态。</td></tr></tbody></table><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p><code>CountDownLatch</code>不能<code>reset</code>（递减到0后不能复原），<code>CyclicBarrier</code>正如其名是可以循环使用的。</p></li><li><p><code>CountDownLatch</code>工作线程之间互不关心，<code>CyclicBarrier</code>所有线程必须到达一个共同的点才会继续执行</p></li></ul><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>JDK1.5引入的，看名字就猜得到大概是干嘛的，主要就是用于<code>两个线程</code> 之间的数据交换，其实也就相当于只有两个参与方的<code>CyclicBarrier</code> 当两个线程都达到<code>exchanger point</code> (集合点) 就会进行数据的交换，<code>一手交钱，一手交货</code> 所以在使用的时候也要注意两个线程能否正确的到达<code>exchanger point</code> 如果有一方无法到达则另一方就会陷入等待，当然你可以加上timeout。另外这个只适用与两个线程，如果有2个以上的线程参与将会造成数据传输混乱，无法控制。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/25 13:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Exchanger<string> exchanger=<span class="keyword">new</span> Exchanger<>();</string></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" start"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                String res = exchanger.exchange(<span class="string">"i am  A"</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(<span class="string">"back msg="</span> +res);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">catch</span> (TimeoutException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"done"</span>);</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" start"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                String res = exchanger.exchange(<span class="string">"i am  B"</span>);</span><br><span class="line">                System.out.println(<span class="string">"back msg="</span> +res);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"done"</span>);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>确实Exchanger如果使用不当会造成很多问题，所以在使用的时候一定要谨慎，首先它只适用与两个线程之间传输数据，其次这里传输的对象是<code>同一个</code> ，也就是说发送端和接收端的对象内存地址是一样的是一个对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/25 15:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Exchanger<simple> exchanger=<span class="keyword">new</span> Exchanger<>();</simple></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            Simple simple = <span class="keyword">new</span> Simple(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" start. send to B"</span>+simple);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Simple res = exchanger.exchange(simple);</span><br><span class="line">                <span class="comment">//休眠10s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">"A receive from B obj:"</span>+res +<span class="string">" data:"</span>+res.a);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" done"</span>);</span><br><span class="line">        },<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            Simple simple = <span class="keyword">new</span> Simple(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" start. send to A:"</span>+simple);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Simple res = exchanger.exchange(simple);</span><br><span class="line">                <span class="comment">//修改发送出去的obj</span></span><br><span class="line">                simple.setA(<span class="number">100000</span>);</span><br><span class="line">                System.out.println(<span class="string">"B receive from A obj:"</span>+res +<span class="string">" data:"</span>+res.a);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" done"</span>);</span><br><span class="line">        },<span class="string">"B"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Simple</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>结果</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">A start. send to Bjuc_study.tools.Exchanger.ExchangerTest2$Simple@<span class="number">72</span>d6db17</span><br><span class="line">B start. send to A:juc_study.tools.Exchanger.ExchangerTest2$Simple@<span class="number">4295</span>c176</span><br><span class="line">B receive from A obj:juc_study.tools.Exchanger.ExchangerTest2$Simple@<span class="number">72</span>d6db17 data:<span class="number">1</span></span><br><span class="line">B done</span><br><span class="line">A receive from B obj:juc_study.tools.Exchanger.ExchangerTest2$Simple@<span class="number">4295</span>c176 data:<span class="number">100000</span></span><br><span class="line">A done</span><br></pre></td></tr></tbody></table></figure></div><p>两个线程拿到的是同一个对象并不是拷贝，两个线程同时的去操作这个对象这其实是很危险的很有可能就会产生一些线程安全问题，使用的时候一定要注意</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，相信学过操作系统的同学肯定对这个很熟悉了，熟悉PV操作的话这个一看就懂了。</p><table><thead><tr><th>Constructor and Description</th></tr></thead><tbody><tr><td><code>Semaphore(int permits)</code>   创建一个 <code>Semaphore</code>与给定数量的许可证，默认非公平锁</td></tr><tr><td><code>Semaphore(int permits,  boolean fair)</code>  创建一个 <code>Semaphore</code>与给定数量的许可证和是否公平</td></tr></tbody></table><h3 id="Semaphore实现一个显示锁"><a href="#Semaphore实现一个显示锁" class="headerlink" title="Semaphore实现一个显示锁"></a>Semaphore实现一个显示锁</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/25 15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> SemaphoreLock semaphoreLock=<span class="keyword">new</span> SemaphoreLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                semaphoreLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get the lock"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }<span class="keyword">finally</span> {</span><br><span class="line">                semaphoreLock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"release the lock"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                semaphoreLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get the lock"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }<span class="keyword">finally</span> {</span><br><span class="line">                semaphoreLock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"release the lock"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span>  Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>{</span><br><span class="line">            semaphore.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="实现生产者消费者模型"><a href="#实现生产者消费者模型" class="headerlink" title="实现生产者消费者模型"></a>实现生产者消费者模型</h3><p>生产者消费者模型其实也挺重要的，有时候面试会让你手写一个生产者消费者模型，在之前的文章中其实有实现过一个但是那个其实还是很简单的一个，那个是没有Buffer的，下面这个用信号量实现的就是有Buffer的，后面会单独整理出所有的生产者消费者模型的实现方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/25 16:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumerV4</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ProduceConsumerV4 pc = <span class="keyword">new</span> ProduceConsumerV4();</span><br><span class="line">        Stream.of(<span class="string">"Produce1"</span>, <span class="string">"Produce2"</span>, <span class="string">"Produce3"</span>, <span class="string">"Produce4"</span>).forEach(n -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    pc.produce();</span><br><span class="line">                }</span><br><span class="line">            }, n).start();</span><br><span class="line">        });</span><br><span class="line">        Stream.of(<span class="string">"Consumer1"</span>, <span class="string">"Consumer2"</span>, <span class="string">"Consumer3"</span>, <span class="string">"Consumer4"</span>).forEach(n -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    pc.consumer();</span><br><span class="line">                }</span><br><span class="line">            }, n).start();</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buffer载体</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList<object> buffer=<span class="keyword">new</span> LinkedList<>();<br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore full = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buffer最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore empty = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore mutex= <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//已经生产了</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            empty.acquire();</span><br><span class="line">            <span class="comment">//不能和上面的信号量交换</span></span><br><span class="line">            mutex.acquire();</span><br><span class="line">            buffer.add(<span class="keyword">new</span> Object());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" produce a obj , current list size:"</span> +buffer.size());</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mutex.release();</span><br><span class="line">            full.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            full.acquire();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            <span class="comment">//移除最后一个</span></span><br><span class="line">            buffer.removeLast();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" consumer a obj, current size: "</span> + buffer.size());<span class="comment">//consumer</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mutex.release();</span><br><span class="line">            empty.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></object></span></pre></td></tr></tbody></table></figure></div><h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>acquire()</code>   从该信号量获取许可证，阻塞直到获取到，可以被interrupt</td></tr><tr><td><code>void</code></td><td><code>acquire(int permits)</code>   从该信号量获取给定数量的许可证，阻塞直到获取到可以被interrupt</td></tr><tr><td><code>void</code></td><td><code>acquireUninterruptibly()</code>  从该信号量获取许可证，阻塞直到获取到，无视interrupt，不会被interrupt</td></tr><tr><td><code>void</code></td><td><code>acquireUninterruptibly(int permits)</code>   从该信号量获取给定数量的许可证，阻止直到获取到，不可被interrupt。</td></tr><tr><td><code>int</code></td><td><code>availablePermits()</code>   返回此信号量中当前可用的许可数。</td></tr><tr><td><code>int</code></td><td><code>drainPermits()</code>   获取并返回所有可立即获得的许可证。</td></tr><tr><td><code>protected Collection<thread></thread></code></td><td><code>getQueuedThreads()</code>   返回一个包含<code>可能</code>正在等待获取的线程的集合。</td></tr><tr><td><code>int</code></td><td><code>getQueueLength()</code>   返回等待获取的线程数的估计值。</td></tr><tr><td><code>boolean</code></td><td><code>hasQueuedThreads()</code>   查询是否有线程等待获取。</td></tr><tr><td><code>boolean</code></td><td><code>isFair()</code>   是不是公平锁</td></tr><tr><td><code>protected void</code></td><td><code>reducePermits(int reduction)</code>   缩小可用许可证的数量。</td></tr><tr><td><code>void</code></td><td><code>release()</code>   释放许可证，将其返回到信号量。(0的时候也可以release)</td></tr><tr><td><code>void</code></td><td><code>release(int permits)</code>   释放给定数量的许可证，将其返回到信号量。</td></tr><tr><td><code>String</code></td><td><code>toString()</code>   返回一个标识此信号量的字符串及其状态。</td></tr><tr><td><code>boolean</code></td><td><code>tryAcquire()</code>   从这个信号量获得许可证，立即返回，不会阻塞。</td></tr><tr><td><code>boolean</code></td><td><code>tryAcquire(int permits)</code>   从这个信号量获取给定数量的许可证，不会阻塞</td></tr><tr><td><code>boolean</code></td><td><code>tryAcquire(int permits,  long timeout, TimeUnit unit)</code>  从该信号量获取给定数量的许可证，如果在给定的等待时间获取到，就返回true，可以被打断</td></tr><tr><td><code>boolean</code></td><td><code>tryAcquire(long timeout,  TimeUnit unit)</code>  从该信号量获取许可证，如果在给定的等待时间获取到，就返回true，可以被打断</td></tr></tbody></table><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>通常被称为显式锁，与之对应的<code>synchroized</code> 则被称为内部锁，显式锁是jdk1.5引入的锁，他的作用与内部锁相同，但是它的功能比内部锁更加强大，但是并不是内部锁的替代品，其实在之前的 <a href="http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/#LOCK%E6%8E%A5%E5%8F%A3">Java多线程基础</a>  一文中就手写过一个带有<code>限时等待</code>的锁 ，那个其实就是模仿的<code>Lock</code> 接口</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是Lock接口的一个实现类也是用的最多的一个实现类，<code>Reentrant</code> 本意就是 可重入的，可再入的， 表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，<code>synchnorized</code>也是可重入的。</p><table><thead><tr><th>Constructor and Description</th></tr></thead><tbody><tr><td><code>ReentrantLock()</code>   创建一个 <code>ReentrantLock</code>的实例。</td></tr><tr><td><code>ReentrantLock(boolean fair)</code>   根据给定的公平策略创建一个 <code>ReentrantLock</code>的实例。</td></tr></tbody></table><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/25 20:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(() -> needLock() );</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -> needLock() );</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">needLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//可打断的获取锁</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" is get the lock"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line"><span class="comment">//空转</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock(); <span class="comment">//确保锁的释放</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试结果</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> is get the lock</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at juc_study.tools.Lock.ReentrantLockTest1.needLock(ReentrantLockTest1.java:<span class="number">26</span>)</span><br><span class="line">at juc_study.tools.Lock.ReentrantLockTest1.lambda$main$<span class="number">1</span>(ReentrantLockTest1.java:<span class="number">16</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Exception in thread <span class="string">"Thread-1"</span> java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:<span class="number">151</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:<span class="number">1261</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:<span class="number">457</span>)</span><br><span class="line">at juc_study.tools.Lock.ReentrantLockTest1.needLock(ReentrantLockTest1.java:<span class="number">34</span>)</span><br><span class="line">at juc_study.tools.Lock.ReentrantLockTest1.lambda$main$<span class="number">1</span>(ReentrantLockTest1.java:<span class="number">16</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></tbody></table></figure></div><h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>getHoldCount()</code>  当前线程调用lock()的次数 (重入的次数)</td></tr><tr><td><code>protected Thread</code></td><td><code>getOwner()</code>   返回当前拥有此锁的线程，如果没有，返回 <code>null</code> 。</td></tr><tr><td><code>protected Collection<thread></thread></code></td><td><code>getQueuedThreads()</code>   返回包含可能正在等待获取此锁的线程的集合。</td></tr><tr><td><code>int</code></td><td><code>getQueueLength()</code>   返回等待获取此锁的线程数的估计值。</td></tr><tr><td><code>protected Collection<thread></thread></code></td><td><code>getWaitingThreads(Condition condition)</code>   返回包含可能在与此锁相关联的给定条件下等待的线程的集合。</td></tr><tr><td><code>int</code></td><td><code>getWaitQueueLength(Condition condition)</code>   返回与此锁相关联的给定条件等待的线程数的估计。</td></tr><tr><td><code>boolean</code></td><td><code>hasQueuedThread(Thread thread)</code>  查询给定线程是否等待获取此锁。</td></tr><tr><td><code>boolean</code></td><td><code>hasQueuedThreads()</code>   查询是否有线程正在等待获取此锁。</td></tr><tr><td><code>boolean</code></td><td><code>hasWaiters(Condition condition)</code>   查询任何线程是否等待与此锁相关联的给定条件。</td></tr><tr><td><code>boolean</code></td><td><code>isFair()</code>   如果此锁的公平设置为true，则返回 <code>true</code> 。</td></tr><tr><td><code>boolean</code></td><td><code>isHeldByCurrentThread()</code>   查询此锁是否由当前线程持有。</td></tr><tr><td><code>boolean</code></td><td><code>isLocked()</code>   查询此锁是否由任何线程持有。</td></tr><tr><td><code>void</code></td><td><code>lock()</code>   获得锁，不能被打断</td></tr><tr><td><code>void</code></td><td><code>lockInterruptibly()</code>   获得锁，可以被打断</td></tr><tr><td><code>Condition</code></td><td><code>newCondition()</code>   返回<code>Condition</code>用于这种用途实例<code>Lock</code>实例。</td></tr><tr><td><code>String</code></td><td><code>toString()</code>   返回一个标识此锁的字符串以及其锁定状态。</td></tr><tr><td><code>boolean</code></td><td><code>tryLock()</code>   尝试获取该锁，不会阻塞，直接返回，</td></tr><tr><td><code>boolean</code></td><td><code>tryLock(long timeout,  TimeUnit unit)</code>  尝试在给定时间内获取锁，可以被打断</td></tr><tr><td><code>void</code></td><td><code>unlock()</code>   释放锁。</td></tr></tbody></table><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>看名字就知道是干啥的了，之前我们在 <a href="http://imlgw.top/2019/04/09/java-duo-xian-cheng-li-mian-de-she-ji-mo-shi/#%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F">多线程设计模式</a> 中也提到了读写锁，并且实现了一个简易的读写锁。</p><p><strong>读写锁案例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26 12:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock readLock=readWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock writeLock=readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> List<long> data=<span class="keyword">new</span> ArrayList<>();</long></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(() -> write());</span><br><span class="line">        thread0.start();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -> read());</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -> read());</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            data.add(System.currentTimeMillis());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            readLock.lock();</span><br><span class="line">            data.forEach(System.out::println);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" ===="</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="显式锁对比内部锁"><a href="#显式锁对比内部锁" class="headerlink" title="显式锁对比内部锁"></a>显式锁对比内部锁</h3><p>显式锁和内部锁都各有优缺点，谁也不能替代谁（这里的显式锁主要指<code>ReentrantLock</code>）。</p><p><strong>特性上</strong></p><ul><li><p>显式锁支持公平锁（显式锁，内部锁默认都是非公平的）</p></li><li><p>显式锁可以<code>tryLock()</code>无需等待，内部锁只能一直等待锁释放</p></li><li><p>显式锁有带超时的<code>tryLock(long timeout,  TimeUnit unit)</code>。</p></li><li><p>显式锁可以响应中断请求 <code>lockInterruptibly()</code></p></li><li><p>显式锁提供了一系列的方法对锁的相关信息监控，内部锁则没有</p></li><li><p>………</p></li></ul><p><strong>性能上</strong></p><p>其实很多人会认为<code>synchronized</code>性能很差，不如显式锁</p><ul><li>jdk1.5中，在高争用的情况下，确实显式锁要优于内部锁</li><li>jdk1.5之后， 对内部锁进行了一些优化，包括 <strong>锁消除</strong>，<strong>锁粗化</strong>，<strong>偏向锁</strong>，和<strong>适应性锁</strong> (这些优化后面的文章会再做解释) 。这些优化使得内部锁的性能提升了很多，甚至在低争用情况下性能还要优于 显式锁。</li></ul><p><strong>使用上</strong></p><ul><li><p>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问。</p></li><li><p>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用，而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p></li></ul><p>其实很明显内部锁相比显式锁使用起来要简单易用，所以保守一点默认优先使用内部锁，在需要显式锁的特性的时候再选用显式锁。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition对应的其实就是显式锁的通信方法，<code>Lock.newCondition()</code> 返回的就是一个Condition实例 </p><p><code>Condition</code>接口的<code>await()/signal()</code>  其实就对应了 <code>synchronize</code> 的 <code>wait()/notify()</code> ，但是相对于 <code>wait()/notify()</code>  Condition接口解决了 <strong>过早唤醒</strong>  问题以及 <code>Object.wait(time)</code> 无法区分是否是由于等待超时还是被唤醒的问题。</p><p><code>Object.wait()/notify()</code>要求执行线程持有所属对象的内部锁，同样<code>Condition.await()/notify()</code>也需要线程持有<strong>创建</strong>该Condition的显式锁，<code>每个Condition</code>实例内部都维护了一个等待队列，不同的Condition之间不会相互影响，这样一来就解决了过早唤醒的问题，对于生产者消费者问题我们可以分别给消费者和生产者创建一个Condition，生产者通知消费者时候只会唤醒消费者，消费者通知生产者的时候也只会通知生产者。</p><h3 id="解决过早唤醒"><a href="#解决过早唤醒" class="headerlink" title="解决过早唤醒"></a>解决过早唤醒</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition pCondition = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition cCondition = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList<long> buffer = <span class="keyword">new</span> LinkedList<>();</long></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer MAX_BUFFER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ConditionTest1 conditionTest1 = <span class="keyword">new</span> ConditionTest1();</span><br><span class="line">        Stream.of(<span class="string">"p1"</span>, <span class="string">"p2"</span>, <span class="string">"p3"</span>, <span class="string">"p4"</span>, <span class="string">"p5"</span>, <span class="string">"p6"</span>, <span class="string">"p7"</span>, <span class="string">"p8"</span>, <span class="string">"p9"</span>, <span class="string">"p10"</span>, <span class="string">"p11"</span>).forEach(name -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> conditionTest1.produce(), name).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Stream.of(<span class="string">"c1"</span>, <span class="string">"c2"</span>, <span class="string">"c3"</span>, <span class="string">"c4"</span>, <span class="string">"c5"</span>, <span class="string">"c6"</span>, <span class="string">"c7"</span>, <span class="string">"c8"</span>, <span class="string">"c9"</span>, <span class="string">"c10"</span>, <span class="string">"c11"</span>).forEach(name -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> conditionTest1.consumer(), name).start();</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            LOCK.lock();</span><br><span class="line">            <span class="keyword">while</span> (buffer.size() >= MAX_BUFFER) {</span><br><span class="line">                pCondition.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">            buffer.add(l);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" produced "</span> + l + <span class="string">" ,current buffer size "</span> + buffer.size());</span><br><span class="line">            <span class="comment">//通知消费者</span></span><br><span class="line">            cCondition.signalAll();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            LOCK.lock();</span><br><span class="line">            <span class="keyword">while</span> (buffer.size() == <span class="number">0</span>) {</span><br><span class="line">                cCondition.await();</span><br><span class="line">            }</span><br><span class="line">            Long aLong = buffer.removeLast();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" consumer "</span> + aLong + <span class="string">" ,current buffer size "</span> + buffer.size());</span><br><span class="line">            <span class="comment">//通知生产者</span></span><br><span class="line">            pCondition.signalAll();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="解决Object-wait-无法区分其返回原因"><a href="#解决Object-wait-无法区分其返回原因" class="headerlink" title="解决Object.wait()无法区分其返回原因"></a>解决Object.wait()无法区分其返回原因</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26 17:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest2</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition condition = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="comment">//3s+</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                <span class="keyword">while</span> (!isReady) {</span><br><span class="line">                    <span class="keyword">boolean</span> b = condition.awaitUntil(date);</span><br><span class="line">                    <span class="keyword">if</span> (!b) {</span><br><span class="line">                        System.out.println(<span class="string">"Fucking t0!!!!!, i am timeout"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"oh i get the lock!!!"</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                LOCK.unlock();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                isReady = <span class="keyword">true</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                LOCK.unlock();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t0"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可见<strong>awaitUntil()</strong> 是有一个返回值的，返回true则表示在等待时间内获取到了锁，反之则是因为超时.</p><blockquote><p>写这个Demo的时候是拿之前的改的，然后有一个地方的notify忘了改成signal，然后一直抛异常。。。因为condition里面也有wait/notify方法所以使用的时候一定要注意不要调错了。</p></blockquote><h3 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>await()</code>   使当前线程等待直到发出信号或中断</td></tr><tr><td><code>boolean</code></td><td><code>await(long time,  TimeUnit unit)</code>  使当前线程等待直到发出信号或中断，或指定的等待时间过去。</td></tr><tr><td><code>long</code></td><td><code>awaitNanos(long nanosTimeout)</code>   使当前线程等待直到发出信号或中断，或指定的等待时间过去。</td></tr><tr><td><code>void</code></td><td><code>awaitUninterruptibly()</code>   使当前线程等待直到发出信号。</td></tr><tr><td><code>boolean</code></td><td><code>awaitUntil(Date deadline)</code>  使当前线程等待直到发出信号或中断，或者指定的最后期限到达。</td></tr><tr><td><code>void</code></td><td><code>signal()</code>   唤醒一个等待线程。</td></tr><tr><td><code>void</code></td><td><code>signalAll()</code>   唤醒所有等待线程。</td></tr></tbody></table><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code>是<code>Java8</code>引入的一种新的锁机制，是对读写锁<code>ReentrantReadWriteLock</code>的增强，读写锁虽然分离了读和写的功能，使得读与读之间不互斥，但是读和写之间依然是互斥的，本质上仍然是悲观锁，如果有大量的读线程就会引起写线程的饥饿，而<code>StampedLock</code>则提供了一种乐观的读策略,这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会写线程</p><h3 id="悲观锁策略"><a href="#悲观锁策略" class="headerlink" title="悲观锁策略"></a>悲观锁策略</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/28 13:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest1</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List<long> shareData = <span class="keyword">new</span> ArrayList<>();</long></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable readRunnable = () -> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                read();</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        Runnable writeRunnable = () -> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                write();</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line">        executorService.submit(readRunnable);</span><br><span class="line"></span><br><span class="line">        executorService.submit(writeRunnable);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            stamped = stampedLock.readLock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" read "</span> + shareData);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            stampedLock.unlockRead(stamped);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> stamp = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            stamp = stampedLock.writeLock();</span><br><span class="line">            shareData.add(System.currentTimeMillis());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" Write "</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实这种方式就和<code>ReadWriteLock</code> 是等价的了。</p><h3 id="乐观读策略"><a href="#乐观读策略" class="headerlink" title="乐观读策略"></a>乐观读策略</h3><p>相对上面的方式，其实就是改变了读的策略</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">//非阻塞</span></span><br><span class="line">    <span class="comment">//暂存res</span></span><br><span class="line">    String res=Thread.currentThread().getName() + <span class="string">" read "</span> + shareData;</span><br><span class="line">    <span class="keyword">if</span> (!stampedLock.validate(stamp)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//验证失败,说明有线程进行了写操作,可能造成数据不一致</span></span><br><span class="line">            <span class="comment">//进行锁升级,获取共享读锁</span></span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            <span class="comment">//覆盖res</span></span><br><span class="line">            res=Thread.currentThread().getName() + <span class="string">" read "</span> + shareData;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(res);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>先尝试获取乐观读锁（非阻塞）返回一个戳，然后进行读操作，缓存读的结果，然后根据前面返回的戳验证在此过程中是否有写线程被占用过，如果被占用过就表示数据可能不一致了，就需要转换成普通的<code>共享读锁</code> ，再次读取数据刷新结果，保证数据的一致性，最后释放锁。</p><p>这里一开始被视频里面讲的搞懵了他写的是这样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">//非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (stampedLock.validate(stamp)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" read "</span> + shareData);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>然后就说这样比ReadWriteLock效率高很多，我越看越觉得不对劲，然后自己查了下，看了下官方的Demo发现他写的确实是错的。。。</p><p>API什么的就不多说了，这里如果想了解更多可以看看<a href="https://segmentfault.com/a/1190000015808032#articleHeader20" target="_blank" rel="noopener">这篇文章</a></p><p>另外如果想看看性能对比的可以看看 <a href="http://ifeve.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="noopener">这篇文章</a></p><blockquote><p>这里还要存个疑，最后的释放读锁之后到最后一步的时候不是也有可能有写线程进入么，那样不是也会造成数据不一致的情况么？ 因为源码上注释的Demo也是这样写的所以这里还是有点疑问的。</p></blockquote><h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ul><li><p>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；</p></li><li><p>所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；</p></li><li><p>StampedLock是不可重入的 (如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)，所以这就要我们开发人员不要去修改返回的戳或者让它逃逸出去</p></li><li><p>StampedLock 不支持Condition</p></li></ul><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin是Java7提供的原生多线程并行处理框架，其基本思想是将大任务分割成小任务，最后将小任务聚合起来得到结果。fork是分解的意思, join是收集的意思. 它非常类似于HADOOP提供的MapReduce框架，只是MapReduce的任务可以针对集群内的所有计算节点，可以充分利用集群的能力完成计算任务。ForkJoin更加类似于单机版的MapReduce。</p><h3 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h3><p><strong>计算sum和</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/30 11:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个值代表一个线程可以处理的最大数据，不能太小也不能太大</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRESHOLD=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask<integer> submit = forkJoinPool.submit(<span class="keyword">new</span> CaculateRecursiveTask(<span class="number">0</span>, <span class="number">100</span>));</integer></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Integer integer = submit.get();</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (ExecutionException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaculateRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span><<span class="title">Integer</span>></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CaculateRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span>(end-start<=MAX_THRESHOLD){</span><br><span class="line">                <span class="keyword">return</span> IntStream.rangeClosed(start,end).sum();</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">                CaculateRecursiveTask leftTask=<span class="keyword">new</span> CaculateRecursiveTask(start,mid);</span><br><span class="line">                CaculateRecursiveTask rightTask=<span class="keyword">new</span> CaculateRecursiveTask(mid+<span class="number">1</span>,end);</span><br><span class="line">                <span class="comment">//阻塞</span></span><br><span class="line">                leftTask.fork();</span><br><span class="line">                rightTask.fork();</span><br><span class="line">                <span class="comment">//返回结果</span></span><br><span class="line">                <span class="keyword">return</span> leftTask.join()+rightTask.join();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h3><p><strong>计算sum和</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/30 13:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveActionTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRESHOLD=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger SUM=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        forkJoinPool.submit(<span class="keyword">new</span> CalculateRecursiveAction(<span class="number">0</span>, <span class="number">100</span>));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(SUM.get());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateRecursiveAction</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CalculateRecursiveAction</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(end-start<=MAX_THRESHOLD){</span><br><span class="line">                SUM.addAndGet(IntStream.rangeClosed(start,end).sum());</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">                CalculateRecursiveAction leftTask=<span class="keyword">new</span> CalculateRecursiveAction(start,mid);</span><br><span class="line">                CalculateRecursiveAction rightTask=<span class="keyword">new</span> CalculateRecursiveAction(mid+<span class="number">1</span>,end);</span><br><span class="line">                <span class="comment">//阻塞</span></span><br><span class="line">                leftTask.fork();</span><br><span class="line">                rightTask.fork();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>CountDownLatch和CyclicBarrier都是JDK 1.5引入的，而Phaser是JDK 1.7引入的。Phaser的功能与CountDownLatch和CyclicBarrier有部分重叠，同时也提供了更丰富的语义和更灵活的用法。</p><p>Phaser顾名思义，与阶段相关。Phaser比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个CyclicBarrier来实现，每个CyclicBarrier负责等待一个阶段的任务全部完成。但是使用CyclicBarrier的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而Phaser可同时解决这两个问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/30 13:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line"></span><br><span class="line">        Stream.of(<span class="string">"t1"</span>, <span class="string">"t2"</span>, <span class="string">"t3"</span>, <span class="string">"t4"</span>, <span class="string">"t5"</span>).forEach(name -> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(phaser), name).start());</span><br><span class="line">        <span class="comment">//注册main线程</span></span><br><span class="line">        phaser.register();</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(<span class="string">"all of work finished"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        Task(Phaser phaser) {</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">            <span class="comment">//动态增加</span></span><br><span class="line">            <span class="keyword">this</span>.phaser.register();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is working"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>arrive()</code>   抵达这个移相器，而不用等待别人到达。</td></tr><tr><td><code>int</code></td><td><code>arriveAndAwaitAdvance()</code>   到达这个移相器，等待其他人。</td></tr><tr><td><code>int</code></td><td><code>arriveAndDeregister()</code>   到达这个移相器并从其中注销，而无需等待别人到达。</td></tr><tr><td><code>int</code></td><td><code>awaitAdvance(int phase)</code>   等待该相位器的相位从给定相位值前进，如果当前相位不等于给定相位值，则立即返回，或者该相位器被终止。</td></tr><tr><td><code>int</code></td><td><code>awaitAdvanceInterruptibly(int phase)</code>   等待该移相器的阶段从给定的相位值推进，如果在等待时 <code>InterruptedException</code>则抛出  <code>InterruptedException</code> ，或者如果当前相位不等于给定的相位值或者该相位器被终止，则立即返回。</td></tr><tr><td><code>int</code></td><td><code>awaitAdvanceInterruptibly(int phase,  long timeout, TimeUnit unit)</code>  等待该移相器的阶段从给定的相位值或给定的超时时间  <code>InterruptedException</code>到等待时抛出 <code>InterruptedException</code>  ，如果当前相位不等于给定的相位值，则立即返回，或者该相位器被终止。</td></tr><tr><td><code>int</code></td><td><code>bulkRegister(int parties)</code>   增加给定数量的新的有争议的派对到这个移相器。</td></tr><tr><td><code>void</code></td><td><code>forceTermination()</code>   强制此移相器进入终止状态。</td></tr><tr><td><code>int</code></td><td><code>getArrivedParties()</code>   返回在此移相器的当前阶段到达的已注册方的数量。</td></tr><tr><td><code>Phaser</code></td><td><code>getParent()</code>   返回此移相器的父级，如果没有，则返回 <code>null</code> 。</td></tr><tr><td><code>int</code></td><td><code>getPhase()</code>   返回当前相位数。</td></tr><tr><td><code>int</code></td><td><code>getRegisteredParties()</code>   返回在此移动设备上注册的各方数量。</td></tr><tr><td><code>Phaser</code></td><td><code>getRoot()</code>   返回此移相器的根祖先，如果它没有父代，则与该移相器相同。</td></tr><tr><td><code>int</code></td><td><code>getUnarrivedParties()</code>   返回尚未到达此移相器当前阶段的已注册方的数量。</td></tr><tr><td><code>boolean</code></td><td><code>isTerminated()</code>   返回 <code>true</code>如果移相器已被终止。</td></tr><tr><td><code>protected boolean</code></td><td><code>onAdvance(int phase,  int registeredParties)</code>  在即将进行的相位提前执行动作的可覆盖方法，并控制终止。</td></tr><tr><td><code>int</code></td><td><code>register()</code>   添加一个新的unririved party到这个移相器。</td></tr><tr><td><code>String</code></td><td><code>toString()</code>   返回一个标识此移相器的字符串及其状态。</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大致归纳了一些常见的并发工具，当然只是浅显的记录了一下怎样使用，原理部分还没有深入的了解，后续肯定会去研究底层实现源码包括<code>AQS</code>和<code>LockSupport</code>等等，其实越往后学就越想知道到底层是怎样个过程，到底是如何加锁如何解锁？CAS又起到了什么作用？Synchnorized底层又是如何实现？…学无止境啊. JUC除了这些并发工具外还有<strong>线程池</strong> ，<strong>阻塞队列</strong> 还没介绍，后面会继续介绍。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode滑动窗口</title>
      <link href="/2019/07/20/leetcode-hua-dong-chuang-kou/"/>
      <url>/2019/07/20/leetcode-hua-dong-chuang-kou/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="LeetCode-滑动窗口"><a href="#LeetCode-滑动窗口" class="headerlink" title="LeetCode 滑动窗口"></a>LeetCode 滑动窗口</h2><p>滑动问题包含一个滑动窗口，它是一个运行在一个大数组上的子列表，该数组是一个底层元素集合。假设有数组 [a b c d e f g h ]，一个大小为 3 的 <strong>滑动窗口</strong> 在其上滑动，则有：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[a b c]</span><br><span class="line">  [b c d]</span><br><span class="line">    [c d e]</span><br><span class="line">      [d e f]</span><br><span class="line">        [e f g]</span><br><span class="line">          [f g h]</span><br></pre></td></tr></tbody></table></figure></div><p>一般情况下就是使用这个窗口在数组的 <strong>合法区间</strong> 内进行滑动，同时 <strong>动态地</strong>记录一些有用的数据，很多情况下，能够极大地提高算法地效率。</p><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h2><p>给定一个数组 <em>nums*，有一个大小为 *k</em> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 <em>k</em> 内的数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口最大值。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意：</strong></p><p>你可以假设 <em>k</em> 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。</p><p><strong>进阶：</strong></p><p>你能在线性时间复杂度内解决此题吗？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSlidingWindow2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) {</span><br><span class="line">    <span class="comment">//题目上说的不为空，还是给我来了个空。。。。</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{};</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    LinkedList<integer> list=<span class="keyword">new</span> LinkedList<integer>();</integer></integer></span><br><span class="line">    <span class="keyword">int</span> []res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty() && nums[list.getLast()]<nums[i]){< span><br><span class="line">            <span class="comment">//小于nums[i]的元素,从右边(尾)出队列 ,控制最左边(头)最大</span></span><br><span class="line">            list.removeLast();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//然后将它加到队列中，从右边(尾)</span></span><br><span class="line">        list.addLast(i);</span><br><span class="line">        <span class="comment">//如果队列溢出了就从右边移除一个（头）</span></span><br><span class="line">        <span class="keyword">if</span>(i-list.getFirst()==k){</span><br><span class="line">            list.removeFirst();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i>=k-<span class="number">1</span>){</span><br><span class="line">            res[index++]=nums[list.getFirst()];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums[i]){<></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实开始我也不会做，看了提示后搞了半天才弄出来，23ms，70%左右，思路就是利用一个双端队列(头尾都可以进出)，队列中存<strong>数组下标</strong>，然后遍历数组，在进入队列时从右向左遍历队尾，将<strong>小于当前元素</strong>的队尾元素去除(因为已经没用了，后面的最大值不可能是它们)，举个例子</p><blockquote><p>[2，1，-1，3，……]  k=3 ，当读到<strong>3</strong>这个元素的时候，窗口再向右移动最大值肯定不会是右边的元素了，所以直接剔除他们，在纸上画一画就明白了</p></blockquote><p>然后很关键的一步就是什么时候移除最左边的元素，其实按照人的思路来想就是最左边的元素不在窗口内的时候，比如上面的例子，读到<strong>3</strong>的时候，<strong>2</strong>其实就应该剔除了因为它已经不在窗口内了。用代码来描述就是</p><p><code>i-list.getFirst()==k</code>，i代表<strong>当前元素下标</strong>，上面的例子<strong>3</strong>对应的<strong>i</strong>就是<strong>3</strong>，<strong>list.getFirst()=0</strong>，刚好差为k，就代表<strong>2</strong>已经超出窗口了应该移除了。</p><p>其实这里我开始不是这样做的，我在队列里面存的不是元素索引，我存的是元素，然后在判断什么时候移除的时候发现判断不了，<strong>index</strong>也只是结果元素的下标，并不能代表队列最左元素的下标，对于数组存下标优先于存元素，多一个已知量有时候还是很方便的</p><p>这题其实还有其他的做法，应该说也是最直接的方法，提交记录上最快的方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSlidingWindow3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) {</span><br><span class="line">    <span class="comment">//题目上说的不为空，还是给我来了个空。。。。</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{};</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{nums[<span class="number">0</span>]};</span><br><span class="line">    <span class="keyword">int</span> localMax = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < k; i++) {</span><br><span class="line">        <span class="comment">//找到第一个窗口的最大值</span></span><br><span class="line">        localMax = max(nums[i], localMax);</span><br><span class="line">    }</span><br><span class="line">    result[<span class="number">0</span>] = localMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len - k + <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="comment">//窗口的下一个元素 k=3 , i=1 下一个元素下标为 3</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i + k - <span class="number">1</span>] > localMax) {</span><br><span class="line">            <span class="comment">//判断当前窗口最大值和下一个元素的大小</span></span><br><span class="line">            <span class="comment">//如果比当前窗口的最大值还要大 就不用找了 就是它了</span></span><br><span class="line">            localMax = nums[i + k - <span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == localMax) {</span><br><span class="line">            <span class="comment">//下一个元素比当前窗口最大值小 而且很不巧</span></span><br><span class="line">            <span class="comment">//当前最大值刚好是当前窗口的最左边的元素，也就是马上要超过窗口的元素</span></span><br><span class="line">            localMax = nums[i];</span><br><span class="line">            <span class="comment">//所以就要重新找最大值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i; x < i + k; x++) {</span><br><span class="line">                localMax = max(nums[x], localMax);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//剩下的请况就是 比当前最大值小，并且最大值不是最左边的元素(还没有出界)，最大值不变</span></span><br><span class="line">        <span class="comment">//copy到结果中</span></span><br><span class="line">        result[i] = localMax;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实可以用Math.max()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(a>=b)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>2ms，99%  这种做法是最快的，而且也比较直白，时间复杂度最坏应该都是O(NK)，第一种耗时应该主要在队列的移除和添加元素上面。</p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h2><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题其实很久以前(半年前)做过一次，当时用的方法很low😂</p><p><img alt="mark" data-src="http://static.imlgw.top///20190503/zQ9MBrOhQm4S.png?imageslim" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> [] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    String temp=<span class="keyword">new</span> String();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <s.length()-<span class="number">1</s.length()-<span></span>; i++) {<br><span class="line">        <span class="keyword">if</span>(chars[i] != chars[i+<span class="number">1</span>]) {</span><br><span class="line">            temp=s.substring(i, i+<span class="number">2</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">2</span>; j < s.length(); j++) {</span><br><span class="line">            <span class="keyword">if</span> (!temp.contains(chars[j]+<span class="string">""</span>)) {</span><br><span class="line">                temp = s.substring(i, j+<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//Break出来后判断是否是最长的k</span></span><br><span class="line">        length=temp.length()>length?temp.length():length;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我这种完全就是利用api暴力法，居然还跑过了，时间复杂度应该是O(N3)，这题的ac率还是挺低的只有 29.3%</p><p><strong>解法二</strong></p><p>下面的是我下午重新做的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring4</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="comment">//边界问题永远不能忽略</span></span><br><span class="line">    <span class="comment">//LinkedList<integer> list=new LinkedList<>();</integer></span></span><br><span class="line">    <span class="keyword">int</span> length=s.length();</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<length;i++) {< span><br><span class="line">        <span class="keyword">int</span> index=i-<span class="number">1</span>; <span class="comment">//当前元素前一个元素下标</span></span><br><span class="line">        <span class="keyword">while</span>(index>=head){</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(index)){</span><br><span class="line">                index--;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//按思路应该是把相等前所有元素移除，但是那样效率好低，所以这里我决定用数组模拟队列</span></span><br><span class="line">                head=index+<span class="number">1</span>;</span><br><span class="line">                tail++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//从尾遍历到头仍然没有相等，可以添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span>(index==head-<span class="number">1</span>){</span><br><span class="line">                tail++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//每次结束循环后 尾index-头index</span></span><br><span class="line">        max=tail-head+<span class="number">1</span> > max?tail-head+<span class="number">1</span>:max;</span><br><span class="line">        <span class="comment">//System.out.println(max);</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></length;i++)></span></pre></td></tr></tbody></table></figure></div><p>20ms左右80%左右，思路也比较清晰，遍历字符串，然后从后往前遍历字符串，判断当前字符串在前面有没有，有的话就将前面相等那个元素(index)前的元素都移除（窗口右移）</p><p>eg: <code>[head...index....tail] i</code>  向右移动<code>....index [head ... i]</code></p><p>把当前元素添加进来，时间复杂度是O(N^2)，比上面单纯的暴力法要快多了，但是并不是最优解</p><p><strong>解法三</strong></p><p>上面的算法，其实还可以优化，每次判断前面有没有重复元素的时候可以直接用一个大小256的扩展ASCII码表数组来判断（前提是这些字符都在标准的ASCII字符中），<code>freq[s.charAt(i)]</code> 代表的就是s.charAt(i)这个字符在窗口内出现过没有，出现过就为1，否则就是0，这里如果ASCII不够其实也可以用HashMap，查找效率也很高接近O(1)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> length=s.length();</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//ASCII码表</span></span><br><span class="line">    freq[s.charAt(<span class="number">0</span>)]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head<length){< span><br><span class="line">        <span class="keyword">if</span>(tail+<span class="number">1</span><length&&freq[s.charat(tail+<span class="number">1</length&&freq[s.charat(tail+<span></span>)]==<span class="number">0</span>){</length){<></span><br><span class="line">            <span class="comment">//没有重复，右边界右移</span></span><br><span class="line">            tail++;</span><br><span class="line">            freq[s.charAt(tail)]++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//逐渐缩减左边界，直到不再有重复元素</span></span><br><span class="line">            freq[s.charAt(head)]--;</span><br><span class="line">            head++;</span><br><span class="line">        }</span><br><span class="line">        max=max<tail-head+<span class="number">1</tail-head+<span></span>?tail-head+<span class="number">1</span>:max;<br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种做法最坏情况（没有重复的字符）下其实会遍历两遍数组tail先移动到尾部head随后有移动到尾部，但是比较好理解，解法四实际上就是对这里的优化，head每次移动都是直接移动到上一个重复元素的位置，而不是一个一个的向右移</p><p><strong>解法四</strong></p><p>提交记录上最快的方法，理解起来有点费劲，现在回头看又看不懂了。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//索引为元素值，这里因为元素都是字符转过来就是askll码，所以可以直接这样</span></span><br><span class="line">    <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j < n; j++) {</span><br><span class="line">        <span class="comment">//如果字符 char 在没有出现过，index[char]为0，出现则index[char]是遍历出现的最后的char的位置</span></span><br><span class="line">        <span class="comment">// index[s.charAt(j)] 是当前字符上一次出现的位置(从1开始)</span></span><br><span class="line">        i = Math.max(i,index[s.charAt(j)]);</span><br><span class="line">        <span class="comment">//j - i + 1 就是舍弃s.charAt(j)重复出现之前字符的长度  如abca,当s.charAt(j) == a时，j - i + 1就是bca的长度</span></span><br><span class="line">        <span class="comment">//求最大值常规操作</span></span><br><span class="line">        ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从1开始</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里最主要就是这个<strong>i</strong>的理解</p><p><img alt="mark" data-src="http://static.imlgw.top///20190503/Qcj2l3E0v5sN.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这个i不一定是当前元素上一次出现的位置，也有可能是离<strong>当前</strong>元素从右向左<strong>最近</strong>的<strong>重复字符</strong>的_位置_。而index中存的就是这个元素的索引位置+1，为什么要加1？</p><p><img alt="mark" data-src="http://static.imlgw.top///20190503/N4GzYaft0suh.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>主要是因为i的默认值是0而数组默认值也是0，如果以0开始就会出现上面的情况。</p><p>其实这两种算法也比较类似，只是后面判断字符是否出现过的方式不同，前者是直接遍历这个子串，后者是利用字符为索引，其值就是上一次出现的位置(+1)，借此来计算长度。</p><p><strong>回首掏</strong></p><p>19/9/14，在网页上又写了一种不同的解法，属于解法4的变体（做的时候并没有想到解法4），<code>freq[]</code> 数组索引是字符串，但是值是该字符在s中对应的索引，不会遍历两遍数组，left可以通过索引直接跳到上一次出现的位置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring6</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()<<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    Arrays.fill(freq,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(right<s.length()){< span><br><span class="line">        <span class="keyword">char</span> sr=s.charAt(right);</span><br><span class="line">        <span class="comment">//已经存在,并且在窗口内</span></span><br><span class="line">        <span class="keyword">if</span>(freq[sr]!=-<span class="number">1</span> && freq[sr]>=left){</span><br><span class="line">            <span class="comment">//System.out.println(left+","+right+","+freq[sr]);</span></span><br><span class="line">            res=Math.max(res,right-left);</span><br><span class="line">            left=freq[sr]+<span class="number">1</span>;</span><br><span class="line">            freq[sr]=right;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            res=Math.max(res,right-left+<span class="number">1</span>);</span><br><span class="line">            freq[sr]=right;</span><br><span class="line">        }</span><br><span class="line">        right++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></s.length()){<></span></pre></td></tr></tbody></table></figure></div><p><strong>回首掏2</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring7</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()<<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Arrays.fill(freq,-1);</span></span><br><span class="line">    <span class="keyword">while</span>(right<s.length()){< span><br><span class="line">        <span class="keyword">char</span> sr=s.charAt(right);</span><br><span class="line">        <span class="comment">//已经存在(出现过),并且上一次出现在窗口内</span></span><br><span class="line">        <span class="keyword">if</span>(freq[sr]!=<span class="number">0</span> && freq[sr]>=left){</span><br><span class="line">            <span class="comment">//这里不包含right,所以不用加1</span></span><br><span class="line">            res=Math.max(res,right-left);</span><br><span class="line">            <span class="comment">//left移动到重复位置元素的下一个</span></span><br><span class="line">            <span class="comment">//因为freq的值是存的索引+1所以这里不用+1</span></span><br><span class="line">            left=freq[sr];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//这里包含right所以需要加1</span></span><br><span class="line">            res=Math.max(res,right-left+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//加1是为了区别s的第一个字符</span></span><br><span class="line">        freq[sr]=right+<span class="number">1</span>;</span><br><span class="line">        right++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></s.length()){<></span></pre></td></tr></tbody></table></figure></div><p>感觉对这题有很深的执念😅，对上面右优化了一下，但是其实还是上面的解法三比较简单，说到解法三，我又抽风改了一个boolean数组版本的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//用boolean数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring8</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> length=s.length();</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ASCII码表</span></span><br><span class="line">    <span class="keyword">boolean</span>[] freq=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">256</span>]; </span><br><span class="line">    freq[s.charAt(<span class="number">0</span>)]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head<length){< span><br><span class="line">        <span class="keyword">if</span>(tail+<span class="number">1</span><length&&!freq[s.charat(tail+<span class="number">1</length&&!freq[s.charat(tail+<span></span>)]){</length){<></span><br><span class="line">            tail++;</span><br><span class="line">            freq[s.charAt(tail)]=<span class="keyword">true</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            freq[s.charAt(head)]=<span class="keyword">false</span>;</span><br><span class="line">            head++;</span><br><span class="line">        }</span><br><span class="line">        max=max<tail-head+<span class="number">1</tail-head+<span></span>?tail-head+<span class="number">1</span>:max;<br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a></h2><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大(不超过)为 <em>k</em>。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题建议区看看原版的英文题，这里翻译过来有点误导人，应该是不超过k，写个最大搞得我有点懵</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">containsNearbyDuplicate2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="comment">//if(k==35000) return false; 哈哈哈哈</span></span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||k==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<len;i++) {< span><br><span class="line">        <span class="keyword">int</span> index=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i-index<=k){</span><br><span class="line">            <span class="comment">//k步之内</span></span><br><span class="line">            <span class="keyword">if</span>(index<<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[index--]){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></len;i++)></span></pre></td></tr></tbody></table></figure></div><p>暴力法，惨不忍睹，600ms，15%beats 。这题最好的做法还是借助hash表</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">containsNearbyDuplicate3</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<len;i++) {< span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(nums[i])){</span><br><span class="line">            <span class="keyword">int</span> index=map.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i-index<=k) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//大于k了那前面那个没用了</span></span><br><span class="line">                map.replace(nums[i],i);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></len;i++)></span></pre></td></tr></tbody></table></figure></div><p>12ms，90%，其实效率的差距就在查找子串里有没有这个字符上，HashMap的containsKey的效率比我们遍历的不知道高到那里去了，底层源码暂时还看不太懂，以后看的时候再专门来讲</p><p>19.9.14又做了一遍，直接在网页上写的，本来应该是bugfree的，结果减反了。。。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">HashMap<integer,integer> hashMap=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right<nums.length){< span><br><span class="line"><span class="keyword">if</span>(hashMap.containsKey(nums[right])){</span><br><span class="line"><span class="comment">//md,重新做的时候这里减反了真是个zz</span></span><br><span class="line"><span class="keyword">if</span>(right-hashMap.get(nums[right])<=k){</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">} <span class="keyword">else</span>{</span><br><span class="line">hashMap.put(nums[right],right);</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">hashMap.put(nums[right],right);</span><br><span class="line">}</span><br><span class="line">right++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></nums.length){<></span></pre></td></tr></tbody></table></figure></div><p>19.9.15又做了一遍，这次代码写的很简洁，思路也不同了，直接利用set集合，维护一个大小为k的连续set(窗口)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    HashSet<integer> set=<span class="keyword">new</span> HashSet<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!set.add(nums[i])) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (set.size()>k) {</span><br><span class="line">            set.remove(nums[i-k]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h2><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。</p><p><strong>示例:</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: s = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶:</strong></p><p>如果你已经完成了<em>O</em>(<em>n</em>) 时间复杂度的解法, 请尝试 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度的解法。</p><p><strong>解法一</strong></p><p>老规矩先上个慢的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<len;i++){< span><br><span class="line">        <span class="keyword">if</span>(nums[i-<span class="number">1</span>]>=s) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=nums[i];</span><br><span class="line">        <span class="comment">//累加前面的元素，直到大于s或者index<0</span></span><br><span class="line">        <span class="keyword">while</span>(sum<s&&index>=<span class="number">0</span>){</s&&index></span><br><span class="line">            sum+=nums[index--];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(sum>=s){</span><br><span class="line">            minLen=minLen>i-index?i-index:minLen;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(i==len-<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minLen;</span><br><span class="line">}</span><br></len;i++){<></span></pre></td></tr></tbody></table></figure></div><p>这个是最开始想到了思路比较清晰，遍历数组然后逆序求和直到大于S，要注意边界，比较慢，主要就是那个循环累加前面的元素会很耗费时间，111ms，14% beats🤣</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSubArrayLen2</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len =nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//窗口左右边界</span></span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2,3,1,2,4,3 | 7</span></span><br><span class="line">    <span class="keyword">while</span> (tail<len) {< span><br><span class="line">        <span class="keyword">if</span>(sum>=s){</span><br><span class="line">            minLen=minLen>tail-head+<span class="number">1</span>?tail-head+<span class="number">1</span>:minLen;</span><br><span class="line">            <span class="comment">//System.out.println(minLen);</span></span><br><span class="line">            <span class="comment">//删除头节点（左边界左移）</span></span><br><span class="line">            sum-=nums[head++];</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//尾指针到达边界了</span></span><br><span class="line">            <span class="keyword">if</span>(tail==len-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//尾节点++，(右边界右移)</span></span><br><span class="line">            sum+=nums[++tail];</span><br><span class="line">            <span class="comment">//如果有元素大于s直接返回，节约时间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[tail]>=s){</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minLen==Integer.MAX_VALUE?<span class="number">0</span>:minLen;</span><br><span class="line">}</span><br></len)></span></pre></td></tr></tbody></table></figure></div><p>2ms ，99%beats，一对比差距就出来了，上面这种做法就是利用了滑动窗口的思想，很巧妙的利用了上一次计算的值，不用重复的计算累加和，上面的那种方法每次都会重新计算累加和，但是很多都是重复的计算，所以浪费了很多时间，要注意边界条件</p><p><code>2 3 1 2 4 3  s=7</code></p><p><img alt="mark" data-src="http://static.imlgw.top///20190504/U9BTOJMRVhDO.jpg?imageslim" src="/img/loading.gif" class="lazyload"></p><p>自己在纸上画一下就懂了</p><p><strong>解法三</strong></p><p>找到一个板子，统一一下写法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSubArrayLen3</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len =nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2,3,1,2,4,3 | 7</span></span><br><span class="line">    <span class="keyword">while</span> (head<=len) {</span><br><span class="line">        <span class="keyword">if</span>(tail+<span class="number">1</span><=len && sum<s){< span><br><span class="line">            sum+=nums[++tail];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            sum-=nums[head++];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(sum>=s){</span><br><span class="line">            minLen=minLen>tail-head+<span class="number">1</span>?tail-head+<span class="number">1</span>:minLen;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minLen==Integer.MAX_VALUE?<span class="number">0</span>:minLen;</span><br><span class="line">}</span><br></s){<></span></pre></td></tr></tbody></table></figure></div><h2 id="480-滑动窗口中位数"><a href="#480-滑动窗口中位数" class="headerlink" title="480. 滑动窗口中位数"></a><a href="https://leetcode-cn.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. 滑动窗口中位数</a></h2><p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p><p>例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，中位数是 <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>]，中位数是 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></tbody></table></figure></div><p>给出一个数组 nums，有一个大小为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p><p>例如：</p><p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">窗口位置                      中位数</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">1</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       -<span class="number">1</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       -<span class="number">1</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p> 因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p><p><strong>提示：</strong><br>假设<code>k</code>是合法的，即：<code>k</code> 始终小于输入的非空数组的元素个数.</p><p>head题，理清楚思路后也不难。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) {</span><br><span class="line">    <span class="comment">//看了一圈评论区，大概知道思路了，还是要排序</span></span><br><span class="line">    <span class="comment">//List<integer> list=new ArrayList<>(); 用链表还是不方便啊</integer></span></span><br><span class="line">    <span class="keyword">int</span> [] queue=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=k-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//头尾</span></span><br><span class="line">    <span class="keyword">double</span> [] res=<span class="keyword">new</span> <span class="keyword">double</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<k;i++) {< span><br><span class="line">        queue[i]=nums[i];</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(queue);</span><br><span class="line">    printArray(queue);</span><br><span class="line">    <span class="keyword">if</span> (k%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">        res[<span class="number">0</span>]=queue[(k-<span class="number">1</span>)/<span class="number">2</span>]/<span class="number">2.0</span>+queue[(k-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>]/<span class="number">2.0</span>;</span><br><span class="line">        <span class="comment">//注意除小数 .。。。。这里的测试用例Integer最大值，直接相加/2会越界</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        res[<span class="number">0</span>]=queue[k/<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=k;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//插入之前要移除上一次的头元素，这里用数组不好搞啊啊</span></span><br><span class="line">        <span class="comment">//System.out.println(nums[i-k]);</span></span><br><span class="line">        deleHead(queue,nums[i-k]);</span><br><span class="line">        tail--;</span><br><span class="line">        <span class="comment">//printArray(queue);</span></span><br><span class="line">        <span class="comment">//二分找插入点</span></span><br><span class="line">        <span class="keyword">int</span> index=binarySearch(queue,<span class="number">0</span>,tail,nums[i]);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="comment">//插入元素，tail++;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=tail;j>index;j--) {</span><br><span class="line">            <span class="comment">//后一个等于前一个，给插入的元素腾出位置</span></span><br><span class="line">            queue[j]=queue[j-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        queue[index]=nums[i];</span><br><span class="line">        <span class="comment">//求中点</span></span><br><span class="line">        <span class="keyword">if</span> (k%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">            res[i-k+<span class="number">1</span>]=queue[head+(tail-head)/<span class="number">2</span>]/<span class="number">2.0</span>+queue[head+(tail-head)/<span class="number">2</span>+<span class="number">1</span>]/<span class="number">2.0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res[i-k+<span class="number">1</span>]=queue[head+(tail-head)/<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleHead</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j<nums.length;j++,i++) {< span><br><span class="line">        <span class="keyword">if</span>(nums[j]==target){</span><br><span class="line">            <span class="keyword">if</span> (i==nums.length-<span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(i<nums.length-<span class="number">1</nums.length-<span></span>){</nums.length;j++,i++)></span><br><span class="line">                nums[i]=nums[i+<span class="number">1</span>];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]<target){< span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]>target){</span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">}</span><br></target){<></span></nums.length;i++)></span></k;i++)></span></pre></td></tr></tbody></table></figure></div><p>根据评论区提供的思路，用数组实现了一遍，当时就感觉有问题，确实，最后 164ms ，27%，很慢了，我觉得主要问题就是那个删除头的操作，但是毕竟数组，没办法，随即改用链表</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] medianSlidingWindow2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) {</span><br><span class="line">    <span class="comment">//看了一圈评论区，大概知道思路了，还是要排序</span></span><br><span class="line">    List<integer> list=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=k-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//头尾</span></span><br><span class="line">    <span class="keyword">double</span> [] res=<span class="keyword">new</span> <span class="keyword">double</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//Arrays.sort(nums,0,k);</span></span><br><span class="line">    <span class="keyword">int</span> []temp=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<k;i++) {< span><br><span class="line">        temp[i]=nums[i];</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(temp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<k;i++) {< span><br><span class="line">        list.add(temp[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (k%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">        res[<span class="number">0</span>]=list.get((k-<span class="number">1</span>)/<span class="number">2</span>)/<span class="number">2.0</span>+list.get((k-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>)/<span class="number">2.0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        res[<span class="number">0</span>]=list.get(k/<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=k;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//插入之前要移除上一次的头元素，这里用数组不好搞啊啊</span></span><br><span class="line">        <span class="comment">//list.remove((Object)nums[i-k]); 直接删太慢了</span></span><br><span class="line">        <span class="keyword">int</span> dele=binarySearch(list,<span class="number">0</span>,k-<span class="number">1</span>,nums[i-k]);</span><br><span class="line">        list.remove(dele);</span><br><span class="line">        <span class="comment">//System.out.println(list);</span></span><br><span class="line">        <span class="comment">//二分找插入点，找的区间为 [i-k+1, i-1]</span></span><br><span class="line">        <span class="comment">//int head=i-k+1,tail=i-1;</span></span><br><span class="line">        <span class="keyword">int</span> index=binarySearch(list,<span class="number">0</span>,k-<span class="number">2</span>,nums[i]);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        list.add(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=k-<span class="number">1</span>;j>index;j--) {</span><br><span class="line">            <span class="comment">//后一个等于前一个，给插入的元素腾出位置</span></span><br><span class="line">            list.set(j,list.get(j-<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        list.set(index,nums[i]);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//求中点</span></span><br><span class="line">        <span class="keyword">if</span> (k%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">            res[i-k+<span class="number">1</span>]=list.get((k-<span class="number">1</span>)/<span class="number">2</span>) / <span class="number">2.0</span> + list.get((k-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>)/<span class="number">2.0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res[i-k+<span class="number">1</span>]=list.get(k/<span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List<integer> list,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> target)</integer></span></span>{</span><br><span class="line">    <span class="keyword">while</span>(lo<=hi){</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(list.get(mid)<target){< span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(list.get(mid)>target){</span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">}</span><br></target){<></span></nums.length;i++)></span></k;i++)></span></k;i++)></span></pre></td></tr></tbody></table></figure></div><p>47ms，70%左右，删除的时候利用二分删除，如果直接根据元素去删就跟数组效率差不多了。</p><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: S = <span class="string">"ADOBECODEBANC"</span>, T = <span class="string">"ABC"</span></span><br><span class="line">输出: <span class="string">"BANC"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明：</strong></p><ul><li>如果 S 中不存这样的子串，则返回空字符串 “”。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> slen=s.length();</span><br><span class="line">    <span class="keyword">int</span> tlen=t.length();</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>; <span class="comment">//初始都为0</span></span><br><span class="line">    <span class="keyword">int</span>[] target=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//A:1 B:1 C:1</span></span><br><span class="line">    <span class="keyword">int</span>[] window=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">//不同字符的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<tlen;i++) {< span><br><span class="line">        target[t.charAt(i)]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a:target) {</span><br><span class="line">        <span class="keyword">if</span> (a!=<span class="number">0</span>) {</span><br><span class="line">            count++; <span class="comment">//统计不同字符出现的次数</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> match=<span class="number">0</span>; <span class="comment">//match代表已经匹配的字符</span></span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">0</span>,Integer.MAX_VALUE};</span><br><span class="line">    <span class="keyword">while</span>(r<slen){< span><br><span class="line">        <span class="keyword">char</span> c=s.charAt(r); </span><br><span class="line">        <span class="keyword">if</span>(target[c]!=<span class="number">0</span>){ <span class="comment">//在目标子串中存在</span></span><br><span class="line">            window[c]++; <span class="comment">//window对应的char++</span></span><br><span class="line">            <span class="keyword">if</span>(window[c]==target[c]){ <span class="comment">//到达了目标串中该char所需的数量</span></span><br><span class="line">                match++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">while</span>(l<r&&count==match) { <span class="comment">//满足目标串，注意别越界</r&&count==match)></span></slen){<></span><br><span class="line">            <span class="keyword">char</span> d=s.charAt(l);</span><br><span class="line">            <span class="keyword">if</span> (r-l<res[<span class="number">1</res[<span></span>]-res[<span class="number">0</span>]) { <span class="comment">//统计最小值</span></tlen;i++)></span><br><span class="line">                res[<span class="number">0</span>]=l;</span><br><span class="line">                res[<span class="number">1</span>]=r;</span><br><span class="line">            }</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (target[d]!=<span class="number">0</span>) {</span><br><span class="line">                window[d]--;</span><br><span class="line">                <span class="keyword">if</span> (window[d]<target[d]) {<span class="comment">//左边界左移后不再满足目标串</target[d])></span><br><span class="line">                    match--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">1</span>]==Integer.MAX_VALUE?<span class="string">""</span>:s.substring(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>10ms 86%，Hard题，其实大致的思路还是有的，主要是不知道怎么去和目标串对比，没想到用一个<code>window</code>数组去对比，一致想的是在目标串的数组上做手脚，但是越想越复杂。。。太蠢了😅，这题其实也可以用一个HashMap来做，但是我看了下提交记录上的普遍都是7,80ms，相对都比较慢，实际上题目没有明确的说明有特殊字符的话都是可以用一个<strong>ASCII</strong>数组来充当HashMap的，当然我这里用数组的时候相比HashMap要多了一步，需要统计不同字符出现的次数，不过这个操作也是常数级别的操作，并不耗时，整体时间复杂度O(N+M)，NM分别代表目标子串<code>t</code> 和源字符串 <code>p</code>的长度，首先遍历了<code>t</code> 然后滑动窗口，后面的滑动窗口左右边界最多移动2M次</p><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h2><p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 <strong>p</strong> 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: <span class="string">"cbaebabacd"</span> p: <span class="string">"abc"</span></span><br><span class="line">输出:</span><br><span class="line">[<span class="number">0</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 <span class="number">0</span> 的子串是 <span class="string">"cba"</span>, 它是 <span class="string">"abc"</span> 的字母异位词。</span><br><span class="line">起始索引等于 <span class="number">6</span> 的子串是 <span class="string">"bac"</span>, 它是 <span class="string">"abc"</span> 的字母异位词。</span><br></pre></td></tr></tbody></table></figure></div><p> <strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: <span class="string">"abab"</span> p: <span class="string">"ab"</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 <span class="number">0</span> 的子串是 <span class="string">"ab"</span>, 它是 <span class="string">"ab"</span> 的字母异位词。</span><br><span class="line">起始索引等于 <span class="number">1</span> 的子串是 <span class="string">"ba"</span>, 它是 <span class="string">"ab"</span> 的字母异位词。</span><br><span class="line">起始索引等于 <span class="number">2</span> 的子串是 <span class="string">"ab"</span>, 它是 <span class="string">"ab"</span> 的字母异位词。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题和上面一题其实一样，只是这里要求是连续的，在上面一题的基础上在添加结果的时候判断下长度就OK</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </integer></span>{</span><br><span class="line">    <span class="keyword">int</span>[] target=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span>[] window=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> plen=p.length();</span><br><span class="line">    <span class="keyword">int</span> slen=s.length();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,match=<span class="number">0</span>;</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArraysList<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<plen;i++) {< span><br><span class="line">        target[p.charAt(i)]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a:target) {</span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="number">0</span>){</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(r<slen){< span><br><span class="line">        <span class="keyword">char</span> right=s.charAt(r);</span><br><span class="line">        <span class="keyword">if</span> (target[right]!=<span class="number">0</span>) {</span><br><span class="line">            window[right]++;</span><br><span class="line">            <span class="keyword">if</span> (window[right]==target[right]) {</span><br><span class="line">                match++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">while</span>(l<r && count="=match){</span"><br><span class="line">            <span class="keyword">char</span> left=s.charAt(l);</span><br><span class="line">            <span class="keyword">if</span> (r-l==res) {</span><br><span class="line">                res.add(l);</span><br><span class="line">            }</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (target[left]!=<span class="number">0</span>) {</span><br><span class="line">                window[left]--;</span><br><span class="line">                <span class="comment">//不满足了</span></span><br><span class="line">                <span class="keyword">if</span> (window[left]<target[left]) {< span><br><span class="line">                    match--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></target[left])></span></r></span></slen){<></span></plen;i++)></span></pre></td></tr></tbody></table></figure></div><p>15ms，86%时间复杂度<code>O(M+N)</code>，但是这很明显并不是最优解，因为这题的窗口长度其实是可以固定的，滑动的可以更快，只用遍历一遍，等以后有时间再研究吧</p><h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>注意:</strong><br>字符串长度 和 k 不会超过 104。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"ABAB"</span>, k = <span class="number">2</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">4</span></span><br><span class="line">解释:</span><br><span class="line">用两个<span class="string">'A'</span>替换为两个<span class="string">'B'</span>,反之亦然。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"AABABBA"</span>, k = <span class="number">1</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">4</span></span><br><span class="line">解释:</span><br><span class="line">将中间的一个<span class="string">'A'</span>替换为<span class="string">'B'</span>,字符串变为 <span class="string">"AABBBBA"</span></span><br><span class="line">子串 <span class="string">"BBBB"</span> 有最长重复字母, 答案为 <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>, cur = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (end < s.length()) {</span><br><span class="line">        <span class="comment">//当前窗口出现最多的字符</span></span><br><span class="line">        cur = Math.max(cur, ++count[s.charAt(end)]);</span><br><span class="line">        <span class="comment">//不能替换了,不同字符太多了,需要缩减窗口</span></span><br><span class="line">        <span class="keyword">while</span> (end - start + <span class="number">1</span> - cur > k){</span><br><span class="line">            <span class="comment">//缩减左边界的count</span></span><br><span class="line">            count[s.charAt(start)]--;</span><br><span class="line">            start++;<span class="comment">//不能替换了，start++</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//统计最大值</span></span><br><span class="line">        max = Math.max(max, end - start + <span class="number">1</span>);</span><br><span class="line">        end++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234. 替换子串得到平衡字符串"></a><a href="https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/" target="_blank" rel="noopener">1234. 替换子串得到平衡字符串</a></h2><p>有一个只含有 <code>'Q', 'W', 'E', 'R'</code> 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 <code>n/4</code> 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 <code>s</code>，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0 </p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"QWER"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：s 已经是平衡的了。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"QQWE"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们需要把一个 <span class="string">'Q'</span> 替换成 <span class="string">'R'</span>，这样得到的 <span class="string">"RQWE"</span> (或 <span class="string">"QRWE"</span>) 是平衡的。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"QQQW"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：我们可以把前面的 <span class="string">"QQ"</span> 替换成 <span class="string">"ER"</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 4：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"QQQQ"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以替换后 <span class="number">3</span> 个 <span class="string">'Q'</span>，使 s = <span class="string">"QWER"</span>。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li>1 <= s.length <= 10^5</li><li>s.length 是 4 的倍数</li><li>s 中只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符</li></ul><p><strong>解法一</strong></p><p>周赛题，说实话不多做做竞赛真不知道自己多菜</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">balancedString</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>|| s.length()<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    <span class="keyword">int</span> balance=len/<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//映射字符</span></span><br><span class="line">    <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//统计4个字符串出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<len;i++) {< span><br><span class="line">        count[s.charAt(i)]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,res=len;</span><br><span class="line">    <span class="keyword">while</span>(right<len){< span><br><span class="line">        count[s.charAt(right)]--;</span><br><span class="line">        <span class="keyword">while</span>(left<len && count[<span class="string">'Q'</len></span>]<=balance && count[<span class="string">'W'</span>]<=balance && count[<span class="string">'E'</span>] <=balance && count[<span class="string">'R'</span>]<=balance){</len){<></span><br><span class="line">            res=Math.min(res, right-left+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//窗口左移，缩小窗口</span></span><br><span class="line">            count[s.charAt(left)]++;</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//扩大右边界</span></span><br><span class="line">        right++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></len;i++)></span></pre></td></tr></tbody></table></figure></div><p>左指针追赶右指针，形成滑动窗口，感觉滑动窗口的题真的有点不好搞啊！！！</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket网络编程</title>
      <link href="/2019/07/19/socket-wang-luo-bian-cheng/"/>
      <url>/2019/07/19/socket-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="Socket概述"><a href="#Socket概述" class="headerlink" title="Socket概述"></a>Socket概述</h3><p>​    套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。socket提供的函数是<strong>操作系统内核将“TCP/IP协议栈 + 底层网卡”抽象出来的一个个用户友好的函数，用于操纵本地的“TCP/IP协议栈 + 底层网卡”与远端的服务器/主机完成通信的任务。</strong></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>🔸 TCP是面向连接的通信协议</p><p>🔸 通过<code>三次握手</code>建立连接，通讯完成时要拆除连接</p><p>🔸 由于TCP是面向连接的所以只能用于端到端的通讯</p><p>🔸 三次握手四次挥手</p><p>🔸 具有校验机制，可靠，数据传输稳定</p><h4 id="简单的Socket小案例"><a href="#简单的Socket小案例" class="headerlink" title="简单的Socket小案例"></a>简单的Socket小案例</h4><p><strong>Socket客户端</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TcpDemo;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/7 9:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOTE_PORT = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOCAL_PORT = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        Socket socket = creatSocket();</span><br><span class="line">        initSocket(socket);</span><br><span class="line">        <span class="comment">//setRecessAddress前</span></span><br><span class="line">        socket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), LOCAL_PORT));</span><br><span class="line">        <span class="comment">//连接远程server</span></span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), REMOTE_PORT), <span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"客户端已经发起连接"</span>);</span><br><span class="line">        System.out.println(<span class="string">"客户端信息:"</span> + socket.getLocalAddress() + <span class="string">"port:"</span> + socket.getLocalPort());</span><br><span class="line">        System.out.println(<span class="string">"服务端信息"</span> + socket.getInetAddress() + <span class="string">"port:"</span> + socket.getPort());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            sendMsg(socket);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.err.println(<span class="string">"连接异常关闭！！！！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            socket.close();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSocket</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> SocketException </span>{</span><br><span class="line">        socket.setSoTimeout(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//是否复用未完全关闭后的端口(TIME_WAIT状态)，必须在bind前，所以就不能通过构造器来绑定本地端口</span></span><br><span class="line">        socket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//是否开启Nagle算法(默认开启) https://baike.baidu.com/item/Nagle%E7%AE%97%E6%B3%95</span></span><br><span class="line">        socket.setTcpNoDelay(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//长时间无数据相应的时候发送确认数据（心跳包）时间大约两个小时</span></span><br><span class="line">        socket.setKeepAlive(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          close关闭后的处理</span></span><br><span class="line"><span class="comment">          这个Socket选项可以影响close方法的行为。</span></span><br><span class="line"><span class="comment">          false 0 默认情况 关闭后立即返回，底层系统接管输出流，将缓冲区的数据发送完成</span></span><br><span class="line"><span class="comment">          true 0 关闭后直接返回 缓冲区数据直接抛弃 直接发送RES结束命令到对方，无需经过2MSL等待</span></span><br><span class="line"><span class="comment">          true 200 关闭时最长阻塞200s 随后按第二情况处理</span></span><br><span class="line"><span class="comment">          (是s不是ms,开始搞错了 设置了20重启就会端口占用。。。。)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        socket.setSoLinger(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置紧急数据是否内敛,如果这个Socket选项打开，</span></span><br><span class="line"><span class="comment">        可以通过Socket类的sendUrgentData方法</span></span><br><span class="line"><span class="comment">        向服务器发送一个单字节的数据 这个单字节数据并不经过输出缓冲区，而是立即发出。</span></span><br><span class="line"><span class="comment">        虽然在客户端并不是使用OutputStream向服务器发送数据，</span></span><br><span class="line"><span class="comment">        但在服务端程序中这个单字节的数据是和其它的普通数据混在一起的</span></span><br><span class="line"><span class="comment">        因此，在服务端程序中并不知道由客户</span></span><br><span class="line"><span class="comment">        端发过来的数据是由OutputStream</span></span><br><span class="line"><span class="comment">        还是由sendUrgentData发过来的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        socket.setOOBInline(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置收发缓冲器大小，默认32K</span></span><br><span class="line">        socket.setReceiveBufferSize(<span class="number">64</span>*<span class="number">1024</span>);</span><br><span class="line">        socket.setSendBufferSize(<span class="number">64</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//设置性能参数的 优先级  短链接 延迟 带宽</span></span><br><span class="line">        socket.setPerformancePreferences(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Socket <span class="title">creatSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //无代理模式, 相当于空构造函数</span></span><br><span class="line"><span class="comment">        Socket socket = new Socket(Proxy.NO_PROXY);</span></span><br><span class="line"><span class="comment">        //HTTP代理模式传输的数据将通过www.imlgw.top转发</span></span><br><span class="line"><span class="comment">        socket = new Socket(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(Inet4Address.getByName("www.imlgw.top"), 80)));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //下面两种方式回在创建的时候就去链接远程的服务器(具体看源码),然而一般情况下其实在连接之前我们还需要设置一些参数</span></span><br><span class="line"><span class="comment">        //新建一个套接字 链接到远程服务器和端口（本地端口为系统分配）</span></span><br><span class="line"><span class="comment">        socket = new Socket("imlgw.top", REMOTE_PORT);</span></span><br><span class="line"><span class="comment">        //新建套接字直接链接到远程端口 并绑定本地端口</span></span><br><span class="line"><span class="comment">        socket=new Socket("imlgw.top",REMOTE_PORT,InetAddress.getLocalHost(),LOCAL_PORT);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建socket然后绑定到本地端口</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">        <span class="keyword">return</span> socket;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">//键盘的输入流</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//拿到socket的输出流</span></span><br><span class="line">        OutputStream socketOutputStream = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//转换为打印流</span></span><br><span class="line">        PrintStream printStream = <span class="keyword">new</span> PrintStream(socketOutputStream);</span><br><span class="line">        <span class="comment">//socket的输入流</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">//转换位buffer流</span></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">//客户端发送消息</span></span><br><span class="line">            printStream.println(scanner.nextLine());</span><br><span class="line">            <span class="comment">//服务端的响应</span></span><br><span class="line">            String s = bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"bye"</span>.equals(s)) {</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                System.out.println(<span class="string">"服务端响应："</span> + s);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (flag);</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        printStream.close();</span><br><span class="line">        scanner.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Socket服务端</strong></p><p> 这里为了同时处理多个客户端设计成了<strong>多线程</strong>异步的模式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TcpDemo;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/7 9:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        ServerSocket server = creatServerSocket();</span><br><span class="line">        initServerSocket(server);</span><br><span class="line">        <span class="comment">//初始化之后再绑定，不然一些设置会失效，比如 setReuseAddress</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), SERVER_PORT), <span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器准备就绪"</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务端信息"</span> + server.getInetAddress() + <span class="string">" port:"</span> + server.getLocalPort());</span><br><span class="line">        <span class="comment">//监听客户端的消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="comment">//阻塞方法</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            ClientHandle clientHandle = <span class="keyword">new</span> ClientHandle(client);</span><br><span class="line">            <span class="keyword">new</span> Thread(clientHandle).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initServerSocket</span><span class="params">(ServerSocket server)</span> <span class="keyword">throws</span> SocketException </span>{</span><br><span class="line">        <span class="comment">//同client</span></span><br><span class="line">        server.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置accept的buffer</span></span><br><span class="line">        server.setReceiveBufferSize(<span class="number">64</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//设置timeout</span></span><br><span class="line">        <span class="comment">//server.setSoTimeout(2000);</span></span><br><span class="line">        <span class="comment">//设置性能参数,连接前设置</span></span><br><span class="line">        server.setPerformancePreferences(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocket <span class="title">creatServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        <span class="comment">//绑定端口 backlog:新连接队列的长度限制,不是链接的数量,是允许等待的队列长度</span></span><br><span class="line">        <span class="comment">//server.bind(new InetSocketAddress(InetAddress.getLocalHost(),SERVER_PORT),50);</span></span><br><span class="line">        <span class="comment">//server =new ServerSocket(SERVER_PORT,50); 等效方案</span></span><br><span class="line">        <span class="comment">//server =new ServerSocket(SERVER_PORT,50,InetAddress.getLocalHost());</span></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        ClientHandle(Socket client) {</span><br><span class="line">            <span class="keyword">this</span>.socket = client;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"新客户端连接："</span> + socket.getInetAddress() + <span class="string">"port："</span> + socket.getPort());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//输入流获取信息</span></span><br><span class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="comment">//输出流响应客户端</span></span><br><span class="line">                PrintStream printStream = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    String s = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"bye"</span>.equalsIgnoreCase(s)) {</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        System.out.println(<span class="string">"客户端关闭了连接"</span>);</span><br><span class="line">                        printStream.println(<span class="string">"bye"</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                        printStream.println(<span class="string">"字符串长度#"</span> + s.length());</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">while</span> (flag);</span><br><span class="line">                reader.close();</span><br><span class="line">                printStream.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    socket.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>具体的一些常用的方法解释都在代码的注释中 <a href="https://elf8848.iteye.com/blog/1739598" target="_blank" rel="noopener">参考</a></p></blockquote><p><img alt="mark" data-src="http://static.imlgw.top/image/20190707/eBKfzShaiIHU.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h4 id="传输基本数据类型"><a href="#传输基本数据类型" class="headerlink" title="传输基本数据类型"></a>传输基本数据类型</h4><p>上面的哪个小案例传送的都是字符串类型的数据，也许有同学会说这些基本类型不都是可以通过字符串来传吗？为什么要费那个劲去传这些基本类型？其实不然，这里假设要传送的是 int类型的12345678 ，如果通过 <code>int</code> 来传输只要在范围内都是<strong>4</strong>个字节大小固定，然而通过<code>String</code>传送将会是”12345678” 也就是<strong>8</strong>个字节，消耗要比使用<code>int</code>要大，而且长度不固定，不方便后期接受的长度判断。</p><p> <strong><code>int</code> 类型</strong>  </p><p>在网络上传输的都是以<strong>Byte</strong>为基本单位，如果要传送<strong>int</strong>我们就需要将<strong>int</strong>转换为<strong>byte</strong>，一个<strong>int</strong>是4个字节，我们可以将其转换为一个<strong>byte[]</strong>数组，废话不多说，上代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/11 13:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteTools</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2byte(<span class="keyword">int</span> a) {</span><br><span class="line">        <span class="comment">//无符号右移</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[]{</span><br><span class="line">                (<span class="keyword">byte</span>) (a >>> <span class="number">24</span>),</span><br><span class="line">                (<span class="keyword">byte</span>) (a >>> <span class="number">16</span>),</span><br><span class="line">                (<span class="keyword">byte</span>) (a >>> <span class="number">8</span>),</span><br><span class="line">                (<span class="keyword">byte</span>) (a)</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byte2int</span><span class="params">(<span class="keyword">byte</span>[] a)</span> </span>{</span><br><span class="line">        <span class="comment">//&0xff-->转换为int 将高位补0,低8位不变</span></span><br><span class="line">        <span class="comment">//-127 ：10000001(补) &0xff --> 00000000 00000000 00000000 10000001</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">3</span>] & <span class="number">0xff</span> | (a[<span class="number">2</span>] & <span class="number">0xff</span>) << <span class="number">8</span> | (a[<span class="number">1</span>] & <span class="number">0xff</span>) << <span class="number">16</span> | (a[<span class="number">0</span>] & <span class="number">0xff</span>) << <span class="number">24</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>为什么这样做的一些细节可以参考 <a href="https://www.cnblogs.com/think-in-java/p/5527389.html" target="_blank" rel="noopener">这篇博客</a></p><p>有了这个工具类我们就可以将<strong>int</strong>转换为<strong>byte[]</strong>后进行传输，同时接收端也可以通过这个方法将数据还原。</p><p>等等🙄 ，这样一来不是所有的类型对应的都要去写个这样的转换的方法？那还是有点麻烦的，而且也没有什么技术含量，所以这样的事情<strong>JDK</strong>帮我们做了</p><p><strong><code>ByteBuffer</code></strong>：nio中的一个包，这里我还不太熟悉这个具体的作用，目前只知道可以用来包装<strong>byte[]</strong>，然后可以实现上面的类型转换</p><p><strong>Client发送端</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line"><span class="comment">//包装buffer (装饰器模式？</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);</span><br><span class="line"><span class="comment">//byte  1</span></span><br><span class="line">byteBuffer.put((<span class="keyword">byte</span>) <span class="number">126</span>);</span><br><span class="line"><span class="comment">//int 类型 4</span></span><br><span class="line">byteBuffer.putInt(<span class="number">123</span>);</span><br><span class="line"><span class="comment">//char 2(unicode)</span></span><br><span class="line">byteBuffer.putChar(<span class="string">'A'</span>);</span><br><span class="line"><span class="comment">//long 8</span></span><br><span class="line">byteBuffer.putLong(<span class="number">323333231234124321L</span>);</span><br><span class="line"><span class="keyword">boolean</span> isOk=<span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//byte 1</span></span><br><span class="line">byteBuffer.put((<span class="keyword">byte</span>) (isOk?<span class="number">1</span>:<span class="number">0</span>));</span><br><span class="line"><span class="comment">//float 4</span></span><br><span class="line">byteBuffer.putFloat(<span class="number">123.2132F</span>);</span><br><span class="line"><span class="comment">//double 8 =28</span></span><br><span class="line">byteBuffer.putDouble(<span class="number">231.1412421321</span>);</span><br><span class="line"><span class="comment">//String 10</span></span><br><span class="line">byteBuffer.put(<span class="string">"HelloWorld"</span>.getBytes());</span><br><span class="line"><span class="comment">//发送 38 Byte </span></span><br><span class="line">socketOutputStream.write(buffer,<span class="number">0</span>,byteBuffer.position());</span><br></pre></td></tr></tbody></table></figure></div><p>需要注意的地方就是最后<strong>write</strong>的时候，第二个参数<strong>len</strong>，直接传<strong>position()</strong>,就可以了，不用+1，这个position是下一个字节位置</p><blockquote><p>这里其实我看的教程这里是加1了的，最后接收过来的数据长度死活对不上，我开始还以为是什么<strong>内存对齐</strong>，什么乱七八糟的然后才发现是这里有问题。。。</p></blockquote><p><strong>Server接收端</strong></p><p>基本类型的读取与上面对应的<strong>get</strong>，最后一个String需要注意，直接用原始的<strong>buffer</strong>就可以了，不需要借助<strong>ByteBuffer</strong>，这里同样后面不用-1</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(buffer, byteBuffer.position(), readByteCount-byteBuffer.position());</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试结果</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">服务器准备就绪</span><br><span class="line">服务端信息LAPTOP-V5R5ABUJ/<span class="number">192.168</span><span class="number">.25</span><span class="number">.1</span> port:<span class="number">20000</span></span><br><span class="line">新客户端连接：/<span class="number">192.168</span><span class="number">.25</span><span class="number">.1</span>port：<span class="number">30000</span></span><br><span class="line">当前下标<span class="number">28</span></span><br><span class="line">接受到Client数据长度(<span class="keyword">byte</span>)：<span class="number">38</span></span><br><span class="line">Client发送的数据:</span><br><span class="line"><span class="number">126</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">A</span><br><span class="line"><span class="number">323333231234124321</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">123.2132</span></span><br><span class="line"><span class="number">231.1412421321</span></span><br><span class="line">HelloWorld</span><br></pre></td></tr></tbody></table></figure></div><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>🔸  UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</p><p>🔸  UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p><p>🔸   UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</p><p>🔸   UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如IP电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP正好符合这种要求。</p><p>🔸   UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p>🔸   UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p><h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><p><strong>消息接收者</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/7 21:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProvide</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">//监听20000端口</span></span><br><span class="line">        DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">20000</span>);</span><br><span class="line">        System.out.println(<span class="string">"UDPProvide is start...."</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">        <span class="comment">//构建接受的DatagramPacket</span></span><br><span class="line">        DatagramPacket udp_receive=<span class="keyword">new</span> DatagramPacket(buf,buf.length);</span><br><span class="line">        <span class="comment">//构建接受的DatagramPacket (阻塞)</span></span><br><span class="line">        socket.receive(udp_receive);</span><br><span class="line">        <span class="comment">//获取发送人的SocketAddress</span></span><br><span class="line">        SocketAddress socketAddress = udp_receive.getSocketAddress();</span><br><span class="line">        <span class="keyword">int</span> datalen = udp_receive.getLength();</span><br><span class="line">        <span class="comment">//获取发送的数据</span></span><br><span class="line">        String receive=<span class="keyword">new</span> String(udp_receive.getData(),<span class="number">0</span>,datalen);</span><br><span class="line">        System.out.println(<span class="string">"receive from the: "</span>+socketAddress);</span><br><span class="line">        System.out.println(<span class="string">"receive data: "</span>+ receive);</span><br><span class="line">        <span class="comment">//构建响应的DatagramPacket</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = (<span class="string">"provider receive the data success "</span>+datalen).getBytes();</span><br><span class="line">        DatagramPacket udp_sendBack=<span class="keyword">new</span> DatagramPacket(bytes,bytes.length,socketAddress);</span><br><span class="line">        socket.send(udp_sendBack);</span><br><span class="line">        <span class="comment">//结束</span></span><br><span class="line">        System.out.println(<span class="string">"UDPProvide Finished."</span>);</span><br><span class="line">        socket.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>消息发送者</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/7 21:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSearch</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        System.out.println(<span class="string">"UDPSearch is ready..."</span>);</span><br><span class="line">        <span class="comment">//构建socket</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="keyword">byte</span>[] buff= <span class="string">"hello world"</span>.getBytes();</span><br><span class="line">        <span class="comment">//构建发送段</span></span><br><span class="line">        DatagramPacket udp_send=<span class="keyword">new</span> DatagramPacket(buff,buff.length);</span><br><span class="line">        <span class="comment">//指定对方ip</span></span><br><span class="line">        udp_send.setAddress(InetAddress.getLocalHost());</span><br><span class="line">        udp_send.setPort(<span class="number">20000</span>);</span><br><span class="line">        socket.send(udp_send);</span><br><span class="line">        <span class="comment">//获取响应段</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">        DatagramPacket udp_receive=<span class="keyword">new</span> DatagramPacket(buf,buf.length);</span><br><span class="line">        socket.receive(udp_receive);</span><br><span class="line">        String s = <span class="keyword">new</span> String(udp_receive.getData(), <span class="number">0</span>, udp_receive.getLength());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">"UDPSearch is over"</span>);</span><br><span class="line">        socket.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="多播-amp-广播"><a href="#多播-amp-广播" class="headerlink" title="多播&广播"></a>多播&广播</h4><p><strong>消息建造器</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/8 8:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCreator</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SN_HEADER = <span class="string">"收到暗号,我是SN:"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PORT_HEADER = <span class="string">"这是暗号,请回送到该端口:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildWithPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> PORT_HEADER + port;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parsePort</span><span class="params">(String sn)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (sn.startsWith(PORT_HEADER)) {</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(sn.substring(PORT_HEADER.length()));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildWithSn</span><span class="params">(String sn)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> SN_HEADER+sn;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseSn</span><span class="params">(String sn)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(sn.startsWith(SN_HEADER)){</span><br><span class="line">            <span class="keyword">return</span> sn.substring(SN_HEADER.length());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>消息接受者</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UdpDemo2;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/7 21:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProvide</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> PROVIDE_LISTEN_PORT = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        String sn = UUID.randomUUID().toString();</span><br><span class="line">        Provider provider = <span class="keyword">new</span> Provider(sn);</span><br><span class="line">        <span class="keyword">new</span> Thread(provider).start();</span><br><span class="line">        System.in.read();</span><br><span class="line">        provider.shutdown();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">public</span> DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String sn;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Provider</span><span class="params">(String sn)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.sn = sn;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"UDPProvide is start...."</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                socket = <span class="keyword">new</span> DatagramSocket(PROVIDE_LISTEN_PORT);</span><br><span class="line">                <span class="keyword">while</span> (!isDone) {</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">                    <span class="comment">//构建接受的DatagramPacket</span></span><br><span class="line">                    DatagramPacket udp_receive = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">                    <span class="comment">//接受DatagramPacket (阻塞)</span></span><br><span class="line">                    socket.receive(udp_receive);</span><br><span class="line">                    <span class="comment">//获取发送人的SocketAddress</span></span><br><span class="line">                    InetSocketAddress socketAddress = (InetSocketAddress) udp_receive.getSocketAddress();</span><br><span class="line">                    <span class="keyword">int</span> datalen = udp_receive.getLength();</span><br><span class="line">                    <span class="comment">//获取发送过来的数据</span></span><br><span class="line">                    String receive = <span class="keyword">new</span> String(udp_receive.getData(), <span class="number">0</span>, datalen);</span><br><span class="line">                    <span class="comment">//打印获取到的数据</span></span><br><span class="line">                    System.out.println(<span class="string">"receive from the: "</span> + socketAddress);</span><br><span class="line">                    System.out.println(<span class="string">"receive data: "</span> + receive);</span><br><span class="line">                    <span class="comment">//解析sn,获取需要回送的端口</span></span><br><span class="line">                    <span class="keyword">int</span> port = MessageCreator.parsePort(receive);</span><br><span class="line">                    <span class="keyword">if</span> (port != -<span class="number">1</span>) {</span><br><span class="line">                        <span class="comment">//构建回送的DatagramPacket</span></span><br><span class="line">                        <span class="keyword">byte</span>[] responseBody = MessageCreator.buildWithSn(sn).getBytes();</span><br><span class="line">                        DatagramPacket udp_sendBack = <span class="keyword">new</span> DatagramPacket(responseBody, <span class="number">0</span>, responseBody.length, socketAddress.getAddress(), port);</span><br><span class="line">                        socket.send(udp_sendBack);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                <span class="comment">// e.printStackTrace();</span></span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                closeRes();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//结束</span></span><br><span class="line">            System.out.println(<span class="string">"UDPProvide Finished."</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">            isDone = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//这里仅仅isDone=true 远远不够,因为socket.receive是一个永久阻塞的方法</span></span><br><span class="line">            <span class="comment">//所以下面还要close这个socket这样就会捕获到一个异常然后结束</span></span><br><span class="line">            closeRes();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeRes</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) {</span><br><span class="line">                socket.close();</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>与上面不同的是这里为了随时可以停止将其构建成了异步线程，当接受到终止信号的时候就会改变状态量，并close资源，然后利用异常停止线程。</p><p><strong>消息发送者</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UdpDemo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/7 21:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSearch</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEARCH_LISTEN_PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">        System.out.println(<span class="string">"UDPSearch is start..."</span>);</span><br><span class="line">        Listener listen = listen();</span><br><span class="line">        sendBoard();</span><br><span class="line">        System.in.read();</span><br><span class="line">        List<device> devices = listen.closeAndGetDeviceList();</device></span><br><span class="line">        <span class="keyword">for</span> (Device device : devices) {</span><br><span class="line">            System.out.println(device);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Listener <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        System.out.println(<span class="string">"UDPSearch Listener is start"</span>);</span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Listener listener=<span class="keyword">new</span> Listener(SEARCH_LISTEN_PORT,countDownLatch);</span><br><span class="line">        <span class="keyword">new</span> Thread(listener).start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">return</span> listener;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendBoard</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">//系统自动分配的端口</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">//构建socket</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = MessageCreator.buildWithPort(SEARCH_LISTEN_PORT).getBytes();</span><br><span class="line">        <span class="comment">//构建发送段</span></span><br><span class="line">        DatagramPacket udp_send = <span class="keyword">new</span> DatagramPacket(buff, buff.length);</span><br><span class="line">        <span class="comment">//广播地址</span></span><br><span class="line">        udp_send.setAddress(InetAddress.getByName(<span class="string">"255.255.255.255"</span>));</span><br><span class="line">        <span class="comment">//接收方的端口</span></span><br><span class="line">        udp_send.setPort(UDPProvide.PROVIDE_LISTEN_PORT);</span><br><span class="line">        socket.send(udp_send);</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">"UDPSearch Board is over"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        String ip;</span><br><span class="line">        String sn;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">(<span class="keyword">int</span> port, String ip, String sn)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.port = port;</span><br><span class="line">            <span class="keyword">this</span>.ip = ip;</span><br><span class="line">            <span class="keyword">this</span>.sn = sn;</span><br><span class="line">        }</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Device{"</span> +</span><br><span class="line">                    <span class="string">"port="</span> + port +</span><br><span class="line">                    <span class="string">", ip='"</span> + ip + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", sn='"</span> + sn + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'}'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> listenPort;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List<device> deviceList = <span class="keyword">new</span> ArrayList<device>();</device></device></span><br><span class="line">        <span class="comment">//private static DatagramSocket socket = null;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Listener</span><span class="params">(<span class="keyword">int</span> listenPort, CountDownLatch countDownLatch)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.listenPort = listenPort;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">//通知已经启动</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                socket = <span class="keyword">new</span> DatagramSocket(listenPort);</span><br><span class="line">                <span class="keyword">while</span> (!isDone) {</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">                    <span class="comment">//构建接受的DatagramPacket</span></span><br><span class="line">                    DatagramPacket udp_receive = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">                    <span class="comment">//接受DatagramPacket (阻塞)</span></span><br><span class="line">                    socket.receive(udp_receive);</span><br><span class="line">                    <span class="comment">//获取发送人的SocketAddress</span></span><br><span class="line">                    InetSocketAddress socketAddress = (InetSocketAddress) udp_receive.getSocketAddress();</span><br><span class="line">                    <span class="keyword">int</span> datalen = udp_receive.getLength();</span><br><span class="line">                    <span class="comment">//获取发送过来的数据</span></span><br><span class="line">                    String sn = <span class="keyword">new</span> String(udp_receive.getData(), <span class="number">0</span>, datalen);</span><br><span class="line">                    System.out.println(<span class="string">"back from the："</span> + socketAddress);</span><br><span class="line">                    System.out.println(<span class="string">"back data："</span> + sn);</span><br><span class="line">                    sn=MessageCreator.parseSn(sn);</span><br><span class="line">                    <span class="keyword">if</span> (sn != <span class="keyword">null</span>) {</span><br><span class="line">                        deviceList.add(<span class="keyword">new</span> Device(socketAddress.getPort(), socketAddress.getAddress().toString(), sn));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">               <span class="comment">//e.printStackTrace();</span></span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                closeRes();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"UDPSearch Listener is Finished..."</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeRes</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) {</span><br><span class="line">                socket.close();</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">List<device> <span class="title">closeAndGetDeviceList</span><span class="params">()</span> </device></span>{</span><br><span class="line">            isDone = <span class="keyword">true</span>;</span><br><span class="line">            closeRes();</span><br><span class="line">            <span class="keyword">return</span> deviceList;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里需要注意的就是广播的地址<strong>255.255.255.255</strong></p><blockquote><p>如果是在局域网内和其他机器通信需要关闭虚拟机的网卡，不然是走的虚拟机的网卡，其他机器接收不到。(我说怎么发送的<strong>IP</strong>不是我的本机的<strong>IP</strong>)</p></blockquote><p>🔸UDP是面向无连接的通讯协议，基于用户数据报的协议</p><p>🔸UDP数据包括目的端口号和源端口号信息</p><p>🔸通讯不需要连接，所以可以实现广播发送，并不局限于端到端</p><p>🔸结构简单，无校验，速度快，容易丢包，可广播</p><p>🔸他一旦把应用程序发给网络层的数据发送出去就不保留数据备份</p><h3 id="UDP辅助TCP-实现点对点传输"><a href="#UDP辅助TCP-实现点对点传输" class="headerlink" title="UDP辅助TCP 实现点对点传输"></a>UDP辅助TCP 实现点对点传输</h3><p>客户端先利用<code>UDP</code>向局域网发送广播，然后对应的服务器接收到之后就会将对应的<code>TCP</code>的端口回送给客户端，然后二者进行TCP的双向通信，代码太多这里就只放一下<code>Server</code>端的<code>Handler</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> udp_tcp_concurrency.server.handle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> udp_tcp_concurrency.utils.CloseUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来处理客户端的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/17 11:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerReadHandler serverReadHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerWriterHandler serverWriterHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloseNotify closeNotify;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket, CloseNotify closeNotify)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.serverReadHandler = <span class="keyword">new</span> ServerReadHandler(socket.getInputStream());</span><br><span class="line">        <span class="keyword">this</span>.serverWriterHandle = <span class="keyword">new</span> ServerWriterHandler(socket.getOutputStream());</span><br><span class="line">        <span class="keyword">this</span>.closeNotify = closeNotify;</span><br><span class="line">        System.out.println(<span class="string">"新客户端连接："</span> + socket.getInetAddress() + <span class="string">"port："</span> + socket.getPort());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String str)</span> </span>{</span><br><span class="line">        serverWriterHandle.send(str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从外界关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>{</span><br><span class="line">        serverReadHandler.stopRead();</span><br><span class="line">        serverWriterHandle.stopWriter();</span><br><span class="line">        CloseUtils.close(socket);</span><br><span class="line">        System.out.println(<span class="string">"客户端已经退出"</span>);</span><br><span class="line">        System.out.println(<span class="string">"address:"</span> + socket.getInetAddress() + <span class="string">",port:"</span> + socket.getPort());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自我关闭--->自闭</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopByMyself</span><span class="params">()</span> </span>{</span><br><span class="line">        stop();</span><br><span class="line">        closeNotify.onSelfClosed(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取并打印到屏幕(启动ClientReadHandle线程)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read2Print</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(serverReadHandler).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将已经关闭的handle暴露给TCPServer然后从list中移除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CloseNotify</span></span>{</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSelfClosed</span><span class="params">(ClientHandler clientHandler)</span></span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理服务端用于读取客户端消息的 Handle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServerReadHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> InputStream inputStream;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServerReadHandler</span><span class="params">(InputStream inputStream)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.inputStream = inputStream;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//输入流获取信息</span></span><br><span class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    String s = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span> (s == <span class="keyword">null</span>) {</span><br><span class="line">                        System.out.println(<span class="string">"客户端已经无法发送数据"</span>);</span><br><span class="line">                        <span class="comment">//结束当前Handle</span></span><br><span class="line">                        ClientHandler.<span class="keyword">this</span>.stopByMyself();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">//打印到屏幕</span></span><br><span class="line">                    System.out.println(s);</span><br><span class="line">                } <span class="keyword">while</span> (!done);</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                <span class="keyword">if</span> (!done) {</span><br><span class="line">                    <span class="comment">//非正常关闭</span></span><br><span class="line">                    System.err.println(<span class="string">"连接异常断开"</span>+e.getMessage());</span><br><span class="line">                    ClientHandler.<span class="keyword">this</span>.stopByMyself();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                CloseUtils.close(inputStream);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopRead</span><span class="params">()</span> </span>{</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            CloseUtils.close(inputStream);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理服务端向客户端发送消息的Handle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServerWriterHandler</span>  </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> PrintStream printStream;</span><br><span class="line">        <span class="comment">//线程池</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServerWriterHandler</span><span class="params">(OutputStream outputStream)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.printStream = <span class="keyword">new</span> PrintStream(outputStream);</span><br><span class="line">            <span class="comment">//单例线程池</span></span><br><span class="line">            executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String str)</span> </span>{</span><br><span class="line">            <span class="comment">//这里如果不用线程池</span></span><br><span class="line">            executorService.submit(<span class="keyword">new</span> WriteRunnable(str));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池的Runnable</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">WriteRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> String msg;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">WriteRunnable</span><span class="params">(String msg)</span> </span>{</span><br><span class="line">                <span class="keyword">this</span>.msg = msg;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">if</span>(ServerWriterHandler.<span class="keyword">this</span>.done){</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    ServerWriterHandler.<span class="keyword">this</span>.printStream.println(msg);</span><br><span class="line">                }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                    System.out.println(<span class="string">"write 异常退出："</span>+e.getMessage());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopWriter</span><span class="params">()</span> </span>{</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            CloseUtils.close(printStream);</span><br><span class="line">            executorService.shutdownNow();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>完整代码放在 <a href="https://github.com/imlgw/socketDemo" target="_blank" rel="noopener">github</a> 有一点需要注意的是这里用了一个单线程池去处理服务端发送消息的功能，这里其实用线程通信机制<code>wait/notify</code>也可以做到但是相比使用线程池会复杂许多。</p><h3 id="局域网聊天室实现"><a href="#局域网聊天室实现" class="headerlink" title="局域网聊天室实现"></a>局域网聊天室实现</h3><blockquote><p>这里的聊天室，其实关键的地方就在于对客户端发送的消息交由服务端进行转发。</p></blockquote><p>基于上面的进行改造</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 回调接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClientHandleCallBack</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将已经关闭的handle暴露给TCPServer然后从list中移除</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onSelfClosed</span><span class="params">(ClientHandler clientHandler)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将消息交给服务器转发</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clientHandler</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNewMessageArrived</span><span class="params">(ClientHandler clientHandler,String msg)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>增加一个消息抵达的接口，然后为了避免阻塞交给异步的单线程池去处理</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewMessageArrived</span><span class="params">(ClientHandler clientHandler, String msg)</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"Receive from:"</span>+clientHandler.getClientInfo()+<span class="string">" msg:"</span>+msg);</span><br><span class="line">       forwardThreadPool.submit(()->{</span><br><span class="line">           <span class="keyword">for</span> (ClientHandler clientHandle : clientHandles) {</span><br><span class="line">               <span class="comment">//跳过自己</span></span><br><span class="line">               <span class="keyword">if</span>(clientHandle.equals(clientHandler)){</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               }</span><br><span class="line">               <span class="comment">//对其他客户端发送消息</span></span><br><span class="line">               clientHandle.send(msg);</span><br><span class="line">           }</span><br><span class="line">       });</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p>详细代码 见<a href="https://github.com/imlgw/socketDemo" target="_blank" rel="noopener">Github</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter压测</title>
      <link href="/2019/06/06/jmeter-ya-ce-gong-ju/"/>
      <url>/2019/06/06/jmeter-ya-ce-gong-ju/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="JMeter入门"><a href="#JMeter入门" class="headerlink" title="JMeter入门"></a>JMeter入门</h2><p><a href="http://jmeter.apache.org/" target="_blank" rel="noopener">官网地址</a> 下载好之后直接运行jar包 </p><h3 id="简单上手"><a href="#简单上手" class="headerlink" title="简单上手"></a>简单上手</h3><p><strong>添加线程组</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190529/wBWwVD5chqtc.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>设置线程个数和配置</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190529/KonWE6pHVdMz.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>Ramp-Up就是多长时间内启动这些线程设置位0就是同时启动。</p><p><strong>设置HTTP请求默认值</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190529/73A4su1jMAWM.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>设置好后再添加具体的请求的时候就不用再写这个了</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190529/Uwy5zrWzFsji.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>添加HTTP请求</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190529/iVbmgkdG7D88.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这里对我们的秒杀商品列表进行压测。</p><p><strong>添加监听器</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190529/yVm6imNhWYKe.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这里添加比较常用的聚合报告就可以了</p><p><strong>结果</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190531/C3pwAwyh7BhG.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这里我们可以需要关注的就是吞吐量这个参数，一开始可能会不太准多测几次。</p><p>同时我们也可以用Linux的<code>top</code>命令查看当前CPU的利用率。</p><h3 id="添加自定义参数"><a href="#添加自定义参数" class="headerlink" title="添加自定义参数"></a>添加自定义参数</h3><p><img alt="mark" data-src="http://static.imlgw.top/image/20190601/VQ9adD8KBfvA.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190601/j1XB0mewqvJG.png?imageslim" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">17362363659</span>,<span class="number">3</span>d3ae96d381d4376b87cb7ebf14aadb6</span><br><span class="line"><span class="number">12012341234</span>,fbb11e35f16b4a54be1315a0a1619193</span><br><span class="line"><span class="number">11012341234</span>,<span class="number">58</span>d63f1d9482472f907829da2ae3b4ff</span><br><span class="line"><span class="number">10012341234</span>,<span class="number">09f</span>e09587b924c49b6db64f763c1ad10</span><br></pre></td></tr></tbody></table></figure></div><p><strong>效果</strong></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190601/5up85aDbSTWM.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h3><p>方便后面的压测，可以直接写一个工具类生成token供后面的redis使用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TokenUtils</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpikeUserService spikeUserService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String str=<span class="string">"0123456789"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HttpServletResponse resp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        FileOutputStream outputStream=<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:\\AliyunKey\\config.txt"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">20000</span>;i++){</span><br><span class="line">            String phone = creatPhone();</span><br><span class="line">            RegisterVo registerVo = <span class="keyword">new</span> RegisterVo(phone,<span class="string">"123456"</span>,<span class="string">"user-"</span>+i);</span><br><span class="line">            spikeUserService.register(registerVo);</span><br><span class="line">            <span class="comment">//需要在service层token返回出来</span></span><br><span class="line">            String token= spikeUserService.login(resp, <span class="keyword">new</span> LoginVo(registerVo.getMobile(), registerVo.getPassword()));</span><br><span class="line">            outputStream.write((phone+<span class="string">","</span>+token+<span class="string">"\n"</span>).getBytes());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">creatPhone</span><span class="params">()</span></span>{</span><br><span class="line">        String res=<span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">            res+=str.charAt(random.nextInt(<span class="number">10</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Redis压测"><a href="#Redis压测" class="headerlink" title="Redis压测"></a>Redis压测</h3><p>①redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000</p><p>100个并发，十万个请求，对常用的一些命令进行测试</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190601/oPkioXCFgL8R.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>②redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100</p><p>100 bytes payload </p><p>-q 是quiet输出信息较少</p><p>③ redis-benchmark -n 100000 -q script load “redis.call(‘set’,’foo’,’bar’)”</p><p>对特定的语句压测</p><h2 id="搭建压测环境"><a href="#搭建压测环境" class="headerlink" title="搭建压测环境"></a>搭建压测环境</h2><h3 id="命令行压测"><a href="#命令行压测" class="headerlink" title="命令行压测"></a>命令行压测</h3><p>其实还是需要借助图形界面来录好jmx文件然后上传到Linux上，然后执行</p><p>sh jmeter.sh -n -t Xxx.jmx -l result.jtl</p><p>然后再用图形界面导入result.jtl就可以看到结果</p><blockquote><p>上面的测试都是在我的开发机(win)上进行的，压测和服务都在本地，结果可能并不准确，这里为了隔离环境我开了了2个虚拟机，一个是部署服务的机器（2G 4核），一个是部署mysql和redis的机器（2G 4核），这里在Linux上运行部署项目有两种方式，一种是打成war包放在tomcat目录下，一种是打成jar包直接运行。</p></blockquote><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>✔ 192.168.25.123   Centos6  mysql+redis  2G4核</p><p>✔ 192.168.25.4     Centos7   SpikeServer+压测  2.5G 4核</p><p>✔<del>win10开发机     Jmeter压测 SpikeServer</del> </p><p>✔<del>192.168.25.129 Centos7 压测设备 2G4核</del></p><h3 id="SpringBoot打war包"><a href="#SpringBoot打war包" class="headerlink" title="SpringBoot打war包"></a>SpringBoot打war包</h3><p><strong>添加tomcat依赖(编译时依赖)</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><dependency></dependency></span><br><span class="line">    <groupid>org.springframework.boot</groupid></span><br><span class="line">    <artifactid>spring-boot-starter-tomcat</artifactid></span><br><span class="line"><scope>provided</scope></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p><strong>添加一个maven插件</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><plugin></plugin></span><br><span class="line">    <groupid>org.apache.maven.plugins</groupid></span><br><span class="line">    <artifactid>maven-war-plugin</artifactid></span><br><span class="line"><configuration></configuration></span><br><span class="line">    <failonmissingwebxml>false</failonmissingwebxml></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p><strong>修改pom打包方式位war</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><packaging>war</packaging></span><br></pre></td></tr></tbody></table></figure></div><p><strong>boot类添加一个方法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpikeApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(SpikeApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 打 war包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> builder.sources(SpikeApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>然后在项目目录下执行<code>mvn clean package</code>就会在target目录下生成war包，然后将war包拷到tomcat里面就可以直接运行了。</p><h3 id="SpringBoot打jar包"><a href="#SpringBoot打jar包" class="headerlink" title="SpringBoot打jar包"></a>SpringBoot打jar包</h3><p><strong>pom里的打包方式改为jar(默认就是jar)</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><packaging>war</packaging></span><br></pre></td></tr></tbody></table></figure></div><p><strong>添加一个maven插件</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><!--打jar包的插件--></span><br><span class="line"><plugin></plugin></span><br><span class="line">    <groupid>org.springframework.boot</groupid></span><br><span class="line"><artifactid>spring-boot-maven-plugin</artifactid></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p><strong>执行mvn clean package</strong></p><p>同上会在target目录下生成一个jar包，jar包内容大致如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Implementation-Title: Spike</span><br><span class="line">Implementation-Version: <span class="number">1.0</span>-SNAPSHOT</span><br><span class="line">Built-By: priva</span><br><span class="line">Implementation-Vendor-Id: top.imlgw</span><br><span class="line">Spring-Boot-Version: <span class="number">2.1</span><span class="number">.2</span>.RELEASE</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br><span class="line">Start-Class: top.imlgw.spike.SpikeApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Created-By: Apache Maven <span class="number">3.5</span><span class="number">.3</span></span><br><span class="line">Build-Jdk: <span class="number">1.8</span><span class="number">.0_172</span></span><br><span class="line">Implementation-URL: https:<span class="comment">//projects.spring.io/spring-boot/#/spring-bo</span></span><br><span class="line"> ot-starter-parent/Spike</span><br></pre></td></tr></tbody></table></figure></div><p>如果确少一些信息比如Main-Class和Start-Class，说明jar包打的有问题，运行会报<code>没有主清单属性</code>，我一开始没注意，我的<code>plugins</code>上层还有个<code>pluginmanagement</code>插件根本没加载进来，去掉就行了。</p><h2 id="开始压测"><a href="#开始压测" class="headerlink" title="开始压测"></a>开始压测</h2><h3 id="压测商品列表页面"><a href="#压测商品列表页面" class="headerlink" title="压测商品列表页面"></a>压测商品列表页面</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tolist</span><span class="params">(Model model,SpikeUser spikeUser)</span> </span>{</span><br><span class="line">    List<goodsvo> goodsVos = goodsService.goodsVoList();</goodsvo></span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, spikeUser);</span><br><span class="line">    model.addAttribute(<span class="string">"goodsList"</span>,goodsVos);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个接口主要就做了一个查询的mysql的操作，没有cookie所以不会去操作redis</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>一开始直接设置了 5000*10 的并发，然后服务端报了   打开文件过多的错误</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java.io.IOException: 打开的文件过多</span><br><span class="line">        at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method) ~[na:<span class="number">1.8</span><span class="number">.0_171</span>]</span><br><span class="line">        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:<span class="number">422</span>) ~[na:<span class="number">1.8</span><span class="number">.0_171</span>]</span><br><span class="line">        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:<span class="number">250</span>) ~[na:<span class="number">1.8</span><span class="number">.0_171</span>]</span><br><span class="line">        at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:<span class="number">448</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.14</span>.jar!/:<span class="number">9.0</span><span class="number">.14</span>]</span><br><span class="line">        at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:<span class="number">70</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.14</span>.jar!/:<span class="number">9.0</span><span class="number">.14</span>]</span><br><span class="line">        at org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:<span class="number">95</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.14</span>.jar!/:<span class="number">9.0</span><span class="number">.14</span>]</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>) [na:<span class="number">1.8</span><span class="number">.0_171</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>google后发现是句柄太少的原因，Linux默认是1024，而我们同时起了5000个线程自然就出问题了。</p><p>通过<code>ulimit -a</code> 可以查看到当前的最大句柄数<code>open files</code> ，这里我们可以通过 <code>ulimit -n 2048</code>临时的设置一个较大的值，但是重启后就会失效。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">core file <span class="title">size</span>          <span class="params">(blocks, -c)</span> 0</span></span><br><span class="line"><span class="function">data seg <span class="title">size</span>           <span class="params">(kbytes, -d)</span> unlimited</span></span><br><span class="line"><span class="function">scheduling <span class="title">priority</span>             <span class="params">(-e)</span> 0</span></span><br><span class="line"><span class="function">file <span class="title">size</span>               <span class="params">(blocks, -f)</span> unlimited</span></span><br><span class="line"><span class="function">pending <span class="title">signals</span>                 <span class="params">(-i)</span> 14707</span></span><br><span class="line"><span class="function">max locked <span class="title">memory</span>       <span class="params">(kbytes, -l)</span> 64</span></span><br><span class="line"><span class="function">max memory <span class="title">size</span>         <span class="params">(kbytes, -m)</span> unlimited</span></span><br><span class="line"><span class="function">open <span class="title">files</span>                      <span class="params">(-n)</span> 1024</span></span><br><span class="line"><span class="function">pipe <span class="title">size</span>            <span class="params">(<span class="number">512</span> bytes, -p)</span> 8</span></span><br><span class="line"><span class="function">POSIX message <span class="title">queues</span>     <span class="params">(bytes, -q)</span> 819200</span></span><br><span class="line"><span class="function">real-time <span class="title">priority</span>              <span class="params">(-r)</span> 0</span></span><br><span class="line"><span class="function">stack <span class="title">size</span>              <span class="params">(kbytes, -s)</span> 8192</span></span><br><span class="line"><span class="function">cpu <span class="title">time</span>               <span class="params">(seconds, -t)</span> unlimited</span></span><br><span class="line"><span class="function">max user <span class="title">processes</span>              <span class="params">(-u)</span> 14707</span></span><br><span class="line"><span class="function">virtual <span class="title">memory</span>          <span class="params">(kbytes, -v)</span> unlimited</span></span><br><span class="line"><span class="function">file <span class="title">locks</span>                      <span class="params">(-x)</span> unlimited</span></span><br></pre></td></tr></tbody></table></figure></div><p>这里最好是直接修改  /etc/security/limits.conf</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">*  soft nofile  <span class="number">32768</span></span><br><span class="line">*  hard nofile <span class="number">65536</span></span><br></pre></td></tr></tbody></table></figure></div><p>就可以将文件句柄限制统一改成软32768，硬65536。配置文件最前面的是指domain，设置为星号代表全局，另外你也可以针对不同的用户做出不同的限制。</p><p>注意：这个当中的硬限制是实际的限制，而软限制，是warnning限制，只会做出warning，其实ulimit命令本身就有分软硬设置，加-H就是硬，加-S就是软</p><p>修改后记得重启才会生效 <a href="https://www.cnblogs.com/ibook360/archive/2012/05/11/2495405.html" target="_blank" rel="noopener">参考资料</a> </p><p>一开始是打算直接用win开发机做压测的，但是发现在进程开大了之后老是跑不完，跑一半就停了（可能是内存给小了），而且数据出入也比较大，然后改用秒杀服务的那条机器来压测，一开始只增大了跑秒杀服务的虚拟机，发现还是会有异常，然后我把mysql和redis的虚拟机也调大了就没报异常了，但是在压测的时候秒杀服务的虚拟机cpu飙到了 <code>9.0+</code>，4核的机子，cpu飙到这么高就有点问题了一般来说应该维持在 <code>4*0.7</code> 左右。</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190604/LedMcRvfSXeb.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190604/UbcTCaTGiEJ9.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>可以看到平均等待时间都在2s以上。</p><p>为了更准确的模拟，我又开了一台<del>1G2核</del> 2G4核的虚拟机专门来做压测（8G内存吃不消了）。</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190604/pr4yMAE2Jamf.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这里用top观察了两台虚拟机的情况发现mysql的那台机器负载一直很低，SpikeServer那台机器（1G双核）负载一路飙到6.0+。吞吐率也明显的下降了，这里我连续测试了两次都是400多。</p><h3 id="最终配置"><a href="#最终配置" class="headerlink" title="最终配置"></a>最终配置</h3><p>经过一上午的折腾，我决定还是值利用两台你虚拟机，一台跑SpikeServer和压测，另外一台跑mysql和redis，再启动一台成本太大了，这里主要根据这个做一个标准量，后期优化后拿来对比</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img alt="mark" data-src="http://static.imlgw.top/image/20190604/IEGxtWU8pujI.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>后面在调整机器或连续测试了5，6次 在5000的并发下QPS大概是1000左右的样子，小于1000。</p><h3 id="压测Redis查询的性能"><a href="#压测Redis查询的性能" class="headerlink" title="压测Redis查询的性能"></a>压测Redis查询的性能</h3><p>上面的goods_list实际上只对mysql进行了一个查询操作，而mysql的并发量并不大。</p><p>下面我们单独对redis做一下压测，看下系统的QPS（这里）</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190604/h2NOJszwC7Lo.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>一开测试忘了调大redis链接池的大小，一直跑不出来，后来改大之后测了4，5次，同样的5000并发10次，QPS大概在3000左右</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190606/58L5ieKaxR7a.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>可以说是相当快了，而且<code>top</code>观察redis那台机器发现负载依然很低，说明这点并发确实对redis来说是小意思，前面其实也单独对redis用它自带的压测工具测试过，大概每秒10 0000的GET是没问题的</p><h3 id="重头戏—压测do-spike接口"><a href="#重头戏—压测do-spike接口" class="headerlink" title="重头戏—压测do_spike接口"></a>重头戏—压测do_spike接口</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/do_spike"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">do_spike</span><span class="params">(Model model, SpikeUser spikeUser, @RequestParam(<span class="string">"goodsId"</span>)</span> <span class="keyword">long</span> goodsId) </span>{</span><br><span class="line">       <span class="keyword">if</span> (spikeUser==<span class="keyword">null</span>) { <span class="comment">//没有登录</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">//检查库存</span></span><br><span class="line">       GoodsVo goodsVo= goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">       <span class="keyword">int</span> stock=goodsVo.getStockCount(); <span class="comment">//这里拿的秒杀商品里面的库存,不是商品里面的库存</span></span><br><span class="line">       <span class="keyword">if</span>(stock<=<span class="number">0</span>){</span><br><span class="line">           model.addAttribute(<span class="string">"failMsg"</span>,CodeMsg.STOCK_EMPTY);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"spike_fail"</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">//看是否重复秒杀</span></span><br><span class="line">       SpikeOrder spikeOrder=spikeService.getGoodsVoByUserIdAndGoodsId(spikeUser.getId(), goodsId);</span><br><span class="line">       <span class="keyword">if</span>(spikeOrder!=<span class="keyword">null</span>){</span><br><span class="line">           model.addAttribute(<span class="string">"failMsg"</span>,CodeMsg.SKIPE_REPEAT);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"spike_fail"</span>;</span><br><span class="line">       }</span><br><span class="line">       OrderInfo orderInfo=spikeService.doSpike(spikeUser.getId(),goodsVo);</span><br><span class="line">       model.addAttribute(<span class="string">"orderInfo"</span>,orderInfo);</span><br><span class="line">       model.addAttribute(<span class="string">"goods"</span>,goodsVo);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"order_detail"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>步骤都跟上面一样，不过要多加一个商品id的参数，这里依然是5000的并发10次，其实这里测出来的结果和上面的商品列表差不太多，差不多950左右QPS，毕竟这里有判断库存的操作，一旦小于0之后就不会对mysql再进行操作，进行复杂的<strong>减库存</strong>和<strong>生成订单</strong>操作</p><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><p>本来只有10件商品，硬生生给减成了负数😂</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190606/m5RhIzmdXRV1.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>可以看到有16个人秒杀到了这个商品这显然是不合理的</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190606/nJmnvKvVzAHt.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这个问题会在后面的文章中提出解决方案，这一篇主要熟悉下压测。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMeter </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebMvcConfigurer小结</title>
      <link href="/2019/05/20/webmvcconfigurer/"/>
      <url>/2019/05/20/webmvcconfigurer/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>利用Redis做分布式session，因为没有借助Spring-session或者其他的session共享方案，手动处理session的存取，在控制层获取cookie中的数据是较为麻烦，所以希望直接将cookie的数据转化为需要的bean然后绑定到参数中，这里就可以借助<strong>WebMvcConfigurer</strong>来实现这个需求简化代码</p><h2 id="WebMvcConfigurer是干嘛的？"><a href="#WebMvcConfigurer是干嘛的？" class="headerlink" title="WebMvcConfigurer是干嘛的？"></a>WebMvcConfigurer是干嘛的？</h2><p>Spring把实现了WebMvcConfigurer接口的bean都看作为SpringMvc的<strong>扩展配置</strong>，如果既想要使用SpringBoot对SpringMvc的自动配置，又想要对自动配置进行扩展，添加一些用户自己的配置，像拦截器，消息转换器或者下文中的参数绑定，只需要写一个实现了WebMvcConfigurer接口的配置类，实现相关方法就能够添加自己的配置了。</p><blockquote><p>SpringBoot2.0之前也就是Spring5之前可以直接继承<strong>WebMvcConfigurationAdapter</strong>+<strong>@EnableWebMvc</strong>注解来实现上述需求，但是这个方法在之后的版本中弃用了(还可以用但是不太好)，因为jdk8之后的接口中可以有<strong>默认方法</strong>了，所以这个抽象类就并没有存在的意义了</p></blockquote><h3 id="WebMvcConfigurationSupport"><a href="#WebMvcConfigurationSupport" class="headerlink" title="WebMvcConfigurationSupport"></a>WebMvcConfigurationSupport</h3><p>其实还有一种方法就是直接继承这个WebMvcConfigurationSupport，上面的WebMvcConfigurer只是扩展配置，如果直接继承WebMvcConfigurationSupport，那么就可以重写默认的配置，如果对原理不是很清楚的开发者不小心重写错了默认的配置，springmvc可能相关功能就无法生效。</p><h2 id="WebMvcConfigurer内的方法"><a href="#WebMvcConfigurer内的方法" class="headerlink" title="WebMvcConfigurer内的方法"></a>WebMvcConfigurer内的方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebMvcConfigurer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//添加资源处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//视图控制器</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//添加参数解析器</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List<handlermethodargumentresolver> resolvers)</handlermethodargumentresolver></span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addReturnValueHandlers</span><span class="params">(List<handlermethodreturnvaluehandler> handlers)</handlermethodreturnvaluehandler></span> </span>{</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//消息转换器</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List<httpmessageconverter<?>> converters)</httpmessageconverter<?></span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List<httpmessageconverter<?>> converters)</httpmessageconverter<?></span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureHandlerExceptionResolvers</span><span class="params">(List<handlerexceptionresolver> resolvers)</handlerexceptionresolver></span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">extendHandlerExceptionResolvers</span><span class="params">(List<handlerexceptionresolver> resolvers)</handlerexceptionresolver></span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Validator <span class="title">getValidator</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> MessageCodesResolver <span class="title">getMessageCodesResolver</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在<strong>SpringBoot</strong>下自定义的WebMvcConfigurer实现配置类上是不需要添加<strong>@EnableWebMvc</strong>的，因为<strong>SpringBoot</strong>已经实例化了WebMvcConfigurationSupport，如果添加了该注解，默认的WebMvcConfigurationSupport配置类就会失效，mvc默认的配置会失效，也就是以用户定义的为主，一般建议还是不覆盖默认的好。</p><p>这点可以从SpringBoot的<strong>WebMvcAutoConfiguration</strong>中看到。（@EnableWebMvc会导入一个WebMvcConfigurationSupport的子类，叫 DelegatingWebMvcConfiguration）。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190520/p5I6RuWHJPMy.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>当没有WebMvcConfigurationSupport的时候自动配置才会生效</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">官方文档</a></p><p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="Controller参数绑定"><a href="#Controller参数绑定" class="headerlink" title="Controller参数绑定"></a>Controller参数绑定</h3><p>在SpringMVC里面可以轻松的把表单的数据映射到对应的bean中，但是有时候这并不能满足我们的需求，比如下面的例子。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tolist</span><span class="params">(HttpServletResponse response, Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @CookieValue(value = SpikeUserService.COOK1_NAME_TOKEN, required = <span class="keyword">false</span>)</span> String cookie,</span></span><br><span class="line"><span class="function">                         @<span class="title">RequestParam</span><span class="params">(value = SpikeUserService.COOK1_NAME_TOKEN, required = <span class="keyword">false</span>)</span> String param) </span>{</span><br><span class="line">        <span class="comment">/*手机浏览器，有可能将cookie放在参数中*/</span></span><br><span class="line">        <span class="keyword">if</span> (param == <span class="keyword">null</span> && cookie == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">        }</span><br><span class="line">        String cook = cookie != <span class="keyword">null</span> ? cookie : param;</span><br><span class="line">        SpikeUser user = spikeUserService.getUserByToken(response, cook);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里为了获取这个<strong>SpikeUser</strong>对象并不能直接从表单中获取，需要借助cookie然后从redis里面查询，如果下面还有一些其他的controller需要获取这个对象，又要写很多重复的代码。这个时候我们就可以通过上面介绍的WebMvcConfigurer来实现简化代码。</p><h4 id="重写addArgumentResolvers"><a href="#重写addArgumentResolvers" class="headerlink" title="重写addArgumentResolvers"></a>重写addArgumentResolvers</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//注入我们的参数解析器</span></span><br><span class="line">    SpikeUserArgumentResolver spikeUserArgumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List<handlermethodargumentresolver> argumentResolvers)</handlermethodargumentresolver></span> </span>{</span><br><span class="line">        argumentResolvers.add(spikeUserArgumentResolver);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里只需要实现<strong>addArgumentResolvers</strong>就可以了，注意加上<strong>@Configuration</strong>注解将WebConfig托付给Spring，使我们添加的参数解析器生效。</p><h4 id="实现HandlerMethodArgumentResolver"><a href="#实现HandlerMethodArgumentResolver" class="headerlink" title="实现HandlerMethodArgumentResolver"></a>实现HandlerMethodArgumentResolver</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpikeUserArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SpikeUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>{</span><br><span class="line">        Class<!--?--> clazz = parameter.getParameterType();</span><br><span class="line">        <span class="comment">//处理SpikeUser类型的</span></span><br><span class="line">        <span class="keyword">return</span> clazz==SpikeUser<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String paramToken = request.getParameter(SpikeUserService.COOK1_NAME_TOKEN);</span><br><span class="line">        String cookieToken = getCookieValue(request, SpikeUserService.COOK1_NAME_TOKEN);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserByToken(response,token);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookiName)</span> </span>{</span><br><span class="line">        Cookie[]  cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies) {</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(cookiName)) {</span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>然后就可以直接在在控制器中拿到SpikeUser了，代码变得清爽简洁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">tolist</span><span class="params">(Model model,SpikeUser spikeUser)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (spikeUser==<span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">       }</span><br><span class="line">       model.addAttribute(<span class="string">"user"</span>, spikeUser);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"><span class="comment">//未优化</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/to_list0"</span>)</span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">tolist0</span><span class="params">(HttpServletResponse response, Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        @CookieValue(value = SpikeUserService.COOK1_NAME_TOKEN, required = <span class="keyword">false</span>)</span> String cookie,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = SpikeUserService.COOK1_NAME_TOKEN, required = <span class="keyword">false</span>)</span> String param) </span>{</span><br><span class="line">                           <span class="comment">//手机浏览器，有可能将cookie放在参数中</span></span><br><span class="line">       System.out.println(<span class="string">"cookie:"</span> +cookie);</span><br><span class="line">       System.out.println(<span class="string">"param "</span> +param);</span><br><span class="line">       <span class="keyword">if</span> (param == <span class="keyword">null</span> && cookie == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">       }</span><br><span class="line">       String cook = cookie != <span class="keyword">null</span> ? cookie : param;</span><br><span class="line">       SpikeUser user = spikeUserService.getUserByToken(response, cook);</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p>这也算是对SpringMVC原理的初次接触吧，后面关于框架还是多看源码啊。</p><p>关于<strong>Spring-Session</strong>的内容后面用到再来介绍。</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>依然是SpringBoot2，所以还是实现的<strong>WebMvcConfigurer</strong>接口</p><p>先看下拦截器的执行流程</p><p><img alt="来自慕课" data-src="http://static.imlgw.top/image/20190609/vUv7FDoickvl.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.spike.intercept;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/9 15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NeedLogin {</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needLogin</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="重写HandlerInterceptor"><a href="#重写HandlerInterceptor" class="headerlink" title="重写HandlerInterceptor"></a>重写HandlerInterceptor</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.spike.intercept;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> top.imlgw.spike.entity.SpikeUser;</span><br><span class="line"><span class="keyword">import</span> top.imlgw.spike.service.SpikeUserService;</span><br><span class="line"><span class="keyword">import</span> top.imlgw.spike.utils.UserContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/8 23:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SpikeUserService spikeUserService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 在登陆前拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span>(!(handler <span class="keyword">instanceof</span> HandlerMethod)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        HandlerMethod hm=(HandlerMethod) handler;</span><br><span class="line">        SpikeUser spikeUser = getSpikeUser(request, response);</span><br><span class="line">        <span class="comment">//有的页面不需要登陆(二次登陆)但是需要用户信息(订单页面...)，所以需要先存进去</span></span><br><span class="line">        UserContext.setUser(spikeUser);</span><br><span class="line">        <span class="comment">//获取方法上的注解</span></span><br><span class="line">        NeedLogin needLogin = hm.getMethodAnnotation(NeedLogin<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(needLogin==<span class="keyword">null</span> || ! needLogin.needLogin()){</span><br><span class="line">            <span class="comment">//没有注解后者注解为false,就直接放过</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//有注解，没登陆</span></span><br><span class="line">        <span class="keyword">if</span>(spikeUser==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 视图渲染完毕后调用(收尾工作)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//删除ThreadLocal中的User否则会产生错乱</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SpikeUser <span class="title">getSpikeUser</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>{</span><br><span class="line">        <span class="comment">//拿参数中的token</span></span><br><span class="line">        String paramToken = request.getParameter(SpikeUserService.COOK_NAME_TOKEN);</span><br><span class="line">        <span class="comment">//拿cookie中的token</span></span><br><span class="line">        String cookieToken = getCookieValue(request, SpikeUserService.COOK_NAME_TOKEN);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {</span><br><span class="line">            <span class="comment">//没登陆cookie为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;</span><br><span class="line">        SpikeUser user = spikeUserService.getUserByToken(response, token);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取cookie中的User</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookieName)</span> </span>{</span><br><span class="line">        Cookie[]  cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span>(cookies == <span class="keyword">null</span> || cookies.length <= <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies) {</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(cookieName)) {</span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="WebConfig里面添加拦截器"><a href="#WebConfig里面添加拦截器" class="headerlink" title="WebConfig里面添加拦截器"></a>WebConfig里面添加拦截器</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.spike.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="keyword">import</span> top.imlgw.spike.intercept.LoginIntercept;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>{</span><br><span class="line"><span class="comment">//自动装配或者 手动创建bean,加到Ioc容器中，否则取不到service</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SpikeUserArgumentResolver spikeUserArgumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LoginIntercept loginIntercept;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List<handlermethodargumentresolver> argumentResolvers)</handlermethodargumentresolver></span> </span>{</span><br><span class="line">        argumentResolvers.add(spikeUserArgumentResolver);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>{</span><br><span class="line">        registry.addInterceptor(loginIntercept).addPathPatterns(<span class="string">"/**"</span>).</span><br><span class="line">            excludePathPatterns(<span class="string">"/login/*"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h3><p>不用为了跳转页面而专门写一个<strong>controller</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>{</span><br><span class="line">    <span class="comment">//这里如果是用的模板引擎，就只能是模板引擎template里面的文件</span></span><br><span class="line">    <span class="comment">//这里后面默认指的是static里面的文件，后缀为html</span></span><br><span class="line">    registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">    registry.addViewController(<span class="string">"/goodslist"</span>).setViewName(<span class="string">"goods_list"</span>);</span><br><span class="line">    registry.addViewController(<span class="string">"/register"</span>).setViewName(<span class="string">"register"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>其他的以后用到会继续补充</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库大作业</title>
      <link href="/2019/05/20/shu-ju-ku-da-zuo-ye/"/>
      <url>/2019/05/20/shu-ju-ku-da-zuo-ye/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>JDK(建议1.8以上)</li><li>开发工具，Eclipse或者idea …</li><li><strong>mysql</strong>或者<strong>mssql</strong>(我是用的<strong>mysql5.7.17</strong>，给的demo是mysql的)</li></ul><h3 id="测试给的Demo"><a href="#测试给的Demo" class="headerlink" title="测试给的Demo"></a>测试给的Demo</h3><p>①装好mysql之后启动它，然后用管理工具我用的是<strong>navicat</strong>，打开然后将给的demo里面的sql脚本导入进去(导入不好的可以手动建立一个，用脚本文件导入后的名字是tb_demo，我这里是手动建的)</p><p><video controls="controls" src="http://static.imlgw.top/image/20190530/M2IOTaKdyaQO.mp4" width="100%"></video></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190524/oNHeEFJhHEYX.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>最后差不多是这样的结构</p><p>②在<strong>Eclipse</strong>里面<strong>import</strong>项目，这里我<strong>import</strong>会有个感叹号，<strong>最好重新建一个项目，不然可能会有奇怪的错误</strong>下面是<strong>如何新建的步骤视频</strong></p><p><video controls="controls" src="http://static.imlgw.top/f0xim-iyaow.mp4" width="100%"></video></p><p>这里要改的地方就是DbUtil里面数据库配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbUtil</span> </span>{</span><br><span class="line"><span class="comment">//com.microsoft.sqlserver.jdbc.SQLServerDriver</span></span><br><span class="line">    <span class="comment">//数据库驱动的名字（1.6还是1.8之后就不需要了，这里还是加上吧）</span></span><br><span class="line">String driverName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"><span class="comment">//jdbc:sqlserver://127.0.0.1:1433;DatabaseName=demo</span></span><br><span class="line">    <span class="comment">//连接数据库的地址，前面的不用改，这里要改的就是后面的 demo 换成你的数据库名字（我上面的是demo）</span></span><br><span class="line">String dbURL = <span class="string">"jdbc:mysql://localhost:3306/demo"</span>;</span><br><span class="line">    <span class="comment">//你的数据库的帐号</span></span><br><span class="line">String userName = <span class="string">"root"</span>;</span><br><span class="line">    <span class="comment">//装mysql时设置的密码</span></span><br><span class="line">String userPwd = <span class="string">"admin"</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getCon</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>{</span><br><span class="line">Class.forName(driverName);</span><br><span class="line">Connection conn = DriverManager.getConnection(dbURL, userName, userPwd);</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeCon</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">conn.close();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">DbUtil dbUtil = <span class="keyword">new</span> DbUtil();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">dbUtil.getCon();</span><br><span class="line">System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//com.microsoft.sqlserver.jdbc.SQLServerDriver</span></span><br><span class="line">   <span class="comment">//数据库驱动的名字（1.6还是1.8之后就不需要了，这里还是加上吧）</span></span><br><span class="line">String driverName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"><span class="comment">//jdbc:sqlserver://127.0.0.1:1433;DatabaseName=demo</span></span><br><span class="line">   <span class="comment">//连接数据库的地址，这里要改的就是后面的 demo 换成你的数据库名字（我上面的是demo）</span></span><br><span class="line">String dbURL = <span class="string">"jdbc:mysql://localhost:3306/demo"</span>;</span><br><span class="line">   <span class="comment">//你的数据库的帐号</span></span><br><span class="line">String userName = <span class="string">"root"</span>;</span><br><span class="line">   <span class="comment">//密码</span></span><br><span class="line">String userPwd = <span class="string">"admin"</span>;</span><br></pre></td></tr></tbody></table></figure></div><p>要改的差不多就是这4个配置</p><p>①如果是<strong>mysql</strong>并且版本是8以下的，那么<strong>driverName</strong> 可以不用改，如果是8以上的（群里面那个是8以上的）就需要改成</p><p><strong>com.mysql.cj.jdbc.Driver</strong>，并且<strong>找到适合版本的驱动拷贝到lib目录然后右键bulidpath</strong>（在这之前先将老的驱动删掉，bulidpath的作用是将jar包<strong>真正的</strong>加到你的项目中去）</p><ul><li><p>8 以上 驱动下载地址 链接：<a href="https://pan.baidu.com/s/1WXjAAHX5gQC6v5pfiTOqmQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1WXjAAHX5gQC6v5pfiTOqmQ</a>  提取码：5lf5 </p></li><li><p>sqlServer需要改的地方我也注释在上面但是我电脑上没sqlserver我没有测试，老师给的包里面有sqlserver的驱动</p></li></ul><p>②<strong>dbURL</strong>，前面的不用改，这里只需要改一下后面的数据库名字，比如我上面建的数据库名字是<strong>demo</strong>,后面就应该是<strong>/demo</strong>（如果用脚本直接导入生成的数据库名字是db_demo，这里就要改成jdbc:mysql://localhost:3306/db_demo</p><ul><li>对应sqlserver的我也放在上面但是我没装sqlserver所以没测试。</li></ul><p>③<strong>userName</strong>，数据库账号（一般默认就是root）</p><p>④<strong>password</strong>，数据库密码</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在view包下的<strong>MainPage</strong>，这是用java的swing组件开发的一个GUI页面，最下面有一个main函数直接启动它就行，（如果有乱码，需要将eclipes的工作空间的编码方式换为<strong>utf-8</strong>），到此环境就基本ok了，后面的就是写代码的事了。</p><h3 id="改用自己的数据库"><a href="#改用自己的数据库" class="headerlink" title="改用自己的数据库"></a>改用自己的数据库</h3><blockquote><p>后面的部分主要是代码的问题了，每个人数据库不同也会有一些差距</p></blockquote><ul><li><p>导入自己的数据</p><p>数据库名字，字段名不要用中文！</p><p>数据库名字，字段名不要用中文 ！</p><p>数据库名字，字段名不要用中文！</p></li><li><p>实体类改成自己的</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInfo</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long stuId;</span><br><span class="line"><span class="keyword">private</span> String stuName;</span><br><span class="line"><span class="keyword">private</span> String stuSex;</span><br><span class="line"><span class="keyword">private</span> Date stuDob;</span><br><span class="line"><span class="keyword">private</span> String stuMajor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getStuId</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> stuId;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuId</span><span class="params">(Long stuId)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.stuId = stuId;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStuName</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> stuName;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuName</span><span class="params">(String stuName)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStuSex</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> stuSex;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuSex</span><span class="params">(String stuSex)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.stuSex = stuSex;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getStuDob</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> stuDob;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuDob</span><span class="params">(Date stuDob)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.stuDob = stuDob;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStuMajor</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> stuMajor;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuMajor</span><span class="params">(String stuMajor)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.stuMajor = stuMajor;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StuInfo</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StuInfo</span><span class="params">(String stuName, String stuSex, Date stuDob, String stuMajor)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.stuName = stuName;</span><br><span class="line"><span class="keyword">this</span>.stuSex = stuSex;</span><br><span class="line"><span class="keyword">this</span>.stuDob = stuDob;</span><br><span class="line"><span class="keyword">this</span>.stuMajor = stuMajor;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里实体类是和数据库的表和字段对应的，一个StuInfo对象就对应一条数据。</p><ul><li>增删改查的修改</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">getUsers</span><span class="params">(User user, Connection con)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">StringBuffer sql = <span class="keyword">new</span> StringBuffer(<span class="string">"select * from t_user "</span>);</span><br><span class="line"><span class="keyword">if</span> (user.getUserName()!= <span class="keyword">null</span>) {</span><br><span class="line">sql.append(<span class="string">" where userName like '%"</span>+user.getUserName()+<span class="string">"%'"</span>);</span><br><span class="line">}</span><br><span class="line">PreparedStatement ps = con.prepareStatement(sql.toString());</span><br><span class="line"><span class="keyword">return</span> ps.executeQuery();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(User user, Connection con)</span> <span class="keyword">throws</span> SQLException</span>{</span><br><span class="line">String sql=<span class="string">"delete from t_user where userName='"</span>+user.getUserName()+<span class="string">"'"</span>;</span><br><span class="line">PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line"><span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user, Connection con)</span> <span class="keyword">throws</span> SQLException</span>{</span><br><span class="line">String sql=<span class="string">"insert into t_user  values(?,?)"</span>;</span><br><span class="line">PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, user.getUserName());</span><br><span class="line">ps.setString(<span class="number">2</span>, user.getTel());</span><br><span class="line"><span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">modify</span><span class="params">(User user, Connection con)</span> <span class="keyword">throws</span> SQLException</span>{</span><br><span class="line">String sql=<span class="string">"update t_user  set userName=?, tel=? where userName = '"</span>+user.getUserName()+<span class="string">"'"</span>;</span><br><span class="line">PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, user.getUserName());</span><br><span class="line">ps.setString(<span class="number">2</span>, user.getTel());</span><br><span class="line">System.out.println(sql);</span><br><span class="line"><span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>最终都是通过调用这个Dao类实现的增删改查。</p><ul><li>页面的修改</li></ul><p>按照老师的要求是对我们常用的数据库做增删改查，因为我们用的数据库和给的demo的表结构不一样，所以需要修改MainPage，这个是用java的swing写的一个GUI，所以需要改这些界面上的一些元素，我记的好像有个插件可以直接拖动生成swing这些界面的(看见刘勇用过)，我对swing不熟悉（早就过时了，没有学的意义），我用web写的界面</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190530/96gB7wwVz4Xj.png?imageslim" src="/img/loading.gif" class="lazyload"></p><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p><a href="https://blog.csdn.net/mr_green1024/article/details/53222526?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">Mysql5.7解压版的安装和卸载及常见问题</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSR303-参数检验</title>
      <link href="/2019/05/13/jsr303-can-shu-xiao-yan/"/>
      <url>/2019/05/13/jsr303-can-shu-xiao-yan/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><p>目前最新的规范已经是JSR380了，也就是Bean Validation 2.0.</p><p><img alt="mark" data-src="http://static.imlgw.top///20190513/qa5DNu5Nsq26.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>参数校验是一个成熟的网站必须的功能，然而有的时候为了校验参数也要费好大的劲，免不了写很多if-else，一点也不优雅。</p><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"> <!--SpringBootWeb 这个包里面自带了hibernate的校验包--></span><br><span class="line"><dependency></dependency></span><br><span class="line"><groupid>org.springframework.boot</groupid></span><br><span class="line"><artifactid>spring-boot-starter-web</artifactid></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><h3 id="JSR提供的注解"><a href="#JSR提供的注解" class="headerlink" title="JSR提供的注解"></a>JSR提供的注解</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Null</span>   被注释的元素必须为 <span class="keyword">null</span>    </span><br><span class="line"><span class="meta">@NotNull</span>    被注释的元素必须不为 <span class="keyword">null</span>    </span><br><span class="line"><span class="meta">@AssertTrue</span>     被注释的元素必须为 <span class="keyword">true</span>    </span><br><span class="line"><span class="meta">@AssertFalse</span>    被注释的元素必须为 <span class="keyword">false</span>    </span><br><span class="line"><span class="meta">@Min</span>(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值    </span><br><span class="line"><span class="meta">@Max</span>(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值    </span><br><span class="line"><span class="meta">@DecimalMin</span>(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值    </span><br><span class="line"><span class="meta">@DecimalMax</span>(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值    </span><br><span class="line"><span class="meta">@Size</span>(max=, min=)   被注释的元素的大小必须在指定的范围内    </span><br><span class="line"><span class="meta">@Digits</span> (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内    </span><br><span class="line"><span class="meta">@Past</span>   被注释的元素必须是一个过去的日期    </span><br><span class="line"><span class="meta">@Future</span>     被注释的元素必须是一个将来的日期    </span><br><span class="line"><span class="meta">@Pattern</span>(regex=,flag=)  被注释的元素必须符合指定的正则表达式</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Hibernate提供的"><a href="#Hibernate提供的" class="headerlink" title="Hibernate提供的"></a>Hibernate提供的</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@NotBlank(message =)   验证字符串非null，且长度必须大于0    </span><br><span class="line">@Email  被注释的元素必须是电子邮箱地址    </span><br><span class="line">@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内    </span><br><span class="line">@NotEmpty   被注释的字符串的必须非空    </span><br><span class="line">@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</span><br></pre></td></tr></tbody></table></figure></div><h3 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h3><p><strong>@IsMobile注解</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.spike.validator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/5/13 17:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(</span><br><span class="line">        validatedBy = {IsMobileValidator<span class="class">.<span class="keyword">class</span>} //指定真正校验的类</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">IsMobile</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "号码格式错误"</span>;</span><br><span class="line"></span><br><span class="line">    Class<!--?-->[] groups() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">    Class<!--? extends Payload-->[] payload() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>IsMobileValidator类</strong></p><blockquote><p>自定义的校验器要实现 ConstraintValidator接口</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.spike.validator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> top.imlgw.spike.utils.ValidatorUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/5/13 18:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span><<span class="title">IsMobile</span>, <span class="title">String</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> required=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>{</span><br><span class="line">        required=constraintAnnotation.required();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, ConstraintValidatorContext constraintValidatorContext)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(required){</span><br><span class="line">            <span class="keyword">return</span>  ValidatorUtil.isMobile(s);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(s)){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span>  ValidatorUtil.isMobile(s);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="字段上加注解"><a href="#字段上加注解" class="headerlink" title="字段上加注解"></a>字段上加注解</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.spike.entity;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/5/11 15:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"id不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"名字不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">6</span>,message = <span class="string">"密码长度至少6位"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User{"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, Integer age, String password)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>@Valid 加BindingResult</strong></p><p><img alt="mark" data-src="http://static.imlgw.top///20190513/ILDAz6Bdj3cz.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>在Controlle层待校验的的参数上加上<code>@Valid</code>注解，然后在后面紧跟一个 <code>BindingResult</code>，校验的结果会封装在这个对象里面，BindingResult 的作用是当参数不合法时能够捕捉到错误，不会直接抛异常，感觉还是有点麻烦。</p><p><strong>@Valid加全局异常捕获</strong></p><p>上面的方法如果不加后面的BindingResult在校验失败后就会抛一个BindException</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: <span class="number">1</span> errors</span><br><span class="line">Field error in object <span class="string">'user'</span> on field <span class="string">'id'</span>: rejected value [<span class="keyword">null</span>]; codes [NotNull.user.id,NotNull.id,NotNull.<span class="keyword">long</span>,NotNull]; arguments .......</span><br></pre></td></tr></tbody></table></figure></div><p>那我们就可以利用<code>@ControllerAdvice+@ExceptionHandler</code>来定义一个全局的异常处理器来处理这个异常，<code>@ExceptionHandle</code>，针对的仅仅是单个controller，加上<code>@ControllerAdvice</code>就可以对所有的Controller层异常进行捕获，这里的全局仅仅指的是controller层。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.spike.exception;</span><br><span class="line"><span class="keyword">import</span> top.imlgw.spike.result.CodeMsg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局通用异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/5/14 20:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> CodeMsg cm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlobalException</span><span class="params">(CodeMsg cm)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(cm.toString());</span><br><span class="line">        <span class="keyword">this</span>.cm = cm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CodeMsg <span class="title">getCm</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> cm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller层异常处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> imlgw.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/5/13 18:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">//直接返回给客户端，需要json的转换</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>{</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) //处理<span class="title">controller</span>层所有异常</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span><<span class="title">String</span>> <span class="title">exceptionHandle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">e</span>) </span>{</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> GlobalException) {</span><br><span class="line">            <span class="comment">//全局异常</span></span><br><span class="line">            GlobalException ex = (GlobalException) e;</span><br><span class="line">            <span class="keyword">return</span> Result.error(ex.getCm());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) {</span><br><span class="line">            <span class="comment">//@Validated 检验器的异常</span></span><br><span class="line">            BindException ex = (BindException) e;</span><br><span class="line">            List<objecterror> errors = ex.getAllErrors();</objecterror></span><br><span class="line">            ObjectError error = errors.get(<span class="number">0</span>);</span><br><span class="line">            String msg = error.getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> Result.error(CodeMsg.SERVER_ERROR);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试Demo 看先处理那个</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = GlobalException<span class="class">.<span class="keyword">class</span>) //处理<span class="title">controller</span>层所有异常</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span><<span class="title">String</span>> <span class="title">GLe</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">e</span>) </span>{</span><br><span class="line">        System.out.println(<span class="string">"优先处理了这个GlobalException"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//全局异常</span></span><br><span class="line">        GlobalException ex = (GlobalException) e;</span><br><span class="line">        <span class="keyword">return</span> Result.error(ex.getCm());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里也做了个小测试，可以看到我定义了两个@ExceptionHandle，一个是另一个的子类，看会先处理那个，测试后发现会先处理小异常，那个最大的异常其实相当于’’兜底’’的。其实后面我为了跟精细的处理，将绑定异常和自定义的异常分开处理了。</p><blockquote><p>@ControllerAdvice :</p><p>It is typically used to define {@link ExceptionHandler <strong>@ExceptionHandler</strong>},</p><p>{@link InitBinder <strong>@InitBinder</strong>}, and {@link ModelAttribute <strong>@ModelAttribute</strong>}</p><p>methods that <strong>apply to all</strong> {@link RequestMapping <strong>@RequestMapping</strong>} methods.</p><p>@author Rossen Stoyanchev</p><p>@since 3.2</p></blockquote><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>只需要在vo里加上对应分组的接口然后在注解上加上就可以了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginVo</span> </span>{</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"手机号不能为空"</span>)</span><br><span class="line">    <span class="meta">@IsMobile</span>(groups = Test1<span class="class">.<span class="keyword">class</span>) //只有在<span class="title">Test1</span>分组下才生效</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">mobile</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"密码不能为空"</span>)</span><br><span class="line">    <span class="meta">@Length</span>(min=<span class="number">6</span> ,groups = Test2<span class="class">.<span class="keyword">class</span>,<span class="title">message</span> </span>= <span class="string">"密码长度过短"</span>) <span class="comment">//只有在Test2分组下才生效</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMobile</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> mobile;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMobile</span><span class="params">(String mobile)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LoginVo [mobile="</span> + mobile + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test1</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test2</span></span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>使用时注意用<code>@Validated</code>，这个其实是Spring对Hibernate的二次封装，增加了一些功能。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jsr303-2"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJSR</span><span class="params">(@Validated({LoginVo.Test2.class})</span> LoginVo vo)</span>{</span><br><span class="line">  <span class="comment">//........</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样在这个Controller里post密码就没有长度的限制了。</p><blockquote><p>其实还有一些校验的方法，基于方法校验，基于少量参数的校验，以后用到再来记录</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 参数校验 </tag>
            
            <tag> JSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode数组</title>
      <link href="/2019/05/04/leetcode-shu-zu/"/>
      <url>/2019/05/04/leetcode-shu-zu/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="LeetCode-数组"><a href="#LeetCode-数组" class="headerlink" title="LeetCode 数组"></a>LeetCode 数组</h2><p>面试中的算法问题，有很多并不需要复杂的数据结构支撑。就是用数组，就能考察出很多东西了。其实，经典的排序问题，二分搜索等等问题，就是在数组这种最基础的结构中处理问题的。 </p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>平生不识<strong>TwoSum</strong>，做遍LeetCode也枉然</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < length - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j < length - i; j++) {</span><br><span class="line">            <span class="keyword">int</span> result = nums[i] + nums[i + j];</span><br><span class="line">            <span class="keyword">if</span> (result == target) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] { i, i + j };</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>最开始的做法，直接暴力求解，简单，但是效率很低，50ms，41% beats，其实在笔试或者其它对效率要求没那么严格的地方用暴力法也没毛病节约很多时间，能直接写出最优解肯定好，但是实在没办法了暴力法也不失为一种好方法，最优解可以下来后再研究。</p><p><strong>hash查找</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">        HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">        <span class="comment">//第一遍把所有的元素和索引存到hashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//再查找hash</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">            <span class="comment">//不能重复所以 下标需要限制下</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]) && map.get(target-nums[i])!=i){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{i,map.get(target-nums[i])};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{};</span><br><span class="line">    }</span><br></nums.length;i++)></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实可以只hash一遍，hash两遍主要考虑顺序的问题。直接利用hashMap查找，效率很高。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">    HashMap<integer,integer> map=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//不能重复所以 下标需要限制下</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target-nums[i]) && map.get(target-nums[i])!=i){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{i,map.get(target-nums[i])};</span><br><span class="line">        }</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{};</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>提交记录上最快的做法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> indexArrayMax=<span class="number">2047</span>;</span><br><span class="line">        <span class="keyword">int</span>[] indexArrays=<span class="keyword">new</span> <span class="keyword">int</span>[indexArrayMax+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> diff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++){< span><br><span class="line">            diff=target-nums[i];</span><br><span class="line">            <span class="comment">//i=0时索引无效,所以单独处理</span></span><br><span class="line">            <span class="keyword">if</span>(diff==nums[<span class="number">0</span>]){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">0</span>,i};</span><br><span class="line">            }</span><br><span class="line">            index=diff&indexArrayMax;</span><br><span class="line">            <span class="keyword">if</span>(indexArrays[index]!=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{indexArrays[index],i};</span><br><span class="line">            }</span><br><span class="line">            indexArrays[nums[i]&indexArrayMax]=i;   </span><br><span class="line">        }   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">}</span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><p>没看懂。。。群里问了下，手动hash。。。。以后再来研究吧.</p><h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h2><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: <span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></tbody></table></figure></div><p>两数之和的变种，看见<strong>有序</strong>其实也可以使用二分来做，但是时间复杂度是<code>O(NlogN)</code>，相对较高</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span>||numbers.length<=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right>left){</span><br><span class="line">            <span class="keyword">int</span> sum=numbers[right]+numbers[left];</span><br><span class="line">            <span class="keyword">if</span>(sum==target){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{left+<span class="number">1</span>,right+<span class="number">1</span>};</span><br><span class="line">            }<span class="keyword">if</span>(sum<target){< span><br><span class="line">                left++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></target){<></span></pre></td></tr></tbody></table></figure></div><p><strong>对撞指针</strong>，很基础的题。</p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h2><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">49</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=height.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<len-<span class="number">1</len-<span></span>;i++){<br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j<len;j++){< span><br><span class="line">                <span class="keyword">int</span> minHight=height[i]>height[j]?height[j]:height[i];</span><br><span class="line">                max=max>(j-i)*minHight ? max:(j-i)*minHight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"> }</span><br></len;j++){<></span></pre></td></tr></tbody></table></figure></div><p>522ms，13% 垫底了，别问，问就是暴力🤣</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=height.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> head=<span class="number">0</span>,tail=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(head<len){< span><br><span class="line">            tail=len-<span class="number">1</span>; <span class="comment">//开始改的时候这一句忘了加</span></span><br><span class="line">            <span class="keyword">while</span>(head!=tail){</span><br><span class="line">                <span class="keyword">int</span> minHight=height[tail]>height[head]?height[head]:height[tail];</span><br><span class="line">                max=max>(tail-head)*minHight ? max:(tail-head)*minHight;</span><br><span class="line">                <span class="keyword">if</span>(height[head]<=height[tail]){</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    tail--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            head++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></len){<></span></pre></td></tr></tbody></table></figure></div><p>212ms，40%，利用双指针稍微优化了下，依然是遍历找每个柱的最大值，但是尾指针在移动时先判断下，如果比头指针大就直接break，因为<strong>已经是最大值</strong>了，tail是从右向左移动的</p><blockquote><p>开始改的时候忘了将尾指针归位，结果还对了，而且90%的beats…..哈哈哈，误打误撞搞了个最优解出来。</p></blockquote><p><strong>解法二</strong></p><p>上面两种其实都是暴力，时间复杂度都很高</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len=height.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(left<right) {< span><br><span class="line">            <span class="keyword">int</span> minHight=height[left]>height[right]?height[right]:height[left];</span><br><span class="line">            max=max>(right-left)*minHight ? max:(right-left)*minHight;</span><br><span class="line">            <span class="keyword">if</span>(height[left]<=height[right]){</span><br><span class="line">                left++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></right)></span></pre></td></tr></tbody></table></figure></div><p><strong>标准</strong>的最优解，这题主要考察的就是双指针，两个指针一头一尾，先算出这个头尾的面积大小，然后下一步思考怎么扩大这个区域的面积，结合题上面的图（最左边为头，最右边为尾）</p><p><img alt="mark" data-src="http://static.imlgw.top///20190505/1uze479AHHLo.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>这个时候如果移动尾指针，明显面积只可能减小，所以只有移动头指针才有可能增大这个区域的面积，这样一来就可以省掉很多没必要的计算，有点像贪心，时间复杂度O(N)</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h2><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，*使得 *a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p>想太多了，没做出来，看了评论才做出来。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List<list<integer>> threeSum(<span class="keyword">int</span>[] nums) {</list<integer></span><br><span class="line">    List<list<integer>> list = <span class="keyword">new</span> ArrayList();</list<integer></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// 先排序  o(nlogn)</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len < <span class="number">3</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="comment">// 完备性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len-<span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span>(nums[i]><span class="number">0</span>){</span><br><span class="line">            <span class="comment">//大于0了，后面的和加起来肯定>0了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//遍历数组，相同的元素只需要遍历一遍，不然会重复</span></span><br><span class="line">        <span class="keyword">if</span>(i > <span class="number">0</span> && nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 一次去重优化</span></span><br><span class="line">        <span class="comment">//当前元素的下一个元素。</span></span><br><span class="line">        <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//尾元素</span></span><br><span class="line">        <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L<r){< span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>){</span><br><span class="line">                list.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                <span class="comment">//-4 -1 -1 0 1 2</span></span><br><span class="line">                <span class="keyword">while</span> (L<r && nums[l]="=" nums[l+<span class="number">1</r></span>]) L++;</r){<></span><br><span class="line">                <span class="comment">//二次去重优化</span></span><br><span class="line">                <span class="keyword">while</span> (L<r && nums[r]="=" nums[r-<span class="number">1</r></span>]) R--;<br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum < <span class="number">0</span>){ <span class="comment">//小于0所以要增大L,逼近0 else R--;</span></span><br><span class="line">                 L++;   </span><br><span class="line">            } <span class="keyword">else</span> R--; <span class="comment">//大于0就减小R</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>代码思路就是遍历数组，然后从<strong>i</strong>位置后面的数组中找能和<strong>i</strong>凑成一对的元素，这里关键就是这里怎么找这两个元素 满足nums[L]+nums[R]=-nums[i]，问题就转化成了上面的<strong>两数之和</strong>，但是这里用暴力法肯定是过不了的，hashMap这里也不好用，所以这里我们可以先给数组排个序，然后利用<strong>双指针对撞</strong>，逐渐逼近0，还有一个很需要注意的地方就是二次去重，如下图</p><p><img alt="mark" data-src="http://static.imlgw.top///20190505/5YlNbCLe57fb.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>当找到一组时有可能L，R的下一个位置的值没变这样就会导致重复。</p><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h2><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [-<span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，-<span class="number">4</span>], 和 target = <span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 <span class="number">2</span>. (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></tbody></table></figure></div><p>跟上面的题其实是一样的，这里主要时为了检测下自己上面的搞懂了没</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||len<<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> closest=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<len-<span class="number">2</len-<span></span>;i++) {<br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>&&nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//跳过重复元素提高效率</span></span><br><span class="line">        <span class="keyword">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> R=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L<r){< span><br><span class="line">            <span class="keyword">int</span> sum=nums[L]+nums[R]+nums[i];</span><br><span class="line">            closest=Math.abs(closest-target)>Math.abs(sum-target)?sum:closest;</span><br><span class="line">            <span class="keyword">if</span>(sum==target){</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(sum>target){</span><br><span class="line">                <span class="keyword">while</span>(L<r && nums[r]="=nums[R-<span" class="number">1</r></span>])R--;</r){<></span><br><span class="line">                R--;</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">while</span>(L<r && nums[l]="=nums[L+<span" class="number">1</r></span>])L++;<br><span class="line">                L++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>一遍<strong>bugfree</strong>，其实都挺简单，这两题我一直在考虑别的算法，我想的是排序后从两遍向中间然后…就不bb了，反之很多没考虑到的地方。</p><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h2><p>给定一个包含 n 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 a，b，c 和 d ，使得 <code>a + b + c + d</code> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>]，和 target = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [-<span class="number">2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>和三数之和一样，但是更加繁琐了，提交了5，6次才AC，还是看了别人的代码的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List<list<integer>> fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</list<integer></span><br><span class="line">    List<list<integer>> res=<span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="comment">//0 0 -1 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<n-<span class="number">3</n-<span></span>;i++) {<br><span class="line">        <span class="comment">//这里我开始写的是和后一个比较，0，0，0，0这种过不了</span></span><br><span class="line">        <span class="keyword">if</span>(i><span class="number">0</span> && nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]>target) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]+nums[n-<span class="number">1</span>]+nums[n-<span class="number">2</span>]+nums[n-<span class="number">3</span>]<target) <span class="keyword">continue</target)></span>;<br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j<n-<span class="number">2</n-<span></span>;j++) {<br><span class="line">            <span class="comment">//同上</span></span><br><span class="line">            <span class="keyword">if</span>(j>i+<span class="number">1</span>&&nums[j]==nums[j-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]+nums[j+<span class="number">2</span>]+nums[j+<span class="number">1</span>]>target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>]<target) <span class="keyword">continue</target)></span>;<br><span class="line">            <span class="keyword">int</span> two=nums[i]+nums[j];</span><br><span class="line">            <span class="comment">//左右边界</span></span><br><span class="line">            <span class="keyword">int</span> left=j+<span class="number">1</span>,right=n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left<right){< span><br><span class="line">                <span class="keyword">if</span> (target-two==nums[left]+nums[right]) {</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//想清楚什么时候跳,放外面就错了</span></span><br><span class="line">                    <span class="keyword">while</span>(left<right && nums[left]="=nums[left+<span" class="number">1</right></span>]){left++;};</right){<></span><br><span class="line">                    <span class="keyword">while</span>(left<right && nums[right]="=nums[right-<span" class="number">1</right></span>]){right--;};<br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (target-two>nums[left]+nums[right]) {</span><br><span class="line">                    left++;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>实不相瞒，这题一开始我暴力做的，冒泡的思想，太蠢了😅 ，注意题目要求空间复杂度O(1)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j < nums.length; j++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) {</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>双指针，真的用的挺多的。</p><h2 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80. 删除排序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除排序数组中的重复项 II</a></h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = <span class="number">7</span>, 并且原数组的前五个元素被修改为 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line">    print(nums[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面题目加一点，在前后相等的时候判断index前是否已经有两个相等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<nums.length;i++){< span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=nums[i-<span class="number">1</span>] || (nums[i]==nums[i-<span class="number">1</span>] && nums[index-<span class="number">2</span>]!=nums[index-<span class="number">1</span>])){</span><br><span class="line">            nums[index++]=nums[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">}</span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></h2><p>给定一个数组 <em>nums</em> 和一个值 <em>val<em>，你需要*</em>原地**移除所有数值等于 *val</em> 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></tbody></table></figure></div><p>目标元素多时</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < nums.length; j++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != val) {</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>目标元素少时</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i < n) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) {</span><br><span class="line">            nums[i] = nums[--n];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明</strong>:</p><ul><li><p>必须在原数组上操作，不能拷贝额外的数组。</p></li><li><p>尽量减少操作次数。</p></li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>){</span><br><span class="line">                nums[index++]=nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i<nums.length;i++){< span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br></nums.length;i++){<></span></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><p>其实就是借助上面题目的思路，最后再补0就ok了，其实也还可以优化下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>; <span class="comment">//[0,k)为非0元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(i!=m){</span><br><span class="line">                <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">                nums[i]=nums[m];</span><br><span class="line">                nums[m]=temp;   </span><br><span class="line">            }</span><br><span class="line">            m++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p>直接上最优解吧，这题暴力法O(N!)，空间也超过了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||len<=<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=len-<span class="number">2</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">while</span>(i>=<span class="number">0</span> &&nums[i]>=nums[i+<span class="number">1</span>]){</span><br><span class="line">            <span class="comment">//找到第一个峰值左相邻的元素（从左到右）</span></span><br><span class="line">            i--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//逆序的, 没有最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i==-<span class="number">1</span>){</span><br><span class="line">            reverse(nums,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//找到峰值右边 [i+1 , len-1] 最后一个比i 大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=len-<span class="number">1</span>;j>i;j--) {</span><br><span class="line">            <span class="keyword">if</span>(nums[j]>nums[i]){</span><br><span class="line">                swap(nums,j,i);</span><br><span class="line">                reverse(nums,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//翻转数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start,j=nums.length-<span class="number">1</span>;i<j;i++,j--) {< span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">}</span><br></j;i++,j--)></span></pre></td></tr></tbody></table></figure></div><ul><li><p>第一步，逆序找到第一个峰值的左边第一个元素 <code>a[i-1]</code>。</p></li><li><p>将峰值右边的<strong>最小的</strong>比<code>a[i-1]</code>大的<code>a[j]</code>(其实就是<code>右边最后一个比它大的元素</code>)元素与<strong>a[i-1]</strong>交换。</p></li><li><p>翻转刚刚调整过<code>a[i-1]</code>后面的逆序的数组(<code>a[i]-->a[len-1]</code>)。</p></li></ul><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190728/G6uqlPyjPLdV.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>至于为什么这样做自己模拟下就懂了，逆序部分是没有下一个比它大的排列的，所以如果想让整个排列变大只能从这个逆序的排列里面选一个比逆序前最后一个’’稍微’’大一点的元素与之交换，然后将整个逆序的部分翻转就是下一个排列，这题看了题解后处理边界又处理了半天，<strong>循环里面的循环边界条件一定要注意</strong></p><h2 id="556-下一个更大元素-III"><a href="#556-下一个更大元素-III" class="headerlink" title="556. 下一个更大元素 III"></a><a href="https://leetcode-cn.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. 下一个更大元素 III</a></h2><p>给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">12</span></span><br><span class="line">输出: <span class="number">21</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">21</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>和上面那一题一样，权当复习了一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(n/<span class="number">10</span>><span class="number">0</span>){</span><br><span class="line">        sb.append(n%<span class="number">10</span>);</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    sb.append(n);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    <span class="keyword">char</span>[] nums=sb.reverse().toString().toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=len-<span class="number">1</span>;i><span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i]>nums[i-<span class="number">1</span>]) { <span class="comment">//逆序的峰值i</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=len-<span class="number">1</span>;j>=i;j--) {</span><br><span class="line">                <span class="keyword">if</span> (nums[j]>nums[i-<span class="number">1</span>]) {</span><br><span class="line">                    swap(nums,j,i-<span class="number">1</span>);</span><br><span class="line">                    reverse(nums,i,len-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> Long.valueOf(<span class="keyword">new</span> String(nums))>Integer.MAX_VALUE?-<span class="number">1</span>:Integer.valueOf(<span class="keyword">new</span> String(nums));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=begin,j=end;i<j;i++,j--) {< span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">char</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></j;i++,j--)></span></pre></td></tr></tbody></table></figure></div><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h2><p>给定一个<strong>非空整数</strong>数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>很可惜，想到了位运算，但是没试，瞄了一眼评论区，看见异或两个字马上就滚回来写了这个😂</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++){< span><br><span class="line">        nums[i]^=nums[i-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">}</span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 无论怎样，你总会到达索引为 <span class="number">3</span> 的位置。但该位置的最大跳跃长度是 <span class="number">0</span> ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>回溯，勉强能过。。。太蠢了，为啥想不到简单的方法，就非得往复杂了想？就这么傻么？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Boolean[] cache=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length<=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    cache=<span class="keyword">new</span> Boolean[nums.length];</span><br><span class="line">    <span class="keyword">return</span> jump(nums,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums[index] >= nums.length-<span class="number">1</span> -index) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cache[index]!=<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[index];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums[index];i>=<span class="number">1</span>;i--) {</span><br><span class="line">        <span class="keyword">if</span> (index+i<nums.length && jump(nums,index+i)) {< span><br><span class="line">            <span class="keyword">return</span> cache[index]=<span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache[index]=<span class="keyword">false</span>;</span><br><span class="line">}</span><br></nums.length></span></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>不用多说了，遍历数组，不断更新能到达的最远距离，如果<strong>某个位置的index大于当前能到达的最远距离就直接返回false</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//MDZZ</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> maxIndex=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length-<span class="number">1</nums.length-<span></span>;i++) {<br><span class="line">        <span class="keyword">if</span>(maxIndex >= nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i>maxIndex) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        maxIndex=Math.max(maxIndex,i+nums[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>分治法， (<code>HashMap</code>或者排序什么的方法就不说了，笔试可以那样写，面试就不能这样了)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> majorityElement(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (lo==hi) {</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMode=majorityElement(nums,lo,mid);</span><br><span class="line">    <span class="keyword">int</span> rightMode=majorityElement(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">    <span class="keyword">if</span> (leftMode==rightMode) {</span><br><span class="line">        <span class="keyword">return</span> rightMode;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> countMode(nums,lo,mid,leftMode)>countMode(nums,mid+<span class="number">1</span>,hi,rightMode)?leftMode:rightMode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMode</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> mode)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left;i<=right;i++) {</span><br><span class="line">        <span class="keyword">if</span> (mode==nums[i]) {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>并不是最优解，时间复杂度<code>O(NlogN)</code>，只是一种思路吧</p><p><strong>解法二</strong></p><p>摩尔投票法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=nums[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">0</span>) {</span><br><span class="line">            res=nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//将众数看做1,其他的看作-1,最后和一定是大于0的</span></span><br><span class="line">        <span class="keyword">if</span> (res!=nums[i]) {</span><br><span class="line">            sum--;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            sum++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">229. 求众数 II</a></h2><p>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</p><p><strong>说明:</strong> 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>和上面的方法一样，抵消去除三个不同的元素对众数没有任何影响</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List<integer> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </integer></span>{</span><br><span class="line">    List<integer> res = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> candidateA = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> candidateB = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> countA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> countB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (num == candidateA) {</span><br><span class="line">            countA++;<span class="comment">//投A</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (num == candidateB) {</span><br><span class="line">            countB++;<span class="comment">//投B</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (countA == <span class="number">0</span>) {</span><br><span class="line">            candidateA = num;</span><br><span class="line">            countA++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (countB == <span class="number">0</span>) {</span><br><span class="line">            candidateB = num;</span><br><span class="line">            countB++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        countA--;</span><br><span class="line">        countB--;</span><br><span class="line">    }</span><br><span class="line">    countA = <span class="number">0</span>;</span><br><span class="line">    countB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (num == candidateA)</span><br><span class="line">            countA++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == candidateB)</span><br><span class="line">            countB++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (countA > nums.length / <span class="number">3</span>)</span><br><span class="line">        res.add(candidateA);</span><br><span class="line">    <span class="keyword">if</span> (countB > nums.length / <span class="number">3</span>)</span><br><span class="line">        res.add(candidateB);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>Head题，想到了桶排序，但是空间不符合要求，看了评论扣了半天边界也没抠出来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;++i){< span><br><span class="line">        <span class="comment">//将每个元素归位，我开始只有一层循环，那样会漏掉很多元素（可能被交换的元素 后面也需要交换），这样的就是一次直接到位。</span></span><br><span class="line">        <span class="keyword">while</span>(nums[i]>=<span class="number">1</span>&&nums[i]<=nums.length&&nums[nums[i]-<span class="number">1</span>]!=nums[i])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> temp=nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">            nums[nums[i]-<span class="number">1</span>]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;++i){< span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">}</span><br></nums.length;++i){<></span></nums.length;++i){<></span></pre></td></tr></tbody></table></figure></div><p>不考虑空间复杂度利用桶排序的思想</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> [] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;++i){< span><br><span class="line">            <span class="keyword">if</span>(nums[i]><span class="number">0</span> && nums[i]<=nums.length){</span><br><span class="line">                bucket[nums[i]-<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//代表这个桶有元素了</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<bucket.length;++i){< span><br><span class="line">            <span class="keyword">if</span>(bucket[i]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">}</span><br></bucket.length;++i){<></span></nums.length;++i){<></span></pre></td></tr></tbody></table></figure></div><p>lc上提交后的空间消耗居然比上面的还小一点😂</p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img alt="rainwatertrap.png" data-src="https://i.loli.net/2019/05/14/5cda71129045d93180.png" src="/img/loading.gif" class="lazyload"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这种解法的关键就是每个柱子能接的水是<strong>左右最长柱子(都大于当前柱子)中的较小的那个减去当前柱子</strong>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap3</span><span class="params">(<span class="keyword">int</span> []height)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length <= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left < right) {</span><br><span class="line">        <span class="keyword">if</span> (height[left] < height[right]) {</span><br><span class="line">            <span class="keyword">if</span> (height[left] < left_max) <span class="comment">//当前左边元素 比右边最大值小，比左边最大值小是个“凹点”</span></span><br><span class="line">                res += left_max - height[left]; </span><br><span class="line">            <span class="keyword">else</span> left_max = height[left]; <span class="comment">//更新左边柱子最大值</span></span><br><span class="line">            left++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (height[right] < right_max) <span class="comment">//当前左边元素 比左边最大值小，比右边最大值小是个“凹点”</span></span><br><span class="line">                res += right_max - height[right]; </span><br><span class="line">            <span class="keyword">else</span> right_max = height[right]; <span class="comment">//更新右边柱子最大值</span></span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>我最开始思路是填满后用总面积减数组和，跑过了130+个，有一种特殊的跑不过了，懒得去处理那个边界了，不太优雅</p></blockquote><p><strong>解法二</strong></p><p>还有一种很巧妙的方法，也比较好理解，找到最大值，然后分别对两边的柱子进行遍历，如果当前的柱子小于前面柱子的最大值，就说明一定可以接到水，这个过程中需要记录柱子左边的最大值，用于计算可以接水的量，最后计算总和</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap5</span><span class="params">(<span class="keyword">int</span> []height)</span></span>{</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> n=height.length,idx=<span class="number">0</span>,lefth=<span class="number">0</span>,righth=<span class="number">0</span>,area=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<n;i++) idx="height[idx]<=height[i]?i:idx;</span"><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<idx;i++){< span><br><span class="line">        <span class="keyword">if</span>(height[i]<lefth) area+="lefth-height[i];" < span><br><span class="line">        <span class="keyword">else</span> lefth=height[i]; <span class="comment">//更新最大值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>;i>idx;i--){</span><br><span class="line">        <span class="keyword">if</span>(height[i]<righth) area+="righth-height[i];" < span><br><span class="line">        <span class="keyword">else</span> righth=height[i]; <span class="comment">//更新最大值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">}</span><br></righth)></span></lefth)></span></idx;i++){<></span></n;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法三</strong></p><p>利用栈的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap6</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque<integer> stack = <span class="keyword">new</span> ArrayDeque<>(); <span class="comment">//栈里面维护一个递减序列</span></integer></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < height.length; i++){</span><br><span class="line">            <span class="keyword">while</span> ( ! stack.isEmpty() && height[stack.peek()] < height[i]) { <span class="comment">//当遍历的元素大于栈顶元素</span></span><br><span class="line">                <span class="keyword">int</span> tmp = stack.pop(); <span class="comment">//栈顶弹出来</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">                res += (Math.min(height[i],height[stack.peek()]) - height[tmp]) * (i - stack.peek() - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//维护递减序列</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种有点不好理解，其实是按照层来计算的，栈里面是递减的元素，如果读到比栈顶大的元素就<strong>按层</strong>计算递减栈<strong>底部元素</strong>到<strong>当前元素</strong>能蓄水的面积。</p><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></h2><p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><p>题目上已经有了提示，很直观的做法就是利用桶排序的方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> [] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//基于桶排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">        bucket[nums[i]]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//重新构造出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="keyword">while</span> (bucket[index]<=<span class="number">0</span>) {</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">        nums[i]=index;</span><br><span class="line">        bucket[index]--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><p>当然还有更优秀的做法，利用<strong>三向切分快排</strong>的思想(荷兰国旗问题)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> less=-<span class="number">1</span>,more=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l<=more){</span><br><span class="line">        <span class="keyword">if</span>(nums[l]<<span class="number">1</span>){</span><br><span class="line">            swap(nums,++less,l++);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]><span class="number">1</span>){</span><br><span class="line">            swap(nums,more--,l);</span><br><span class="line">        } <span class="keyword">else</span>{ </span><br><span class="line">            l++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"race a car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p>easy题，对撞指针</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()<=<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    s=s.toLowerCase();</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">char</span> lch=s.charAt(left);</span><br><span class="line">        <span class="keyword">char</span> rch=s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span>(isNumOrchar(lch) && isNumOrchar(rch)){</span><br><span class="line">            <span class="comment">//System.out.println(lch+","+rch);</span></span><br><span class="line">            <span class="keyword">if</span>(lch==rch){</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>((!isNumOrchar(lch)) && isNumOrchar(rch)){</span><br><span class="line">            left++;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(isNumOrchar(lch) && !isNumOrchar(rch)){</span><br><span class="line">            right--;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isNumOrchar</span><span class="params">(<span class="keyword">char</span> ch)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>((ch>=<span class="string">'0'</span> && ch<=<span class="string">'9'</span>) || (ch>=<span class="string">'a'</span> && ch<=<span class="string">'z'</span>) || (ch>=<span class="string">'A'</span> &&  ch<=<span class="string">'Z'</span>)){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></right){<></span></pre></td></tr></tbody></table></figure></div><p>代码写多了，不够简洁，其实可以直接用<strong>Character</strong>的API</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i < j) {</span><br><span class="line">        <span class="keyword">while</span> (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;</span><br><span class="line">        <span class="keyword">while</span> (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;</span><br><span class="line">        <span class="keyword">if</span> (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215.数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215.数组中的第K个最大元素</a></h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><blockquote><p>这题必须多说几句</p></blockquote><p><strong>解法一</strong></p><p>大根堆的做法（首先想到的方法，不是常规用堆的做法）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">//构建了大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">        siftUp(nums,i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> size=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<k-<span class="number">1</k-<span></span>;i++) {</nums.length;i++){<></span><br><span class="line">        swap(nums,<span class="number">0</span>,size);<span class="comment">//和堆顶交换K次</span></span><br><span class="line">        siftDown(nums,<span class="number">0</span>,--size);<span class="comment">//重新调整堆</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(nums[i]>nums[(i-<span class="number">1</span>)/<span class="number">2</span>]){</span><br><span class="line">        swap(nums,i,(i-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        i=(i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//i 变小 下沉</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">    <span class="comment">//判断有没有子节点（左孩子）</span></span><br><span class="line">    <span class="keyword">int</span> left=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<size){< span><br><span class="line">        <span class="keyword">int</span> right=left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点最大值</span></span><br><span class="line">        <span class="keyword">int</span> larger=left+<span class="number">1</span><size && nums[left]<nums[left+<span class="number">1</size></span>] ?left+<span class="number">1</span>:left;</size){<></span><br><span class="line">        <span class="keyword">if</span>(nums[larger]>nums[i]){</span><br><span class="line">            swap(nums,larger,i);</span><br><span class="line">            i=larger;</span><br><span class="line">            left=larger*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>70%左右的beat，当时感觉还行，时间复杂度应该是<code>O(KlogN)</code>，后来越想越不对，又去看了下堆排序，发现我之前写的堆排序都是有问题的</p><p><strong>优化后的大根堆做法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> last=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length/<span class="number">2</span>-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        siftDown(nums,i,last);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<k-<span class="number">1</k-<span></span>;i++) {<br><span class="line">        swap(nums,<span class="number">0</span>,last);</span><br><span class="line">        siftDown(nums,<span class="number">0</span>,--last);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//i 变小 下沉</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> last)</span></span>{</span><br><span class="line">    <span class="comment">//判断有没有子节点（左孩子）</span></span><br><span class="line">    <span class="keyword">int</span> left=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<=last){</span><br><span class="line">        <span class="keyword">int</span> right=left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点最大值</span></span><br><span class="line">        <span class="keyword">int</span> larger=right<=last && nums[right] > nums[left]?right:left;</span><br><span class="line">        <span class="keyword">if</span>(nums[larger]>nums[i]){</span><br><span class="line">            swap(nums,larger,i);</span><br><span class="line">            i=larger;</span><br><span class="line">            left=larger*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>95% beat，比上面的要快很多，相比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的insert方式时间复杂度是O(NlogN)，其实想想，这两种方式是完全相反的，insert的方式，最后一层每个元素最坏都可能调整<code>logN</code>次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的<code>swim</code>方式最后一层都只需要调整<code>1</code>次，而根节点需要调整<code>logN</code>次，而根节点只有一个，时间复杂度就会大大降低，最终的时间复杂度就是<code>O(N)</code>，<a href="https://www.zhihu.com/question/20729324" target="_blank" rel="noopener">具体推算可以看这篇文章</a>， 现在的时间复杂度才真的是<code>O(KlogN)</code></p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim" src="/img/loading.gif" class="lazyload"></p><blockquote><p>💥💥 上面这两种做法是有问题的，失去了用堆的优势，大根堆的做法必须要阿将整个堆构建完成后才能去找topk这样的话内存消耗比较大，应该维护一个小根堆，这样如果数据量很大的时候不用全读入内存中，  这题因为是我自己实现的堆，所以建堆的复杂度是O(N)（如果使用官方的API，建堆的时间复杂度就是NlogN），最终大根堆小根堆复杂度取决于K和N的大小关系，但是面试的时候最好不要说用大根堆的做法</p></blockquote><p><strong>解法二</strong></p><p>小根堆的做法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> size=nums.length;</span><br><span class="line">    <span class="comment">//先维护一个大小为k的小根堆 ,这里要注意k不是下标，k=index+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k/<span class="number">2</span>; i >=<span class="number">0</span>; i--) {</span><br><span class="line">        heapIfy(nums,i,k);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//再从k开始向里面插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=k;i<size;i++) {< span><br><span class="line">        <span class="keyword">if</span>(nums[i]>nums[<span class="number">0</span>]) { <span class="comment">//大于小根堆堆顶,进取代它</span></span><br><span class="line">            <span class="comment">//小根堆求第K大,保证这个堆的元素是整个堆的前k大的元素，堆顶就是第k大</span></span><br><span class="line">            swap(nums,i,<span class="number">0</span>);</span><br><span class="line">            heapIfy(nums,<span class="number">0</span>,k);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//小于堆顶就不用管了</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//小根堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">heapIfy</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left < size) {</span><br><span class="line">        <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> small = right < size && nums[right] < nums[left] ? right: left;</span><br><span class="line">        <span class="keyword">if</span>(nums[small]<nums[i]) {< span><br><span class="line">            swap(nums,small,i);</span><br><span class="line">            i=small;</span><br><span class="line">            left=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">    nums[l] = nums[r];</span><br><span class="line">    nums[r] = temp;</span><br><span class="line">}</span><br></nums[i])></span></size;i++)></span></pre></td></tr></tbody></table></figure></div><p>2ms，99%beat，一般情况下的topK问题，如果用堆解决的话应该都是采用<strong>小根堆</strong>这种做法来做，时间复杂度为<code>O(NlogK)</code>，维护一个大小为k的小根堆，然后再遍历后面n-k个元素，依次和当前最小堆的堆顶比较（当前topK中的最小元素，堆顶），如果比它小就和它交换然后调整堆，这样就始终保持了这个堆是当前的topK小，最后的堆顶就是第K大的元素。</p><p><strong>解法三</strong></p><p>其实还有一类做法，利用<code>快排+二分</code>的思想</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<=right){</span><br><span class="line">        <span class="comment">//分治</span></span><br><span class="line">        <span class="keyword">int</span> base=partion(nums,left,right); <span class="comment">//拿到划分点</span></span><br><span class="line">        <span class="keyword">if</span>(base<n-k){< span><br><span class="line">            left=base+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(base>n-k){</span><br><span class="line">            right=base-<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> nums[base];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="comment">//随机取值</span></span><br><span class="line">    swap(nums,left,left+(<span class="keyword">int</span>) (Math.random() * (right - left + <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">int</span> base=left;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">while</span>(left<right&&nums[right]>nums[base]){</right&&nums[right]></span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(left<right&&nums[left]<=nums[base]){< span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(left<right){< span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    swap(nums,left,base);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></right){<></span></right&&nums[left]<=nums[base]){<></span></right){<></span></n-k){<></span></pre></td></tr></tbody></table></figure></div><p>这里最好用<strong>随机</strong>的<strong>partition</strong>，我试了下<strong>不随机</strong>大概<code>50+ms 30%beat</code>，这种随机的大概<code>3ms 97%beats</code>，差距还是很大的，时间复杂度是<strong>O(N)</strong></p><blockquote><p>至于为什么是O(N)，我们可以来分析下，这里<strong>假设每次划分都是差不多中点的位置</strong>，如果是快排，那么在<strong>partition</strong>之后依然需要两边的子数组进行<strong>partition</strong>，分治整个递归栈的高度就是<code>logN</code>，每层都是N，所以整体的复杂度就<strong>O(NlogN)</strong>….扯远了，回到正题</p><p>来说说我们这里为什么是O(N)，这里我们沿用前面的分析过程，递归栈深度依然是<code>logN</code>，但是我们在这里第一次确定划分点的相对<strong>k</strong>的位置后，下一步<strong>只需要划分其中一边的元素，不用对另一边的元素继续</strong>，也就是n/2，再往下就是n/4，n/8，n/16 ….   而 <code>(1+1/2+1/4+1/8+......1/2^n)n <=2n</code> ，也就是说整体的复杂度是低于O(2N)的，所以这里复杂度就是O(N)</p></blockquote><p><strong>解法四</strong></p><p><a href="https://zhuanlan.zhihu.com/p/31498036" target="_blank" rel="noopener">BFPRT算法</a> 大佬们提出来的根据上面快排改进而来，其实面试把小根堆和快排的解法答出来应该就差不多了，这个解法还是有些不容易写出来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> findKthLargest(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> mid=findMid(nums,l,r);</span><br><span class="line">    swap(nums,mid,l);</span><br><span class="line">    <span class="keyword">int</span> m=partition(nums,l,r);</span><br><span class="line">    <span class="keyword">if</span>(m==nums.length-k){</span><br><span class="line">        <span class="keyword">return</span> nums[m];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//下面的类似了</span></span><br><span class="line">    <span class="keyword">if</span>(m>nums.length-k){</span><br><span class="line">        <span class="keyword">return</span> findKthLargest(nums,l,m-<span class="number">1</span>,k);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> findKthLargest(nums,m+<span class="number">1</span>,r,k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中位数的中位数，主要的核心就是在这里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">findMid</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> leftSub=l;</span><br><span class="line">    <span class="comment">//分组求中位数，5等分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i<r-<span class="number">4</r-<span></span>;i+=<span class="number">5</span>) {<br><span class="line">        insertSort(nums,i,i+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//将每一组的中位数统一放到左侧，用于递归</span></span><br><span class="line">        swap(nums,leftSub++,i+<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//处理剩下的不足5个的</span></span><br><span class="line">    <span class="keyword">if</span> (r-l<<span class="number">4</span>) {</span><br><span class="line">        insertSort(nums,l,r);</span><br><span class="line">        swap(nums,leftSub,l+(r-l)/<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//找到了</span></span><br><span class="line">    <span class="keyword">if</span>(l==leftSub){</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> findMid(nums,l,leftSub);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//五等分的插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<r;i++) {< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j>=l&&nums[j]<nums[i];j--) {< span><br><span class="line">            swap(nums,j,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排partition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> base=left;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">while</span>(left<right&&nums[right]>nums[base]){</right&&nums[right]></span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(left<right&&nums[left]<=nums[base]){< span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(left<right){< span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    swap(nums,left,base);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></right){<></span></right&&nums[left]<=nums[base]){<></span></right){<></span></nums[i];j--)></span></r;i++)></span></pre></td></tr></tbody></table></figure></div><p><a href="https://zhuanlan.zhihu.com/p/31498036" target="_blank" rel="noopener">具体的时间复杂度证明</a>，当n取5时候，在划分的时候<strong>至少</strong>会大于<strong>3n/10</strong>的元素，避免了极端情况，保证在最坏情况下也不会太坏。</p><p><img alt="mark" data-src="http://static.imlgw.top/image/20190617/Lc4M5f2qkegH.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>如上图，每一列为分好的一组元素，中间黄色部分为每组的中位数，红色块为<strong>中位数的中位数</strong>，这个中位数至少会大于等于左上角黑框框住的部分，所以在划分的时候会保证至少减小大约3n/10 的规模。</p><p>所以时间复杂度   <code>T(N)<=T(n/5)+T( 7n/10)+c*n</code>  总体时间复杂度<strong>O(N)</strong>，至于为什么不用其他的元素可以看看上面的那篇文章。</p><h2 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a></h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Input: "hello"</span><br><span class="line">Output: "holle"</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Input: "leetcode"</span><br><span class="line">Output: "leotcede"</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        <span class="keyword">while</span>(left<right && !isyy(ss[left])){< span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(left<right && !isyy(ss[right])){< span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        swap(left++,right--,ss);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ss);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isYy</span><span class="params">(<span class="keyword">char</span> ch)</span></span>{</span><br><span class="line">    <span class="keyword">char</span> temp=Character.toLowerCase(ch);</span><br><span class="line">    <span class="keyword">return</span> temp==<span class="string">'a'</span>|| temp==<span class="string">'e'</span>||temp==<span class="string">'i'</span>||temp==<span class="string">'o'</span>||temp==<span class="string">'u'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">char</span>[] s)</span></span>{</span><br><span class="line">    <span class="keyword">char</span> temp=s[a];</span><br><span class="line">    s[a]=s[b];</span><br><span class="line">    s[b]=temp;</span><br><span class="line">}</span><br></right></span></right></span></right){<></span></pre></td></tr></tbody></table></figure></div><p>很简单的对撞指针题</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li><li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li></ul><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>典型的二路归并</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums1.length<=<span class="number">0</span>||nums2.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> []res=<span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">    <span class="keyword">int</span> i1=<span class="number">0</span>,i2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i1<m&&i2<n;i++) {< span><br><span class="line">        <span class="keyword">if</span>(nums1[i1]<=nums2[i2]) {</span><br><span class="line">            res[i]=nums1[i1++];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1]>nums2[i2] ){</span><br><span class="line">            res[i]=nums2[i2++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i1>=m){</span><br><span class="line">        System.arraycopy(nums2,i2,res,i2+m,n-i2);</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        System.arraycopy(nums1,i1,res,i1+n,m-i1);</span><br><span class="line">    }</span><br><span class="line">    System.arraycopy(res,<span class="number">0</span>,nums1,<span class="number">0</span>,res.length);</span><br><span class="line">}</span><br></m&&i2<n;i++)></span></pre></td></tr></tbody></table></figure></div><p>1ms ，98%beats.</p><p>看了下评论区发现自己还是太年轻了，原来这题是可以在<strong>O(1)</strong>的空间复杂度下完成的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge3</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums1.length<=<span class="number">0</span>||nums2.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> i1=m-<span class="number">1</span>,i2=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=m+n-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">if</span>(i1<<span class="number">0</span>){</span><br><span class="line">            nums1[i]=nums2[i2--];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(i2<<span class="number">0</span>){</span><br><span class="line">            nums1[i]=nums1[i1--];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1]>nums2[i2]) {</span><br><span class="line">            nums1[i]=nums1[i1--];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1]<=nums2[i2] ){</span><br><span class="line">            nums1[i]=nums2[i2--];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>合并后的长度确定，nums1的空间也足够，所以完全可以从后往前，从大到小，从而避免了使用额外的空间储存结果，学到了学到了👏</p><h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></h2><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p><p><img alt="img" data-src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" src="/img/loading.gif" class="lazyload"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="number">5</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p>递归专题里面的题目，所以直接用递归来实现了下。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List<list<integer>> generate(<span class="keyword">int</span> numRows) {</list<integer></span><br><span class="line">    <span class="keyword">if</span>(numRows<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">    }</span><br><span class="line">    List<list<integer>> res = <span class="keyword">new</span> ArrayList<>();</list<integer></span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList<integer>() {</integer></span><br><span class="line">        {</span><br><span class="line">            add(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    );</span><br><span class="line">    generate(<span class="number">1</span>, res.get(<span class="number">0</span>), res, numRows);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRow, List<integer> preRow, List<list<integer>> res, <span class="keyword">int</span> rowMax)</list<integer></integer></span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rowMax == numRow) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    List<integer> row = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    row.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < preRow.size(); i++) {</span><br><span class="line">        row.add(preRow.get(i - <span class="number">1</span>) + preRow.get(i));</span><br><span class="line">    }</span><br><span class="line">    row.add(<span class="number">1</span>);</span><br><span class="line">    res.add(row);</span><br><span class="line">    generate(numRow + <span class="number">1</span>,row,res,rowMax);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>尾递归，很鸡肋。</p><h2 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">119. 杨辉三角 II</a></h2><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.</p><p><img alt="img" data-src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" src="/img/loading.gif" class="lazyload"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p><strong>Example:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: <span class="number">3</span></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Follow up:</strong></p><p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<integer> <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </integer></span>{</span><br><span class="line">       List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">       <span class="keyword">long</span> cur=<span class="number">1</span>;</span><br><span class="line">       res.add((<span class="keyword">int</span>)cur);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<=rowIndex;i++){</span><br><span class="line">           cur=cur*(rowIndex-i+<span class="number">1</span>)/i;</span><br><span class="line">           res.add((<span class="keyword">int</span>)cur);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>直接利用组合数的公式，m列第n个元素等于C(n-1,M-1)</p><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h2><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题很久之前做过，这次又来做的时候还是没做出来，忘了之前咋做的了，用模拟的方法搞了半天，没搞出来，然后瞄了一眼之前写的才写出来….</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List<integer> <span class="title">spiralOrder2</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </integer></span>{</span><br><span class="line">    List<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">if</span>(matrix.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//a: 行</span></span><br><span class="line">    <span class="comment">//b: 列</span></span><br><span class="line">    <span class="keyword">int</span> la=<span class="number">0</span>,lb=<span class="number">0</span>,ra=matrix.length-<span class="number">1</span>,rb=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">while</span>(lb<=rb && la<=ra){</span><br><span class="line">        <span class="comment">//缓存各个坐标</span></span><br><span class="line">        <span class="keyword">int</span> tla=la,tlb=lb,tra=ra,trb=rb;</span><br><span class="line">        <span class="comment">//特殊情况，特殊处理</span></span><br><span class="line">        <span class="keyword">if</span>(tla==tra){<span class="comment">//同一行</span></span><br><span class="line">            <span class="keyword">while</span>(tlb<=trb){</span><br><span class="line">                res.add(matrix[tla][tlb++]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(tlb==trb){<span class="comment">//同一列</span></span><br><span class="line">            <span class="keyword">while</span>(tla<=tra){</span><br><span class="line">                res.add(matrix[tla++][tlb]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">while</span>(tlb<rb){< span><br><span class="line">                res.add(matrix[tla][tlb++]);</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">while</span>(tla<ra){< span><br><span class="line">                res.add(matrix[tla++][tlb]);</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//向右</span></span><br><span class="line">            <span class="keyword">while</span>(trb>lb){</span><br><span class="line">                res.add(matrix[tra][trb--]);</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">while</span>(tra>la){</span><br><span class="line">                res.add(matrix[tra--][trb]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//向内靠拢(缩圈)</span></span><br><span class="line">        la++;</span><br><span class="line">        lb++;</span><br><span class="line">        ra--;</span><br><span class="line">        rb--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></ra){<></span></rb){<></span></pre></td></tr></tbody></table></figure></div><p>模拟的方式相对要复杂点，需要记录每个节点是否访问然后在选择，这里的方式就很巧妙，直接按层遍历，由外到内，不用考虑那么多。时间复杂度<code>O(NM)</code>空间复杂度<code>O(NM)</code>。</p><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Given input matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题和上面哪一题放在一起很有必要，很类似的题型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> len=matrix.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lx=<span class="number">0</span>,ly=<span class="number">0</span>,rx=len,ry=len;</span><br><span class="line">    <span class="keyword">while</span>(lx<=rx){</span><br><span class="line">        <span class="comment">//len=ry-ly;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<len;i++) {< span><br><span class="line">            <span class="keyword">int</span> temp=matrix[lx][ly+i];</span><br><span class="line">            matrix[lx][ly+i]=matrix[rx-i][ly];</span><br><span class="line">            matrix[rx-i][ly]=matrix[rx][ry-i];</span><br><span class="line">            matrix[rx][ry-i]=matrix[lx+i][ry];</span><br><span class="line">            matrix[lx+i][ry]=temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//缩圈</span></span><br><span class="line">        len-=<span class="number">2</span>; <span class="comment">//写ry-ly可能会好一点，无所谓</span></span><br><span class="line">        lx++;ly++;</span><br><span class="line">        rx--;ry--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></len;i++)></span></pre></td></tr></tbody></table></figure></div><p>和上一题一样，都是从整体出发，从外层到内层，考虑每一层的前<code>n-1</code>个节点的旋转过程，这个过程需要自己在纸上画一画，空想容易搞错</p><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">你可以假设给定的 k 总是合理的，且 <span class="number">1</span> ≤ k ≤ 数组中不相同的元素的个数。</span><br><span class="line">你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><br></pre></td></tr></tbody></table></figure></div><p>也是TopK问题，但是这题其实还有个条件，<code>不会给出有歧义的数据</code> ，举个例子</p><p><code>nums=[1,1,1,2,2,2,3,3,3] ，k=2</code> 这样的就是有歧义的</p><p>但是题目中也没有规定这样的如何处理，经过测试，发现官方的解在遇到这种情况会抛一个异常。</p><p><strong>解法一</strong></p><p>大根堆的做法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List<integer> <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </integer></span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    HashMap<integer,integer> fre=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//fre.get(i) nums[i]出现的频次</span></span><br><span class="line">        fre.put(nums[i],fre.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//1:3,2:3,3:1</span></span><br><span class="line">    PriorityQueue<hashmap.entry<integer,integer>> pq=<span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> ComparatorMap());</hashmap.entry<integer,integer></span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry ent:fre.entrySet()) {</span><br><span class="line">        pq.add(ent);</span><br><span class="line">    }</span><br><span class="line">    ArrayList<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<k;i++) {< span><br><span class="line">        res.add(pq.poll().getKey());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorMap</span> <span class="keyword">implements</span> <span class="title">Comparator</span><<span class="title">HashMap</span>.<span class="title">Entry</span><<span class="title">Integer</span>,<span class="title">Integer</span>>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry<integer, integer> o1, Map.Entry<integer, integer> o2)</integer,></integer,></span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o2.getValue()-o1.getValue();</span><br><span class="line">    }</span><br><span class="line">}</span><br></k;i++)></span></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>用大根堆不太好，容易爆内存，但是在这一题可以保证顺序，<code>但是题目并没有要求顺序</code>，时间复杂度<del>O(KlogN)</del></p><p>这里错了，建堆的时间复杂度就是<code>O(NlogN)</code>了，只有自己手写的堆，采用自底向上的方式建堆时间复杂度才是O(N) ，可以参考 <a href="http://imlgw.top/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%9B%B4%E4%BC%98%E7%9A%84%E5%81%9A%E6%B3%95">之前的文章</a> ，这也是上面topK问题中提到的</p><p><strong>解法二</strong></p><p>小根堆的做法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List<integer> <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </integer></span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    HashMap<integer,integer> fre=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//fre.get(i) nums[i]出现的频次</span></span><br><span class="line">        fre.put(nums[i],fre.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//1:3,2:3,3:1</span></span><br><span class="line">    <span class="comment">//其实可以这样写，但是对比了一下lambda大概要60ms，而直接构造比较器只要20ms</span></span><br><span class="line">    <span class="comment">//PriorityQueue<hashmap.entry<integer,integer>> pq=new PriorityQueue<>((o1,o2)->o1.getValue()-o2.getValue());</hashmap.entry<integer,integer></span></span><br><span class="line">    PriorityQueue<hashmap.entry<integer,integer>> pq=<span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> ComparatorMap());</hashmap.entry<integer,integer></span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry ent:fre.entrySet()) {</span><br><span class="line">        pq.add(ent);</span><br><span class="line">        <span class="keyword">if</span>(pq.size()>k){</span><br><span class="line">            pq.poll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ArrayList<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) {</span><br><span class="line">        res.add(pq.poll().getKey());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorMap</span> <span class="keyword">implements</span> <span class="title">Comparator</span><<span class="title">HashMap</span>.<span class="title">Entry</span><<span class="title">Integer</span>,<span class="title">Integer</span>>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry<integer, integer> o1, Map.Entry<integer, integer> o2)</integer,></integer,></span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.getValue()-o2.getValue();</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>时间复杂度<code>O(NlogK)</code>因为只维护了一个K大小的小根堆 ，时间复杂度和大根堆<del>O(KlogN)</del> <code>O(NlogN)</code>相比会快很多，除此之外，如果N和K很接近的话可以考虑<code>O(Nlog(N-K))</code> 的做法，维护一个N-K的大根堆，里面存频率最低的那些元素，最后返回其他的元素（no code， just talk）</p><p><strong>解法三</strong></p><p>桶排序，这题的最优解应该就是桶排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List<integer> <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </integer></span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    HashMap<integer,integer> fre=<span class="keyword">new</span> HashMap<>();</integer,integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++) {< span><br><span class="line">        <span class="comment">//记录nums[i]出现的频次</span></span><br><span class="line">        fre.put(nums[i],fre.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    ArrayList<integer> [] bucket=<span class="keyword">new</span> ArrayList[nums.length+<span class="number">1</span>];</integer></span><br><span class="line">    <span class="keyword">for</span> (Integer num:fre.keySet()) {</span><br><span class="line">        <span class="keyword">if</span>(bucket[fre.get(num)]==<span class="keyword">null</span>){</span><br><span class="line">            bucket[fre.get(num)]=<span class="keyword">new</span> ArrayList<>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        bucket[fre.get(num)].add(num); <span class="comment">//所有出现fre.get(num)次的元素构成一条链表</span></span><br><span class="line">    }</span><br><span class="line">    ArrayList<integer> res=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">int</span> topk=bucket.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="comment">//从后向前遍历（从频次大到小）</span></span><br><span class="line">        <span class="comment">//指针移动到合适的位置</span></span><br><span class="line">        <span class="keyword">while</span>(bucket[topk]==<span class="keyword">null</span>&&topk><span class="number">0</span>){</span><br><span class="line">            topk--;</span><br><span class="line">        }</span><br><span class="line">        res.addAll(bucket[topk--]);</span><br><span class="line">        <span class="keyword">if</span>(res.size()==k){</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>桶排序的思路，时间复杂度<code>O(N)</code>，空间复杂度也是<code>O(N)</code>，在leetcode提交三种方法的差距不大，可能是数据量太少了</p><h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为非空字符串且只包含数字 1 和 0。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: a = <span class="string">"11"</span>, b = <span class="string">"1"</span></span><br><span class="line">输出: <span class="string">"100"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: a = <span class="string">"1010"</span>, b = <span class="string">"1011"</span></span><br><span class="line">输出: <span class="string">"10101"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>这题和下面的题目是我有意放在一起的，这题也可以作为大数相加的模板</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>{</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder(); </span><br><span class="line">    <span class="keyword">int</span> idxA=a.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> idxB=b.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> carry=<span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//int carry=0;</span></span><br><span class="line">    <span class="keyword">while</span>(idxA >=<span class="number">0</span> || idxB >=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">char</span> bina=idxA>=<span class="number">0</span>?a.charAt(idxA):<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">char</span> binb=idxB>=<span class="number">0</span>?b.charAt(idxB):<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(bina == <span class="string">'1'</span> && binb ==<span class="string">'1'</span>){</span><br><span class="line">            res.append(carry?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            carry=<span class="keyword">true</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>((bina == <span class="string">'1'</span> && binb ==<span class="string">'0'</span>) ||(bina == <span class="string">'0'</span> && binb ==<span class="string">'1'</span>)){</span><br><span class="line">            res.append(carry?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            res.append(carry?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            carry=<span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        idxA--;idxB--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(carry) res.append(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: num1 = <span class="string">"2"</span>, num2 = <span class="string">"3"</span></span><br><span class="line">输出: <span class="string">"6"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: num1 = <span class="string">"123"</span>, num2 = <span class="string">"456"</span></span><br><span class="line">输出: <span class="string">"56088"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明：</strong></p><ol><li>num1 和 num2 的长度小于110。</li><li>num1 和 num2 只包含数字 0-9。</li><li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li><li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li></ol><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiply2</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    <span class="comment">// 1 2 3 </span></span><br><span class="line">    <span class="comment">// 4 5 6</span></span><br><span class="line">    <span class="comment">// 501 6</span></span><br><span class="line">    <span class="keyword">int</span> n1=num1.length();</span><br><span class="line">    <span class="keyword">int</span> n2=num2.length();</span><br><span class="line">    <span class="comment">//n1*n2 结果最长为 n1+n2</span></span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n1+n2];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n1-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=n2-<span class="number">1</span>;j>=<span class="number">0</span>;j--) {</span><br><span class="line">            <span class="comment">//主要就是对这个i+j+1的理解</span></span><br><span class="line">            res[i+j+<span class="number">1</span>]+=(num1.charAt(i)-<span class="number">48</span>)*(num2.charAt(j)-<span class="number">48</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//处理进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=res.length-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">if</span>(res[i]>=<span class="number">10</span>){</span><br><span class="line">            res[i-<span class="number">1</span>]+=res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i]%=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//去掉前面多余的0</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index<res.length-<span class="number">1</res.length-<span></span>&&res[index]==<span class="number">0</span>) { <br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i<res.length;i++) {< span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></res.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>其实就是模拟的手算的过程，关键的地方就是 <code>i+j+1</code> 的理解</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190928/4xnHi4yd4hwA.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>解法二</strong></p><p>其实仔细分析，会发现上面的代码其实有很多多余的操作，比如去掉前面的0，因为两个<strong>非0的数相乘</strong>，最后的结果最多n1+n2位，最少n1+n2-1位，所以前面的0<strong>最多就一个</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> n1=num1.length();</span><br><span class="line">    <span class="keyword">int</span> n2=num2.length();</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n1+n2];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n1-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=n2-<span class="number">1</span>;j>=<span class="number">0</span>;j--) {</span><br><span class="line">            <span class="comment">//注意这里的i+j+1</span></span><br><span class="line">            res[i+j+<span class="number">1</span>]+=(num1.charAt(i)-<span class="number">48</span>)*(num2.charAt(j)-<span class="number">48</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//处理进位(其实这里res[0]是不可能大于10的)，模拟下知道了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=res.length-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">if</span>(res[i]>=<span class="number">10</span>){</span><br><span class="line">            res[i-<span class="number">1</span>]+=res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i]%=<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<res.length;i++) {< span><br><span class="line">        <span class="comment">//前面最多只有一个0(除了两个数中有一个为0的时候)</span></span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> && res[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></res.length;i++)></span></pre></td></tr></tbody></table></figure></div><p><strong>解法三</strong></p><p>其实上面的进位和计算对应位置的值可以同时处理，这是最接近人手算的思路了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiply3</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> n1=num1.length();</span><br><span class="line">    <span class="keyword">int</span> n2=num2.length();</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n1+n2];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n1-<span class="number">1</span>;i>=<span class="number">0</span>;i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=n2-<span class="number">1</span>;j>=<span class="number">0</span>;j--) {</span><br><span class="line">            <span class="keyword">int</span> sum=res[i+j+<span class="number">1</span>]+(num1.charAt(i)-<span class="number">48</span>)*(num2.charAt(j)-<span class="number">48</span>);</span><br><span class="line">            res[i+j+<span class="number">1</span>]=sum%<span class="number">10</span>;</span><br><span class="line">            res[i+j]+=sum/<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<res.length;i++) {< span><br><span class="line">        <span class="comment">//前面最多只有一个0(除了两个数中有一个为0的时候)</span></span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> && res[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></res.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>"ace"</code>是<code>"abcde"</code>的一个子序列，而<code>"aec"</code>不是）。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">s = <span class="string">"abc"</span>, t = <span class="string">"ahbgdc"</span></span><br><span class="line">返回 <span class="keyword">true</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">s = <span class="string">"axc"</span>, t = <span class="string">"ahbgdc"</span></span><br><span class="line">返回 <span class="keyword">false</span>.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>后续挑战 :</strong></p><p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || t==<span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sindex=<span class="number">0</span>,tindex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sindex<s.length()) {< span><br><span class="line">        <span class="keyword">while</span>(tindex<t.length() && sindex<s.length()){< span><br><span class="line">            <span class="keyword">if</span> (s.charAt(sindex)==t.charAt(tindex)) {</span><br><span class="line">                sindex++;</span><br><span class="line">            }</span><br><span class="line">            tindex++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (tindex==t.length()) {</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sindex==s.length();</span><br><span class="line">}</span><br></t.length()></span></s.length())></span></pre></td></tr></tbody></table></figure></div><p>可以改成递归（多练习递归）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s,String t)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> subsequence(s,t,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">subsequence</span><span class="params">(String s,String t,<span class="keyword">int</span> sindex,<span class="keyword">int</span> tindex)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (sindex == s.length()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//上下if不能交换,可能最后一个才相等</span></span><br><span class="line">    <span class="keyword">if</span> (tindex == t.length()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.charAt(sindex)==t.charAt(tindex)?subsequence(s,t,sindex+<span class="number">1</span>,tindex+<span class="number">1</span>):subsequence(s,t,sindex,tindex+<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//大量的s字符串 处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence3</span><span class="params">(String s, String t)</span> </span>{</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    ArrayList<arraylist<integer>> hash=<span class="keyword">new</span> ArrayList<>();</arraylist<integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">26</span>;i++) {</span><br><span class="line">        hash.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<t.length();i++) {< span><br><span class="line">        hash.get(t.charAt(i)-<span class="string">'a'</span>).add(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//经过上面的预处理,后面的处理就会很快,不用再遍历t字符串</span></span><br><span class="line">    <span class="keyword">int</span> lastIndex=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<s.length();i++) {< span><br><span class="line">        List<integer> indexList=hash.get(s.charAt(i)-<span class="string">'a'</span>);</integer></span><br><span class="line">        <span class="keyword">int</span> temp=binarySearch(indexList,lastIndex);</span><br><span class="line">        <span class="keyword">if</span> (temp==indexList.size()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        lastIndex=indexList.get(temp);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个比target大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List<integer> list,<span class="keyword">int</span> target)</integer></span></span>{</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=list.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<=right){</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.get(mid)>target) {</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br></s.length();i++)></span></t.length();i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>,<span class="number">99</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法 </li></ul><p><strong>解法一</strong></p><p>常规解法，每次保留数组最后一个元素，从后往前将每个元素赋值为前一个元素的值，这样就相当于将数组整体向后循环移动一次，循环移动k次就是最后的结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">1</span>||k==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    k=k%len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<k;i++) {< span><br><span class="line">        <span class="keyword">int</span> temp=nums[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=len-<span class="number">1</span>;j>=<span class="number">0</span>;j--) {</span><br><span class="line">            nums[j]=nums[j-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        nums[<span class="number">0</span>]=temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></k;i++)></span></pre></td></tr></tbody></table></figure></div><p>时间复杂度较高，<code>O(NK)</code> Java可以过，但是C/C++可能过不了</p><p><strong>解法二</strong></p><p>这个做法就相当巧妙了，三次翻转🐂🍺</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//翻转的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length<=<span class="number">1</span>||k==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    k=k%len;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    reverse(nums,<span class="number">0</span>,len-k-<span class="number">1</span>);</span><br><span class="line">    reverse(nums,len-k,len-<span class="number">1</span>);</span><br><span class="line">    reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(left<right){< span><br><span class="line">        swap(nums,left++,right--);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></right){<></span></pre></td></tr></tbody></table></figure></div><p><code>O(N)</code> 应该是最优解了</p><h2 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/" target="_blank" rel="noopener">1232. 缀点成线</a></h2><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 <code>true</code>，否则请返回  <code>false</code></p><p><strong>解法一</strong></p><p>10.20竞赛第一题，判断给定的点是不是再一条直线上，判断和前两个点是不是在一条直线上，注意不要直接除算斜率，那样是不准确的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i<coordinates.length;i++) {< span><br><span class="line">        <span class="keyword">if</span>((coordinates[i][<span class="number">1</span>]-coordinates[i-<span class="number">1</span>][<span class="number">1</span>])*(coordinates[i-<span class="number">1</span>][<span class="number">0</span>]-coordinates[i-<span class="number">2</span>][<span class="number">0</span>])!=</span><br><span class="line">           (coordinates[i][<span class="number">0</span>]-coordinates[i-<span class="number">1</span>][<span class="number">0</span>])*(coordinates[i-<span class="number">1</span>][<span class="number">1</span>]-coordinates[i-<span class="number">2</span>][<span class="number">1</span>])){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></coordinates.length;i++)></span></pre></td></tr></tbody></table></figure></div><h2 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/" target="_blank" rel="noopener">1233. 删除子文件夹</a></h2><p>你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。</p><p>我们这样定义「子文件夹」：</p><ul><li><p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的子文件夹。<br>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：</p></li><li><p><code>/</code> 后跟一个或者多个小写英文字母。<br>例如，<code>/leetcode</code> 和 <code>/leetcode/problems</code> 都是有效的路径，而空字符串和 <code>/</code> 不是。</p><p><strong>示例 1：</strong></p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：folder = [<span class="string">"/a"</span>,<span class="string">"/a/b"</span>,<span class="string">"/c/d"</span>,<span class="string">"/c/d/e"</span>,<span class="string">"/c/f"</span>]</span><br><span class="line">输出：[<span class="string">"/a"</span>,<span class="string">"/c/d"</span>,<span class="string">"/c/f"</span>]</span><br><span class="line">解释：<span class="string">"/a/b/"</span> 是 <span class="string">"/a"</span> 的子文件夹，而 <span class="string">"/c/d/e"</span> 是 <span class="string">"/c/d"</span> 的子文件夹。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：folder = [<span class="string">"/a"</span>,<span class="string">"/a/b/c"</span>,<span class="string">"/a/b/d"</span>]</span><br><span class="line">输出：[<span class="string">"/a"</span>]</span><br><span class="line">解释：文件夹 <span class="string">"/a/b/c"</span> 和 <span class="string">"/a/b/d/"</span> 都会被删除，因为它们都是 <span class="string">"/a"</span> 的子文件夹。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：folder = [<span class="string">"/a/b/c"</span>,<span class="string">"/a/b/d"</span>,<span class="string">"/a/b/ca"</span>]</span><br><span class="line">输出：[<span class="string">"/a/b/c"</span>,<span class="string">"/a/b/ca"</span>,<span class="string">"/a/b/d"</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ul><li>1 <= folder.length <= 4 * 10^4</li><li>2 <= folder[i].length <= 100</li><li>folder[i] 只包含小写字母和 /</li><li>folder[i] 总是以字符 / 起始</li><li>每个文件夹名都是唯一的</li></ul><p><strong>解法一</strong></p><p><code>2019.10.20</code>的竞赛题，当时没做出来。。。一直超时，太菜了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List<string> <span class="title">removeSubfolders</span><span class="params">(String[] folder)</span> </string></span>{</span><br><span class="line">    Arrays.sort(folder);</span><br><span class="line">    List<string> res=<span class="keyword">new</span> LinkedList<>();</string></span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">    res.add(folder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<folder.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (!folder[i].startsWith(folder[root]+<span class="string">"/"</span>)) {</span><br><span class="line">            res.add(folder[i]);</span><br><span class="line">            root=i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></folder.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>当时我想到了排序，但是并没处理好，排序之后还是傻傻的一个个去对比，其实排序后就很清楚了</p><p><code>folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]</code> 题目其实也在暗示我们要排序，给的case都是排好序的</p><p>当然这里很精髓的一步就是在对比的时候在 <code>folder[root]</code> 后面加上一个 <code>"/"</code> ，这样就不会将 <code>a/b/c</code> 判断为 <code>a/b/ca</code> 的根目录了~</p><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="string">"cbbd"</span></span><br><span class="line">输出: <span class="string">"bb"</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>是面试经常考的一题，还是挺有意思的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    String res=s.charAt(<span class="number">0</span>)+<span class="string">""</span>;<span class="comment">//只有1个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<s.length();i++) {< span><br><span class="line">        String even=palindrome(s,i-<span class="number">1</span>,i); <span class="comment">//偶数长度回文,从两个字符中间开始扩散</span></span><br><span class="line">        String odd=palindrome(s,i,i); <span class="comment">//奇数长度回文,从某一个字符开始扩散</span></span><br><span class="line">        String temp=odd.length()>even.length()?odd:even;</span><br><span class="line">        <span class="keyword">if</span> (temp.length()>res.length()) {</span><br><span class="line">            res=temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">palindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(i>=<span class="number">0</span> && j<=s.length()-<span class="number">1</span> && s.charAt(i)==s.charAt(j)){</span><br><span class="line">        i--;</span><br><span class="line">        j++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.substring(i+<span class="number">1</span>,j);</span><br><span class="line">}</span><br></s.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>如果采用暴力法的话就是枚举所有子串，判断是不是回文串，最后求个最长的，时间复杂度<code>O(N^3)</code> ，但是我们可以利用回文的特征，利用中心扩散法，以<code>str</code>的<strong>各个位置</strong>作为中心，向两边扩散，最后求得最大值，注意得这里说的是<strong>各个位置</strong>，这个里面其实就包含了元素之间的间隙，其实整体思路还是挺简单的，但经过我们小小的转换思路，时间复杂度就降低到了<code>O(N^2)</code>，当然，这里还不是最优解，最优应该是<a href="https://oi-wiki.org/string/manacher/" target="_blank" rel="noopener">Manacher</a> （马拉车）算法，等后面有时间我再来研究这种算法</p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>思路也没啥好说的，类似贪心吧</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) {</span><br><span class="line">    <span class="keyword">if</span> (intervals ==<span class="keyword">null</span> || intervals.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]{};</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(intervals,(a,b)->a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    LinkedList<<span class="keyword">int</span>[]> list=<span class="keyword">new</span> LinkedList<>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<intervals.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]<=intervals[i-<span class="number">1</span>][<span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">1</span>]>intervals[i-<span class="number">1</span>][<span class="number">1</span>]) {</span><br><span class="line">                intervals[i][<span class="number">0</span>]=intervals[i-<span class="number">1</span>][<span class="number">0</span>];   </span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                intervals[i][<span class="number">0</span>]=intervals[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>]=intervals[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            list.add(intervals[i-<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    list.add(intervals[intervals.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/*  int[][] res=new int[list.size()][2];</span></span><br><span class="line"><span class="comment">        for (int i=0;i<list.size();i++) {< span></list.size();i++)></span><br><span class="line"><span class="comment">            res[i][0]=list.get(i)[0];</span></span><br><span class="line"><span class="comment">            res[i][1]=list.get(i)[1];</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//题解哪里学到一招</span></span><br><span class="line">}</span><br></span></intervals.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>最大的收获就是学到了一招list转array的方法😁</p><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><ul><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ul><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [<span class="number">1</span>,<span class="number">2</span>] 来使剩下的区间没有重叠。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>动态规划，其实和最长递增子序列是一样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="keyword">null</span> || intervals.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(intervals,(a,b)->a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span>[]dp=<span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">    <span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<intervals.length;i++) {< span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<i;j++) {< span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]>=intervals[j][<span class="number">1</span>]){</span><br><span class="line">                dp[i]=Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        max=Math.max(max,dp[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> intervals.length-max;</span><br><span class="line">}</span><br></i;j++)></span></intervals.length;i++)></span></pre></td></tr></tbody></table></figure></div><p>171ms，8%，感觉快要过不了了。。。本来是是写的记忆化递归的，结果过不了。。。卡在倒数第二个case上</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">HashMap<pair,integer> cache=<span class="keyword">new</span> HashMap<>();<span class="comment">//TLE</span></pair,integer></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals2</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>{</span><br><span class="line">    Arrays.sort(intervals,(a,b)->a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> intervals.length-dfs(intervals,<span class="number">0</span>,Integer.MIN_VALUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//背包问题,返回最多可以留下的区间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] intervals,<span class="keyword">int</span> index,<span class="keyword">int</span> prev)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index==intervals.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Pair key=<span class="keyword">new</span> Pair(index,prev);</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) {</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res=dfs(intervals,index+<span class="number">1</span>,prev);</span><br><span class="line">    <span class="keyword">if</span> (intervals[index][<span class="number">0</span>]>=prev) {</span><br><span class="line">        res=Math.max(res,dfs(intervals,index+<span class="number">1</span>,intervals[index][<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    cache.put(key,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二</strong></p><p>贪心，时间复杂度降低为线性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="keyword">null</span> || intervals.length<=<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//按照起点排序,重叠的时候选择保留结尾小的那一个</span></span><br><span class="line">    <span class="comment">//Arrays.sort(intervals,(a,b)->a[0]-b[0]); lambda初始化效率会低一点</span></span><br><span class="line">    Arrays.sort(intervals,<span class="keyword">new</span> Comparator<<span class="keyword">int</span>[]>(){</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>{</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<intervals.length;i++) {< span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]>=intervals[prev][<span class="number">1</span>]) {</span><br><span class="line">            res++;</span><br><span class="line">            prev=i;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]<intervals[prev][<span class="number">1</intervals[prev][<span></span>]){</intervals.length;i++)></span><br><span class="line">            prev=i; <span class="comment">//选择结尾小的那一个</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> intervals.length-res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>按照起点排序，在重叠的时候优先选择结尾小的哪一个，这样就可能得到更多的区间组合，关于这个算法的正确性我就不证明了</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNI初探</title>
      <link href="/2019/05/02/jni-chu-tan/"/>
      <url>/2019/05/02/jni-chu-tan/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="JNI简介"><a href="#JNI简介" class="headerlink" title="JNI简介"></a>JNI简介</h2><blockquote><p>JNI是<strong>Java Native Interface</strong>的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是<a href="https://baike.baidu.com/item/C/7252092" target="_blank" rel="noopener">C</a>&<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank" rel="noopener">C++</a>）。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少要保证本地代码能工作在任何Java 虚拟机环境。</p></blockquote><p>相信大家在看源码的时候都看见过用<strong>native</strong>修饰的方法，这些方法就是用C/C++语言实现的，那到底java是如何调用的这些方法的呢？</p><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p><strong>准备工作</strong></p><blockquote><p>文中环境为Linux下Centos6版本</p></blockquote><p>✅ 首先需要有<code>JDK</code>(我的是jdk1.7)，编译java</p><p>✅ 然后需要<code>gcc</code> 用来编译C/C++</p><p><strong>Java代码</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> JniTest().hi();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">//加载一个动态链接库</span></span><br><span class="line">        System.loadLibrary(<span class="string">"jniTest"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在静态代码块里面加载了一个<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">动态链接库</a></p><p>编写完之后直接<code>javac JniTest.java</code>编译一下，然后执行<code>javah -jni  JniTest</code>，会在当前目录下生成一个<code>JniTest.h</code>的头文件如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><jni.h></jni.h></span></span></span><br><span class="line"><span class="comment">/* Header for class JniTest */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_JniTest</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_JniTest</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     JniTest</span></span><br><span class="line"><span class="comment"> * Method:    hi</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_JniTest_hi</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>C代码</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">#include<stdio.h></stdio.h></span><br><span class="line">#include "JniTest.h"</span><br><span class="line">#include <jni.h></jni.h></span><br><span class="line"><span class="comment">//这一段来自上面的头文件</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_JniTest_hi</span><br><span class="line">  (JNIEnv *env, jobject o){</span><br><span class="line">        printf(<span class="string">"you  successfully called the c code\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li><code>JNIEnv*</code>：用于引用JNI环境，该指针变量可以访问所有JNI函数</li><li><code>jobject</code>：引用<code>this</code> Java对象，也就是可以用来访问当前java调用者</li></ul><p>写完之后执行如下命令编译它</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">gcc -fPIC -D_REENTRANT  -I<span class="string">"$JAVA_HOME/include"</span>  -I<span class="string">"$JAVA_HOME/include/linux"</span> -c JniTest.c</span><br></pre></td></tr></tbody></table></figure></div><p>会在当前目录下生成一个<code>JniTest.o</code>的可执行文件。</p><p>然后执行</p><p><code>gcc -shared JniTest.o -o libjniTest.so</code></p><p>注意<code>linux</code>上动态链接库必须以<code>lib</code>开头，所以这里是<code>libjniTest</code>后面的是前面<code>java</code>代码中加载的哪个动态链接库名称<code>jniTest</code>，最后会在当前目录下生成一个<code>libjniTest.so</code>的动态库</p><p><strong>执行</strong></p><p>首先给<code>libjniTest.so</code>赋予可执行权限</p><p><code>chmod 777 libjniTest.so</code></p><p>因为我这里没有设置<code>java.library.path</code>所以需要在运行的时候加上路径</p><p><code>java -Djava.library.path=/usr/jnitest JniTest</code></p><p><strong>结果</strong></p><p><img alt="mark" data-src="http://static.imlgw.top///20190502/rKdNPEwUmstf.png?imageslim" src="/img/loading.gif" class="lazyload"></p><blockquote><p> 篇文章中只是简单的调用了C语言的代码，关于如何传递参数，如何返回值，后面遇到之再做记录</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile关键字详解</title>
      <link href="/2019/04/29/volatile-guan-jian-zi/"/>
      <url>/2019/04/29/volatile-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="JMM-amp-CPU缓存"><a href="#JMM-amp-CPU缓存" class="headerlink" title="JMM&CPU缓存"></a>JMM&CPU缓存</h2><h3 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h3><p>其实这个并不是指某一个具体的部件，<code>寄存器(Register)</code>，<code>高速缓存(Cache)</code>，<code>写缓冲器(Store Buffer)</code>，<code>无效化队列(Invalidate Queue)</code>等等都可以称为 CPU缓存。</p><h4 id="为什么要有CPU缓存？"><a href="#为什么要有CPU缓存？" class="headerlink" title="为什么要有CPU缓存？"></a>为什么要有CPU缓存？</h4><p><code>缓存</code>通常意义下都是为了加快速度，这里同样也是，因为CPU的速度比<code>主内存(RAM)</code>快很多，<code>主内存</code>会拖CPU后腿影响整体的效率，所以缓存就出现了，缓存的速度比<code>主内存</code>快很多(造价高)CPU会直接通过缓存来对主内存进行读写操作，所以缓存里面实际上相当于是<code>主内存</code>的副本。</p><h4 id="使用CPU缓存带来的问题"><a href="#使用CPU缓存带来的问题" class="headerlink" title="使用CPU缓存带来的问题"></a>使用CPU缓存带来的问题</h4><p>正常情况下CPU执行计算的过程如下</p><p>1️⃣程序以及数据被加载到主内存</p><p>2️⃣指令和数据被加载到CPU缓存</p><p>3️⃣CPU执行指令，把结果写到高速缓存</p><p>4️⃣高速缓存中的数据写回主内存</p><p>如果是单核CPU，上面的步骤没有任何问题，但如果是多核CPU就可能会出现一些意料之外的问题，假设有两个核</p><p>下面这种情况也是有可能发生的</p><p>1️⃣核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存</p><p>2️⃣核1做了上面同样的工作，这样核0与核1的缓存拥有同样的数据</p><p>3️⃣核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存</p><p>4️⃣核1访问该字节，由于核0并未将数据写回主存，数据不同步</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>🔶LOCK# 总线锁，效率很低，同时只能有一个CPU对内存操作，其他的CPU只能干等着</p><p>🔶缓存一致性<code>协议</code>，缓存一致性协议有多种，<code>MESI</code>协议是当前最主流的缓存一致性协议</p><p><img alt="MESI状态" data-src="http://static.imlgw.top///20190411/GYdTPdVBGCQB.png?imageslim" src="/img/loading.gif" class="lazyload">)日常处理的大多数计算机设备都属于<code>嗅探(snooping)</code>协议，CPU缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去<code>读写内存</code>时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一<code>写内存</code>，其它处理器马上知道这块内存在它们的缓存段中<code>已失效(Invaid)</code>，如果这个时候有处理器想<code>读内存</code>(会被立即察觉到，因为一直在嗅探总线)，那么已修改的缓存行(Cache line)就会立即刷新到主存中，然后设置为<code>Share</code>状态，这样一来读取到的数据就不是脏数据了。</p><p>再放一张 处理器&缓存&主内存交互的图（来自组成原理书上的图）</p><p><img alt="Cache基本结构" data-src="http://static.imlgw.top///20190415/lJzPTl3yQWBn.jpg?imageslim" src="/img/loading.gif" class="lazyload"></p><p>既然有了MESI协议，是不是就不需要volatile的可见性语义了？当然不是</p><ul><li><strong>并不是所有的硬件架构都提供了相同的一致性保证，JVM需要volatile统一语义</strong>（就算是MESI，也只解决CPU缓存层面的问题，没有涉及其他层面）。</li><li>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的<code>内存模型</code>中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。</li><li><a href="https://www.zhihu.com/question/277395220" target="_blank" rel="noopener">这个回答应该很好的解释了</a> 大概就是缓存一致性协议并不能保证实时性，而有时候我们需要保证严格的实时性</li></ul><h3 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h3><blockquote><p>为了屏蔽各个操作系统和硬件的差异，使得 Java 程序在所有平台下都能达到一致的内存访问效果，所以 Java 虚拟机定义了一种 Java 内存模型。</p></blockquote><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。（这里的变量不包括局部变量和方法参数，因为那是线程私有的，不会产生竞争）</p><p>Java 虚拟机规定所有的变量都存储在主内存（Main Memory），每个线程都有自己的工作线程（Work Memory 有些地方称为线程栈）。</p><p>线程的工作内存中保存了使用到的变量的主内存副本拷贝，线程对变量的操作是在自己的工作内存中，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，而不能直接对主内存的变量进行读取赋值。</p><p>不同线程之间无法直接访问对方工作内存中的变量，需要通过主内存来进行传递。</p><p><img alt="JMM" data-src="http://static.imlgw.top///20190411/PjL8vV724vXx.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>（来自 <a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">zejian</a>）</p><p>工作内存实际上就是对上面<strong>CPU缓存</strong>的抽象。</p><h4 id="内存间交互"><a href="#内存间交互" class="headerlink" title="内存间交互"></a>内存间交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。<br>read：把一个变量的值从主内存传输到工作内存中<br>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中<br>use：把工作内存中一个变量的值传递给执行引擎<br>assign：把一个从执行引擎接收到的值赋给工作内存的变量<br>store：把工作内存的一个变量的值传送到主内存中<br>write：在 store 之后执行，把 store 得到的值放入主内存的变量中<br>lock：作用于主内存的变量<br>unlock：对应lock</p><p><strong>JMM</strong>还定义了一些关于<code>happens-before</code>关系的规则如下</p><ul><li><p>代码的执行顺序，编写在前面的发生在编写在后面的。</p></li><li><p>unlock 必须发生在lock之后</p></li><li><p>volatile 修饰的 写操作先发生在读之前</p></li><li><p>传递规则 ，A 先于B B先于C A肯定先于C</p></li><li><p>线程启动规则，start肯定现场发生与run</p></li><li><p>线程中断方法，interrupt 必须发生在捕获之前</p></li><li><p>对象的初始化必须发生在finalize前</p></li><li><p>线程终结规则，所有操作都发生在线程死亡前</p></li></ul><p><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html" target="_blank" rel="noopener">参考</a></p><h2 id="Volatile干了什么？"><a href="#Volatile干了什么？" class="headerlink" title="Volatile干了什么？"></a>Volatile干了什么？</h2><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>这里我们来看一个具体的Demo。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop){</span><br><span class="line">    <span class="comment">//doSomething();</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></tbody></table></figure></div><p>其实在上一篇 <a href="http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/">Java多线程基础</a> 里面 “优雅的结束线程” 里面有类似的代码</p><p><img alt="mark" data-src="http://static.imlgw.top///20190428/LQuwmhuMiwxp.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>当时没有说明为啥要加<code>Volatile</code>，其实这里上面的代码如果不给状态量加上 <code>volatile</code>  并且用<code>server</code>模式运行有可能就会陷入死循环，即使在主线程里面将<code>isCancel</code>修改为<code>true</code>仍然无法结束，线程陷入了死循环，永远无法停止！！!为什么会这样？？？</p><p><img alt="mark" data-src="http://static.imlgw.top///20190410/nCcFbqyGiqIz.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>🔸 在<code>server</code>模式下JIT对我们的代码进行了优化（这也是为什么要用server模式运行的原因，<strong>Client VM的编译器没有像Server VM一样执行许多复杂的优化算法</strong>）。它会将代码优化为类似下面这样的效果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!stop){</span><br><span class="line"> <span class="keyword">while</span> (stop){</span><br><span class="line"><span class="comment">//do something....</span></span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>JIT</code>认为只有一个线程对其进行访问，所以为了避免重复的读取状态变量<code>stop</code>就将代码进行了 <a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E4%BB%A3%E7%A0%81%E5%A4%96%E6%8F%90" target="_blank" rel="noopener">循环不变表达式外提</a>（wikipedia），而这恰恰导致了死循环</p><p>🔸另一方面，也和计算机的储存系统有关，也就是上面<code>CPU缓存</code>的问题中提到的，这里 <code>stop</code>就是共享变量，当线程①和②运行的时候先将主内存的<code>stop</code>拷贝了一份到<code>工作内存</code>中，其中一个线程修改了<code>stop</code>的值但是其他的线程无法感知到这个变化就可能会陷入死循环。</p><p>📢 <code>volatile</code>在这里起到的作用就是</p><p>① 阻止<code>JIT</code>的异常优化</p><p>② 在一个线程修改了<code>volatile</code>修饰的共享变量后会<strong>立即刷新到主内存</strong>当中，这个过程称为_冲刷处理器缓存_。如果一个线程在读<code>voaltile</code>修饰的变量就会使相应的处理器<strong>必须从主内存中进行同步</strong>，这个过程称之为_刷新处理器缓存_，从而保证了可见性，通俗的讲就是<code>读必须从主内存中读，写必须同步到主内存中</code>。</p><h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><p><strong>重排序</strong></p><p>提到有序性就不得不说重排序，先来看一个<code>Demo</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isReady=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> data=getFromXxx(); <span class="comment">//①</span></span><br><span class="line">    isReady=<span class="keyword">true</span> <span class="comment">//②</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(isReady){</span><br><span class="line">        <span class="comment">//doSth</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这一看似乎没有什么问题，writer线程完成后开始read，问题就出来这里，<strong>有可能data数据还没获取到，isReady就已经是true了</strong>也就是说②和①的执行交换了顺序，也就是所谓的<strong>重排序</strong>，这样的重排序将会导致不可预知的错误，而导致这种现象的来源很多，比如编译器(JIT)，处理器和存储子系统(Cache)，至于为什么要重排序，主要还是为了提升性能，当然重排序对单线程来讲是没有影响的(有影响那还得了😂)</p><p><strong>其实不只是上面那种比较显而易见的重排序，还有下面这种比较隐含的</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObjectPlus</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  SingletonObjectPlus singletonObjectPlus =<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObjectPlus <span class="title">getSingletonObject3</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(singletonObjectPlus==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">synchronized</span>(SingletonObject<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">            <span class="keyword">if</span>(singletonObjectPlus==<span class="keyword">null</span>){</span><br><span class="line">                singletonObjectPlus= <span class="keyword">new</span> SingletonObjectPlus();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     <span class="keyword">return</span> singletonObjectPlus;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>熟悉的朋友可能看出来了，这是一个DCL单例，那它有什么问题呢？它也会被重排序么？那么会在哪里重排序呢？</p><p>上述代码确实有问题，问题在<strong>new SingletonObjectPlus();</strong>里面，实际上new这个操作可以划分为如下好几步</p><ol><li>分配对象所需的空间 <code>objRef=allocate(SingleObjectPlus.class);</code></li><li>初始化引用的对象 <code>invokeConstructor(objRef);</code></li><li>设置<code>singletonObjectPlus</code>指向刚分配的内存地址<code>singletonObjectPlus=objRef</code></li></ol><p>而这些步骤有可能就会被重排序，比如将③排到②之前，也就是对象还没有初始化完成就会被返回(已经分配空间了，就不为null了)，这样在<code>最外层if</code>判断的时候就可能会直接返回一个初始化未完成的对象</p><blockquote><p>发生这样重排序的概率很低，并不是必然出现的，重排序也不是随意的顺序调整，而是按照一定的规则去重排序，保证不会对单线程程序运行结果造成影响，显而易见，如果两条语句之间存在依赖关系，肯定是不会重排序的，具体就是两条语句访问同一个变量地址，至少有一条为写操作，那么这两条指令就存在依赖关系就不会被重排序比如 x=1;x=2;这样的 就不会被重排序。</p></blockquote><p>其实上面的问题都很好解决，只要在<strong>isReady</strong>和<strong>singletonObjectPlus</strong>上加上<code>volatile</code>就ok了，在这里volatile会禁止指令的重排序（底层通过调用处理器提供的内存屏障）</p><h3 id="保障Long-Double变量写的原子性"><a href="#保障Long-Double变量写的原子性" class="headerlink" title="保障Long/Double变量写的原子性"></a>保障Long/Double变量写的原子性</h3><p>这一点其实很容易被遗忘，实际上Java对所有除了Long和Double的变量的<strong>读写</strong>操作都是原子性的，包括基础类型(byte，boolean，short，float，和int)和引用类型。因为Double和Long类型的变量会占用64位，如果在<code>32位机器</code>上JVM对这种变量的读写可能就是会被分解为两个操作而在多线程的情况下就会出现问题，这里就不做演示了，知道有这么个事就行了。在加上<code>Volatile</code>之后就可以保证该操作的原子性了。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>volatile在保障可见性的时候仅仅只能保障能够读取到该共享变量的相对新值，对于引用类型变量和数组类型的变量，volatile能保证的也仅仅是该变量本身的可见性，而对于数组中的元素，引用类型中的字段（实例变量，静态变量）则无法保证其可见性，对于这些变量可见性的保障可以利用JUC工具包中的<code>Atomic原子类</code>。</p></blockquote><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>先简单了解两个指令：</p><ul><li>Store：将处理器缓存的数据刷新到内存中。</li><li>Load：将内存存储的数据拷贝到处理器的缓存中。</li></ul><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;<code>LoadLoad</code>;Load2</td><td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td></tr><tr><td>StoreStore Barriers</td><td>Store1;<code>StoreStore</code>;Store2</td><td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td></tr><tr><td>LoadStore Barriers</td><td>Load1;<code>LoadStore</code>;Store2</td><td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;<code>StoreLoad</code>;Load2</td><td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td></tr></tbody></table><p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为<code>全能屏障</code>（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵</p><ul><li><p>按照可见性划分，内存屏障可以分为<strong>加载屏障</strong>(Load Barrier)，和<strong>存储屏障</strong>(Store Barrier)</p></li><li><p>按照有序性划分可分为<strong>获取屏障</strong>(Acquire Barrier)和<strong>释放屏障</strong>(Release Barrier)</p></li></ul><p>具体那个充当加载屏障，那个充当存储屏障，我并不想讨论，各种博客各种资料各有各的说法，其实关于究竟底层是如何实现，如何插入，插入的哪一种这些细节我们不用去关心，不同的CPU不同的架构实现的方式都不一样，太过深入也没有多大的意义，很多博客介绍的也<code>完全不同</code>，我们只需要知道大概的原理就行了。如果想了解更多可以参考下列文章</p><p><a href="http://www.0xffffff.org/2017/02/21/40-atomic-variable-mutex-and-memory-barrier/" target="_blank" rel="noopener">聊聊原子变量、锁、内存屏障那点事</a></p><p><a href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" target="_blank" rel="noopener">一文解决内存屏障</a></p><p><a href="https://www.jianshu.com/p/506c1e38a922" target="_blank" rel="noopener">面试必问的volatile，你了解多少？</a></p><p><a href="https://www.infoq.cn/article/java-memory-model-4/?utm_source=infoq&%253Butm_medium=related_content_link&%253Butm_campaign=relatedContent_articles_clk" target="_blank" rel="noopener">深入理解 Java 内存模型（四）——volatile</a></p><h3 id="锁与内存屏障"><a href="#锁与内存屏障" class="headerlink" title="锁与内存屏障"></a>锁与内存屏障</h3><p>用<strong>OneNote</strong>画了几张图</p><p><img alt="mark" data-src="http://static.imlgw.top///20190428/EUPpWHTPnlH8.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>实际上锁就是通过<strong>内存屏障</strong>来保证了有序性和可见性，通过<strong>互斥排它</strong>来保证了原子性</p><h3 id="Volatile和内存屏障"><a href="#Volatile和内存屏障" class="headerlink" title="Volatile和内存屏障"></a>Volatile和内存屏障</h3><p><strong>Volatile写操作和内存屏障</strong></p><p><img alt="volatile变量的写操作" data-src="http://static.imlgw.top///20190428/PImPUeLGqau6.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>🔔 写线程对于<code>volatile变量的写操作</code>会产生类似于<code>锁释放</code>的效果。在写完成后会<code>冲刷处理器缓存</code>将结果立即刷新到主存中让其他处理器对应的缓存行失效，让其他处理器可同步该数据</p><blockquote><p>volatile变量在原子性方面仅仅保证对被修饰的变量的读写<code>本身</code>的原子性。也就是说这个操作不能涉及任何共享变量(包括volatile变量本身)的访问，比如 volatile1=volatile2+1，volatile++ 这样的操作无法保证它的原子性，另外，voaltile可以保证<code>long</code>和<code>double</code>变量在<code>32位</code>机上写的原子性</p></blockquote><p>这里我们再回头看看前面的单例的例子</p><p>①分配对象所需的空间 objRef=allocate(SingleObjectPlus.class);</p><p>②初始化引用的对象 invokeConstructor(objRef);</p><p>③设置singletonObjectPlus指向刚分配的内存地址 singletonObjectPlus=objRef</p><p>虽然这里volatile子保证了子操作③的原子性 但是①②操作只涉及到了局部变量没有涉及到共享变量，由于内存屏障的作用①②操作不可能重排序到③之后，所以可以保证在得到返回之前对象一定已经初始化完毕了，不会出现没初始化完毕就返回的情况</p><p><strong>Volatile读操作和内存屏障</strong></p><p><img alt="volatile变量的读操作" data-src="http://static.imlgw.top///20190428/tJcC98zgp532.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>🔔 读线程对于<code>volatile变量的读操作</code>会产生类似于<code>获得锁</code>的效果。读volatile变量前会先<code>刷新处理器缓存</code>从主存或其他处理器缓存中<code>同步</code>该数据</p><blockquote><p>volatile只能保证读线程读到共享变量的相对新值，对于引用类型和数组类型的并不能保证实例的字段或数组的元素的相对新值，只是保障了<code>引用地址</code>的相对新值(<code>相对新值</code>表示读的过程中其他线程有可能更改了这个值，对应的还有<code>最新值</code>，读的过程中写线程无法更改)</p></blockquote><h3 id="Volatile变量的开销-amp-场景"><a href="#Volatile变量的开销-amp-场景" class="headerlink" title="Volatile变量的开销&场景"></a>Volatile变量的开销&场景</h3><p><strong>开销</strong></p><p>volatile变量的读写都不会导致上下文切换，所以开销比锁要小，从上面的介绍中可以看出 写一个voaltile会使该操作和该操作前的所有写操作对后面的线程是可见的，所以它的成本会比普通变量大一些但是比锁小一点，读一个volatile变量也会比锁小，但是会比普通变量大因为变量都会从内存或其他处理器高速缓存中去拿无法直接从寄存器中去拿，但是也很快了。</p><p><strong>应用场景</strong></p><p>🔶 使用volatile变量作为状态标志位，应用程序的某个状态由一个线程设置，其他线程会读取该状态作为后面操作的依据，此时用volatile作为同步机制好处就是一个线程可以及时”通知”另一个线程某种事件(例如掉线重连)而避免使用锁造成较大开销</p><p>🔶使用volatile保障可见性，一个线程更新了共享变量其他线程无需加锁也可以看到该更新</p><p>🔶volatile bean模式（下面是我的个人理解可以直接跳过）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String firstName,String lastName,<span class="keyword">int</span> age)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>{ <span class="keyword">return</span> firstName; }</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>{ <span class="keyword">return</span> lastName; }</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{ <span class="keyword">return</span> age; }</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>{ </span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>{ </span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{ </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>关于这个场景的我理解的就是会保证类似volatile Person  preson=new Person(xx,xx,xx,xx);这样的操作具有可见性或者说完整性，不会初始化一半就返回对象要么为null要么就初始化完毕，类似于上面的提到的dcl单例的例子。</p><p>🔶简易读写锁</p><p>允许读线程读取的时候写线程进行更新，典型的例子就是实现一个计数器如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{ <span class="keyword">return</span> value; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>想了解更多去看看IBM这篇文章<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">Java 理论与实践:正确使用 Volatile 变量</a></p><h2 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h2><p><img alt="可见性的例子" data-src="http://static.imlgw.top///20190428/4CYfervOyHH3.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>上面可见性的问题，图中的代码如果循环里面加上图中框内类似的代码，会发现即使共享变量上面不加<strong>volatile</strong>程序依然可以正常退出，上面出现的死循环并没有出现 (我的JDK版本是1.8，不同的版本情况可能不一样)，那是不是说这些操作也达到了保证可见性的作用呢？其实仔细分析这几行代码，后面三种都会刷新或冲刷处理器缓存(print里面也是加锁了的)，我一开始觉得可能是这个原因导致的，但是按道理应该是只会保证同步块内部的变量的可见性，但是sleep并没有加锁，是个本地方法为啥还是会导致这样的结果呢？这里我也不想深究了，我感觉也没啥必要了，具体的场景下该加<strong>volatile</strong>还是老老实实加<strong>volatile</strong>，如果继续探究下可以看下<a href="http://www.importnew.com/19434.html" target="_blank" rel="noopener">这篇文章 </a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>《Java多线程编程实战指南：核心篇》</p></li><li><p><a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">javazejian</a></p></li><li><p>…</p></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS与原子变量</title>
      <link href="/2019/04/22/cas-yu-yuan-zi-bian-liang/"/>
      <url>/2019/04/22/cas-yu-yuan-zi-bian-liang/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><em>这个<strong>CAS</strong>可不是单点登陆的那个CAS😄!!!</em></p><blockquote><p>CAS（Compare-and-Swap），是对一种处理器指令的称呼，很多Java多线程相关的类库的最终实现都会借助CAS</p></blockquote><p>​    从所周知，类似<code>i++</code>自增这样的操作并不是原子的，是一个<code>read-modify-write</code>的操作 ，如果要保证这种操作的原子性按照之前的做法可以使用<code>synchronized</code>内部锁来解决，但是这样似乎有点太小题大做了，锁确实可以解决这个问题，但是前面的文章也提到过，锁是很消耗性能的，并不是最好的做法，比较好的做法就是<strong>CAS</strong>，它能够将这些操作转换为原子操作。</p><p>​    Compare and Swap，比较并交换，顾名思义是一种<code>if-then-act</code>的操作，而这个操作的原子性由<code>处理器</code>保证(硬件锁)，如果一个线程想要将变量V的值由A变为B，借助CAS就会产生类似下面代码的作用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">comapreAndSet</span><span class="params">(Variable V,Object A,Objext B)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(V.get()==A){ <span class="comment">//判断是否和当前V的值相同（是否被修改）</span></span><br><span class="line">        V.set(B);   <span class="comment">//没被修改就更新</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//被修改过就直接return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样一来就是先下手为强了，当你最先修改了V的值，后面的所有线程都会直接失败，所以实际上也是一种快速失败策略，当然你也可以尝试再次请求直到成功为止。</p><h2 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h2><p>_原子变量类_是基于CAS实现的一组保证共享变量<code>read-modify-write</code>操作(例如自增)原子性的工具类</p><table><thead><tr><th>分组</th><th>类</th></tr></thead><tbody><tr><td>基础数据类型</td><td>AtomicInteger，AtomicLong，AtomicBoolean</td></tr><tr><td>数组类</td><td>AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</td></tr><tr><td>字段更新器</td><td>AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater</td></tr><tr><td>引用型</td><td>AtomicReference，AtomicStampedReference，AtomicMarkableReference</td></tr></tbody></table><p>关于怎么使用就不多介绍，API上都写的明明白白，这里有个地方需要注意，数组类单纯的GET/SET并不是原子操作。</p><h3 id="利用CAS写一个锁"><a href="#利用CAS写一个锁" class="headerlink" title="利用CAS写一个锁"></a>利用CAS写一个锁</h3><p><a href="http://imlgw.top/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/">前面的文章</a>  利用内部锁实现过一个<strong>BooleanLock</strong>，这里利用CAS再实现一个简易的锁</p><p><strong>getLockException</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetLockException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetLockException</span><span class="params">(String message)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetLockException</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>CASLock</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger value = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread lockedThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trylock</span><span class="params">()</span> <span class="keyword">throws</span> GetLockException </span>{</span><br><span class="line">        <span class="keyword">boolean</span> success = value.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!success) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GetLockException(<span class="string">"获得锁失败"</span>);</span><br><span class="line">        }</span><br><span class="line">        lockedThread = Thread.currentThread();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == value.get()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (lockedThread == Thread.currentThread()) {</span><br><span class="line">            <span class="comment">//解铃还须系铃人</span></span><br><span class="line">            <span class="keyword">boolean</span> success = value.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 释放了锁"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实挺简单的，值得注意的地方就是释放锁的时候别忘了判断是不是当前线程加的锁，解铃还须系铃人😂</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><blockquote><p>从所周知，CAS成立的条件就是共享变量当前值和当前线程所提供的旧值相同，我们就可以认为这个变量没有被修改过，那么问题来了，对于一个共享变量<strong>V</strong>，如果当前线程看到它的时候它的值是A，当它想执行CAS修改这个变量的时候，另一个线程将<strong>V</strong>的值从A–>B–>A，那么这时当前线程再来执行CAS的时候，是否可以认为变量<strong>V</strong>没有被修改过呢？这里执行肯定是会成功的，但是这样结果是否可以接受呢 ?</p></blockquote><h4 id="无法接受的例子"><a href="#无法接受的例子" class="headerlink" title="无法接受的例子"></a>无法接受的例子</h4><p><img alt="mark" data-src="http://static.imlgw.top///20190423/vakfPgUQChGb.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>上图为用<strong>单链表</strong>实现的栈结构，若T2先抢到了执行权，将A，B弹出栈，然后依次<code>push</code>了D，C，A，然后T1执行，利用CAS，head.compareAndSet(A，B)，执行成功，栈顶变为B，然而B就是个孤儿节点，这样一来C，D节点就被莫名其妙被丢掉了这显然是有问题的</p><h4 id="如何解决ABA问题"><a href="#如何解决ABA问题" class="headerlink" title="如何解决ABA问题"></a>如何解决ABA问题</h4><p>其实ABA问题并非完全无法接受，要考虑具体的场景，当然Java中也提供了解决的方案:</p><p><code>AtomicStampedReference</code> 这个类看名字就知道是带了戳的，带了一个类似版本号的东西，直接上源码吧。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An {<span class="doctag">@code</span> AtomicStampedReference} maintains an object reference</span></span><br><span class="line"><span class="comment"> * along with an integer "stamp", that can be updated atomically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <p>Implementation note: This implementation maintains stamped<br><span class="line"><span class="comment"> * references by creating internal objects representing "boxed"</span></span><br><span class="line"><span class="comment"> * [reference, integer] pairs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea 真正的大师</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <v> The type of object referred to by this reference</v></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span><<span class="title">V</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span><<span class="title">T</span>> </span>{</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">static</span> <t> <span class="function">Pair<t> <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </t></span>{</t></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair<t>(reference, stamp);</t></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair<v> pair;</v></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>{</span><br><span class="line">        pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value of the reference.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value of the reference</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> pair.reference;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> pair.stamp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] stampHolder)</span> </span>{</span><br><span class="line">        Pair<v> pair = <span class="keyword">this</span>.pair;</v></span><br><span class="line">        stampHolder[<span class="number">0</span>] = pair.stamp;</span><br><span class="line">        <span class="keyword">return</span> pair.reference;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> newStamp)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> compareAndSet(expectedReference, newReference,</span><br><span class="line">                             expectedStamp, newStamp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value of both the reference and stamp</span></span><br><span class="line"><span class="comment">     * to the given update values if the</span></span><br><span class="line"><span class="comment">     * current reference is {<span class="doctag">@code</span> ==} to the expected reference</span></span><br><span class="line"><span class="comment">     * and the current stamp is equal to the expected stamp.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedReference the expected value of the reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newReference the new value for the reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedStamp the expected value of the stamp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStamp the new value for the stamp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>{</span><br><span class="line">        Pair<v> current = pair;</v></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference && <span class="comment">//期望值和当前值相等</span></span><br><span class="line">            expectedStamp == current.stamp &&<span class="comment">//期望的戳和当前的戳一致</span></span><br><span class="line">            ((newReference == current.reference && <span class="comment">//新的值是不是和当前的值一样</span></span><br><span class="line">              newStamp == current.stamp) ||<span class="comment">//新的戳是不是和当前的戳一样</span></span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); <span class="comment">//如果不一样就利用CAS设置新值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span> </span>{</span><br><span class="line">        Pair<v> current = pair;</v></span><br><span class="line">        <span class="keyword">if</span> (newReference != current.reference || newStamp != current.stamp)</span><br><span class="line">            <span class="keyword">this</span>.pair = Pair.of(newReference, newStamp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptStamp</span><span class="params">(V expectedReference, <span class="keyword">int</span> newStamp)</span> </span>{</span><br><span class="line">        Pair<v> current = pair;</v></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &&</span><br><span class="line">            (newStamp == current.stamp ||</span><br><span class="line">             casPair(current, Pair.of(expectedReference, newStamp)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics 底层调用unsafe的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> pairOffset =</span><br><span class="line">        objectFieldOffset(UNSAFE, <span class="string">"pair"</span>, AtomicStampedReference<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//cas设置新值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair<v> cmp, Pair<v> val)</v></v></span> </span>{</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(sun.misc.Unsafe UNSAFE,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String field, Class<!--?--> klazz)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.objectFieldOffset(klazz.getDeclaredField(field));</span><br><span class="line">        } <span class="keyword">catch</span> (NoSuchFieldException e) {</span><br><span class="line">            <span class="comment">// Convert Exception to corresponding Error</span></span><br><span class="line">            NoSuchFieldError error = <span class="keyword">new</span> NoSuchFieldError(field);</span><br><span class="line">            error.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></p></span></span></pre></td></tr></tbody></table></figure></div><p>这里删掉了部分注释， 可以看到里面封装了一个<code>Pair</code>里面有对象的引用和一个戳，在进行CAS的时候会判断<code>期望的引用</code>（传进来的引用）和<code>当前实际的引用</code>是不是一致，<code>期望的戳</code>（传进来的戳）和<code>当前实际的戳</code>是不是一致的，不一致就会直接<code>fail</code>，关键的CAS代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>{</span><br><span class="line">        Pair<v> current = pair;</v></span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">            expectedReference == current.reference && <span class="comment">//期望值和当前值相等</span></span><br><span class="line">            expectedStamp == current.stamp &&<span class="comment">//期望的戳和当前的戳一致</span></span><br><span class="line">            ((newReference == current.reference && <span class="comment">//新的值是不是和当前的值一样</span></span><br><span class="line">              newStamp == current.stamp) ||<span class="comment">//新的戳是不是和当前的戳一样</span></span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); <span class="comment">//如果不一样就利用CAS设置新值</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试AtomicStampedReference</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicRefStampedTest</span> </span>{</span><br><span class="line">   <span class="keyword">static</span> AtomicStampedReference<integer> reference=<span class="keyword">new</span> AtomicStampedReference<>(<span class="number">100</span>,<span class="number">0</span>);</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//第一个线程进行ABA操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">"t1 "</span>+reference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, reference.getStamp(), reference.getStamp()+<span class="number">1</span>));</span><br><span class="line">                System.out.println(reference.getStamp()+<span class="string">","</span>+reference.getReference());</span><br><span class="line">                System.out.println(<span class="string">"t1 "</span>+ reference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>,reference.getStamp() , reference.getStamp()+<span class="number">1</span>));</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个线程等待第一个线程执行完</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">int</span> stamp = reference.getStamp();</span><br><span class="line">                <span class="comment">//假设执行到这里发生上下文切换</span></span><br><span class="line">                System.out.println(<span class="string">"Before sleep:stamp="</span>+stamp);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="string">"After sleep:stamp="</span>+reference.getStamp());</span><br><span class="line">                <span class="keyword">boolean</span> b = reference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Before sleep:stamp=0</span></span><br><span class="line"><span class="comment">t1 true</span></span><br><span class="line"><span class="comment">1,101</span></span><br><span class="line"><span class="comment">t1 true</span></span><br><span class="line"><span class="comment">After sleep:stamp=2</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></tbody></table></figure></div><p>结果肯定是t2执行失败了，毕竟戳不一样了，就算引用一样也没用。</p><h4 id="小插曲-Integer缓存"><a href="#小插曲-Integer缓存" class="headerlink" title="小插曲(Integer缓存)"></a>小插曲(Integer缓存)</h4><p>这里一开始发生了一个小插曲，首先这里是的引用类型是 <code>Integer</code>类型的，然后我在进行CAS的时候从100—>200 ,然后又从200–>100，可能细心的朋友已经知道啥问题了，后面的从200–>100会失败，为啥？这个200和前面的200不是一个对象，引用不一样，那为啥101就可以呢？对，Integer有一个缓冲池，大小在-128–127之间的数，可以直接从缓冲池中拿，我开始在这里纠结了好一会儿😂</p><h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><p>如果我们只需要某个类里的某个字段，也就是说让普通的变量也享受原子操作，可以使用原子更新字段类，如在某些时候由于项目前期考虑不周全，项目需求又发生变化，使得某个类中的变量需要执行多线程操作，由于该变量多处使用，改动起来比较麻烦，而且原来使用的地方无需使用线程安全，只要求新场景需要使用时，可以借助原子更新器处理这种场景，Java中提供了几种字段更新器<code>AtomicIntegerFieldUpdater</code>，<code>AtomicLongFieldUpdater</code>，<code>AtomicReferenceFieldUpdater</code>，看名字就知道是对应啥的</p><h4 id="AtomicIntegerFieldUpdater测试"><a href="#AtomicIntegerFieldUpdater测试" class="headerlink" title="AtomicIntegerFieldUpdater测试"></a>AtomicIntegerFieldUpdater测试</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(TestUpdate.class, "num");</span><br><span class="line">        TestUpdate testUpdate = <span class="keyword">new</span> TestUpdate();</span><br><span class="line">        Stream.of(<span class="string">"t1"</span>, <span class="string">"t2"</span>, <span class="string">"t3"</span>, <span class="string">"t4"</span>, <span class="string">"t5"</span>).forEach(s -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < MAX; i++) {</span><br><span class="line">                    System.out.println(updater.getAndIncrement(testUpdate));</span><br><span class="line">                }</span><br><span class="line">            }, s).start();</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUpdate</span> </span>{</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> num;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样就保证了Integer字段自增操作的原子性，另外两个与之类似。</p><p><strong>需要注意的地方</strong></p><ul><li><p>操作的字段不能是static类型。</p></li><li><p>操作的字段不能是final类型的，因为final根本没法修改。</p></li><li><p>字段必须是volatile修饰的，也就是数据本身是读一致的。</p></li><li><p>属性必须对当前的Updater所在的区域是可见的，也就是说无论何时都应该保证操作类与被操作类间的可见性。</p></li></ul><p><img alt="mark" data-src="http://static.imlgw.top///20190430/hIuzU4rePaAe.png?imageslim" src="/img/loading.gif" class="lazyload"></p><blockquote><p>使用字段更新器比起直接使用原子类要节约内存，但是操作起来不方便</p></blockquote><h2 id="Unsafe双刃剑"><a href="#Unsafe双刃剑" class="headerlink" title="Unsafe双刃剑"></a>Unsafe双刃剑</h2><p><strong>Unsafe</strong>类，看名字就知道不安全，并不是它写的不安全，而是用起来不安全，因为它可以像c/c++一样去操作内存地址，<strong>unsafe</strong>里面的所有方法都是<strong>native</strong>的，底层都是c/c++实现的，直接与操作系统底层交互，上面CAS执行也依赖于<strong>unsafe</strong>类中的方法，其实整个并发包里的类都依赖于<strong>unsafe</strong>，但是官方并不建议用户使用这个类</p><ul><li>Unsafe有可能在未来的Jdk版本移除或者不允许Java应用代码使用，这一点可能导致使用了Unsafe的应用无法运行在高版本的Jdk</li><li>Unsafe的不少方法中必须提供原始地址(内存地址)和被替换对象的地址，偏移量要自己计算，一旦出现问题就是JVM崩溃级别的异常，会导致整个JVM实例崩溃，表现为应用程序直接崩掉。</li><li>Unsafe提供的直接内存访问的方法中使用的内存不受JVM管理(无法被GC)，需要手动管理，一旦出现疏忽很有可能成为内存泄漏的源头。</li></ul><h3 id="获取Unsafe"><a href="#获取Unsafe" class="headerlink" title="获取Unsafe"></a>获取Unsafe</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//获取Unsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>{</span><br><span class="line">    Field f = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe)f.get(<span class="keyword">null</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h3><p>Java中的CAS实现调用的就是三个本地方法，第一个参数代表的就是实例对象，第二个参数代表需要CAS字段在该实例上的偏移量（不用自己计算，Unsafe提供了方法计算偏移量），第三个参数就是期望值，最后一个参数就是更新的值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></tbody></table></figure></div><h3 id="利用Unsafe自己写一个原子Counter"><a href="#利用Unsafe自己写一个原子Counter" class="headerlink" title="利用Unsafe自己写一个原子Counter"></a>利用Unsafe自己写一个原子Counter</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CASCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CASCounter</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>{</span><br><span class="line">        unsafe = getUnsafe();</span><br><span class="line">        <span class="comment">//获取counter字段的内存偏移量</span></span><br><span class="line">        offset= unsafe.objectFieldOffset(CASCounter.class.getDeclaredField("counter"));</span><br><span class="line">        System.out.println(offset);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> offset;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>{</span><br><span class="line">        Field f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe)f.get(<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> current=counter;</span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapLong(<span class="keyword">this</span>,offset,current,current+<span class="number">1</span>)){</span><br><span class="line">            current=counter;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Unsafe的骚操作"><a href="#Unsafe的骚操作" class="headerlink" title="Unsafe的骚操作"></a>Unsafe的骚操作</h3><p><strong>绕过构造器创建对象</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFooTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,InstantiationException, NoSuchFieldException </span>{</span><br><span class="line">        Unsafe unsafe = UnsafeTest.getUnsafe();</span><br><span class="line">        <span class="comment">//绕过构造器创建对象</span></span><br><span class="line">        Simple simple = (Simple) unsafe.allocateInstance(Simple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(simple.get()); <span class="comment">//null</span></span><br><span class="line">        System.out.println(simple.getClass().getClassLoader());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> String a = <span class="string">"a"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Simple</span><span class="params">()</span> </span>{</span><br><span class="line">            a = <span class="string">"new"</span>;</span><br><span class="line">            System.out.println(<span class="string">"============== "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">static</span> {</span><br><span class="line">            System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>修改字段在内存中的值</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFooTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, NoSuchFieldException </span>{</span><br><span class="line">        Unsafe unsafe = UnsafeTest.getUnsafe();</span><br><span class="line">        Permission permission = <span class="keyword">new</span> Permission();</span><br><span class="line">        permission.doSth();</span><br><span class="line">        <span class="comment">//通过反射也可以做到，但是unsafe直接是到内存地址中将值修改了</span></span><br><span class="line">        Field access_allow = permission.getClass().getDeclaredField(<span class="string">"ACCESS_ALLOW"</span>);</span><br><span class="line">        <span class="comment">//获取字段再对象中的内存偏移量，可以简单理解为指针（内存地址）</span></span><br><span class="line">        unsafe.putLong(permission,unsafe.objectFieldOffset(access_allow),-<span class="number">1</span>);</span><br><span class="line">        permission.doSth();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Permission</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ACCESS_ALLOW = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAllow</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span>  ACCESS_ALLOW==-<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (isAllow()) {</span><br><span class="line">            System.out.println(<span class="string">"i am workind"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>defindClass加载类文件</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFooTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException </span>{</span><br><span class="line">        Unsafe unsafe = UnsafeTest.getUnsafe();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = loadClassContent();</span><br><span class="line">        Class<!--?--> aClass = unsafe.defineClass(<span class="keyword">null</span>, bytes, <span class="number">0</span>, bytes.length, ClassLoader.getSystemClassLoader(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> get = (<span class="keyword">int</span>) aClass.getMethod(<span class="string">"get"</span>).invoke(aClass.newInstance(), <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(get);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将class字节码加载到内存中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] loadClassContent() {</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\ClassLoaderTest\\Res.class"</span>);</span><br><span class="line">        FileInputStream stream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            stream = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">             bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            stream.read(bytes);</span><br><span class="line">            stream.close();</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>将编译好的class文件放到对应的目录下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Res</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Res</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.i=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>结果</strong>，是不是很牛皮？🐂🍺是🐂🍺但是这个玩意尽量的别用。。</p><p><img alt="mark" data-src="http://static.imlgw.top/blog/20190720/zLJJUhQ6GAdc.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>Unsafe</strong>里面的方法还有很多这里就不都列举了，毕竟暂时还用不到，如果想了解更多可以看看这几篇文章</p><ul><li><p><a href="https://www.cnblogs.com/throwable/p/9139947.html" target="_blank" rel="noopener">JAVA中神奇的双刃剑–Unsafe</a></p></li><li><p><a href="https://www.zhihu.com/question/29266773?sort=created" target="_blank" rel="noopener">R大关于Unsafe的使用建议</a></p></li><li><p><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener">Java魔法类：Unsafe应用解析</a></p></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之设计模式</title>
      <link href="/2019/04/09/java-duo-xian-cheng-li-mian-de-she-ji-mo-shi/"/>
      <url>/2019/04/09/java-duo-xian-cheng-li-mian-de-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p> 观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程</p></blockquote><p><strong>观察者接口</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>{</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observer</span><span class="params">(Subject subject)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.subject=subject;</span><br><span class="line">        subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>观察者1</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(subject);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Binarry String :"</span>+ Integer.toBinaryString(subject.getState()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>观察者2</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalOberver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OctalOberver</span><span class="params">(Subject subject)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(subject);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Octal String:"</span>+Integer.toOctalString(subject.getState()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>被观察者</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>{</span><br><span class="line">    <span class="comment">//观察者们</span></span><br><span class="line">    <span class="keyword">private</span>  List<observer> observers = <span class="keyword">new</span> ArrayList<>();</observer></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>{</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(state==<span class="keyword">this</span>.state){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.state=state;</span><br><span class="line">        notifyAllObserver();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//通知所有观察者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title">notifyAllObserver</span><span class="params">()</span></span>{</span><br><span class="line">        observers.stream().forEach(Observer::update);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverCLi</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Subject subject=<span class="keyword">new</span> Subject();</span><br><span class="line">        BinaryObserver binary=<span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line">        OctalOberver octalOberver = <span class="keyword">new</span> OctalOberver(subject);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        subject.setState(<span class="number">12</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="读写锁分离模式"><a href="#读写锁分离模式" class="headerlink" title="读写锁分离模式"></a>读写锁分离模式</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readingR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitingR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writingW = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitingW = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>{</span><br><span class="line">        <span class="keyword">this</span>.waitingR++;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//如果有线程在写就不能读</span></span><br><span class="line">            <span class="keyword">while</span> (writingW > <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.readingR++;</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">this</span>.waitingR--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readUnlock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>{</span><br><span class="line">        <span class="keyword">this</span>.readingR--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>{</span><br><span class="line">        <span class="keyword">this</span>.waitingW++;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (readingR><span class="number">0</span>||writingW><span class="number">0</span>){</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.writingW++;</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">this</span>.waitingW--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeUnlock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>{</span><br><span class="line">        <span class="keyword">this</span>.writingW--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>只有读的时候不加锁，其他的时候加锁，在读的操作多于写的操作时，效率提升明显。</p><h2 id="不可变对象设计模式"><a href="#不可变对象设计模式" class="headerlink" title="不可变对象设计模式"></a>不可变对象设计模式</h2><p>这个设计模式还是很重要也很常见的，<code>不可变</code>顾名思义，一个对象在被创建后对象所有的状态和属性都在其生命周期内都不会发生任何变化。</p><blockquote><p>不可变对象一定是线程安全的(里面的任何属性或者应用类型的都不能被修改)，可变对象不一定是线程安全的(SrtingBuffer)。J2EE里面，Servlet就不是线程安全的，struts1的Action也不是线程安全的。</p></blockquote><p>通常来说，创建不可变类原则有以下几条：</p><p>① 所有成员变量必须是<code>private</code></p><p>② 最好同时用<code>final</code>修饰(非必须)</p><p>③ 不提供能够修改原有对象状态的方法</p><ul><li><p>最常见的方式是不提供setter方法</p></li><li><p>如果提供修改方法，需要新创建一个对象，并在新创建的对象上进行修改</p></li></ul><p>④ 通过构造器初始化所有成员变量，引用类型的成员变量必须进行深拷贝(deep copy)</p><p>⑤ getter方法不能对外泄露this引用以及成员变量的引用</p><p>⑥ 最好不允许类被继承(非必须)</p><p>　　JDK中提供了一系列方法方便我们创建不可变集合，如：</p><p><code>Collections.unmodifiableList(List<!--? extends T--> list)</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="comment">//定义成final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">final</span> String name,<span class="keyword">final</span> String address)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>虽然说是不可变对象，但是其实通过反射等方法还是可以改变的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>{</span><br><span class="line">        <span class="comment">/*String s="Hello";</span></span><br><span class="line"><span class="comment">        String s1=s.replace("l","K");</span></span><br><span class="line"><span class="comment">        System.out.println(s.hashCode());</span></span><br><span class="line"><span class="comment">        System.out.println(s1.hashCode());*/</span></span><br><span class="line">        String s = <span class="string">"Hello World"</span>;</span><br><span class="line">        System.out.println(<span class="string">"s = "</span> + s);<span class="comment">//Hello World</span></span><br><span class="line"><span class="comment">//String类里面的char[]</span></span><br><span class="line">        Field valueFieldOfString = String.class.getDeclaredField("value");</span><br><span class="line">        valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">        value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">        System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello_World</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Future设计模式-异步"><a href="#Future设计模式-异步" class="headerlink" title="Future设计模式(异步)"></a>Future设计模式(异步)</h2><p><code>Future</code>接口</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span><<span class="title">T</span>> </span>{</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>FutureTask</code>接口</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FutureTask</span><<span class="title">T</span>> </span>{</span><br><span class="line">    <span class="function">T <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>AsynFuture</code>异步</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsynFuture</span><<span class="title">T</span>> <span class="keyword">implements</span> <span class="title">Future</span><<span class="title">T</span>> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(T result)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            <span class="keyword">this</span>.done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//完成任务通知调用者</span></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">while</span> (!done) {</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>FutureService</code>连接<code>Future</code>和<code>FutureTask</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <t> <span class="function">Future<t> <span class="title">submit</span><span class="params">(<span class="keyword">final</span> FutureTask<t> task)</t></span> </t></span>{</t></span><br><span class="line">        AsynFuture<t> asynFuture = <span class="keyword">new</span> AsynFuture<>();</t></span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            T result = task.call();</span><br><span class="line">            asynFuture.done(result);</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">return</span> asynFuture;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//java8 回调 callback</span></span><br><span class="line">    <span class="keyword">public</span> <t> <span class="function">Future<t> <span class="title">submit</span><span class="params">(<span class="keyword">final</span> FutureTask<t> task, <span class="keyword">final</span> Consumer<t> consumer)</t></t></span> </t></span>{</t></span><br><span class="line">        AsynFuture<t> asynFuture = <span class="keyword">new</span> AsynFuture<>();</t></span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            T result = task.call();</span><br><span class="line">            asynFuture.done(result);</span><br><span class="line">            consumer.accept(result);</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">return</span> asynFuture;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>测试<code>Future</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncInvoker</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line"></span><br><span class="line">        FutureService futureService = <span class="keyword">new</span> FutureService();</span><br><span class="line">        Future<string> submit = futureService.submit(() -> {</string></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">10000l</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"FINISH"</span>;</span><br><span class="line">        },System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">        System.out.println(<span class="string">" do other thing."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread.sleep(<span class="number">10000l</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"FINISH"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>Future   ->未来的票据</p><p>FutureTask   ->实际执行的任务</p><p>FutureService  ->桥接Future和FutureTask</p></blockquote><h2 id="Guarded-Suspension设计模式"><a href="#Guarded-Suspension设计模式" class="headerlink" title="Guarded Suspension设计模式"></a>Guarded Suspension设计模式</h2><p><code>保护性暂挂模式</code></p><p>Guarded是被守护的意思。Suspension是暂停的意思，Guarded Suspension模式通过让线程等待来保证实例的安全性。</p><blockquote><p>核心思想: 如果某个线程执行特定的操作前需要满足一定的条件，则在该条件未满足时将线程暂停运行（即暂挂线程，使其处于等待（waiting）状态，直到该条件满足时才继续运行）</p></blockquote><p><strong>Request对象</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>RequestQueue</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList<request> queue = <span class="keyword">new</span> LinkedList<>();</request></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">getRequest</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) {</span><br><span class="line">            <span class="keyword">while</span> (queue.size() <= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">//队列为空等一下</span></span><br><span class="line">                    queue.wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            Request request = queue.removeFirst();</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) {</span><br><span class="line">            queue.addLast(request);</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Server</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue queue)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!closed) {</span><br><span class="line">            Request request = queue.getRequest();</span><br><span class="line">            <span class="comment">//get可能会返回null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == request) {</span><br><span class="line">                System.out.println(<span class="string">"Received the empty request."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"Server ->"</span> + request.getValue());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="comment">//打断后直接return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Client</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sendValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue queue, String sendValue)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.sendValue = sendValue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"Client -> request "</span> + sendValue);</span><br><span class="line">            <span class="comment">//客户端发送请求</span></span><br><span class="line">            queue.putRequest(<span class="keyword">new</span> Request(sendValue));</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspensionClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">final</span> RequestQueue queue = <span class="keyword">new</span> RequestQueue();</span><br><span class="line">        <span class="keyword">new</span> ClientThread(queue, <span class="string">"Shaw"</span>).start();</span><br><span class="line">        ServerThread serverThread = <span class="keyword">new</span> ServerThread(queue);</span><br><span class="line">        serverThread.start();</span><br><span class="line">        <span class="comment">//serverThread.join(); join住了后面还咋close？？？</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        serverThread.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>线程局部变量，线程保险箱，以<code>Thread</code>作为<code>key</code></p><blockquote><p>This class provides <code>thread-local variables</code>. These variables differ from their normal counterparts in that each thread that accesses one (via its <code>get</code> or <code>set</code> method) has its own, independently initialized copy of the variable.</p></blockquote><p>模拟<code>ThreadLocal</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalSimulator</span><<span class="title">T</span>> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map<thread,t> threadMap=<span class="keyword">new</span> HashMap<>();</thread,t></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>{</span><br><span class="line">        Thread currentThread=Thread.currentThread();</span><br><span class="line">        <span class="keyword">synchronized</span> (threadMap){</span><br><span class="line">            threadMap.put(currentThread,t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>{</span><br><span class="line">        Thread currentThread =Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(threadMap.get(currentThread)==<span class="keyword">null</span>){</span><br><span class="line">             threadMap.put(currentThread,initVal());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> threadMap.get(currentThread);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initVal</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Balking设计模式"><a href="#Balking设计模式" class="headerlink" title="Balking设计模式"></a>Balking设计模式</h2><blockquote><p>核心思想：当不再适合或者没有必要进行这个操作时，就直接放弃进行这个操作而直接返回，不需要就算了</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalkingData</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BalkingData</span><span class="params">(String fileName, String content, <span class="keyword">boolean</span> changed)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.changed = changed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String newContent)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.content = newContent;</span><br><span class="line">        <span class="keyword">this</span>.changed = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="keyword">if</span> (!changed) {</span><br><span class="line">            <span class="comment">//顾客没有服务请求，那么放弃提供服务操作，直接返回。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        doSave();</span><br><span class="line">        <span class="keyword">this</span>.changed = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSave</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" call  do save content"</span>);</span><br><span class="line">        <span class="keyword">try</span>(Writer writer = <span class="keyword">new</span> FileWriter(fileName, <span class="keyword">true</span>)) {</span><br><span class="line">            writer.write(content);</span><br><span class="line">            writer.write(<span class="string">"\n"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>CustomerThread</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BalkingData balkingData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerThread</span><span class="params">(BalkingData balkingData)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Customer"</span>);</span><br><span class="line">        <span class="keyword">this</span>.balkingData = balkingData;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            balkingData.save();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">20</span>; i++) {</span><br><span class="line">                balkingData.change(<span class="string">"No."</span> + i);</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                balkingData.save();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>WaiterThread</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaiterThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BalkingData balkingData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaiterThread</span><span class="params">(BalkingData balkingData)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Waiter"</span>);</span><br><span class="line">        <span class="keyword">this</span>.balkingData = balkingData;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">200</span>; i++) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                balkingData.save();</span><br><span class="line">                Thread.sleep(<span class="number">1_000L</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="CountDown设计模式"><a href="#CountDown设计模式" class="headerlink" title="CountDown设计模式"></a>CountDown设计模式</h2><p><strong>CountDown</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDown</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDown</span><span class="params">(<span class="keyword">int</span> total)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>){</span><br><span class="line">            <span class="keyword">this</span>.counter++;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>){</span><br><span class="line">            <span class="keyword">while</span> (counter!=total){</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>测试</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKCountDown</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">//JDK的CountDown</span></span><br><span class="line">        <span class="comment">//final CountDownLatch latch=new CountDownLatch(5);</span></span><br><span class="line">        <span class="keyword">final</span> CountDown latch=<span class="keyword">new</span> CountDown(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"准备多线程处理任务"</span>);</span><br><span class="line">        <span class="comment">//the first phase</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>,<span class="number">5</span>).forEach(i->{</span><br><span class="line">            <span class="keyword">new</span> Thread(()->{</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" is working"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                latch.down();</span><br><span class="line">            },String.valueOf(i)).start();</span><br><span class="line">        });</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="comment">//the second phase</span></span><br><span class="line">        System.out.println(<span class="string">"多线程任务全部结束，准备第二阶段任务"</span>);</span><br><span class="line">        System.out.println(<span class="string">"........"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Finish"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="Double-check"><a href="#Double-check" class="headerlink" title="Double check"></a>Double check</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObjectPlus</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span>  SingletonObjectPlus singletonObjectPlus =<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObjectPlus <span class="title">getSingletonObject3</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(singletonObjectPlus==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">synchronized</span>(SingletonObject<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">            <span class="keyword">if</span>(singletonObjectPlus==<span class="keyword">null</span>){</span><br><span class="line">                singletonObjectPlus= <span class="keyword">new</span> SingletonObjectPlus();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     <span class="keyword">return</span> singletonObjectPlus;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>这种方式在实例对象上要加上 <code>volatile</code>，避免实例对象没有初始化完成就返回</p></blockquote><h3 id="InstanceHolder"><a href="#InstanceHolder" class="headerlink" title="InstanceHolder"></a>InstanceHolder</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleGraceful</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleGraceful</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//private静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>{</span><br><span class="line">        <span class="comment">//只会被初始化一次</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingleGraceful instance=<span class="keyword">new</span> SingleGraceful();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleGraceful <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> SingleGraceful.InstanceHolder.instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>JVM只会为static变量分配一次内存，也就是只会初始化一次，而内部类不会在其外部类被加载的同时被加载，所以这也是一种很简洁很优秀的单例</p><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleGraceful2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleGraceful2</span><span class="params">()</span> </span>{}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton {</span><br><span class="line">        INSTANCE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingleGraceful2 instance;</span><br><span class="line"></span><br><span class="line">        Singleton() {</span><br><span class="line">            instance = <span class="keyword">new</span> SingleGraceful2();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingleGraceful2 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleGraceful2 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li>枚举类构造函数是<code>private</code>类型的</li><li>枚举类的域(field)(<code>INSTANCE</code>)其实是相应的enum类型(<code>Singleton</code>)的一个静态实例对象，所以只会被初始化一次，构造器也只会被调用一次</li><li>枚举单例可以防止<code>反序列化</code> ，<code>反射</code>，<code>克隆</code>对单例的破坏，所以是一种极其优秀的单例实现。</li></ul><blockquote><p>这里其实还有很多没有介绍出来，设计模式这些东西没有实际的场景去用确实难以体会到它的精髓，需要慢慢的积累经验才行。</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程基础</title>
      <link href="/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/"/>
      <url>/2019/04/07/java-duo-xian-cheng-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="1-线程与进程区别"><a href="#1-线程与进程区别" class="headerlink" title="1.线程与进程区别"></a>1.线程与进程区别</h2><p>每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。</p><p>使用线程可以把占据时间长的程序中的任务放到后台去处理，程序的运行速度可能加快，在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。</p><p>如果有大量的线程,会影响性能，因为操作系统需要在它们之间切换，更多的线程需要更多的内存空间，线程的中止需要考虑其对程序运行的影响。通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。</p><p>总结:进程是所有线程的集合，每一个线程是进程中的一条执行路径。</p><h2 id="2-为什么要使用多线程？多线程应用场景？"><a href="#2-为什么要使用多线程？多线程应用场景？" class="headerlink" title="2.为什么要使用多线程？多线程应用场景？"></a>2.为什么要使用多线程？多线程应用场景？</h2><p>答:主要能体现到多线程提高程序效率。</p><p>举例: 迅雷多线程下载、数据库连接池、分批发送短信等。</p><h2 id="3-线程创建方式"><a href="#3-线程创建方式" class="headerlink" title="3.线程创建方式"></a>3.线程创建方式</h2><h3 id="继承Thread类重写run方法"><a href="#继承Thread类重写run方法" class="headerlink" title="继承Thread类重写run方法"></a>继承Thread类重写run方法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayGame</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++) {</span><br><span class="line">System.out.println(<span class="string">"PlayGame"</span> + (i + <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//void say() {}</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListenMusic</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++) {</span><br><span class="line">System.out.println(<span class="string">"ListenMusic"</span> + (i + <span class="number">1</span>));<span class="comment">//底层操作居然是用的StringBuilder</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Thread music = <span class="keyword">new</span> ListenMusic();</span><br><span class="line">Thread pg = <span class="keyword">new</span> PlayGame();</span><br><span class="line">music.start(); <span class="comment">//三个线程同时运行抢占资源</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">pg.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++) {</span><br><span class="line">System.out.println(<span class="string">"    main方法:"</span> + (i + <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line">pg.start();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">System.out.println(<span class="string">"出现了IllegalThreadStateException异常"</span>);  <span class="comment">//线程只能启动一次</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种方法官方也不推荐使用因为Java是单继承的继承了Thread类之后就不能继承其他的类</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (inti = <span class="number">0</span>; i< <span class="number">10</span>; i++) {</span><br><span class="line">System.out.println(<span class="string">"i:"</span> + i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"-----多线程创建开始-----"</span>);</span><br><span class="line"><span class="comment">// 1.创建一个线程</span></span><br><span class="line">CreateRunnable createThread = <span class="keyword">new</span> CreateRunnable();</span><br><span class="line"><span class="comment">// 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法</span></span><br><span class="line">System.out.println(<span class="string">"-----多线程创建启动-----"</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(createThread);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(<span class="string">"-----多线程创建结束-----"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InClass</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"> Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i< <span class="number">100</span>; i++) {</span><br><span class="line">System.out.println(<span class="string">"i:"</span> + i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//lambda表达式还是比较简洁</span></span><br><span class="line"> <span class="keyword">new</span> Thread(()-> {<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <<span class="number">100</span>; i++) {System.out.println(<span class="string">"lambda:"</span> +i);}}).start();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>线程创建方式不只这些还有很多，后面再介绍</p><h3 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h3><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。<code>start()</code>方法被用来启动新创建的线程，而且<code>start()</code>内部native方法<code>start0()</code>调用了run()方法，这和直接调用<code>run()</code>方法的效果不一样。当你调用<code>run()</code>方法的时候，只会是在原来的线程中调用，没有新的线程启动，<code>start()</code>方法才会启动新线程</p><h2 id="4-Thread构造函数"><a href="#4-Thread构造函数" class="headerlink" title="4.Thread构造函数"></a>4.Thread构造函数</h2><table><thead><tr><th align="left"><strong>常用线程api方法</strong></th><th></th></tr></thead><tbody><tr><td align="left">start()</td><td>启动线程</td></tr><tr><td align="left">currentThread()</td><td>获取当前线程对象</td></tr><tr><td align="left">getID()</td><td>获取当前线程ID   Thread-编号 该编号从0开始</td></tr><tr><td align="left">getName()</td><td>获取当前线程名称</td></tr><tr><td align="left">sleep(long mill)</td><td>休眠线程</td></tr><tr><td align="left">Stop（）</td><td>停止线程,</td></tr><tr><td align="left"><strong>常用线程构造函数</strong></td><td></td></tr><tr><td align="left">Thread（）</td><td>分配一个新的 Thread 对象</td></tr><tr><td align="left">Thread（String name）</td><td>分配一个新的 Thread对象，具有指定的 name正如其名。</td></tr><tr><td align="left">Thread（Runnable r）</td><td>分配一个新的 Thread对象</td></tr><tr><td align="left">Thread（Runable r, String name）</td><td>分配一个新的 Thread对象，具有指定的 name正如其名。</td></tr><tr><td align="left">Thread(ThreadGroup group, Runnable target)</td><td>分配一个新的 Thread对象，如果不传<code>ThreadGroup</code>默认加入当前线程的<code>ThreadGroup</code>中</td></tr><tr><td align="left">Thread(ThreadGroup group, Runnable target, String name)</td><td>分配一个新的 <code>Thread</code>对象，使其具有  <code>target</code>作为其运行对象，具有指定的 <code>name</code>作为其名称，属于  <code>group</code>引用的线程组。</td></tr><tr><td align="left">Thread(ThreadGroup group, Runnable target, String name,  long stackSize)</td><td>分配一个新的 <code>Thread</code>对象，以便它具有  <code>target</code>作为其运行对象，将指定的 <code>name</code>正如其名，以及属于该线程组由称作  <code>group</code> ，并具有指定的 <em>堆栈大小</em></td></tr></tbody></table><h3 id="Thread构造方法的一些细节"><a href="#Thread构造方法的一些细节" class="headerlink" title="Thread构造方法的一些细节"></a>Thread构造方法的一些细节</h3><p>直接上源码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) {</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) {</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) {</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">//这里继承了父类的一些属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="comment">//传入的Runnable接口</span></span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals && parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>① 创建的线程会继承父线程的一些属性，是否是守护线程 ，和优先级。</p><p>②使用Thread(Runnable r)创建线程时<code>this.target = target</code>传入的<code>Runnable</code>接口在这里赋值然后会在<code>run方法</code>中被调用。</p><p>③<code>stacksize</code>这个参数会影响<code>虚拟机栈</code>的大小，这个值越大能存放的<code>栈帧</code>就越多，可达到的递归深度越深，但是这个参数不一定有效，有的平台可能并没有效果，具体的<code>JVM</code>底层的知识等后面学到再来细化</p><p>④一种奇怪的写法，这里只会执行重写<code>Thread</code>的<code>run</code>方法，这里从源码上可以看出来，传递<code>Runnable</code>接口其实是在Thread的run方法中调用了<code>target</code>的<code>run</code>方法，如果同时再<code>继承</code>Thread类，重写<code>run</code>方法，调用的就不再是Thread类的run方法，而是匿名Thread子类重写的run方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">    System.out.println(<span class="string">"Runnable"</span>);</span><br><span class="line">}) {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Thread"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div><p>④线程<code>tid</code>通过<code>threadSeqNumber</code>从0自增的来，main线程是第<code>10</code>个线程因为会有一些守护线程会在main启动前启动.</p><h2 id="5-守护线程"><a href="#5-守护线程" class="headerlink" title="5.守护线程"></a>5.守护线程</h2><p>Java中有两种线程，一种是用户线程，另一种是守护线程。</p><p>用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止</p><ul><li>守护线程顾名思义当父线程结束时，守护线程也会被停止。</li><li>JVM只有在最后一个非守护线程结束后才会退出</li><li>在线程start前<code>setDaemon(true)</code>方法设置为守护线程，否则就会报错</li><li>父线程是守护线程，子线程默认是守护线程。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">500</span>;i++) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">        Thread r1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Daemon(),<span class="string">"后台线程"</span>);     <span class="comment">//设置该线程为后台线程</span></span><br><span class="line">        r1.setDaemon(<span class="keyword">true</span>);                        <span class="comment">//前台线程挂掉后，后台线程就会挂掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">50</span>;i++) {                   </span><br><span class="line">            System.out.println(<span class="string">"main"</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">10</span>) {</span><br><span class="line">                r1.start();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"主线程执行完毕"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>心跳检测</code>，在通信过程中会需要判断对方是否在线，会需要创建一条线程去做这些事情，但是如果这样会导致<code>主线程停止工作</code>了，但是检测心跳的线程仍然在继续工作，JVM就无法停下来，显然这样时不合理的，这时就可以把检测心跳的线程设置为<code>守护线程</code>，这样当它主线程停止工作时它的守护线程也会随之停止。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//心跳检测MOCK</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            Thread inThread = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"start heart check"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">1_00</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="comment">//将子线程设置为守护线程</span></span><br><span class="line">            inThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            inThread.start();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">                System.err.println(<span class="string">"Thread finish done..."</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程(main)-->t-->inThread</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h2 id="6-线程的状态"><a href="#6-线程的状态" class="headerlink" title="6.线程的状态"></a>6.线程的状态</h2><p>线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。</p><p><img alt="mark" data-src="http://static.imlgw.top///20181226/WXPYz3SiidMT.png?imageslim" src="/img/loading.gif" class="lazyload"></p><ul><li><p>新建状态<br>当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</p></li><li><p>就绪状态<br>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。<br>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由<code>Java</code>运行时系统的线程调度程序(<em>thread scheduler</em>)来调度的。</p></li><li><p>运行状态<br>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.</p></li><li><p>阻塞状态<br>线程运行过程中，可能由于各种原因进入阻塞状态:<br>1>线程通过调用sleep方法进入睡眠状态；<br>2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；<br>3>线程试图得到一个锁，而该锁正被其他线程持有；<br>4>线程在等待某个触发条件；</p></li><li><p>死亡状态</p><p>有两个原因会导致线程死亡：</p><p>1) run方法正常退出而自然死亡，</p><p>2) 一个未捕获的异常终止了run方法而使线程猝死。 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用<code>isAlive</code>方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.</p></li></ul><h2 id="7-join-方法"><a href="#7-join-方法" class="headerlink" title="7.join()方法"></a>7.join()方法</h2><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (millis < <span class="number">0</span>) {</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) {</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) {</span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="keyword">while</span> (isAlive()) {</span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay <= <span class="number">0</span>) {</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">               wait(delay);</span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p>①<code>thread.join()</code>没有参数会默认调用<code>join(0)</code>然后回轮询检查调用<code>join()</code>的线程也就是是<code>thread</code>线程是否<code>isAlive()</code>如果thread依然存活就回释放<code>当前线程</code>的CPU执行权，然后继续轮询，知道<code>thread</code>进入终止状态。</p><p>②<code>join(long millis)</code> 参数的作用就是当前线程最多等待时间，限时等待，避免无止境的等待。</p><p>③一个线程自己调用自己的<code>join</code>方法该线程就回一直<code>wait</code>下去因为他自己要一直等自己😄</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p> 多线程同时采集数据，最后将统计的总时间等信息存到数据库中，如果不jion就无法统一结束的时间</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin3</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CaptureMachine(<span class="string">"M0"</span>, <span class="number">1000</span>));</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CaptureMachine(<span class="string">"M1"</span>, <span class="number">2000</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CaptureMachine(<span class="string">"M2"</span>, <span class="number">4000</span>));</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//让主线程等待子线程结束然后统计最后总体结束的时间</span></span><br><span class="line">        t0.join();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"end save begin timestamp:"</span> + l1 + <span class="string">"end timestamp"</span> + l);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptureMachine</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String machineId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> spentTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaptureMachine</span><span class="params">(String machineId, <span class="keyword">long</span> spentTime)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">        <span class="keyword">this</span>.spentTime = spentTime;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(spentTime);</span><br><span class="line">            System.out.println(machineId + <span class="string">" capture done"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="8-优先级"><a href="#8-优先级" class="headerlink" title="8.优先级"></a>8.优先级</h2><p>现代操作系统基本采用时分的形式调度运行的线程，线程分配得到的时间片的多少决定了线程使用处理器资源的多少，也对应了线程优先级这个概念。在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。下面是Demo（基于1.8）中关于priority的一些量和方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSimpleAPI2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t0.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t1.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="9-Interrupt方法"><a href="#9-Interrupt方法" class="headerlink" title="9.Interrupt方法"></a>9.Interrupt方法</h2><h3 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) {</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) {</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        interrupt0();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在知乎上看见一个好的回答：首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己<code>自行停止</code>。所以，<code>Thread.stop()</code> ,<code>Thread.suspend()</code>,<code>Thread.resume()</code>都已经被废弃了。而<code>Thread.interrupt()</code>的作用也不是中断线程，<em>而是通知线程该结束了</em> 具体中断还是继续运行还是由被通知的线程自己处理。具体来说，当对一个线程调用<code>interrupt()</code>时</p><p>①如果线程处于阻塞状态(sleep,wait,join等)，那么线程将<del>立即退出被阻塞状态</del>并抛出一个异常(2019.8.10 fix)</p><blockquote><p>这里其实是有点问题的，在有同步锁存在的情况下，并不一定会立即退出被阻塞的状态，即使抛出异常也要等到再次拿到锁之后才能抛出，同时也不是所有的阻塞操作都会响应中断信号，比如IO操作之类的都不会响应中断信号</p></blockquote><p><strong>验证Demo</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (object) {</span><br><span class="line">                    System.out.println(<span class="string">"线程1 获取到监视器锁"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">"线程1 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。"</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        System.out.println(<span class="string">"线程1 wait方法抛出了InterruptedException异常，即使是异常，我也是要获取到监视器锁了才会抛出"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (object) {</span><br><span class="line">                    System.out.println(<span class="string">"线程2 拿到了监视器锁。为什么呢，因为线程1 在 wait 方法的时候会自动释放锁"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程2 设置线程1 中断"</span>);</span><br><span class="line">                    thread1.interrupt();</span><br><span class="line">                    System.out.println(<span class="string">"线程2 执行完了 中断，先休息3秒再说。"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        System.out.println(<span class="string">"线程2 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁"</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"线程2 休息够了，结束操作"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程2"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>②如果线程处于正常活动状态，那么会将该线程的<code>中断标志位</code>设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响。</p><p>③对已经结束的线程调用<code>interupt</code>没有任何效果</p><p>上面只是简单的分析，其实情况还是很复杂的，后面再来总结</p><p><strong>具体的小案例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrup2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread main=Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//t.interrupt(); 这里打断的是t线程但是阻塞的是main线程所以打断不了，捕获不到异常</span></span><br><span class="line">            main.interrupt();</span><br><span class="line">            System.out.println(<span class="string">"打断 main 线程"</span>);</span><br><span class="line">        });</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//这里阻塞的是main线程</span></span><br><span class="line">            t.join();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>看懂这个小案例应该就理解interrupt了。</p><h3 id="如何优雅的结束线程"><a href="#如何优雅的结束线程" class="headerlink" title="如何优雅的结束线程"></a>如何优雅的结束线程</h3><p><strong>1. 使用“开关”</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCloseGraceful</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Worker worker=<span class="keyword">new</span> Worker();</span><br><span class="line">        worker.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>); <span class="comment">//等待10s</span></span><br><span class="line">        worker.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">    <span class="comment">//优雅的停止线程-----开关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (start){</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.start=<span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>为了及时的感知到开关的变化 start需要声明为 volatile（后面讲Volatile的时候会说到）</p></blockquote><p><strong>2. 轮询中断标志位</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCloseGraceful2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Worker2 worker2 = <span class="keyword">new</span> Worker2();</span><br><span class="line">        worker2.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        worker2.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">    <span class="comment">//优雅的停止线程2-----打断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            <span class="comment">/*try {</span></span><br><span class="line"><span class="comment">                Thread.sleep(1);</span></span><br><span class="line"><span class="comment">            } catch (InterruptedException e) {</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">                break; //return 会直接退出</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">            <span class="comment">//代码有可能在执行isInterrupted之前就Block了</span></span><br><span class="line">            <span class="keyword">if</span>(isInterrupted()){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//-----------</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>3. 利用守护线程</strong></p><p>上面的代码已经提到了，有可能在轮询<code>开关</code> 或者 轮询<code>中断标志位</code>之前就堵塞了，这时也不能一直等该下去所以就需要强制结束线程的方法，<code>（当然不会是stop）</code> 这里就可以利用守护线程的特性去完成这件事</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadService</span> </span>{</span><br><span class="line">    <span class="keyword">private</span>  Thread executeThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span>  <span class="keyword">boolean</span> finished=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>{</span><br><span class="line">        executeThread =<span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="comment">//子线程</span></span><br><span class="line">            Thread t=<span class="keyword">new</span> Thread(()->{</span><br><span class="line">                task.run();</span><br><span class="line">            });</span><br><span class="line">            t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            t.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                t.join(); <span class="comment">//这里阻塞的是executeThread</span></span><br><span class="line">                finished=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//到这里说明executeThread已经不阻塞了,子线程已经执行完了，没有超时</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"TLE，executeThread execution was interrupted"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        executeThread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">long</span> mills)</span></span>{</span><br><span class="line">        <span class="keyword">long</span> base=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (!finished){ <span class="comment">//轮询检查标志位，看是否已经结束</span></span><br><span class="line">            <span class="keyword">if</span>(System.currentTimeMillis()-base>=mills){</span><br><span class="line">                <span class="comment">//超时了没有完成</span></span><br><span class="line">                System.out.println(<span class="string">"TLE, will end it now"</span>);</span><br><span class="line">                executeThread.interrupt(); <span class="comment">//打断executeThread</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//没超时</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                executeThread.sleep(<span class="number">10</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"executeThread was interrupted when shutdown"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//标志位复原</span></span><br><span class="line">        finished=<span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>将待执行的<code>task</code>传递到<code>ThreadService</code>中然后会创建一个<code>executeThread</code>的线程，在线程中创建一个子线程去执行<code>task</code>的<code>run</code>方法然后将子线程设置为<code>executeThread</code>的守护线程然后<code>join</code>阻塞<code>executeThread</code>线程，同时会调用<code>ThreadService</code>的<code>shutdown</code>方法传入一个最长等待时间然后<code>轮询标志位</code>检查是否结束，如果超时就会打断<code>executeThread</code>进而结束<code>executeThread</code>的子线程也就是<code>task</code></p><h3 id="Thread-interrupted"><a href="#Thread-interrupted" class="headerlink" title="Thread.interrupted()"></a>Thread.interrupted()</h3><p>这个方法和<code>isInterrupt()</code>类似但是他会清除中断标志位为<code>false</code>方便之后的中断操作而且这个是<code>静态方法</code>，所以你用线程实例去调用这个方法没有任何意义，它这里是用来判断<strong>当前执行线程</strong>是否 <code>interrupt</code> ，并且设置中断标志位为<code>false</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tests whether the current thread has been interrupted.  The</span><br><span class="line"> * <span class="tag"><<span class="name">i</span>></span>interrupted status<span class="tag"><!--<span class="name"-->i</span>></span> of the thread is cleared by this method.  In<br><span class="line"> * other words, if this method were to be called twice in succession, the</span><br><span class="line"> * second call would return false (unless the current thread were</span><br><span class="line"> * interrupted again, after the first call had cleared its interrupted</span><br><span class="line"> * status and before the second call had examined it).</span><br><span class="line"> *</span><br><span class="line"> * <span class="tag"><<span class="name">p</span>></span>A thread interruption ignored because a thread was not alive</span><br><span class="line"> * at the time of the interrupt will be reflected by this method</span><br><span class="line"> * returning false.</span><br><span class="line"> *</span><br><span class="line"> * @return  <span class="tag"><<span class="name">code</span>></span>true<span class="tag"><!--<span class="name"-->code</span>></span> if the current thread has been interrupted;<br><span class="line"> *          <span class="tag"><<span class="name">code</span>></span>false<span class="tag"><!--<span class="name"-->code</span>></span> otherwise.<br><span class="line"> * @see #isInterrupted()</span><br><span class="line"> * @revised 6.0</span><br><span class="line"> */</span><br></pre></td></tr></tbody></table></figure></div><p>同时在抛出<code>InterruptedException</code> 之后中断状态也会被自动清除为false</p><blockquote><p>if any thread has interrupted the current thread. The <i>interrupted status</i> of the current thread is cleared when this exception is thrown.     —-Thread.sleep注释</p></blockquote><h2 id="10-Yield方法"><a href="#10-Yield方法" class="headerlink" title="10.Yield方法"></a>10.Yield方法</h2><p>Thread.yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）<br>yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。<br>结论：大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p><h2 id="11-Synchronized关键字"><a href="#11-Synchronized关键字" class="headerlink" title="11.Synchronized关键字"></a>11.Synchronized关键字</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NO = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (index > MAX_NO) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"第："</span> + index++);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>用这个创建多个<code>Thread</code>然后运行</p><blockquote><p>二号窗口第：497<br>三号窗口第：499<br>一号窗口第：498<br>一号窗口第：500<br>二号窗口第：<code>502</code><br>三号窗口第：<code>501</code></p></blockquote><p>可以看出打印出了501，502明显不对为什么会出现这种问题呢？其实仔细想想也很容易理解</p><p><img alt="mark" data-src="http://static.imlgw.top///20190326/zSGNeiCW2zc1.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>当两个线程如图所示的情况，2号线程<code>index=500</code>然后<code>index++</code>然后 1号线程读取到<code>index</code>的值就会产生这个问题。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p><strong>解决线程安全问题</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NO = <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object MONITOR = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (MONITOR) {</span><br><span class="line">                <span class="comment">//单线程</span></span><br><span class="line">                <span class="keyword">if</span> (index > MAX_NO) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"第："</span> + index++);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>利用<code>MONITOR</code>对象作为同步锁同步之后的部分就相当于单线程，<code>MONITOR</code>锁对象一般设置为<code>final</code>的避免在执行过程中对<code>MONITOR</code>对象进行改变而产生无法预料的后果</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizeRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NO = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//this锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (ticket()) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ticket</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//synchronized (this) {</span></span><br><span class="line">            <span class="comment">//1.getFiled</span></span><br><span class="line">            <span class="keyword">if</span> (index > MAX_NO) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// getFiled index</span></span><br><span class="line">            <span class="comment">// index=index+1</span></span><br><span class="line">            <span class="comment">// putFiled index</span></span><br><span class="line">            <span class="comment">//同步代码块就是保护共享数据index, MAX_NO不是,他是只读数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"第："</span> + index++);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// }</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>默认加的是<code>this</code>锁</p><p><strong>证明this锁的存在</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedThis</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ThisLock thisLock = <span class="keyword">new</span> ThisLock();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -> thisLock.m1(), <span class="string">"Thread0"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -> thisLock.m2(), <span class="string">"Thread1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -> thisLock.m3(), <span class="string">"Thread2"</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisLock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>运行上面的代码会发现<code>Thread0</code>和<code>Thread2</code>会先打印出来因为他们不是同一个锁不用等待对方，而<code>Thread1</code>会等待一段时间后才会执行因为它需要等待<code>Thread0</code>释放锁而这个锁只能是<code>this锁</code></p><p><strong>证明class锁的存在</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClass</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(() -> ClassLock.m1(), <span class="string">"Thread0"</span>);</span><br><span class="line">        thread0.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -> ClassLock.m2(), <span class="string">"Thread1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -> ClassLock.m3(), <span class="string">"Thread2"</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLock</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">synchronized</span> (ClassLock<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">            System.out.println(<span class="string">"static"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>运行上面的代码会发现最开始只有一个线程会去执行静态代码快，在静态代码快执行完之后<code>Thread2</code>会和另一个线程一起执行，说明一开始<code>Thread2</code>回和其中一个线程抢<code>Class锁</code>执行静态代码块（静态代码块只会执行一次）</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>一个线程可以持有多个锁，而这样就可能会导致<code>死锁</code>的产生</p></blockquote><p><strong>死锁示例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service1</span> </span>{</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Object LOCK=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service2 service2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">s1</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK){</span><br><span class="line">            System.out.println(<span class="string">"s1=============="</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">s2</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK){</span><br><span class="line">            System.out.println(<span class="string">"s2=============="</span>);</span><br><span class="line">            service2.m2();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setService2</span><span class="params">(Service2 service2)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.service2 = service2;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service2</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Service1 service1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Service2</span><span class="params">(Service1 service1)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.service1 = service1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  Object LOCK=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">m1</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK){</span><br><span class="line">            System.out.println(<span class="string">"m1"</span>);</span><br><span class="line">            service1.s1();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">m2</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK){</span><br><span class="line">            System.out.println(<span class="string">"m2"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Service1 service1=<span class="keyword">new</span> Service1();</span><br><span class="line">        Service2 service2 =<span class="keyword">new</span> Service2(service1);</span><br><span class="line">        service1.setService2(service2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                service2.m1();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()->{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                service1.s2();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>执行上面代码就会发现在运行一段时间后两个线程都<code>阻塞</code>了，这就是<code>死锁</code></p><ul><li><code>jps</code>&<code>jstack</code>  分析死锁</li></ul><p><img alt="mark" data-src="http://static.imlgw.top///20190328/BG9eU9Rq8ae0.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>两个线程都需要对方手上的的锁，陷入僵持状态，就会产生死锁，也可以使用<code>jconsole</code>图形化界面来分析</p><h2 id="12-线程间通讯"><a href="#12-线程间通讯" class="headerlink" title="12.线程间通讯"></a>12.线程间通讯</h2><p>在Java平台中，Object.wait()/notify() 等方法可用于实现线程的等待和通知，wait将当前线程暂停生命周期变为 <strong>WAITING</strong> ，而notify() 则可以唤醒一个被暂停的线程从而实现通知，一般来说wait() 代码模板类似下面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(someObj){</span><br><span class="line">    <span class="keyword">while</span>(保护条件不成立){</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        someObj.wait();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//保护条件满足</span></span><br><span class="line">    doAction();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>而<code>notify()</code> 对应代码模板如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(someObj){</span><br><span class="line">    <span class="comment">//更新等待线程的保护条件设计的共享变量</span></span><br><span class="line">    updateSharedDate();</span><br><span class="line">    <span class="comment">//唤醒其他线程</span></span><br><span class="line">    someObj,notify();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p><strong>错误示例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumerVersion1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ProduceConsumerVersion1 pc = <span class="keyword">new</span> ProduceConsumerVersion1();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                pc.produce();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"Produce"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                pc.consumer();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"Consumer"</span>).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) {</span><br><span class="line">            System.out.println(<span class="string">"Produce->"</span> + (i++));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) {</span><br><span class="line">            System.out.println(<span class="string">"Consumer->"</span> + (i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种模型当生产者和消费者启动后会发现两个线程无法协作，生产者不断生产，消费者<code>不消费</code>或者<code>重复消费</code></p><p><strong>单生产者&单消费者</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumerVersion2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ProduceConsumerVersion2 pc = <span class="keyword">new</span> ProduceConsumerVersion2();</span><br><span class="line">        Stream.of(<span class="string">"Produce1"</span>).forEach(n -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    pc.produce();</span><br><span class="line">                }</span><br><span class="line">            }, n).start();</span><br><span class="line">        });</span><br><span class="line">        Stream.of(<span class="string">"Consumer1"</span>).forEach(n -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    pc.consumer();</span><br><span class="line">                }</span><br><span class="line">            }, n).start();</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isProduced = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) {</span><br><span class="line">            <span class="keyword">if</span> (isProduced) {</span><br><span class="line">                <span class="comment">//已经生产了</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    LOCK.wait();<span class="comment">//等待消费者唤醒</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-->"</span> + (++i));<span class="comment">//produce</span></span><br><span class="line">            isProduced = <span class="keyword">true</span>;</span><br><span class="line">            LOCK.notify();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) {</span><br><span class="line">            <span class="keyword">if</span> (!isProduced) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    LOCK.wait();<span class="comment">//等待生产者唤醒</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-->"</span> + (i));<span class="comment">//consumer</span></span><br><span class="line">            isProduced = <span class="keyword">false</span>;</span><br><span class="line">            LOCK.notify();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>wait()：</strong> 当前线程<code>释放锁</code>进入该锁对象的<code>等待队列</code> </p><blockquote><p>Causes the current thread to wait until another thread invokes the</p><p>{@link java.lang.Object#notify()} method or the</p><p>{@link java.lang.Object#notifyAll()} method for this object.</p><p>In other words, this method behaves exactly as if it simply</p><p>performs the call {@code <code>wait(0)</code>}.</p><p>The current thread <code>must own this object's monitor.</code> The thread</p><p><code>releases</code> ownership of this monitor and waits until another thread</p><p>notifies threads waiting on this object’s monitor to wake up</p><p>either through a call to the {@code notify} method or the</p><p>{@code notifyAll} method. The thread then waits until it can</p><p>re-obtain ownership of the monitor and resumes execution.</p></blockquote><p><strong>wait(long timeout)：</strong><code>wait()</code>的重载方法很容易想到是干啥的✔</p><blockquote><p>Causes the current thread to wait until either another thread invokes the</p><p>{@link java.lang.Object#notify()} method or the</p><p>{@link java.lang.Object#notifyAll()} method for this object, or a</p><p><code>specified amount of time has elapsed.</code></p><p>The current thread must own this object’s monitor.</p><p>@throws  <code>IllegalArgumentException</code>  if the value of timeout is negative.</p></blockquote><p><strong>notify()：</strong> 唤醒该<code>锁对象</code>的<code>等待队列</code>的线程，唤醒方法不同的虚拟机实现不同有的可能是<code>FCFS</code>有的可能是<code>SJF</code> 等等….所以唤醒的是那个线程是无法确定的</p><blockquote><p>Wakes up a single thread that is <code>waiting on this object's</code></p><p><code>monitor</code>. If any threads are waiting on this object, one of them</p><p>is chosen to be awakened. <code>The choice is arbitrary and occurs at</code></p><p><code>the discretion of the implementation</code>. A thread waits on an object’s</p><p>monitor by calling one of the {@code wait} methods.</p><p>The awakened thread will not be able to proceed until the current</p><p>thread <code>relinquishes</code> the lock on this object. The awakened thread will</p><p>compete in the usual manner with any other threads that might be</p><p>actively competing to synchronize on this object; for example, the</p><p>awakened thread enjoys no reliable privilege or disadvantage in being</p><p>the next thread to lock this object.</p></blockquote><p>生产者生产一个消费者消费一个，没毛病，但是上面的代码仅仅适用于<code>单生产者&消费者</code>对于多个生产者消费者就会有线程安全问题，具体问题如下</p><p><strong>测试多消费者&生产者</strong></p><p>沿用上面single p&c的代码，测试多消费者和生产者</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    ProduceConsumerVersion3 pc = <span class="keyword">new</span> ProduceConsumerVersion3();</span><br><span class="line">    Stream.of(<span class="string">"Produce1"</span>, <span class="string">"Produce2"</span>, <span class="string">"Produce3"</span>, <span class="string">"Produce4"</span>).forEach(n -> {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                pc.produce();</span><br><span class="line">            }</span><br><span class="line">        }, n).start();</span><br><span class="line">    });</span><br><span class="line">    Stream.of(<span class="string">"Consumer1"</span>, <span class="string">"Consumer2"</span>, <span class="string">"Consumer3"</span>).forEach(n -> {</span><br><span class="line">        <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                pc.consumer();</span><br><span class="line">            }</span><br><span class="line">        }, n).start();</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>运行会发现程序进入<code>”死锁“</code>状态，用<code>jps&jstack</code>分析</p><p><img alt="mark" data-src="http://static.imlgw.top///20190328/pzXBY0ertEVV.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>程序并没有发现死锁❎，这就是多生产者多消费者会产生的<code>假死</code>状态，实际上是所有的线程都进入了<code>wait()</code>状态都放弃了<code>CPU</code>的执行权</p><p><strong>假死原因分析</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Produce1--><span class="number">1</span>notify C1 wait</span><br><span class="line">Consumer1--><span class="number">1</span>notify P1 wait</span><br><span class="line">Produce1--><span class="number">2</span>    notify C2 wait</span><br><span class="line">Consumer2--><span class="number">2</span>   notify P2 wait</span><br><span class="line">Produce2--><span class="number">3</span>notify P1 wait ---> Produce1-->wait</span><br></pre></td></tr></tbody></table></figure></div><p>上面是其中一种情况，大致分析下：前两次生产消费都正常一个<code>消费者</code>唤醒一个<code>生产者</code>，前两次执行完之后<code>P1 C1 C2</code>都进入<code>wait</code>状态然后第三次生产的时候<code>P2</code>唤醒了一个不该唤醒的人😂 唤醒了<code>P1</code>然后<code>wait</code>了，<code>P1</code>醒来后发现已经生产了然后也<code>wait</code>去了，至此所有的线程全部进入<code>wait</code>状态就造成了假死。这个问题记得大一的时候还问过老师当时特别纠结为啥会死锁，现在看看其实也没啥，主要就是<code>notify</code>唤醒的线程是不确定的，是由<code>JVM</code>决定的每种<code>JDK</code>的实现也不太一样，无法保证消费者一定唤醒生产者，反之亦然。</p><p><strong>多生产者&多消费者</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumerVersion3</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ProduceConsumerVersion3 pc = <span class="keyword">new</span> ProduceConsumerVersion3();</span><br><span class="line">        Stream.of(<span class="string">"Produce1"</span>, <span class="string">"Produce2"</span>, <span class="string">"Produce3"</span>, <span class="string">"Produce4"</span>).forEach(n -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    pc.produce();</span><br><span class="line">                }</span><br><span class="line">            }, n).start();</span><br><span class="line">        });</span><br><span class="line">        Stream.of(<span class="string">"Consumer1"</span>, <span class="string">"Consumer2"</span>, <span class="string">"Consumer3"</span>).forEach(n -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    pc.consumer();</span><br><span class="line">                }</span><br><span class="line">            }, n).start();</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isProduced = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) {</span><br><span class="line">            <span class="keyword">while</span> (isProduced) {</span><br><span class="line">                <span class="comment">//已经生产了</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    LOCK.wait(); <span class="comment">//加入LOCK锁的wait队列</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-->"</span> + (++i));<span class="comment">//produce</span></span><br><span class="line">            isProduced = <span class="keyword">true</span>;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) {</span><br><span class="line">            <span class="keyword">while</span> (!isProduced) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-->"</span> + (i));<span class="comment">//consumer</span></span><br><span class="line">            isProduced = <span class="keyword">false</span>;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>notifyAll()：</strong>唤醒当前锁对象等待队列上的<code>所有</code>线程</p><blockquote><p>Wakes up <code>all threads</code> that are waiting on <code>this object's monitor</code>. A</p><p>thread waits on an object’s monitor by calling one of the</p><p>{@code wait} methods.</p><p>The awakened threads will not be able to proceed until the current</p><p>thread relinquishes the lock on this object. The awakened threads</p><p>will <code>compete in the usual manner</code> with any other threads that might</p><p>be actively competing to synchronize on this object; for example,</p><p>the awakened threads enjoy <code>no reliable privilege or disadvantage</code> in</p><p>being the next thread to lock this object.</p></blockquote><p>① 为了解决上面的<code>假死</code>问题这里使用了<code>notifyAll()</code>来唤醒<code>等待队列</code>的线程，看名字就知道这个方法会唤醒所有的线程，那么上面的假死问题就自然解决了。</p><p>② 还有一点不同的是这里判断生产状态时用的是<code>while</code>而不是<code>if</code>为什么不用<code>if</code>? 其实也很好理解如果有多个生产者或者消费者同时在<code>等待队列</code>中，然后其中一个抢到锁后执行，执行完生产后唤醒了所有等待的线程，假设唤醒的是<code>生产者</code>的话，因为是<code>if语句</code>控制的被唤醒的生产者抢到锁之后就直接顺着执行下去了，就直接去生产了，就会造成<code>重复的生产</code>当然用<code>else</code>语句貌似可以解决这个问题，但是那会影响效率（个人感觉），而且很别扭（被唤醒了直接退出？？？）. 所以这里用<code>while</code>来进行<code>二次检测</code>避免这种情况，这种while循环也被称为<code>自旋锁</code> 这一块后面的文章会再详细的讲。</p><h3 id="为什么wait和notify必须在同步方法或同步块中调用？"><a href="#为什么wait和notify必须在同步方法或同步块中调用？" class="headerlink" title="为什么wait和notify必须在同步方法或同步块中调用？"></a>为什么wait和notify必须在同步方法或同步块中调用？</h3><p>这是<code>阿里巴巴</code>的一道面试题</p><p>① 首先从语法层面讲，如果不在同步方法和同步代码块中调用，也就是说没有加锁，自然就不用谈是不是<code>锁对象的持有者</code> ，就会报<code>IllegalMonitorStateException</code>.</p><blockquote><p>@throws  <code>IllegalMonitorStateException</code>  if the current thread is not</p><p>the owner of the object’s monitor.</p></blockquote><p>②设想下如果不加锁可以直接调用，就会产生所谓的<code>竞态条件</code>，假设<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>方法不需要加锁就能够被调用。此时消费者线程调用<code>wait()</code>正在进入状态变量的等待队列(译者注:可能还未进入)。在同一时刻，生产者线程调用<code>notify()</code>方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>方法必须在该对象的同步方法或同步代码块中被互斥地调用。</p><blockquote><p>计算的正确性取决于多个线程的交替执行时序时就会产生竞态条件</p></blockquote><h3 id="wait-后被唤醒会怎么样？"><a href="#wait-后被唤醒会怎么样？" class="headerlink" title="wait()后被唤醒会怎么样？"></a>wait()后被唤醒会怎么样？</h3><p>上面说到被唤醒后会去抢锁，但是这里有人可能会有疑问，去抢锁会不会回到同步的起点去争抢锁，然后把wait前的逻辑再执行一遍？这里肯定事不会的，确实是要抢锁但是会有记录会继续顺着wait方法走下去。</p><h3 id="notify和中断的一个很有意思的现象"><a href="#notify和中断的一个很有意思的现象" class="headerlink" title="notify和中断的一个很有意思的现象"></a>notify和中断的一个很有意思的现象</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyInter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        NotifyInter waitNotify = <span class="keyword">new</span> NotifyInter();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (object) {</span><br><span class="line">                    System.out.println(<span class="string">"线程1 获取到监视器锁"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">"线程1 正常恢复啦。但是 isInterrupt = "</span>+ Thread.currentThread().isInterrupted());</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        System.out.println(<span class="string">"线程1 wait方法抛出了InterruptedException异常"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (object) {</span><br><span class="line">                    System.out.println(<span class="string">"线程2 获取到监视器锁"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">"线程2 正常恢复啦。"</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        System.out.println(<span class="string">"线程2 wait方法抛出了InterruptedException异常"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程2"</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里让 thread1 和 thread2 先起来，然后再起后面的 thread3</span></span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (object) {</span><br><span class="line">                    System.out.println(<span class="string">"线程3 拿到了监视器锁。"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程3 设置线程1中断"</span>);</span><br><span class="line">                    thread1.interrupt(); <span class="comment">// 1</span></span><br><span class="line">                    <span class="comment">//waitNotify.a = 1; // 这行是为了禁止上下的两行中断和notify代码重排序</span></span><br><span class="line">                    System.out.println(<span class="string">"线程3 调用notify"</span>);</span><br><span class="line">                    object.notify(); <span class="comment">//2</span></span><br><span class="line">                    System.out.println(<span class="string">"线程3 调用完notify后，休息一会"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"线程3 休息够了，结束同步代码块"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程3"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>多执行几次可能就可能会发生如下情况，线程1被打断后居然正常的返回了！！！！线程2被阻塞住了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">线程<span class="number">1</span> 获取到监视器锁</span><br><span class="line">线程<span class="number">2</span> 获取到监视器锁</span><br><span class="line">线程<span class="number">3</span> 拿到了监视器锁。</span><br><span class="line">线程<span class="number">3</span> 设置线程<span class="number">1</span>中断</span><br><span class="line">线程<span class="number">3</span> 调用notify</span><br><span class="line">线程<span class="number">3</span> 调用完notify后，休息一会</span><br><span class="line">线程<span class="number">3</span> 休息够了，结束同步代码块</span><br><span class="line">线程<span class="number">1</span> 正常恢复啦。但是 isInterrupt = <span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p>其实这里主要问题就是 <code>notify()</code> 和<code>interrupt()</code> 执行顺序的问题</p><ul><li><p>如果先被打断，那么后续的notify会这个线程无效，依然会抛出异常，如果这是该锁实例上仍然有其他线程处于wait状态，那么这个notify会唤醒其中的一个，不能虚发，具体可以参考 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4" target="_blank" rel="noopener">Java语言规范文档17.2.4</a></p><blockquote><p>The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption.</p><p>If a thread is both notified and interrupted while waiting, it may either:</p><ul><li>return normally from <code>wait</code>, while still having a pending interrupt (in other words, a call to <code>Thread.interrupted</code> would return true)</li><li>return from <code>wait</code> by throwing an <code>InterruptedException</code></li></ul><p>The thread may not reset its interrupt status and return normally from the call to <code>wait</code>.</p><p>Similarly, notifications cannot be lost due to interrupts. Assume that a set <em>s</em> of threads is in the wait set of an object <em>m</em>, and another thread performs a <code>notify</code> on <em>m</em>. Then either:</p><ul><li>at least one thread in <em>s</em> must return normally from <code>wait</code>, or</li><li>all of the threads in <em>s</em> must exit <code>wait</code> by throwing <code>InterruptedException</code></li></ul><p>Note that if a thread is both interrupted and woken via <code>notify</code>, and that thread returns from <code>wait</code> by throwing an <code>InterruptedException</code>, then some other thread in the wait set must be notified.</p></blockquote></li><li><p>如果先被notify()，那么线程会从wait中醒来，然后中断，设置中断标志位为 true，但不会在这个wait上抛出异常，而会影响后面的阻塞操作，具体可以看下面的Demo</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyInter</span> </span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        NotifyInter waitNotify = <span class="keyword">new</span> NotifyInter();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (object) {</span><br><span class="line">                    System.out.println(<span class="string">"线程1 获取到监视器锁"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">"线程1 正常恢复啦。但是 isInterrupt = "</span>+ Thread.currentThread().isInterrupted());</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        System.out.println(<span class="string">"线程1 wait方法抛出了InterruptedException异常"</span>);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        System.out.println(<span class="string">"在sleep中被中断"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">// 这里让 thread1 和 thread2 先起来，然后再起后面的 thread3</span></span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (object) {</span><br><span class="line">                    System.out.println(<span class="string">"线程3 拿到了监视器锁。"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程3 设置线程1中断"</span>);</span><br><span class="line">                    object.notify(); <span class="comment">//2</span></span><br><span class="line">                    waitNotify.a = <span class="number">1</span>; <span class="comment">// 这行是为了禁止上下的两行中断和notify代码重排序</span></span><br><span class="line">                    thread1.interrupt(); <span class="comment">// 1</span></span><br><span class="line">                    System.out.println(<span class="string">"线程3 调用notify"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程3 调用完notify后，休息一会"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"线程3 休息够了，结束同步代码块"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程3"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><p>这也是一道面试常问的题</p><p>① 首先<code>sleep()</code>是线程Thread的静态方法，<code>wait()</code>是<code>Object</code>类的实例方法</p><p>②<code>sleep()</code>不会释放锁对象，<code>wait()</code>会释放锁对象，这一点比较重要</p><p>③ 承接第二点，<code>wait()</code>会释放锁，但是要是你没有锁呢？其实就是上面语法层面说到的，所以调用<code>wait()</code>必须要<code>持有</code>锁对象否则就会报<code>IllegalMonitorStateException</code></p><p>④<code>sleep()</code>不需要被唤醒<code>timeout</code>后会自动醒来，而<code>wait()</code>需要被其他线程唤醒（<code>wait(long time)</code>除外）</p><h3 id="线程通讯综合案例"><a href="#线程通讯综合案例" class="headerlink" title="线程通讯综合案例"></a>线程通讯综合案例</h3><p>控制同一时间执行同一方法线程的数量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlThreadNum</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LinkedList THREADS = <span class="keyword">new</span> LinkedList<>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THREAD = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List<thread> worker = <span class="keyword">new</span> ArrayList();</thread></span><br><span class="line">        <span class="comment">//创建了十个线程，但是控制每次最多同时运行的只有5个</span></span><br><span class="line">        Arrays.asList(<span class="string">"M1"</span>, <span class="string">"M2"</span>, <span class="string">"M3"</span>, <span class="string">"M4"</span>, <span class="string">"M5"</span>, <span class="string">"M6"</span>, <span class="string">"M7"</span>, <span class="string">"M8"</span>, <span class="string">"M9"</span>, <span class="string">"M10"</span>).stream().map(ControlThreadNum::captureThread).forEach(t -> {</span><br><span class="line">            t.start();</span><br><span class="line">            worker.add(t);</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">//main线程等待worker的线程都执行完</span></span><br><span class="line">        worker.stream().forEach(thread -> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                thread.join();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        Optional.of(<span class="string">"All capture is done"</span>).ifPresent(System.out::println);</span><br><span class="line">        Optional.of(System.currentTimeMillis() - start).ifPresent(System.out::println);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Thread <span class="title">captureThread</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            Optional.of(<span class="string">"Thread "</span> + Thread.currentThread().getName() + <span class="string">"  is begin"</span>).ifPresent(System.out::println);</span><br><span class="line">            <span class="keyword">synchronized</span> (THREADS) {</span><br><span class="line">                <span class="keyword">while</span> (THREADS.size() >= MAX_THREAD) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        THREADS.wait();</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//THREADS 只是用来控制数量&锁 元素是什么并不重要</span></span><br><span class="line">                THREADS.addLast(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//到这里是并行</span></span><br><span class="line">            Optional.of(<span class="string">"Thread "</span> + Thread.currentThread().getName() + <span class="string">"  is running"</span>).ifPresent(System.out::println);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (THREADS) {</span><br><span class="line">                Optional.of(<span class="string">"Thread "</span> + Thread.currentThread().getName() + <span class="string">"  is end"</span>).ifPresent(System.out::println);</span><br><span class="line">                THREADS.removeLast();</span><br><span class="line">                THREADS.notifyAll();</span><br><span class="line">            }</span><br><span class="line">        }, name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里一开始一共创建了10个线程，但是执行的时候会控制<code>running</code>的个数小于5个，<code>runnning</code>线程个数用一个<code>LinkList</code>记录，若<code>size()>=5</code>就进入<code>wait</code>然后如果有线程<code>end</code>就会<code>notifyAll</code>唤醒进入等待状态的线程。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread M2  is begin</span><br><span class="line">Thread M3  is begin</span><br><span class="line">Thread M2  is running</span><br><span class="line">Thread M1  is begin</span><br><span class="line">Thread M1  is running</span><br><span class="line">Thread M3  is running</span><br><span class="line">Thread M4  is begin</span><br><span class="line">Thread M4  is running</span><br><span class="line">Thread M5  is begin</span><br><span class="line">Thread M6  is begin</span><br><span class="line">Thread M5  is running</span><br><span class="line">Thread M7  is begin</span><br><span class="line">Thread M8  is begin</span><br><span class="line">Thread M9  is begin</span><br><span class="line">Thread M10  is begin</span><br><span class="line">Thread M3  is `end`</span><br><span class="line">Thread M10  is running</span><br><span class="line">Thread M5  is `end`</span><br><span class="line">Thread M1  is `end`</span><br><span class="line">Thread M2  is `end`</span><br><span class="line">Thread M4  is `end`</span><br><span class="line">Thread M6  is running</span><br><span class="line">Thread M7  is running</span><br><span class="line">Thread M9  is running</span><br><span class="line">Thread M8  is running</span><br><span class="line">Thread M10  is end</span><br><span class="line">Thread M8  is end</span><br><span class="line">Thread M9  is end</span><br><span class="line">Thread M7  is end</span><br><span class="line">Thread M6  is end</span><br><span class="line">All capture is done</span><br><span class="line"><span class="number">20124</span></span><br></pre></td></tr></tbody></table></figure></div><p>这样就是其实就是为了提高效率，线程并不是越多越好，线程创建太多，就会达到瓶颈，效率反而会降低，因为时间都消耗在了<code>线程切换</code>上了，当然这是在没有<code>线程池</code>的情况下，后面用<code>线程池</code>就不会这么麻烦了。</p><h3 id="wait-notify的开销及问题"><a href="#wait-notify的开销及问题" class="headerlink" title="wait()/notify的开销及问题"></a>wait()/notify的开销及问题</h3><p><strong>过早唤醒</strong> </p><p> 比如生产者消费者问题中生产者生产后唤醒了生产者，其实就是过早唤醒了，过早唤醒使得那些本来无须被唤醒的等待线程也被唤醒了，从而造成资源浪费。这就好比你在人群里大喊一声“美女”，便会有许多自我感觉良好的女性回头一样——尽管你要喊的仅仅是其中某一个人，但大家却都以为你是在喊自己。过早唤醒问题可以利用JDK<br>1.5引入的<code>java.util.concurrent.locks.Condition</code>接口来解决，后面的文章会讲到。</p><p><strong>信号丢失</strong></p><p>信号丢失（Missed Signal）问题。如果等待线程在执行<code>Object.wait()</code>前没有先判断保护条件是否已然成立，那么有可能出现这种情形——通知线程在该等待线程进人临界区之前就已经更新了相关共享变量，使得相应的保护条件成立并进行了通知，但是此时等待线程还没有被暂停，自然也就无所谓唤醒了。这就可能造成等待线程直接执行<code>Object.wait()</code>而被暂停的时候，该线程由于没有其他线程进行通知而一直处于等待状态。这种现象就相当于等待线程错过了一个本来“发送”给它的“信号”，因此被称为信号丢失（Missed Signal）。只要将对保护条件的判断和<code>Object.wait()</code>调用放在一个循环语句之中就可以避免上述场景的信号丢失。信号丢失的另外一个表现是在应该调用<code>Object.notifyAll()</code> 的地方却调用了<code>Object.notify()</code>。比如，对于使用同一个保护条件的多个等待线程，如果通知线程在侦测到这个保护条件成立后调用的是<code>Object.notify()</code>，那么这些等待线程最多只有一个线程能够被唤醒，甚至一个也没有被唤醒——被唤醒的线程是<code>Object.notify()</code>所属对象上使用其他保护条件的一个等待线程！也就是说，尽管通知线程在调用<code>Object.notify()</code>前可能考虑（判断）了某个特定的保护条件是否成立，但是<code>Object.notify()</code>本身在其唤醒线程时是不考虑任何保护条件的！这就可能使得通知线程执行<code>Object.notify()</code>进行的通知对于使用相应保护条件的等待线程来说丢失了。这种情形下，避免信号丢失的一个方法是在必要的时候使用<code>Object.notifyAll()</code>来通知。总的来说，信号丢失本质上是一种代码错误，而不是Java标准库API自身的问题。</p><p><strong>欺骗性唤醒</strong></p><p>由于莫名其妙的原因，线程有可能在没有调用过<code>notify()</code>和<code>notifyAll()</code>的情况下醒来。这就是所谓的假唤醒（spurious wakeups），无端端地醒过来了，然而此时可能保护条件并没有成立。这个问题的解决同样是讲 保护条件和wait放在临界区内同一个循环体内就可以了。</p><p><strong>上下文切换</strong></p><p>​    首先，等待线程执行<code>Object.wait()</code>至少会导致该线程对相应对象内部锁的两次申请与释放。通知线程在执行<code>Object.notify()/notifyAll()</code>时需要持有相应对象的内部锁，因此<code>Object.notify()/notifyAll()</code>调用会导致一次锁的申请。而锁的申请与释放可能导致上下文切换。</p><p>​    其次，等待线程从被暂停到唤醒这个过程本身就会导致上下文切换。</p><p>​    再次，被唤醒的等待线程在继续运行时需要再次申请相应对象的内部锁，此时等待线程可能需要和相应对象的入口集中的其他线程以及其他新来的活跃线程（即申请相应的内部锁且处于RUNNABLE状态的线程）争用相应的内部锁，而这又可能导致上下文切换。<br>最后，过早唤醒问题也会导致额外的上下文切换，这是因为被过早唤醒的线程仍然需要继续等待，即再次经历被暂停和唤醒的过程。</p><p><a href="http://ifeve.com/thread-signaling/" target="_blank" rel="noopener">更多参考</a></p><h2 id="13-手写一个BooleanLock"><a href="#13-手写一个BooleanLock" class="headerlink" title="13.手写一个BooleanLock"></a>13.手写一个BooleanLock</h2><p><code>Synchronized</code>的缺点其实很明显，当多个线程竞争锁的时候，当一个线程抢到锁后其他的线程只能傻傻的等着，这样会影响效率，所以这里可以自己简单手写一个限制等待时间的锁。</p><h3 id="LOCK接口"><a href="#LOCK接口" class="headerlink" title="LOCK接口"></a>LOCK接口</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimeOutException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TimeOutException</span><span class="params">(String message)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> InterruptedException,TimeOutException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Collection<thread> <span class="title">getBlockThread</span><span class="params">()</span></thread></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>定义了一个<code>TimeOutException</code></p><h3 id="BooleanLock实现类"><a href="#BooleanLock实现类" class="headerlink" title="BooleanLock实现类"></a>BooleanLock实现类</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//false indicated free</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initValue;</span><br><span class="line">    <span class="comment">//加锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection<thread> blockThreadCollection = <span class="keyword">new</span> ArrayList<>();</thread></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BooleanLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.initValue = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">while</span> (initValue) {</span><br><span class="line">            blockThreadCollection.add(Thread.currentThread());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is wait"</span>);</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        blockThreadCollection.remove(Thread.currentThread());</span><br><span class="line">        <span class="keyword">this</span>.initValue = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.lockedThread = Thread.currentThread();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> InterruptedException, TimeOutException </span>{</span><br><span class="line">        <span class="keyword">if</span> (time <= <span class="number">0</span>) lock();</span><br><span class="line">        <span class="keyword">long</span> remainTime=time;</span><br><span class="line">        <span class="keyword">long</span> endTime=System.currentTimeMillis()+time;</span><br><span class="line">        <span class="keyword">while</span> (initValue){</span><br><span class="line">            <span class="keyword">if</span>(remainTime<=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeOutException(<span class="string">"time is out"</span>);</span><br><span class="line">            }</span><br><span class="line">            blockThreadCollection.add(Thread.currentThread());</span><br><span class="line">            <span class="keyword">this</span>.wait(time);</span><br><span class="line">            remainTime=endTime-System.currentTimeMillis();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.initValue=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.lockedThread=Thread.currentThread();</span><br><span class="line">        blockThreadCollection.remove(Thread.currentThread());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//判断是不是加锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (lockedThread == Thread.currentThread()) {</span><br><span class="line">            <span class="keyword">this</span>.initValue = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            Optional.of(Thread.currentThread().getName() + <span class="string">"  release the lock monitor"</span>).ifPresent(System.out::println);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection<thread> <span class="title">getBlockThread</span><span class="params">()</span> </thread></span>{</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableCollection(blockThreadCollection);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="测试BooleanLock的效果"><a href="#测试BooleanLock的效果" class="headerlink" title="测试BooleanLock的效果"></a>测试BooleanLock的效果</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> BooleanLock booleanLock = <span class="keyword">new</span> BooleanLock();</span><br><span class="line">        Stream.of(<span class="string">"t0"</span>, <span class="string">"t1"</span>, <span class="string">"t2"</span>).forEach(name -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    booleanLock.lock(<span class="number">10</span>);</span><br><span class="line">                    Optional.of(Thread.currentThread().getName() + <span class="string">" get the lock"</span>).ifPresent(System.out::println);</span><br><span class="line">                    doSomething();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (Lock.TimeOutException e) {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" Time out"</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    booleanLock.unLock();</span><br><span class="line">                }</span><br><span class="line">            }, name).start();</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">//main线程释放锁，不应该，谁加的锁应该由谁去释放锁</span></span><br><span class="line">        <span class="comment">//booleanLock.unLock();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>{</span><br><span class="line">        Optional.of(Thread.currentThread().getName() + <span class="string">" is working..."</span>).ifPresent(System.out::println);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里设置在抢不到锁的时候，只等待<code>10ms</code>，然后<code>doSomething</code>会<code>sleep</code>5000ms，所以只有一个线程可以抢到锁后面的都会超时 throw <code>TimeOutException</code>典型的<code>限时等待</code>模型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">t0 get the lock</span><br><span class="line">t0 is working...</span><br><span class="line">`base_thread_study.chaper10.Lock$TimeOutException: time is out`</span><br><span class="line">at base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:<span class="number">41</span>)</span><br><span class="line">at base_thread_study.chaper10.LockTest.lambda$<span class="keyword">null</span>$<span class="number">0</span>(LockTest.java:<span class="number">12</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">`base_thread_study.chaper10.Lock$TimeOutException: time is out`</span><br><span class="line">at base_thread_study.chaper10.BooleanLock.lock(BooleanLock.java:<span class="number">41</span>)</span><br><span class="line">at base_thread_study.chaper10.LockTest.lambda$<span class="keyword">null</span>$<span class="number">0</span>(LockTest.java:<span class="number">12</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">t2 Time out</span><br><span class="line">t1 Time out</span><br><span class="line">t0  release the lock monitor</span><br></pre></td></tr></tbody></table></figure></div><h2 id="14-给应用程序注入钩子Hook"><a href="#14-给应用程序注入钩子Hook" class="headerlink" title="14.给应用程序注入钩子Hook"></a>14.给应用程序注入钩子Hook</h2><p>关于<code>Hook</code>是什么就不多介绍了，这里的钩子和<code>git</code>,<code>svn</code>里面的是一样的，类似的在使用<code>Tomcat</code>等服务的时候，在你关闭它之后它仍然会打印日志和释放一些资源，这就是<code>Hook</code>的一种，当然<code>Hook</code>有多种，这只是其中一种。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitCap</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []arg)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(()->{</span><br><span class="line">       System.out.println(<span class="string">"The test app will shutdown"</span>);</span><br><span class="line">    notifyAndRelease();</span><br><span class="line">}));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">"i am working"</span>);</span><br><span class="line">}<span class="keyword">catch</span>(Exception e){</span><br><span class="line"> <span class="comment">//donothing</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(i><span class="number">10</span>){</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">}</span><br><span class="line">i++;    </span><br><span class="line">}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyAndRelease</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"notify to admin"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">}<span class="keyword">catch</span>(Exception e){}</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"release the resources(socker. file, connection.)"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        }<span class="keyword">catch</span>(Exception e){}</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"release and notify done"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里是在<code>Linux</code>上进行的测试，因为效果比较明显，顺便也熟悉下<code>Linux</code>的命令，可以看到上面的钩子就是通过<code>Runtime.getRuntime().addShutdownHook()</code>注入了一个<code>Thread</code>进去的，这样就会检测到程序的退出并触发<code>Hook</code>做一些释放资源之类的工作。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">i am working</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException</span><br><span class="line">at base_thread_study.chaper10.ExitCap.main(ExitCap.java:<span class="number">18</span>)</span><br><span class="line">i am working</span><br><span class="line">`The test app will shutdown`</span><br><span class="line">`notify to admin`</span><br><span class="line">`<span class="function">release the <span class="title">resources</span><span class="params">(socker. file, connection.)</span>`</span></span><br><span class="line"><span class="function">`release and notify done`</span></span><br></pre></td></tr></tbody></table></figure></div><p>上面是在正常情况下终止线程比如 <code>异常</code>，<code>ctrl C</code>或者 <code>kill pid</code>如果使用 <code>kill -9 pid</code>就不会触发钩子，强制停止，所以一般不建议用<code>kill -9</code></p><h2 id="15-捕获线程的Runtime异常"><a href="#15-捕获线程的Runtime异常" class="headerlink" title="15.捕获线程的Runtime异常"></a>15.捕获线程的Runtime异常</h2><p>在Java多线程环境下，所有线程都不允许抛出未捕获的<code>checked exception</code>(比如sleep的InterruptException)，也就是各个线程必须自己把自己的<code>checked exception</code>处理掉，但是如果是<code>unchecked exception</code>呢？主要就是指<code>RuntimeException</code>此类异常抛出时该线程会<code>shutdown</code>但是其它线程不受影响也无法感知到这个异常，就像下面的例子</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadException</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            thread=<span class="keyword">new</span> Thread(()->{</span><br><span class="line">                <span class="keyword">int</span> res=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            });</span><br><span class="line">            thread.start();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            System.out.println(<span class="string">"捕获到异常"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>控制台输出<code>main线程</code>并没有捕获到异常，其实这也是一种很好的理念，每个线程的事情应该由线程自己去处理不应该由其他线程去干扰，正如<code>stop/resume/suspend</code>这些方法被弃用的原因。但是这些异常如果不去处理可能会导致一些严重的后果，JDK1.5之后官方也提供了API去处理线程的异常。setDefaultUncaughtExceptionHandler()和setUncaughtExceptionHandler()前者是<code>Thread</code>的静态方法，用于给所有的线程设置默认的异常处理，后者是实例方法，针对每个线程会给每个线程加上一个异常处理器，如下Demo</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadException</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">              <span class="keyword">int</span> res = A / B;</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//最好在start前设置异常处理器，放在后面可能会起不到作用。</span></span><br><span class="line">        thread.setUncaughtExceptionHandler((t, e) -> {</span><br><span class="line">            System.out.println(t.getName());</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        });</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p><code>Thread-0</code><br><code>java.lang.ArithmeticException: / by zero</code></p></blockquote><p>可以看到已经捕获到了这个异常，当线程遇到未捕获的异常而结束时会调用<code>UncaughtExceptionHandler</code> 处理一些”后事”和释放一些宝贵的资源，<code>setUncaughtExceptionHandler</code>建议放在线程start之前，不然可能起不到作用。</p><h2 id="16-ThreadGroup线程组"><a href="#16-ThreadGroup线程组" class="headerlink" title="16.ThreadGroup线程组"></a>16.ThreadGroup线程组</h2><h3 id="获取线程组信息"><a href="#获取线程组信息" class="headerlink" title="获取线程组信息"></a>获取线程组信息</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupAPI</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ThreadGroup tgp = <span class="keyword">new</span> ThreadGroup(<span class="string">"TGP1"</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(tgp, <span class="string">"t0"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        System.out.println(getThreadGroup().getName());</span><br><span class="line">                        System.out.println(getThreadGroup().getParent());</span><br><span class="line">                        <span class="comment">//可以访问，文档上说不行</span></span><br><span class="line">                        System.out.println(getThreadGroup().getParent().activeCount());</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        ThreadGroup tgp2 = <span class="keyword">new</span> ThreadGroup(<span class="string">"TGP2"</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(tgp2, <span class="string">"t0"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(tgp.getName());</span><br><span class="line">                System.out.println(tgp.activeCount());</span><br><span class="line">                Thread[] threads=<span class="keyword">new</span> Thread[tgp.activeCount()];</span><br><span class="line">                tgp.enumerate(threads);</span><br><span class="line">                <span class="comment">//也可以访问</span></span><br><span class="line">                Arrays.asList(threads).forEach(System.out::println);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//System.out.println(tgp2.getName());</span></span><br><span class="line">        <span class="comment">//System.out.println(tgp2.getParent().getName());</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>文档上说的不能访问其他线程组的信息，这里测试的几个都可以，可能描述有点问题，<code>线程组</code>的创建类似于<code>线程</code>的创建，如果没有显示的指定线程组都会默认加到父线程的线程组中。</p><h3 id="打断线程组interrupt"><a href="#打断线程组interrupt" class="headerlink" title="打断线程组interrupt()"></a>打断线程组interrupt()</h3><blockquote><p>Interrupts all threads in this thread group.</p><p>First, the <code>checkAccess</code> method of this thread group is</p><p>called with no arguments; this may result in a security exception.</p><p>This method then calls the <code>interrupt</code> method on all the</p><p>threads in this thread group and in <code>all of its subgroups.</code></p></blockquote><p>打断该线程组里面所有的线程，包括子线程组的线程。</p><h3 id="线程组setDaemon"><a href="#线程组setDaemon" class="headerlink" title="线程组setDaemon()"></a>线程组setDaemon()</h3><p>和线程的<code>setDaemon</code>不一样。</p><blockquote><p>Changes the daemon status of this thread group.</p><p>First, the <code>checkAccess</code> method of this thread group is</p><p>called with no arguments; this may result in a security exception.</p><p>A daemon thread group is <code>automatically</code> <code>destroyed</code> when its last</p><p>thread is stopped or its <code>last thread group is destroyed</code>.</p></blockquote><p>当最后一个线程执行完毕后自动销毁线程组，当然与其对应的也有手动销毁的方法<code>destroy()</code>这个方法如果线程没执行完毕就调用会抛<code>IllegalThreadStateException</code>，其他的方法详细可以参考文档。</p><h2 id="17-线程池"><a href="#17-线程池" class="headerlink" title="17.线程池"></a>17.线程池</h2><h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><p> 创建和销毁线程开销大，利用好线程池可以避免cpu花费不必要的时间在这上面，从而专注于具体的任务:)</p><p>基本的线程池包括下面几部分：</p><p>①任务队列</p><p>②拒绝策略(抛出异常，直接丢弃，阻塞，临时队列)</p><p>③<code>init</code>(<code>min</code>)初始大小</p><p>④<code>active</code>中间常态大小</p><p>⑤<code>max</code>最大个数，超过就会加到任务队列中，任务队列也满就会执行拒绝策略</p><blockquote><p>min<=active<=max</p></blockquote><h3 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h3><h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadPool</span> </span>{</span><br><span class="line">    <span class="comment">//线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> LinkedList<runnable> TASK_QUEUE = <span class="keyword">new</span> LinkedList<>();</runnable></span><br><span class="line"><span class="comment">//线程序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadGroup GROUP = <span class="keyword">new</span> ThreadGroup(<span class="string">"Pool_Group"</span>);</span><br><span class="line"><span class="comment">//线程前缀名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String THREAD_PREFIX = <span class="string">"SIMPLE_THREAD_POOL-"</span>;</span><br><span class="line"><span class="comment">//线程队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List<mythread> THREAD_QUEUE = <span class="keyword">new</span> ArrayList<>();</mythread></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        init();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SIZE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; i++) {</span><br><span class="line">            createThreadQueue();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴露对外的接口，提交任务队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (TASK_QUEUE) {</span><br><span class="line">            TASK_QUEUE.addLast(runnable);</span><br><span class="line">            <span class="comment">//唤醒线程池中的线程</span></span><br><span class="line">            TASK_QUEUE.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createThreadQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread(GROUP, THREAD_PREFIX + (seq++));</span><br><span class="line">        thread.start();</span><br><span class="line">        THREAD_QUEUE.add(thread);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ThreadState {</span><br><span class="line">        FREE, RUNNING, BLOCKED, DEAD</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包装的线程类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState threadState = ThreadState.FREE;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ThreadState <span class="title">getThreadState</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.threadState;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(ThreadGroup group, String name)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(group, name);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            OUTER:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.threadState != ThreadState.DEAD) {</span><br><span class="line">                <span class="comment">//当前线程没有dead</span></span><br><span class="line">                Runnable runnable;</span><br><span class="line">                <span class="keyword">synchronized</span> (TASK_QUEUE) {</span><br><span class="line">                    <span class="keyword">while</span> (TASK_QUEUE.isEmpty()) {</span><br><span class="line">                        <span class="comment">//任务队列为空，全员wait</span></span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">this</span>.threadState = ThreadState.BLOCKED;</span><br><span class="line">                            TASK_QUEUE.wait();</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            System.out.println(<span class="string">"break"</span>);</span><br><span class="line">                            <span class="keyword">break</span> OUTER;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    runnable = TASK_QUEUE.removeFirst();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//这里应该并行</span></span><br><span class="line">                Optional.of(runnable).ifPresent(t -> {</span><br><span class="line">                    <span class="keyword">this</span>.threadState = ThreadState.RUNNING;</span><br><span class="line">                    t.run();</span><br><span class="line">                    <span class="keyword">this</span>.threadState = ThreadState.FREE;</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.threadState = ThreadState.DEAD;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>最开始实现的时候<code>synchronized</code>的范围太大，将具体的执行<code>run</code>的过程也同步了起来，这明显是有问题的，只需要同步共享变量就可以了，同步了后面的代码那就跟单线程一样了。</p><h4 id="关闭线程池-amp-拒绝策略"><a href="#关闭线程池-amp-拒绝策略" class="headerlink" title="关闭线程池&拒绝策略"></a>关闭线程池&拒绝策略</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadPool</span> </span>{</span><br><span class="line">    <span class="comment">//线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//任务队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueSize;</span><br><span class="line"><span class="comment">//默认线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//线程池中线程编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//默认任务队列的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_TASK_QUEUE_SIZE = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadGroup GROUP = <span class="keyword">new</span> ThreadGroup(<span class="string">"Pool_Group"</span>);</span><br><span class="line"><span class="comment">//线程名前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String THREAD_PREFIX = <span class="string">"SIMPLE_THREAD_POOL-"</span>;</span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> LinkedList<runnable> TASK_QUEUE = <span class="keyword">new</span> LinkedList<>();</runnable></span><br><span class="line"><span class="comment">//线程队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List<mythread> THREAD_QUEUE = <span class="keyword">new</span> ArrayList<>();</mythread></span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscardPolicy discardPolicy;</span><br><span class="line"><span class="comment">//线程次是否销毁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroy = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//默认的拒绝策略（抛异常）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DiscardException(<span class="string">"Discard this Task!!!!(Default Policy)"</span>);</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> queueSize, DiscardPolicy discardPolicy)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.queueSize = queueSize;</span><br><span class="line">        <span class="keyword">this</span>.discardPolicy = discardPolicy;</span><br><span class="line">        init();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < size; i++) {</span><br><span class="line">            createThreadQueue();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (destroy) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The Pool is shutdown , you can't submit now ! !"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (TASK_QUEUE) {</span><br><span class="line">            <span class="keyword">if</span> (TASK_QUEUE.size() > queueSize) {</span><br><span class="line">                discardPolicy.discard();</span><br><span class="line">            }</span><br><span class="line">            TASK_QUEUE.addLast(runnable);</span><br><span class="line">            <span class="comment">//唤醒线程池中的线程</span></span><br><span class="line">            TASK_QUEUE.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">//判断任务队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> (!TASK_QUEUE.isEmpty()) {</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> initVal = THREAD_QUEUE.size();</span><br><span class="line">        <span class="keyword">while</span> (initVal > <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span> (MyThread thread : THREAD_QUEUE) {</span><br><span class="line">                <span class="keyword">if</span> (thread.getThreadState() == ThreadState.BLOCKED) {</span><br><span class="line">                    thread.close();</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                    initVal--;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.destroy = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"My Thread pool is shutdown"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.destroy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createThreadQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread(GROUP, THREAD_PREFIX + (seq++));</span><br><span class="line">        thread.start();</span><br><span class="line">        THREAD_QUEUE.add(thread);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ThreadState {</span><br><span class="line">        FREE, RUNNING, BLOCKED, DEAD</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardException</span><span class="params">(String message)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscardPolicy</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">discard</span><span class="params">()</span> <span class="keyword">throws</span> DiscardException</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState threadState = ThreadState.FREE;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ThreadState <span class="title">getThreadState</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.threadState;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(ThreadGroup group, String name)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(group, name);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            OUTER:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.threadState != ThreadState.DEAD) {</span><br><span class="line">                Runnable runnable;</span><br><span class="line">                <span class="keyword">synchronized</span> (TASK_QUEUE) {</span><br><span class="line">                    <span class="keyword">while</span> (TASK_QUEUE.isEmpty()) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">this</span>.threadState = ThreadState.BLOCKED;</span><br><span class="line">                            TASK_QUEUE.wait();</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" is dead"</span>);</span><br><span class="line">                            <span class="keyword">break</span> OUTER;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    runnable = TASK_QUEUE.removeFirst();</span><br><span class="line">                }</span><br><span class="line">                Optional.of(runnable).ifPresent(t -> {</span><br><span class="line">                    <span class="keyword">this</span>.threadState = ThreadState.RUNNING;</span><br><span class="line">                    t.run();</span><br><span class="line">                    <span class="keyword">this</span>.threadState = ThreadState.FREE;</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.threadState = ThreadState.DEAD;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li><code>shutdown</code>方法实现</li></ul><p>①先轮询任务队列是否为空，不为空就会让<code>当前线程</code>等待<code>线程队列</code>的线程执行完所有任务。</p><p>②当任务队列为空时，遍历<code>线程队列</code>，然后打断<code>BLOCK</code>的线程并且设置为<code>DEAD</code>状态跳出循环，因为<code>任务队列</code>为空<code>线程队列</code>里面的线程都会在<code>TASK_QUEUE</code>上面<code>BLOCK</code>住，但是也存在特殊情况，可能某个线程刚拿到最后一个任务，这种情况我们可以稍微等一下，等它<code>BLOCK</code>，毕竟这是个<code>lg(N)-lg(N2)</code>的方法</p><p>③设置<code>destory</code>状态为true，然后在<code>submit</code>的时候会根据这个变量来判断是否已经销毁，如果已经销毁就会抛出一个<code>RunntimeException</code></p><ul><li><code>拒绝策略</code>实现</li></ul><p>这里实现了一个·默认的拒绝策略，抛出异常，在submit的时候判断任务队列是不是满的，如果满了就直接抛异常，这里如果用这种方式拒绝，一但出现异常<code>当前线程</code>就会<code>直接结束</code>可能就无法关闭连接池。</p><h4 id="自动扩容-amp-闲时回收"><a href="#自动扩容-amp-闲时回收" class="headerlink" title="自动扩容&闲时回收"></a>自动扩容&闲时回收</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadPool</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="comment">//线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//线程大小变化值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> active;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="comment">//默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> ACTIVE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//任务队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActive</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> active;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中线程编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//默认任务队列的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_TASK_QUEUE_SIZE = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadGroup GROUP = <span class="keyword">new</span> ThreadGroup(<span class="string">"Pool_Group"</span>);</span><br><span class="line">    <span class="comment">//线程名前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String THREAD_PREFIX = <span class="string">"SIMPLE_THREAD_POOL-"</span>;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> LinkedList<runnable> TASK_QUEUE = <span class="keyword">new</span> LinkedList<>();</runnable></span><br><span class="line">    <span class="comment">//线程队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List<mythread> THREAD_QUEUE = <span class="keyword">new</span> ArrayList<>();</mythread></span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscardPolicy discardPolicy;</span><br><span class="line">    <span class="comment">//线程池是否销毁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroy = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//默认的拒绝策略（抛异常）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DiscardException(<span class="string">"Discard this Task!!!!(Default Policy)"</span>);</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> active, <span class="keyword">int</span> max, <span class="keyword">int</span> queueSize, DiscardPolicy discardPolicy)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.queueSize = queueSize;</span><br><span class="line">        <span class="keyword">this</span>.discardPolicy = discardPolicy;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">        <span class="keyword">this</span>.active = active;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        init();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(MIN, ACTIVE, MAX, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池的线程，维护整个线程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!destroy) {</span><br><span class="line">            System.err.printf(<span class="string">"Pool#min:%d,active:%d,max:%d,currentSize:%d,taskRemain:%d\n"</span>,</span><br><span class="line">                    <span class="keyword">this</span>.min, <span class="keyword">this</span>.active, <span class="keyword">this</span>.max, <span class="keyword">this</span>.size, TASK_QUEUE.size());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">if</span> (TASK_QUEUE.size() > active && size < active) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i < active; i++) {</span><br><span class="line">                        createThreadQueue();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"increment to active success"</span>);</span><br><span class="line">                    <span class="keyword">this</span>.size = active;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (TASK_QUEUE.size() > max && size < MAX) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i < max; i++) {</span><br><span class="line">                        createThreadQueue();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(<span class="string">"increment to max success"</span>);</span><br><span class="line">                    <span class="keyword">this</span>.size = max;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (TASK_QUEUE.isEmpty() && size > active) {</span><br><span class="line">                    System.out.println(<span class="string">"==================reduce================="</span>);</span><br><span class="line">                    <span class="comment">//防止并发修改，在shutdown的时候reduce</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (THREAD_QUEUE) {</span><br><span class="line">                        <span class="keyword">int</span> release = size - active;</span><br><span class="line">                        <span class="comment">//Itertor可以在遍历的过程中remove</span></span><br><span class="line">                        <span class="keyword">for</span> (Iterator<mythread> it = THREAD_QUEUE.iterator(); it.hasNext(); ) {</mythread></span><br><span class="line">                            <span class="keyword">if</span> (release <= <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            MyThread mt = it.next();</span><br><span class="line">                            <span class="comment">//如果该线程在工作就不要打断它</span></span><br><span class="line">                            <span class="keyword">if</span>(mt.getThreadState()==ThreadState.RUNNING){</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            }</span><br><span class="line">                            mt.close();</span><br><span class="line">                            mt.interrupt();</span><br><span class="line">                            it.remove();</span><br><span class="line">                            release--;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">this</span>.size = active;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">/*    for (int i = 0; i < size; i++) {</span></span><br><span class="line"><span class="comment">            createThreadQueue();</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="keyword">this</span>.min; i++) {</span><br><span class="line">            createThreadQueue();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.size = min;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (destroy) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The Pool is shutdown , you can't submit now ! !"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (TASK_QUEUE) {</span><br><span class="line">            <span class="keyword">if</span> (TASK_QUEUE.size() > queueSize) {</span><br><span class="line">                discardPolicy.discard();</span><br><span class="line">            }</span><br><span class="line">            TASK_QUEUE.addLast(runnable);</span><br><span class="line">            <span class="comment">//唤醒线程池中的线程</span></span><br><span class="line">            TASK_QUEUE.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">while</span> (!TASK_QUEUE.isEmpty()) {</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> initVal = THREAD_QUEUE.size();</span><br><span class="line">        <span class="keyword">synchronized</span> (THREAD_QUEUE) {</span><br><span class="line">            <span class="keyword">while</span> (initVal > <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">for</span> (MyThread thread : THREAD_QUEUE) {</span><br><span class="line">                    <span class="keyword">if</span> (thread.getThreadState() == ThreadState.BLOCKED) {</span><br><span class="line">                        <span class="comment">//设置为DEAD状态</span></span><br><span class="line">                        thread.close();</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                        initVal--;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.destroy = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"My Thread pool is shutdown"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.destroy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createThreadQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread(GROUP, THREAD_PREFIX + (seq++));</span><br><span class="line">        thread.start();</span><br><span class="line">        THREAD_QUEUE.add(thread);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> ThreadState {</span><br><span class="line">        FREE, RUNNING, BLOCKED, DEAD</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardException</span><span class="params">(String message)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscardPolicy</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">discard</span><span class="params">()</span> <span class="keyword">throws</span> DiscardException</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState threadState = ThreadState.FREE;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ThreadState <span class="title">getThreadState</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.threadState;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(ThreadGroup group, String name)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(group, name);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            OUTER:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.threadState != ThreadState.DEAD) {</span><br><span class="line">                Runnable runnable;</span><br><span class="line">                <span class="keyword">synchronized</span> (TASK_QUEUE) {</span><br><span class="line">                    <span class="keyword">while</span> (TASK_QUEUE.isEmpty()) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">this</span>.threadState = ThreadState.BLOCKED;</span><br><span class="line">                            TASK_QUEUE.wait();</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" is dead"</span>);</span><br><span class="line">                            <span class="keyword">break</span> OUTER;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    runnable = TASK_QUEUE.removeFirst();</span><br><span class="line">                }</span><br><span class="line">                Optional.of(runnable).ifPresent(t -> {</span><br><span class="line">                    <span class="keyword">this</span>.threadState = ThreadState.RUNNING;</span><br><span class="line">                    t.run();</span><br><span class="line">                    <span class="keyword">this</span>.threadState = ThreadState.FREE;</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.threadState = ThreadState.DEAD;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>相比上面固定的size这个版本</p><p>① 增加了三个字段用于动态的扩容，因为需要管理这些线程，所以将整个线程池也继承了<code>Thread</code>并实现了run方法，主要就是判断<code>TASK_QUEUE.size() > active && size < active</code>当前任务队列任务多于<code>active</code>并且当前线程队列线程数小于<code>active</code>，就可以扩容到active，max同理</p><p>②<code>TASK_QUEUE.isEmpty() && size > active</code> 闲时回收，任务队列没有任务，但是线程队列线程还很多，浪费了资源，所以需要<code>reduce</code>一些空闲的线程。这里有两个小细节，1.在reduce和shutdown的时候需要同步<code>线程队列</code>不然在<code>reduce</code>的时候<code>shutdown</code>会产生<code>并发修改异常</code>（一个在遍历，一个在remove）。</p><h3 id="测试线程池"><a href="#测试线程池" class="headerlink" title="测试线程池"></a>测试线程池</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        SimpleThreadPool threadPool= <span class="keyword">new</span> SimpleThreadPool();</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line">                .forEach(i -> {</span><br><span class="line">                    threadPool.submit(() -> {</span><br><span class="line">                        System.out.println(<span class="string">"The task "</span> + i + <span class="string">"  runnable by thread "</span> + Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                        System.out.println(<span class="string">"The task "</span> + i + <span class="string">"  runnable by thread "</span> + Thread.currentThread().getName() + <span class="string">" end"</span>);</span><br><span class="line">                    });</span><br><span class="line">                    System.out.println(<span class="string">"submit "</span> + i);</span><br><span class="line">                });</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java多线程编程实战指南》 </li><li><a href="http://ifeve.com" target="_blank" rel="noopener">并发编程网</a></li><li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.2.4" target="_blank" rel="noopener">Java语言规范</a></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode链表</title>
      <link href="/2019/02/27/leetcode-lian-biao/"/>
      <url>/2019/02/27/leetcode-lian-biao/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。<br> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><strong>示例：</strong><br><strong>输入：</strong>(2 -> 4 -> 3) + (5 -> 6 -> 4)<br><strong>输出</strong>：7 -> 0 -> 8<br><strong>原因</strong>：342 + 465 = 807</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">     <span class="comment">// 先用0补齐短的哪一个</span></span><br><span class="line">       ListNode n1 = l1;</span><br><span class="line">       ListNode n2 = l2;</span><br><span class="line">       <span class="keyword">while</span> (n1 != <span class="keyword">null</span> && n2 != <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">if</span> (n1.next == <span class="keyword">null</span> && n2.next != <span class="keyword">null</span>) {</span><br><span class="line">               n1.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (n1.next != <span class="keyword">null</span> && n2.next == <span class="keyword">null</span>) {</span><br><span class="line">               n2.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (n1.next == <span class="keyword">null</span> && n2.next == <span class="keyword">null</span>) {</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           }</span><br><span class="line">           n1 = n1.next;</span><br><span class="line">           n2 = n2.next;</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">// 从头开始加</span></span><br><span class="line">       ListNode res = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//实际操作的链表</span></span><br><span class="line">       ListNode real=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 进位</span></span><br><span class="line">       <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) {</span><br><span class="line">           <span class="comment">// 当前位</span></span><br><span class="line">           m = (l1.val + l2.val) % <span class="number">10</span>+n;</span><br><span class="line">           <span class="comment">// 判断进位后是否为10</span></span><br><span class="line">           <span class="keyword">if</span>(m==<span class="number">10</span>) {</span><br><span class="line">               m=<span class="number">0</span>;</span><br><span class="line">               n=<span class="number">1</span>;</span><br><span class="line">           }<span class="keyword">else</span> {         </span><br><span class="line">            <span class="comment">// 进位 0 or 1</span></span><br><span class="line">            n = (l1.val + l2.val) / <span class="number">10</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// 添加到原链表的后面</span></span><br><span class="line">           <span class="comment">// 判断是不是第一次</span></span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">               real=res = <span class="keyword">new</span> ListNode(m);</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               ListNode temp = <span class="keyword">new</span> ListNode(m);</span><br><span class="line">               real.next = temp;</span><br><span class="line">               real=temp;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">//判断位数相同的情况下最后一位和大于10的情况</span></span><br><span class="line">           <span class="keyword">if</span>(n==<span class="number">1</span>&&l1.next==<span class="keyword">null</span>) {</span><br><span class="line">               <span class="comment">//在最后加个1</span></span><br><span class="line">               real.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">           }</span><br><span class="line">           l2 = l2.next;</span><br><span class="line">           l1 = l1.next;</span><br><span class="line">           i++;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>很久之前写的代码了，代码很乱，用0补齐短的那个然后对应相加注意进位就行了。</p><h2 id="445-两数相加Ⅱ"><a href="#445-两数相加Ⅱ" class="headerlink" title="445. 两数相加Ⅱ"></a>445. 两数相加Ⅱ</h2><p>给定两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br><strong>进阶:</strong><br>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。<br><strong>示例:</strong><br><strong>输入:</strong> (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)<br><strong>输出:</strong> 7 -> 8 -> 0 -> 7</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">    BigInteger b1 = <span class="keyword">new</span> BigInteger(list2num(l1));</span><br><span class="line">    BigInteger b2 = <span class="keyword">new</span> BigInteger(list2num(l2));</span><br><span class="line">    String resStr=b1.add(b2).toString();</span><br><span class="line">    <span class="comment">//再变成字符串存到连表里面</span></span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode real=res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<resstr.length();i++) {< span><br><span class="line">        real.next=<span class="keyword">new</span> ListNode(Integer.valueOf(resStr.charAt(i)-<span class="number">48</span>));</span><br><span class="line">        real=real.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String  <span class="title">list2num</span><span class="params">(ListNode l)</span></span>{</span><br><span class="line">    String num=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=<span class="keyword">null</span>){</span><br><span class="line">        num=num+l.val;</span><br><span class="line">        l=l.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br></resstr.length();i++)></span></pre></td></tr></tbody></table></figure></div><p>这两题方法很多，下面那题实际上是上面那一题反过来的，但是题目要求不改变链表所以可以利用栈来反转，然后就跟上面的类似了，然后这里我偷了个懒用的<code>BigInteger</code>搞的速度也还行 77%beat。</p><hr><h2 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876. 链表的中间节点"></a><strong>876. 链表的中间节点</strong></h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="comment">// 1 2 3 4 5 6 7</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&&fast.next!=<span class="keyword">null</span>){</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p><code>快慢指针</code>，很常见很经典的做法后面很多题会用到这个。</p></blockquote><hr><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><strong>206. 反转链表</strong></h2><p>反转一个单链表。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1->2->3->4->5->NULL<br><strong>输出:</strong> 5->4->3->2->1->NULL</p><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p><strong>解法一:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    ListNode newHead = reverseList(head.next);</span><br><span class="line">    <span class="comment">//从后往前</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//三指针迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    ListNode cur=head.next;</span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">        temp=cur.next;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=temp;</span><br><span class="line">    }</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="92-反转链表Ⅱ"><a href="#92-反转链表Ⅱ" class="headerlink" title="92. 反转链表Ⅱ"></a><strong>92. 反转链表Ⅱ</strong></h2><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1->2->3->4->5->NULL, <em>m</em> = 2, <em>n</em> = 4<br><strong>输出:</strong> 1->4->3->2->5->NULL</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(m==n) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//用来遍历</span></span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    ListNode mid=head.next;</span><br><span class="line">    ListNode rear=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//在遍历的中间连接这个表 时间复杂厚度O(N)</span></span><br><span class="line">    <span class="comment">//所以需要先保存 m前的节点用于后面到n的时候连接n和前面的部分 preM</span></span><br><span class="line">    <span class="comment">//还要保存m节点，在后面遍历到n的时候将M节点和后面的部分连接</span></span><br><span class="line">    <span class="comment">//中间段的前后节点 </span></span><br><span class="line">    ListNode preM =<span class="keyword">null</span>;</span><br><span class="line">    ListNode valM=head;</span><br><span class="line">    <span class="comment">//ListNode nNext=null;</span></span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(count <=n-<span class="number">1</span>){</span><br><span class="line">        <span class="comment">//count的位置实际上是指的pre的位置因为只有pre是从head开始走的</span></span><br><span class="line">        <span class="comment">//尾指针后移</span></span><br><span class="line">        rear=mid.next;</span><br><span class="line">        <span class="keyword">if</span>(count==m-<span class="number">1</span>){</span><br><span class="line">            <span class="comment">//保存M点前面的节点和M节点</span></span><br><span class="line">            preM=pre;</span><br><span class="line">            valM=mid;</span><br><span class="line">            <span class="comment">//System.out.println("preM :"+preM.val);</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(count==n-<span class="number">1</span>){</span><br><span class="line">            <span class="comment">//连接n后面节点的值</span></span><br><span class="line">            valM.next=rear;</span><br><span class="line">            <span class="comment">//在这里判断下m前有没有元素</span></span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">1</span>){</span><br><span class="line">                head=mid;</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                preM.next=mid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(count >= m && count <=n-<span class="number">1</span>){</span><br><span class="line">            <span class="comment">//只有mid的位置大于m小于等于n才会将节点next域反转</span></span><br><span class="line">            mid.next=pre;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//其他两个指针也向后移动</span></span><br><span class="line">        pre=mid;</span><br><span class="line">        mid=rear;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>代码写的比较烂但是思路还是比较清晰，只扫描了一遍链表 2ms beat 100%，但是创建的指针有点多，抠边界要细心。</p><hr><h2 id="725-分隔链表"><a href="#725-分隔链表" class="headerlink" title="725. 分隔链表"></a><strong><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">725. 分隔链表</a></strong></h2><p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p><p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p><p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p><p>Return a List of ListNode’s representing the linked list parts that are formed.</p><p>Examples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p><p><strong>Example 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">root = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], k = <span class="number">5</span></span><br><span class="line">Output: [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[],[]]</span><br><span class="line">Explanation:</span><br><span class="line">The input and each element of the output are ListNodes, not arrays.</span><br><span class="line">For example, the input root has root.val = <span class="number">1</span>, root.next.val = <span class="number">2</span>, \root.next.next.val = <span class="number">3</span>, and root.next.next.next = <span class="keyword">null</span>.</span><br><span class="line">The first element output[<span class="number">0</span>] has output[<span class="number">0</span>].val = <span class="number">1</span>, output[<span class="number">0</span>].next = <span class="keyword">null</span>.</span><br><span class="line">The last element output[<span class="number">4</span>] is <span class="keyword">null</span>, but it<span class="string">'s string representation as a ListNode is [].</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>Example 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">root = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], k = <span class="number">3</span></span><br><span class="line">Output: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br><span class="line">Explanation:</span><br><span class="line">The input has been split into consecutive parts with size difference at most <span class="number">1</span>, and earlier parts are a larger size than the later parts.</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Note:</strong></p><p>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</p><p>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</p><p><code>k</code> will be an integer in the range <code>[1, 50]</code>.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) {</span><br><span class="line">    <span class="comment">//先要获取下链表的长度</span></span><br><span class="line">    ListNode temp=root;</span><br><span class="line">    ListNode next=root;</span><br><span class="line">    ListNode [] result=<span class="keyword">new</span> ListNode[k];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        temp=temp.next;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    temp=root;</span><br><span class="line">    <span class="comment">//任意两部分差距不能大于1，大的在前，小的在后面</span></span><br><span class="line">    <span class="comment">//其实就是对count进行分配</span></span><br><span class="line">    <span class="comment">//注意: 有null的情况一定是 k>count 直接按 1 切分就完事了</span></span><br><span class="line">    <span class="comment">//k<count的情况只要在 count k 的前几个元素上加上 的余数就行了< span></count的情况只要在></span><br><span class="line">    <span class="keyword">int</span> size=count/k;</span><br><span class="line">    <span class="keyword">int</span> num=count%k;</span><br><span class="line">    result[<span class="number">0</span>]=root;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k<=count){</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;temp!=<span class="keyword">null</span> && index < k;i++){</span><br><span class="line">            next=temp.next;</span><br><span class="line">            <span class="keyword">if</span>(i<=(size+<span class="number">1</span>)*num && i%(size+<span class="number">1</span>)==<span class="number">0</span>){</span><br><span class="line">                <span class="comment">//前几个res的分割点</span></span><br><span class="line">                result[index++]=next;</span><br><span class="line">                <span class="comment">//切断</span></span><br><span class="line">                temp.next=<span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(i>(size+<span class="number">1</span>)*num && (i-num)%size==<span class="number">0</span>){</span><br><span class="line">                result[index++]=next;</span><br><span class="line">                temp.next=<span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            temp=next;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//剩下的情况就是后面要补null的情况</span></span><br><span class="line">        <span class="comment">// 这里两种情况应该是可以合并的，但是k>count num>0 懒得去抠边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<k;i++){< span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>){</span><br><span class="line">                <span class="comment">//这个if其实没必要</span></span><br><span class="line">                result[i]=<span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                next=temp.next;</span><br><span class="line">                result[i]=next;</span><br><span class="line">                temp.next=<span class="keyword">null</span>;</span><br><span class="line">                temp=next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></k;i++){<></span></span></pre></td></tr></tbody></table></figure></div><p>3ms beat 89% 这题也比较简单主要是边界要抠好</p><hr><h2 id="86-分隔-割-链表"><a href="#86-分隔-割-链表" class="headerlink" title="86. 分隔(割)链表"></a><strong>86. 分隔(割)链表</strong></h2><p>给定一个链表和一个特定值_ x_，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> head = 1->4->3->2->5->2, <em>x</em> = 3<br><strong>输出:</strong> 1->2->2->4->3->5</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="comment">//先在头部加一个dummy节点统一操作</span></span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next=head;</span><br><span class="line">    <span class="comment">//分割点</span></span><br><span class="line">    ListNode pre=cutNode=dummyNode;</span><br><span class="line">    ListNode cur=head;</span><br><span class="line">    <span class="keyword">int</span> cut=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(cur.val>=x&&cut==<span class="number">0</span>){</span><br><span class="line">            <span class="comment">//只会执行一次在找到第一个val>=x的节点的时候---保存分割点</span></span><br><span class="line">            cutNode=pre;</span><br><span class="line">            cut=<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(cur.val<x && cut="=<span" class="number">1</x></span>){<br><span class="line">            <span class="comment">//找到分割点后 遍历到val<x的节点的情况---将cur连接到cutnode的后面 处理好cur相邻的两个节点< span></x的节点的情况---将cur连接到cutnode的后面></span><br><span class="line">            <span class="comment">//先处理好cur相邻的节点</span></span><br><span class="line">            pre.next=cur.next;</span><br><span class="line">            <span class="comment">//连接cutNode</span></span><br><span class="line">            cur.next=cutNode.next;</span><br><span class="line">            cutNode.next=cur;</span><br><span class="line">            <span class="comment">//cutNode后移</span></span><br><span class="line">            cutNode=cur;</span><br><span class="line">        }</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next</span><br><span class="line">}</span><br></span></pre></td></tr></tbody></table></figure></div><p>这题也挺简单和上面的那题名字一样是在整理这篇博客的时候现场做的(2019.2.27)前后大概半个小时orz。。。比较菜，但是这个我没有在本地跑直接在LeetCode上提交的然后就过了 1ms beat84% 感觉思路比较清晰就没有本地跑，提交记录上最快的居然是用了额外空间new了两个链表然后连起来的。。。醉了可能是测试用例太少了。</p><hr><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><strong>160. 相交链表</strong></h2><p>编写一个程序，找到两个单链表相交的起始节点。<br>如下面的两个链表：<br><img alt="mark" data-src="http://static.imlgw.top///20190303/NVEXndTcF1R6.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/ymln2djUVieT.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>输入</strong>: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br><strong>输出</strong>: Reference of the node with value = 8<br><strong>输入解释</strong>:相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p><strong>示例 2：</strong></p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/2F7qqhkUIWog.png?imageslim" src="/img/loading.gif" class="lazyload"><br><strong>输入</strong>:intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br><strong>输出</strong>:Reference of the node with value = 2<br><strong>输入解释</strong>:相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p><strong>示例 3：</strong></p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/hKSAelGSE1TY.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>输入</strong>:intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br><strong>输出</strong>:null<br><strong>输入解释</strong>:从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br><strong>解释</strong>:这两个链表不相交，因此返回 null。</p><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li></ul><p><strong>解法一：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>{</span><br><span class="line">    ListNode pA=headA;</span><br><span class="line">    ListNode pB=headB;</span><br><span class="line">    <span class="comment">//计算两个链表长度然后计算差距然后向后对齐</span></span><br><span class="line">    <span class="keyword">int</span> lenA=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenB=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pA!=<span class="keyword">null</span>){</span><br><span class="line">        pA=pA.next;</span><br><span class="line">        lenA++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(pB!=<span class="keyword">null</span>){</span><br><span class="line">        pB=pB.next;</span><br><span class="line">        lenB++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> dis=lenB>lenA?lenB-lenA:lenA-lenB;</span><br><span class="line">    <span class="keyword">if</span>(lenB>lenA){</span><br><span class="line">        <span class="keyword">while</span>(dis--><span class="number">0</span>){</span><br><span class="line">            headB=headB.next;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">while</span>(dis--><span class="number">0</span>){</span><br><span class="line">            headA=headA.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//不相等就一直向后移</span></span><br><span class="line">    <span class="keyword">while</span>(headA!=headB){</span><br><span class="line">        <span class="comment">//如果有一条为空说明没有交点</span></span><br><span class="line">        <span class="keyword">if</span>(headA.next==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        headA=headA.next;</span><br><span class="line">        headB=headB.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> headA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种方法比较直接直接计算两个链表的长度然后计算差值然后将长的那个移动到对应的位置让<code>两条链表尾对齐</code>然后一起向后移动<br><strong>解法二：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方法二 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode2</span><span class="params">(ListNode headA, ListNode headB)</span> </span>{</span><br><span class="line">    <span class="comment">//当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，向后对齐，方法还是很巧妙的。</span></span><br><span class="line">    ListNode pA=headA;</span><br><span class="line">    ListNode pB=headB;</span><br><span class="line">    <span class="keyword">if</span>(headB==<span class="keyword">null</span> || headA==<span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//while(pA!=null && pB!=null ){</span></span><br><span class="line">    <span class="keyword">while</span>(pA!=pB){</span><br><span class="line">        <span class="comment">//要保证两个==null的时候都只能执行一次不然如果没有交点就会死循环</span></span><br><span class="line">        <span class="comment">//改变while的条件</span></span><br><span class="line">        <span class="comment">//改变pA，pB跳转的条件</span></span><br><span class="line">        <span class="comment">//这样就可以保证最后没交点的时候 第二遍循环pA和pB最后会同时等于null会有出口不会死循环</span></span><br><span class="line">        pA=pA==<span class="keyword">null</span>?headB:pA.next;</span><br><span class="line">        pB=pB==<span class="keyword">null</span>?headA:pB.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p> 同时遍历两个链表，当一个指针到结尾时转到另一个链表头再向后移动 ，这样做的目的和就是可以直接消除链表之间的长度差，使之尾对齐，方法还是很巧妙的，代码也比较简洁。</p></blockquote><hr><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><strong>234. 回文链表</strong></h2><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1->2<br><strong>输出:</strong> false</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 1->2->2->1<br><strong>输出:</strong> true</p><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 利用快慢指针找到中点</span></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) {</span><br><span class="line">        fast = fast.next.next == <span class="keyword">null</span> ? fast.next : fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是偶数节点，slow就是偏右的那个 奇数就是正中间的 奇数在正中间不用管</span></span><br><span class="line">    <span class="comment">// fast是尾节点 1 1 1 1 1 1</span></span><br><span class="line">    resverList(slow);</span><br><span class="line">    <span class="comment">//slow.next==null</span></span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> && head != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (fast.val != head.val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resverList</span><span class="params">(ListNode node)</span> </span>{</span><br><span class="line">    ListNode cur = node;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = node;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        next = next.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这题就用到了上面的翻转链表的方法，不过这里只翻转了一半，翻转了后半段然后从两边到中间逐个节点对比</p><hr><h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><strong>237. 删除链表中的节点</strong></h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/9MUvMzlcAN0G.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> head = [4,5,1,9], node = 5<br><strong>输出:</strong> [4,1,9]<br><strong>解释:</strong> 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> head = [4,5,1,9], node = 1<br><strong>输出:</strong> [4,5,9]<br><strong>解释:</strong> 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.</p><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><p><strong>二货做法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNodelow</span><span class="params">(ListNode node)</span> </span>{</span><br><span class="line">    <span class="comment">//思路就是和node后面的元素一直交换，就像冒泡排序一样</span></span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode pre=temp;</span><br><span class="line">    <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>){</span><br><span class="line">        next=node.next;</span><br><span class="line">        <span class="keyword">if</span>(node.next.next==<span class="keyword">null</span>){</span><br><span class="line">            pre=node;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//先保存最后一个节点前的节点</span></span><br><span class="line">        <span class="comment">//交换当前节点和后一个节点</span></span><br><span class="line">        temp.val=node.val;</span><br><span class="line">        node.val=next.val;</span><br><span class="line">        next.val=temp.val;</span><br><span class="line">        node=next;</span><br><span class="line">    }</span><br><span class="line">    pre.next=<span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>首先想到的愚蠢的做法,怎么这么蠢？？？？</p><p><strong>正确做法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>{</span><br><span class="line">      node.val=node.next.val;</span><br><span class="line">      node.next=node.next.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><strong>203. 移除链表元素</strong></h2><p>删除链表中等于给定值 <strong>_val _</strong>的所有节点。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1->2->6->3->4->5->6, <em><strong>val</strong></em> = 6<br><strong>输出:</strong> 1->2->3->4->5</p><p><strong>解法一：</strong><br>双指针 + 虚拟头节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//再头接待你之前加了新的节点</span></span><br><span class="line">       dummyHead.next = head;</span><br><span class="line">       ListNode pre = dummyHead, cur = head;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">if</span> (cur.val == val) {</span><br><span class="line">               pre.next = cur.next;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="comment">//不是相等的值就向后移动</span></span><br><span class="line">               pre = cur;</span><br><span class="line">           }</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二：</strong></p><p>递归方法比较简洁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements2</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将下一个元素放进递归如果是==val的就会把下一个的下一个元素返回连接到当前元素</span></span><br><span class="line">    head.next = removeElements2(head.next, val);</span><br><span class="line">    <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><strong>19. 删除链表的倒数第N个节点</strong></h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1->2->3->4->5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1->2->3->5.<br>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>你能尝试使用一趟扫描实现吗？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>&&head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//双指针 主要是头和尾的删除需要抠一下边界</span></span><br><span class="line">    <span class="comment">//  -1 | 1 2 3 4 5 6</span></span><br><span class="line">    ListNode fast=head;</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next=head;</span><br><span class="line">    ListNode slow=dummyNode;</span><br><span class="line">    <span class="comment">//加了哑节点，直接先加1</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span>){</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        slow=count<n?slow:slow.next;< span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(fast.next==<span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//slow到达需要删除的位置的前一个</span></span><br><span class="line">            slow.next=slow.next.next;</span><br><span class="line">            <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></n?slow:slow.next;<></span></pre></td></tr></tbody></table></figure></div><p>看了评论才知道咋一遍循环，主要就是控制slow指针走<code>length-n</code>步，让快指针先走n步，然后快慢一起走，快指针到头时慢指针就到<code>length-n</code>的位置了，这题也可以用List保存每个节点让然后把待删除的节点的前一个拿出来操作，遍历两遍的方法比较简单就不写了，感觉这种方法比较好 , 这题的OJ case比较少所以没什么可比性 , 前几个都是跑了两遍的，我把最快的拷过来跑的比我还慢。。。。然后我又提交了一次 beat 90%…….</p><hr><h2 id="82-删除链表中的重复元素Ⅱ"><a href="#82-删除链表中的重复元素Ⅱ" class="headerlink" title="82. 删除链表中的重复元素Ⅱ"></a><strong>82. 删除链表中的重复元素Ⅱ</strong></h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 _没有重复出现 _的数字。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1->2->3->3->4->4->5<br><strong>输出:</strong> 1->2->5</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 1->1->1->2->3<br><strong>输出:</strong> 2->3</p><blockquote><p>乍一看跟上面那一题一样？这题是排序链表上面那题是无序的，而且这题不给定元素</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//首先想到的思路是3指针，然后遍历的过程中后面的指针遇到==val的情况就让后面的指针一直后移走到！=val</span></span><br><span class="line">    <span class="comment">//先添加个哑节点</span></span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next=head;</span><br><span class="line">    ListNode cur=head;</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    ListNode pre=dummyNode;</span><br><span class="line">    <span class="keyword">while</span>(next!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">while</span>(next.val==cur.val){</span><br><span class="line">            next=next.next;</span><br><span class="line">            <span class="keyword">if</span>(next==<span class="keyword">null</span>){</span><br><span class="line">                pre.next=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(next.val!=cur.val){</span><br><span class="line">                pre.next=next;</span><br><span class="line">                <span class="comment">//cur跟上</span></span><br><span class="line">                cur=next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//关键就是pre移动这里有坑 不能直接将pre移到cur,因为会有连续的连续存在</span></span><br><span class="line">        pre=cur.next!=<span class="keyword">null</span>&&cur.val==cur.next.val?pre:cur;</span><br><span class="line">        cur=next;</span><br><span class="line">        next=next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>整体来说还是挺简单的只跑了一趟 1ms beta98%，评论里面大都只用了两个指针我用了三个这样感觉比较清晰<br>怎么好理解怎么来。貌似最快的是一个递归的，递归写起来确实玄学还要多练练啊</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (head.next != <span class="keyword">null</span> && head.val == head.next.val) {</span><br><span class="line">          <span class="keyword">while</span> (head.next != <span class="keyword">null</span> && head.val == head.next.val) {</span><br><span class="line">              head = head.next;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> deleteDuplicates(head.next);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">          head.next = deleteDuplicates(head.next);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div><p>这题还有个简单版的那个删除后会留下一个，那样向我上面这样写pre的跳转就会更简单一点，这里就不写了</p><hr><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><strong>143. <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">重排链表</a></strong></h2><p>给定一个单链表 <em>L</em>：L0→L1→…→Ln-1→Ln<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><p>给定链表 1->2->3->4, 重新排列为 1->4->2->3.</p><p><strong>示例 2:</strong></p><p>给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.</p><blockquote><p>这题和上面的回文链表有点类似，都是快慢指针不过这题稍微复杂点</p></blockquote><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    ListNode right = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="comment">// 1 1 1 1 1 1 1</span></span><br><span class="line">    <span class="keyword">while</span> (right.next != <span class="keyword">null</span>) {</span><br><span class="line">        right = right.next.next != <span class="keyword">null</span> ? right.next.next : right.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从slow开始翻转</span></span><br><span class="line">    res(slow);</span><br><span class="line">    <span class="comment">//左半部分</span></span><br><span class="line">    ListNode left = head;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    ListNode rnext = right;</span><br><span class="line">    ListNode lnext = left;</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6 7 8 </span></span><br><span class="line">    <span class="comment">// 1 8 2 7 3 6 4 5</span></span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span> && left != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 要保存right的下一个节点 , left也需要,不然无法导航到下一个节点</span></span><br><span class="line">        lnext = lnext.next;</span><br><span class="line">        rnext = rnext.next;</span><br><span class="line">        <span class="comment">// 偶数个数节点,如果遍历到right链表的最后一个节点</span></span><br><span class="line">        <span class="comment">// 偶数的话right链表会短一点 最后连接的时候</span></span><br><span class="line">        <span class="comment">// left: 1->2->3->4->5 right: 8->7->6->5   </span></span><br><span class="line">        <span class="comment">// 像这样会将5加到left的4和5之间,但是明显只有一个5这样添加就是有问题的</span></span><br><span class="line">        <span class="keyword">if</span>(right.next==<span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//所以这里吧lnext赋值为null,后面就不会重复连接5这个节点</span></span><br><span class="line">            lnext=<span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//奇数个数的时候这样连接没问题</span></span><br><span class="line">        <span class="comment">// 1 2 3 4 5 </span></span><br><span class="line">        <span class="comment">// 9 8 7 6 5</span></span><br><span class="line">        <span class="comment">//5.next=5</span></span><br><span class="line">        left.next = right;</span><br><span class="line">        <span class="comment">//如果奇数个数到最后这一步 right和left是同一个节点都为值是5的节点</span></span><br><span class="line">        <span class="comment">//所以这里下面的直接覆盖了上面的</span></span><br><span class="line">        <span class="comment">//5.next=null</span></span><br><span class="line">        right.next = lnext;</span><br><span class="line">        left = lnext;</span><br><span class="line">        right = rnext;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">res</span><span class="params">(ListNode node)</span> </span>{</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = node;</span><br><span class="line">    ListNode nex = node;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        nex = nex.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nex;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>也是之前的代码了，写的比较烂，但是思路还是比较清晰的，边界需要注意，速度还行 4ms  77% 。</p><hr><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入： <span class="number">1</span>-><span class="number">2</span>-><span class="number">4</span>, <span class="number">1</span>-><span class="number">3</span>-><span class="number">4</span></span><br><span class="line">输出： <span class="number">1</span>-><span class="number">1</span>-><span class="number">2</span>-><span class="number">3</span>-><span class="number">4</span>-><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><p>常规迭代的做法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">        ListNode temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res=temp;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&&l2!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span>(l2.val<l1.val){< span><br><span class="line">                temp.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                temp.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        temp.next=l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">}</span><br></l1.val){<></span></pre></td></tr></tbody></table></figure></div><p>归并分治的思想，期末考试的一道题</p><p><strong>解法二</strong></p><p>递归的做法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    mergeTwoLists(l1,l2,dummyNode);</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2,ListNode res)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="keyword">null</span>){</span><br><span class="line">        res.next=l2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l2==<span class="keyword">null</span>){</span><br><span class="line">        res.next=l1;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l1.val>l2.val){</span><br><span class="line">        res.next=l2;</span><br><span class="line">        mergeTwoLists(l1,l2.next,res.next);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        res.next=l1;</span><br><span class="line">        mergeTwoLists(l1.next,l2,res.next);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面是我一开始自己写的，一点也不<em>递归</em> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l1.val<l2.val){< span><br><span class="line">        l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></l2.val){<></span></pre></td></tr></tbody></table></figure></div><p>这种看着就很简洁</p><hr><h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-><span class="number">4</span>-><span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-><span class="number">3</span>-><span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-><span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-><span class="number">1</span>-><span class="number">2</span>-><span class="number">3</span>-><span class="number">4</span>-><span class="number">4</span>-><span class="number">5</span>-><span class="number">6</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(lists.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode temp=lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<lists.length-<span class="number">1</lists.length-<span></span>;i++){<br><span class="line">        temp=merge2List(temp,lists[i+<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge2List</span><span class="params">(ListNode headA,ListNode headB)</span></span>{</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res=dummyNode;</span><br><span class="line">    ListNode tempA=headA;</span><br><span class="line">    ListNode tempB=headB;</span><br><span class="line">    <span class="keyword">while</span>(tempB!=<span class="keyword">null</span>&&tempA!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(tempB.val>tempA.val){</span><br><span class="line">            res.next=tempA;</span><br><span class="line">            tempA=tempA.next;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            res.next=tempB;</span><br><span class="line">            tempB=tempB.next;</span><br><span class="line">        }</span><br><span class="line">        res=res.next;</span><br><span class="line">    }</span><br><span class="line">    res.next=tempA==<span class="keyword">null</span>?tempB:tempA;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>最先想到的方法，和前面的二路归并一样，把前两个归并的结果和后面的继续归并。速度太慢了200ms左右…..时间复杂度是<code>O(N^2)</code>.<br><strong>解法二：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists2</span><span class="params">(ListNode[] lists)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(lists.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> divide(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">divide</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(left>=right)<span class="keyword">return</span> lists[left];</span><br><span class="line">    <span class="keyword">int</span> mid=left+((right-left)>><span class="number">1</span>);</span><br><span class="line">    ListNode l = divide(lists,left,mid);</span><br><span class="line">    ListNode r = divide(lists,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">return</span> merge2List(l,r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge2List</span><span class="params">(ListNode headA,ListNode headB)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="keyword">null</span>)<span class="keyword">return</span> headB;</span><br><span class="line">    <span class="keyword">if</span>(headB==<span class="keyword">null</span>)<span class="keyword">return</span> headA;</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res=dummyNode;</span><br><span class="line">    ListNode tempA=headA;</span><br><span class="line">    ListNode tempB=headB;</span><br><span class="line">    <span class="keyword">while</span>(tempB!=<span class="keyword">null</span>&&tempA!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(tempB.val>tempA.val){</span><br><span class="line">            res.next=tempA;</span><br><span class="line">            tempA=tempA.next;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            res.next=tempB;</span><br><span class="line">            tempB=tempB.next;</span><br><span class="line">        }</span><br><span class="line">        res=res.next;</span><br><span class="line">    }</span><br><span class="line">    res.next=tempA==<span class="keyword">null</span>?tempB:tempA;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>看起来很眼熟？没错就是归并排序的思路，利用分治的思想，先归并左边，再归并右边，然后merge左右的结果，时间复杂度为<code>O(NlogK)</code> (递归树深度为logK，归并每一层时间复杂度都是N)， 10ms左右，N是链表的元素个数，K是链表个数。而且因为是链表空间复杂度也不高。另外这题也可以改成非递归的方式如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists3</span><span class="params">(ListNode [] lists)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> k = lists.length;</span><br><span class="line">    <span class="keyword">while</span> (k > <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < k / <span class="number">2</span>; i++) {</span><br><span class="line">            <span class="comment">//两两合并将结果保存在前半部分的节点中然后缩小一半的范围</span></span><br><span class="line">            lists[i] = merge2Lists(lists[i], lists[i + (k + <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//缩小一半的范围</span></span><br><span class="line">        k = (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法三：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//小根堆的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists4</span><span class="params">(ListNode[] lists)</span> </span>{</span><br><span class="line">    <span class="comment">//利用一个按节点值最小次序排列的优先队列, 每次取最小的节点加入返回链表中</span></span><br><span class="line">    <span class="keyword">if</span>(lists.length < <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue<listnode> pq = <span class="keyword">new</span> PriorityQueue<>((a, b) -> (a.val - b.val));</listnode></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">for</span> (ListNode p : lists){</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>)</span><br><span class="line">        pq.offer(p);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) {</span><br><span class="line">        cur.next = pq.poll();</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        <span class="keyword">if</span>(cur.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//讲当前节点后一个节点加入队列</span></span><br><span class="line">        pq.offer(cur.next);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>利用了小根堆，Java里面有小根堆可以直接用，思路就是每次把每条链表的头元素都放进小根堆里面然后找出最小的加到新链表中然后，最小的那个节点的链表向后移再加到小根堆里面，方法还是相当简洁的。但是用了90ms左右比较慢，我想了下感觉这个时间复杂度好像是NKlogK,但是评论说是NlogK。。。算法渣渣有点迷。。。</p><hr><h2 id="430-扁平化多级双向链表"><a href="#430-扁平化多级双向链表" class="headerlink" title="430. 扁平化多级双向链表"></a>430. 扁平化多级双向链表</h2><p>您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。</p><p><strong>示例:</strong></p><p><strong>输入:</strong><br> 1—2—3—4—5—6–NULL<br>         |<br>         7—8—9—10–NULL<br>             |<br>             11–12–NULL</p><p><strong>输出:</strong><br>1-2-3-7-8-11-12-9-10-4-5-6-NULL<br><strong>以上示例的说明:</strong></p><p>给出以下多级双向链表:</p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/DqC2qKF5h63V.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>我们应该返回如下所示的扁平双向链表:</p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/qOSn0TLmMuCt.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>解法一：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        这种解法思路还是比较清晰的</span></span><br><span class="line"><span class="comment">        每次有子链的时候就直接把子链遍历到尾 然后添加到链表中形成新主链 把子链的入口节点child指定为null</span></span><br><span class="line"><span class="comment">        然后主链继续向后遍历所以整个遍历的次数就是整个链表元素的个数 O(M)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">flatten1</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>&&head.child==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    Node cur=head;</span><br><span class="line">    Node nNext;</span><br><span class="line">    Node child;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(cur.child!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//有子链表</span></span><br><span class="line">            child=cur.child;</span><br><span class="line">            <span class="comment">//子链表的表头</span></span><br><span class="line">            nNext=cur.next;</span><br><span class="line">            <span class="comment">//主链的下一节点</span></span><br><span class="line">            <span class="comment">//连接子链表</span></span><br><span class="line">            cur.next=child;</span><br><span class="line">            <span class="comment">//主链的下一节点为子链表头</span></span><br><span class="line">            child.prev=cur;</span><br><span class="line">            <span class="comment">//子链表的前驱节点</span></span><br><span class="line">            <span class="comment">//已经拼接到主链，孩子链置为空 （这步还很关键我开始一直忘设置为null）</span></span><br><span class="line">            cur.child=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(nNext==<span class="keyword">null</span>){</span><br><span class="line">                <span class="comment">//遍历到主链最后一个了</span></span><br><span class="line">                <span class="comment">//所以没有下一个节点，后面的步骤不用继续但是也不能Break 因为最后一个节点有可能还有子链表</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(child.next!=<span class="keyword">null</span>){</span><br><span class="line">                <span class="comment">//找到新主链的下一节点 (子链的最后一个)</span></span><br><span class="line">                child=child.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//连接以前的主链</span></span><br><span class="line">            child.next=nNext;</span><br><span class="line">            nNext.prev=child;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//主链表向后移动</span></span><br><span class="line">        cur=cur.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法二：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//标准的DFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">flatten2</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">   <span class="keyword">if</span>(node==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    Node head = node;</span><br><span class="line">    <span class="keyword">while</span> (head!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//我感觉这样会快一些</span></span><br><span class="line">         Node next = head.next;</span><br><span class="line">        <span class="keyword">if</span>(head.child!=<span class="keyword">null</span>){</span><br><span class="line">            next = head.next;</span><br><span class="line">            <span class="comment">//子链表扁平化 返回头节点</span></span><br><span class="line">            Node nextLayer = flatten2(head.child);<span class="comment">//子链表的头节点</span></span><br><span class="line">            <span class="comment">//连接子链表头和主链</span></span><br><span class="line">            head.next = nextLayer;</span><br><span class="line">            nextLayer.prev = head;</span><br><span class="line">            <span class="comment">//然后子链表置为null</span></span><br><span class="line">            head.child = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//遍历到子链表的结尾</span></span><br><span class="line">            <span class="keyword">while</span> (nextLayer.next!=<span class="keyword">null</span>){</span><br><span class="line">                nextLayer = nextLayer.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//连接子链表的尾部</span></span><br><span class="line">            nextLayer.next = next;</span><br><span class="line">            <span class="keyword">if</span>(next!=<span class="keyword">null</span>){</span><br><span class="line">                next.prev = nextLayer;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这里就直接跳过子链表 之前的是head=head.next; 但是因为之前的子链表已经加到主链表中所以会浪费一些时间（子链表肯定是已经扁平化的肯定都没有子链表）</span></span><br><span class="line">        head = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>两种方法都是看的评论里面的第二种我稍微改了下，直接跳过子链表效率会高很多，不过这题case也比较少看不出差异。</p><hr><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><strong>141. 环形链表</strong></h2><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>head = [3,2,0,-4], pos = 1<br><strong>输出：</strong>true<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/H2wmyaG9uoiz.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>示例 2：</strong><br><strong>输入：</strong> head = [1,2], pos = 0<br><strong>输出：</strong> true<br><strong>解释：</strong> 链表中有一个环，其尾部连接到第一个节点。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/UqIc2XWwtxbo.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> head = [1], pos = -1<br><strong>输出：</strong> false<br><strong>解释：</strong> 链表中没有环。</p><p><img alt="mark" data-src="http://static.imlgw.top///20190303/dAg8QrxqJJga.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p><strong>进阶：</strong></p><p>你能用 _O(1)_（即，常量）内存解决此问题吗？</p><p><strong>有一点需要注意的是只有一个节点的情况应该是不考虑的直接 false 。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//快慢指针 相遇的时候快指针回到头部step改为1 再次相遇的时候就是环的pos</span></span><br><span class="line">    <span class="comment">//这题只是判断有没有环所以只要相遇就有环</span></span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    ListNode fast=head.next;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast){</span><br><span class="line">        <span class="comment">//有环是不会走到尽头的</span></span><br><span class="line">        <span class="keyword">if</span>(fast.next==<span class="keyword">null</span> || fast.next.next==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="141-环形链表Ⅱ"><a href="#141-环形链表Ⅱ" class="headerlink" title="141. 环形链表Ⅱ"></a>141. 环形链表Ⅱ</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong> 不允许修改给定的链表。 ps:上题的基础上返回入环的第一个节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    ListNode fast=head;</span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    Boolean isMeet=<span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//快指针没有到尽头</span></span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&&fast.next!=<span class="keyword">null</span>){</span><br><span class="line">        fast=isMeet?fast.next:fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow){</span><br><span class="line">            <span class="keyword">if</span>(!isMeet){</span><br><span class="line">                <span class="comment">//第一次相遇</span></span><br><span class="line">                <span class="comment">//我这种写法开始没考虑到这种情况,入环节点就是头节点就不能继续走了</span></span><br><span class="line">                <span class="keyword">if</span>(fast==head) <span class="keyword">return</span>;</span><br><span class="line">                fast=head;</span><br><span class="line">                isMeet=<span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>这种解法还是挺有意思的<code>快慢指针</code>，快指针一次走两步慢指针一次走一步在环上相遇的时候快指针回到头节点步数调整为1，再>次相遇的>时候（这里有可能重合，当头节点就是入环节点的时候）就是入环节点。<br>原理 :<br>A—->B—->C      分别为<code>头节点</code>，<code>入环节点</code>，<code>第一次相遇的节点</code><br>分析第一次相遇时快慢指针走过的路径可得<br>AB+BC+CB+BC=2(AB+BC)  快指针走过的路程肯定是慢指针的两倍<br>化简最后就得到AB=CB 所以他们<code>再次相遇</code>就是入环的节点</p></blockquote><hr><h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><strong>61. <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">旋转链表</a></strong></h2><p>给定一个链表，旋转链表，将链表每个节点向右移动  <em>k</em>个位置，其中 <em>k</em>是非负数。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-><span class="number">2</span>-><span class="number">3</span>-><span class="number">4</span>-><span class="number">5</span>->NULL, k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span>-><span class="number">5</span>-><span class="number">1</span>-><span class="number">2</span>-><span class="number">3</span>->NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">5</span>-><span class="number">1</span>-><span class="number">2</span>-><span class="number">3</span>-><span class="number">4</span>->NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">4</span>-><span class="number">5</span>-><span class="number">1</span>-><span class="number">2</span>-><span class="number">3</span>->NULL</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: <span class="number">0</span>-><span class="number">1</span>-><span class="number">2</span>->NULL, k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span>-><span class="number">0</span>-><span class="number">1</span>->NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">2</span>-><span class="number">0</span>-><span class="number">1</span>->NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">1</span>-><span class="number">2</span>-><span class="number">0</span>->NULL</span><br><span class="line">向右旋转 <span class="number">3</span> 步: <span class="number">0</span>-><span class="number">1</span>-><span class="number">2</span>->NULL</span><br><span class="line">向右旋转 <span class="number">4</span> 步: <span class="number">2</span>-><span class="number">0</span>-><span class="number">1</span>->NULL</span><br></pre></td></tr></tbody></table></figure></div><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//先获取下链表的长度，顺便记录tail的值</span></span><br><span class="line">    ListNode temp=head;</span><br><span class="line">    ListNode tail=head;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>){</span><br><span class="line">            tail=temp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将K化简</span></span><br><span class="line">    k=k%length;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    temp=head;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//然后再遍历一遍链表在 length-k 的地方断开</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(count==(length-k-<span class="number">1</span>)){</span><br><span class="line">            tail.next=head;</span><br><span class="line">            head=temp.next;</span><br><span class="line">            temp.next=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        count++;</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>虽然难度是mid，但是感觉这题还是比较简单，我看见有一种比较好点的方法是在第一遍循环完之后将链表转换为<code>双向链表</code>然后再移动还是比较有意思的</p><hr><h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><strong>328. 奇偶链表</strong></h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> <code>1->2->3->4->5->NULL</code><br><strong>输出:</strong> <code>1->3->5->2->4->NULL</code></p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> <code>2->1->3->5->6->4->7->NULL</code><br><strong>输出:</strong> <code>2->3->6->7->1->5->4->NULL</code></p><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//奇偶链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>||head.next.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">    ListNode pOdd=head;</span><br><span class="line">    ListNode pEven=head.next;</span><br><span class="line">    ListNode temp=pEven;</span><br><span class="line">    <span class="keyword">while</span>(pEven!=<span class="keyword">null</span>&&pEven.next!=<span class="keyword">null</span>){</span><br><span class="line">        pOdd.next=pEven.next;</span><br><span class="line">        <span class="comment">//奇数先走</span></span><br><span class="line">        pOdd=pOdd.next;</span><br><span class="line">        pEven.next=pOdd.next;</span><br><span class="line">        pEven=pEven.next;</span><br><span class="line">    }</span><br><span class="line">    pOdd.next=temp;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>很像踩石头过河的游戏，一道很简单的mid，不知道为啥一开始抠了半天的边界。。。果然<br>还是不熟悉啊。Add oil ! ! ! 👍👍👍👍👍</p></blockquote><hr><h2 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a><strong>147. 对链表进行插入排序</strong></h2><p>插入排序的动画演示如上篇文章。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。<br>插入排序算法：<br>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>重复直到所有输入数据插入完为止。<br>示例 1：<br>输入: 4->2->1->3<br>输出: 1->2->3->4<br>示例 2：<br>输入: -1->5->3->4->0<br>输出: -1->0->3->4->5</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//beat 50%</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//哑节点</span></span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(Integer.MIN_VALUE);</span><br><span class="line">    System.out.println(dummyNode.val);</span><br><span class="line">    dummyNode.next=head;</span><br><span class="line">    ListNode tempNode=head;</span><br><span class="line">    <span class="comment">//外循环内的指针</span></span><br><span class="line">    ListNode loopVariable=head.next;</span><br><span class="line">    ListNode loopPre=head;</span><br><span class="line">    <span class="comment">//内循环的指针</span></span><br><span class="line">    ListNode tempPre=dummyNode;</span><br><span class="line">    <span class="keyword">while</span>(loopVariable!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">for</span> (tempNode=dummyNode;tempNode!=loopVariable;tempNode=tempNode.next){</span><br><span class="line">            <span class="keyword">if</span>(tempNode.val>loopVariable.val){</span><br><span class="line">                <span class="comment">//System.out.println(loopVariable.val);</span></span><br><span class="line">                <span class="comment">//printList(dummyNode.next);</span></span><br><span class="line">                <span class="comment">//先处理好loopVariable的前后节点</span></span><br><span class="line">                loopPre.next=loopVariable.next;</span><br><span class="line">                <span class="comment">//再处理tempNode前后的节点</span></span><br><span class="line">                loopVariable.next=tempNode;</span><br><span class="line">                tempPre.next=loopVariable;</span><br><span class="line">                <span class="comment">//loopVariable 归位</span></span><br><span class="line">                loopVariable=loopPre;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            tempPre=tempNode;</span><br><span class="line">        }</span><br><span class="line">        loopPre=loopVariable;</span><br><span class="line">        loopVariable=loopVariable.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面的是我开始自己写的，但是提交后发现速度有点慢40ms 50%左右 然后我有点不信把比较靠前的拷了一个 10ms😂前几名10ms以内的都是用的方法不是插入….<br>在研究别人10ms的代码时突然意识到了问题所在 我在进行插入的时候没有判断就时没有关心是不是应该进行插入操作，对于数组的插入排序是不用关心这个问题的，因为是反向遍历的 而这里是链表只能正向的遍历如果不判断就会浪费很多时间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 16ms  beat  70% 开始少写了一个if判断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//哑节点</span></span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(Integer.MIN_VALUE);</span><br><span class="line">    System.out.println(dummyNode.val);</span><br><span class="line">    dummyNode.next=head;</span><br><span class="line">    ListNode tempNode=head;</span><br><span class="line">    <span class="comment">//外循环内的指针</span></span><br><span class="line">    ListNode loopVariable=head.next;</span><br><span class="line">    ListNode loopPre=head;</span><br><span class="line">    <span class="comment">//内循环的指针</span></span><br><span class="line">    ListNode tempPre=dummyNode;</span><br><span class="line">    <span class="keyword">while</span>(loopVariable!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">if</span>(loopVariable.val<looppre.val){< span><br><span class="line">            <span class="keyword">for</span> (tempNode=dummyNode;tempNode!=loopVariable;tempNode=tempNode.next){</span><br><span class="line">                <span class="keyword">if</span>(tempNode.val>loopVariable.val){</span><br><span class="line">                    <span class="comment">//System.out.println(loopVariable.val);</span></span><br><span class="line">                    <span class="comment">//printList(dummyNode.next);</span></span><br><span class="line">                    <span class="comment">//先处理好loopVariable的前后节点</span></span><br><span class="line">                    loopPre.next=loopVariable.next;</span><br><span class="line">                    <span class="comment">//再处理tempNode前后的节点</span></span><br><span class="line">                    loopVariable.next=tempNode;</span><br><span class="line">                    tempPre.next=loopVariable;</span><br><span class="line">                    <span class="comment">//loopVariable 归位</span></span><br><span class="line">                    loopVariable=loopPre;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                tempPre=tempNode;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        loopPre=loopVariable;</span><br><span class="line">        loopVariable=loopVariable.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></looppre.val){<></span></pre></td></tr></tbody></table></figure></div><p>这题整体思路就是按照插入排序的思路来的，值得注意的就是链表只能正向遍历，而且需要考虑保存的节点有两个，插入位置的前一个，以及待插入的前一个(头插法)。</p><hr><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><font color="red" size="5" face="黑体">148. 排序链表</font></h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><p>输入: 4->2->1->3<br>输出: 1->2->3->4<br>示例 2:</p><p>输入: -1->5->3->4->0<br>输出: -1->0->3->4->5</p><blockquote><p>上面那题时间复杂度明显是O(n2)最坏，这题要求是O(nlogn)和常数空间上面的插入肯定不适合了</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//归并排法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    ListNode fast=head;</span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&&fast.next!=<span class="keyword">null</span>){</span><br><span class="line">        pre=slow;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    }</span><br><span class="line">    pre.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这里要注意断开两条链表不然后面不方便找中点</span></span><br><span class="line">    ListNode left = mergeSort(head);</span><br><span class="line">    <span class="comment">//归并左边</span></span><br><span class="line">    ListNode right = mergeSort(slow);</span><br><span class="line">    <span class="comment">//归并右边</span></span><br><span class="line">    <span class="keyword">return</span> merge2list(left,right);</span><br><span class="line">    <span class="comment">//返回 左右两条链表归并结果</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge2list</span><span class="params">(ListNode headA,ListNode headB)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="keyword">null</span>)<span class="keyword">return</span> headB;</span><br><span class="line">    <span class="keyword">if</span>(headB==<span class="keyword">null</span>)<span class="keyword">return</span> headA;</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next=headA;</span><br><span class="line">    ListNode temp=dummyNode;</span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="keyword">null</span>&&headB!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(headA.val>headB.val){</span><br><span class="line">            temp.next=headB;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            temp.next=headA;</span><br><span class="line">            headA=headA.next;</span><br><span class="line">        }</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    temp.next=headA==<span class="keyword">null</span>?headB:headA;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>​        4ms 85%  标准的<code>归并操作</code><em>分治</em>的思想，但是我还是扣了好长时间，最后还是看了别人的代码才知道，其实一开始就想到了<code>快慢指针找中点</code>但是感觉时间复杂度可能会变得更高就没那样做。。。还是太菜了时间复杂度都不会分析。。。这里有一个小地方就是找到中点之后要记得断开中点和后面链表的连接，这样会方便后面归并，不然就需要传递一个边界的指针那样又会有很多问题（没错我开始就是这么做的😭）</p><p>   下面这种是后来又写的<code>经典快排</code>，400ms，12% 我都怀疑我到底写了个啥？后来把插入拿来试了下884+ms然后又看了一遍才相信我写的是快排。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//我自己写的快排</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList4</span><span class="params">(ListNode head)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    sortList(head,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortList</span><span class="params">(ListNode head,ListNode tail)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(tail==head){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//确定枢纽元素</span></span><br><span class="line">    ListNode base=partion(head,tail);</span><br><span class="line">    sortList(head,base);</span><br><span class="line">    sortList(base.next,tail);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//看了下别人的博客也学到了一种快排的新思路</span></span><br><span class="line"><span class="comment">//慢指针左边都是小于base枢纽元素的，快指针和慢指针中间都是大于等于base枢纽元素的</span></span><br><span class="line"><span class="comment">//慢指针后面的都是未知区域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">partion</span><span class="params">(ListNode head,ListNode tail)</span></span>{</span><br><span class="line">    ListNode base=head;</span><br><span class="line">    ListNode fast=head.next;</span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    <span class="comment">// 3  1  3  2  5  -1 0</span></span><br><span class="line">    <span class="comment">//    s  f</span></span><br><span class="line">    <span class="keyword">while</span>(fast!=tail){</span><br><span class="line">        <span class="keyword">if</span>(fast.val<=base.val){</span><br><span class="line">            <span class="comment">//交换两个节点的值</span></span><br><span class="line">            swap(fast,slow.next);</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        }</span><br><span class="line">        fast=fast.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    swap(head,slow);</span><br><span class="line">    <span class="comment">//应该可以试试返回区间</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ListNode a,ListNode b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=a.val;</span><br><span class="line">    a.val=b.val;</span><br><span class="line">    b.val=temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>实际上快排确实不适合链表（下面光速打脸）因为毕竟不是数组可以从两边开始遍历，链表每次都需要遍历整个链表才能划分好基准位置。</p></blockquote><p>看了下前几的代码发现了这个，<code>非标准的三向切分的快排</code>，为啥说是非标准呢？看下面代码就知道了，我给加了注释</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList3</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    node.next = head;</span><br><span class="line">    sort(node, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> node.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(ListNode from, ListNode to)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (from == <span class="keyword">null</span> || from == to || from.next == to || from.next.next == to)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> v = from.next.val;</span><br><span class="line">    <span class="comment">//基准元素</span></span><br><span class="line">    ListNode mid = from;</span><br><span class="line">    <span class="comment">//切分点指针</span></span><br><span class="line">    ListNode equal = from.next;</span><br><span class="line">    <span class="comment">//等于区域右边界</span></span><br><span class="line">    ListNode node = from.next;</span><br><span class="line">    <span class="comment">//遍历用的指针</span></span><br><span class="line">    <span class="keyword">while</span> (node.next != to) {</span><br><span class="line">        <span class="comment">//node不到头  左开右开区间（from,to）</span></span><br><span class="line">        <span class="keyword">if</span> (node.next.val < v) {</span><br><span class="line">            <span class="comment">//小于基准位置元素</span></span><br><span class="line">            <span class="comment">//保存当前节点的下一个元素，用于插入节点</span></span><br><span class="line">            <span class="comment">//小于基准元素的节点</span></span><br><span class="line">            ListNode currentNext = node.next.next;</span><br><span class="line">            <span class="comment">//保存切分点的下一个元素，作用同上</span></span><br><span class="line">            ListNode midNext = mid.next;</span><br><span class="line">            <span class="comment">//交换node.next和mid</span></span><br><span class="line">            <span class="comment">//纸上画一下就了解了</span></span><br><span class="line">            mid.next = node.next;</span><br><span class="line">            node.next.next = midNext;</span><br><span class="line">            node.next = currentNext;</span><br><span class="line">            <span class="comment">//切分点后移</span></span><br><span class="line">            mid = mid.next;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.next.val == v) {</span><br><span class="line">            <span class="comment">//node的下一个等于基准元素</span></span><br><span class="line">            <span class="comment">//3 1 2 3 4 5 6</span></span><br><span class="line">            <span class="keyword">if</span> (equal == node) {</span><br><span class="line">                <span class="comment">//等于区域和node.next==val相邻了，直接跳过</span></span><br><span class="line">                equal = node.next;</span><br><span class="line">                node = node.next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//将node.next插入equal后面</span></span><br><span class="line">                <span class="comment">//然后equal向后移动</span></span><br><span class="line">                <span class="comment">//和上面的类似</span></span><br><span class="line">                ListNode nodeNext = node.next.next;</span><br><span class="line">                ListNode equalNext = equal.next;</span><br><span class="line">                equal.next = node.next;</span><br><span class="line">                node.next.next = equalNext;</span><br><span class="line">                node.next = nodeNext;</span><br><span class="line">                equal = equal.next;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//大于直接跳过</span></span><br><span class="line">            node = node.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// [mid.next---equal] 为等于val的节点</span></span><br><span class="line">    sort(from, mid.next);</span><br><span class="line">    sort(equal, to);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>整体思路就是一共有三个指针，<code>mid</code>(切分点)  <code>equal</code>(等于区) <code>node</code>(遍历指针) node从from遍历到to，注意这里是<code>左开右开区间</code> 就是说头from和尾to都取不到，然后将小与base的节点插入到mid的后面，然后mid后移，等于区插入到equal的后面，最后形成的就是<code>[mid.next---equal]</code> 为等于val的节点，然后对子区域递归就ok了，这个用时 <code>4ms</code> 。。。。。。还要继续加油啊！！！</p><hr><h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138.复制带随机指针的链表"></a><font color="red" size="5" face="黑体">138.复制带随机指针的链表</font></h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的深拷贝。<br>示例：<br><img alt="mark" data-src="http://static.imlgw.top///20190308/tR8e3eu2yqaq.png?imageslim" src="/img/loading.gif" class="lazyload"><br>输入：<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}</code><br>解释：<br>节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。<br>节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。</p><p>提示：<br>你必须返回给定头的拷贝作为对克隆列表的引用。</p><p><strong>解法一：</strong> 利用Map</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    Map<node,node> copNode =<span class="keyword">new</span> HashMap<>();</node,node></span><br><span class="line">    Node temp=head;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//建立对应关系</span></span><br><span class="line">        copNode.put(temp,<span class="keyword">new</span> Node(temp.val,<span class="keyword">null</span>,<span class="keyword">null</span>));</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//再循环一次复制next和Radom节点</span></span><br><span class="line">    temp=head;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        copNode.get(temp).next=copNode.get(temp.next);</span><br><span class="line">        copNode.get(temp).random=copNode.get(temp.random);</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> copNode.get(head);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第一个循环利用Map将原链表和拷贝链表形成对应关系，第二个循环就是直接给拷贝链表的next域和random域赋值。</p><p><strong>解法二：</strong><code>奥义 影分身</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyRandomList2</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    Node temp=head;</span><br><span class="line">    <span class="comment">//链表  奥义 - 影分身</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//这里直接将next域传入构造器完成和后面元素的连接</span></span><br><span class="line">        temp.next=<span class="keyword">new</span> Node(temp.val,temp.next,<span class="keyword">null</span>);</span><br><span class="line">        temp=temp.next.next;</span><br><span class="line">    }</span><br><span class="line">    temp=head;</span><br><span class="line">    <span class="comment">//连接random域</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(temp.random!=<span class="keyword">null</span>){</span><br><span class="line">            temp.next.random=temp.random.next;</span><br><span class="line">        }</span><br><span class="line">        temp=temp.next.next;</span><br><span class="line">    }</span><br><span class="line">    temp=head;</span><br><span class="line">    <span class="comment">// 分离</span></span><br><span class="line">    Node newHead=head.next;</span><br><span class="line">    Node next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        next=temp.next;</span><br><span class="line">        <span class="keyword">if</span>(next!=<span class="keyword">null</span>){</span><br><span class="line">            temp.next=next.next;</span><br><span class="line">        }</span><br><span class="line">        temp=next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>为啥要叫影分身？因为帅…这种方法比上面的要快一点可能是创建hashMap比较耗时间，其实分析这两种方法其实都是先把链表拷贝了一份，然后通过对应关系来连接拷贝链表的next和random域，map是通过键值对的方式对应拷贝链表，这样可以方便的通过原链表找到拷贝链表的random. 然后上面这种方法也是一样，在原链表每个节点后面copy一个节点，然后根据前一个节点的random来找拷贝节点的random(前一个节点的random的next) 主要就是找到一个对应关系.</p><blockquote><p>tips: 这题OJ上的0ms是有问题的，这题本意肯定也不是这个</p><p><img alt="mark" data-src="http://static.imlgw.top///20190308/p1GPgJVYaURp.png?imageslim" src="/img/loading.gif" class="lazyload"></p></blockquote><p>最开始能通过主要是OJ后台只判断了val的值，可以看出现在题目已经改了。现在肯定是跑不过的，可能是判断了random是不是new出来的(我试了下看了下返回这个)<br>输入<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}</code><br>输出<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":</code></p><p><code>{"$id":"3","next":null,"random":null,"val":2},"val":2},</code></p><p><code>"random":{"$id":"4","next":null,"random":null,"val":2},"val":1}</code><br>预期结果<br><code>{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}</code></p><hr><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><strong>24. <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></strong></h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><p>给定 1->2->3->4, 你应该返回 2->1->4->3.</p><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next=head;</span><br><span class="line">    ListNode nex=head.next;</span><br><span class="line">    ListNode cur=head;</span><br><span class="line">    ListNode pre=dummyNode;</span><br><span class="line">    <span class="comment">// -1|1 2 3 4</span></span><br><span class="line">    <span class="keyword">while</span>(nex!=<span class="keyword">null</span>){</span><br><span class="line">        pre.next=nex;</span><br><span class="line">        cur.next=nex.next;</span><br><span class="line">        nex.next=cur;</span><br><span class="line">        pre=cur;</span><br><span class="line">        <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">        }</span><br><span class="line">        cur=cur.next;</span><br><span class="line">        nex=cur.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实跟反转链表是一样的，三个指针分别记录前 中 后三个节点然后逆序，只不过步长不一样，这里step为2，一次走两步， 我上面的代码可能写的有些乱，思路还是一样的</p><p><strong>解法二</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    head.next=swapPairs(next.next);</span><br><span class="line">    next.next=head;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>递归是真的简洁，我最开始写反转链表的递归就是这么写的😂</p><hr><h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a><font color="red" size="5" face="黑体">25.K个一组翻转链表</font></h2><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p><p><strong>示例 :</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">给定这个链表：<span class="number">1</span>-><span class="number">2</span>-><span class="number">3</span>-><span class="number">4</span>-><span class="number">5</span></span><br><span class="line">当 k = <span class="number">2</span> 时，应当返回: <span class="number">2</span>-><span class="number">1</span>-><span class="number">4</span>-><span class="number">3</span>-><span class="number">5</span></span><br><span class="line">当 k = <span class="number">3</span> 时，应当返回: <span class="number">3</span>-><span class="number">2</span>-><span class="number">1</span>-><span class="number">4</span>-><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明 :</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><p><strong>解法一</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//非递归，理一下思路： 记录每次翻转前后的节点 然后翻转返回头 将每 K 个元素当成一个整体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode dummyNode=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next=head;</span><br><span class="line">    ListNode pre=dummyNode;</span><br><span class="line">    ListNode cur=head;</span><br><span class="line">    ListNode next=head;</span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="keyword">while</span>(next!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//temp 保存 cur 方便后面连接  K+1位置的元素</span></span><br><span class="line">        temp=cur;</span><br><span class="line">        <span class="comment">//k 个一组翻转</span></span><br><span class="line">        <span class="keyword">int</span> step=k;</span><br><span class="line">        <span class="keyword">while</span>(step><span class="number">0</span> && next!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//next走到 K+1 位置节点</span></span><br><span class="line">            next=next.next;</span><br><span class="line">            step--;</span><br><span class="line">            <span class="comment">//小细节 k>链表长度时应该直接返回（我认为）等下提交了看看</span></span><br><span class="line">            <span class="comment">//所以直接应该直接返回 (掉了k的值判断 因为有可能刚好有k个元素)</span></span><br><span class="line">            <span class="keyword">if</span>(next==<span class="keyword">null</span>&& step!=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//翻转 cur--next.prev 返回头节点</span></span><br><span class="line">        <span class="comment">//连接 反转后的头节点</span></span><br><span class="line">        pre.next=reverse(cur,k);</span><br><span class="line">        temp.next=next;</span><br><span class="line">        <span class="comment">//pre temp向后移动</span></span><br><span class="line">        pre=temp;</span><br><span class="line">        cur=next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1| 1 2 3 | 4 5 6 | 7 8</span></span><br><span class="line"><span class="comment">//翻转链表并返回子链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node,<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">    ListNode cur=node;</span><br><span class="line">    ListNode next=node;</span><br><span class="line">    <span class="keyword">while</span>(k><span class="number">0</span>&&next!=<span class="keyword">null</span>){</span><br><span class="line">        next=next.next;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=next;</span><br><span class="line">        k--;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//返回反转后的头节点</span></span><br><span class="line">    System.out.println(<span class="string">"头"</span>+pre.val);</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>7ms 74% 也是我第一道做出来的困难题，<a href="http://imlgw.top/2018/10/31/%E4%B8%80%E9%81%93LeetCode%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/">上一道困难题超时了</a><br>这题虽然说是困难题但是其实也不难，感觉就mid左右的水平，确实比上一题要复杂一点，但是只要思路理清楚其实也挺简单的，下面是我用OneNote画的一张图片。<br>4个指针分别对应 K 链表的 前一个(pre)  K链表的头节点(cur) 没有翻转前的K链表的头节点and<code>翻转后的尾节点(temp)</code>   K链表的后一个节点(next)。然后其实就简单了，写一个翻转链表的函数然后返回头节点(也可以多加一个指针指向<code>翻转前的头节点</code>)，然后就简单了，next指针一次走K步，走到 K+1 位置 同时也是<code>下一次K链表的头节点</code>，而temp则为下一次K链表的pre…然后循环这个过程就行了，其实写成递归会很简洁，但是我是真的不会写递归，太菜了Orz</p></blockquote><p><img alt="mark" data-src="http://static.imlgw.top///20190312/jl7moiy7PbjH.png?imageslim" src="/img/loading.gif" class="lazyload"></p><hr><h2 id="817-链表组件"><a href="#817-链表组件" class="headerlink" title="817. 链表组件"></a><strong>817. 链表组件</strong></h2><p>给定一个链表（链表结点包含一个整型值）的头结点 head。<br>同时给定列表 G，该列表是上述链表中整型值的一个子集。<br>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。<br>示例 1：<br>输入:<br>head: 0->1->2->3<br>G = [0, 1, 3]<br>输出: 2<br>解释:<br>链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。<br>示例 2：<br>输入:<br>head: 0->1->2->3->4<br>G = [0, 3, 1, 4]<br>输出: 2<br>解释:<br>链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。<br>注意:<br>如果 N 是给定链表 head 的长度，1 <= N <= 10000。<br>链表中每个结点的值所在范围为 [0, N - 1]。<br>1 <= G.length <= 10000<br>G 是链表中所有结点的值的一个子集.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode head, <span class="keyword">int</span>[] G)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode temp=head;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(isInG(temp.val,G)){</span><br><span class="line">            <span class="keyword">while</span>(temp!=<span class="keyword">null</span>&&isInG(temp.val,G)){</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            }</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isInG</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span>[] G)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<g.length;i++){< span><br><span class="line">        <span class="keyword">if</span>(G[i]==val){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></g.length;i++){<></span></pre></td></tr></tbody></table></figure></div><p>首先想到的方法 91ms 19%….. 有点慢了，然后我稍微改了下。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numComponents2</span><span class="params">(ListNode head, <span class="keyword">int</span>[] G)</span> </span>{</span><br><span class="line">    ListNode temp=head;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    Boolean [] isInG=<span class="keyword">new</span> Boolean[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<g.length;i++){< span><br><span class="line">            <span class="keyword">if</span>(G[i]==temp.val){</span><br><span class="line">                isInG[j]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        j++;</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    temp=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;temp!=<span class="keyword">null</span>;temp=temp.next,i++){</span><br><span class="line">        <span class="keyword">if</span>(isInG[i]){</span><br><span class="line">            <span class="keyword">while</span>(temp!=<span class="keyword">null</span>&&isInG[i]){</span><br><span class="line">                temp=temp.next;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></g.length;i++){<></span></pre></td></tr></tbody></table></figure></div><p>   用了一个数组保存了每个位置的状态速度跟前面的差不多。。。主要问题就是那个数组的创建，这种创建方式用连续的下标来对应连续的链表的每个元素，每次都要遍历G才知道当前位置是不是在G中。</p><p>   其实可以直接把当前节点的val作为数组的下标这样既有了对应关系也不用遍历G.可以说是很优秀了，但是实际上这样做是有前提条件的那就是链表中的元素值应该<code>没有负数</code>，还是题做少了啊 Orz。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numComponents3</span><span class="params">(ListNode head, <span class="keyword">int</span>[] G)</span> </span>{</span><br><span class="line">    ListNode temp=head;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    Boolean [] isInG=<span class="keyword">new</span> Boolean[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//换一种方式 以node.val作为数组的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:G){</span><br><span class="line">        isInG[i]=<span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(isInG[temp.val]){</span><br><span class="line">            <span class="keyword">while</span>(temp!=<span class="keyword">null</span>&&isInG[temp.val]){</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            }</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><strong>109. 有序链表转换二叉搜索树</strong></h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></tbody></table></figure></div><p>BST不太熟看了下评论写出来的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> build(head,<span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">build</span><span class="params">(ListNode head,ListNode tail)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(head==tail){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//快慢指针找中点</span></span><br><span class="line">    ListNode fast=head,slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=tail&&fast.next!=tail){</span><br><span class="line">        <span class="comment">//左闭右开</span></span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//slow为中点或中点后一个</span></span><br><span class="line">    <span class="comment">//1 2 3 4</span></span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">    root.left=build(head,slow);</span><br><span class="line">    root.right=build(slow.next,tail);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">1019. 链表中的下一个更大节点</a></h2><p>给出一个以头节点 <code>head</code> 作为第一个节点的链表。链表中的节点分别编号为：<code>node_1, node_2, node_3, ...</code> 。</p><p>每个节点都可能有下一个更大值（<em>next larger</em> <strong>value</strong>）：对于 <code>node_i</code>，如果其 <code>next_larger(node_i)</code> 是 <code>node_j.val</code>，那么就有 <code>j > i</code> 且  <code>node_j.val > node_i.val</code>，而 <code>j</code> 是可能的选项中最小的那个。如果不存在这样的 <code>j</code>，那么下一个更大值为 <code>0</code> 。</p><p>返回整数答案数组 <code>answer</code>，其中 <code>answer[i] = next_larger(node_{i+1})</code> 。</p><p><strong>注意：</strong>在下面的示例中，诸如 <code>[2,1,5]</code> 这样的<strong>输入</strong>（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 3：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><ol><li>对于链表中的每个节点，<code>1 <= node.val <= 10^9</code></li><li>给定列表的长度在 <code>[0, 10000]</code> 范围内</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) {</span><br><span class="line">    <span class="comment">//list里面存元素</span></span><br><span class="line">    ArrayList<integer> A = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (ListNode node = head; node != <span class="keyword">null</span>; node = node.next)</span><br><span class="line">                A.add(node.val);</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[A.size()];</span><br><span class="line">    <span class="comment">//栈里面存索引</span></span><br><span class="line">    Stack<integer> stack = <span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < A.size(); ++i) {</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() && A.get(stack.peek()) < A.get(i))</span><br><span class="line">             res[stack.pop()] = A.get(i);</span><br><span class="line">        stack.push(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>新题，磨了好长时间，没做出来。。。真是菜啊 Orz，70ms，因为跑两遍。下面这个<code>14ms</code>可以说是相当快了，但，时间可能耗费在建立栈和list上了，看了下提交上的前几个都是用的数组，用数组模拟的栈。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//和上面的方法差不多,但这个更快，上面那个跑了两遍</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextLargerNodes3(ListNode head) {</span><br><span class="line">    <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="comment">//temp是链表的副本，相当于上面的list</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="comment">//top 栈顶</span></span><br><span class="line">    <span class="keyword">int</span> top = -<span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (top != -<span class="number">1</span> && temp[stack[top]] < node.val){</span><br><span class="line">            <span class="comment">//后一个大于当前节点, 栈不为空</span></span><br><span class="line">            <span class="comment">//pop出比它小的元素并赋值res，重新生成单调栈</span></span><br><span class="line">            res[stack[top--]] = node.val;</span><br><span class="line">        }</span><br><span class="line">        stack[++top] = i;</span><br><span class="line">        temp[i++] = node.val;</span><br><span class="line">        node = node.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(res, i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路就是利用<code>单调栈</code>，栈里面存的索引对应的元素都是单调递减的，遇到不递减的就会一直pop()直到再次单调递减。这样很容易就找到了每个元素的下一个最大元素了。</p><p>19.7.21 重新做了一遍这道题，第一遍还是没想出来，还是看了之前的代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextLargerNodes5(ListNode head) {</span><br><span class="line">        List<integer> list=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        ListNode temp=head;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>){</span><br><span class="line">            list.add(temp.val);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> [] stack=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">int</span> stackIndex=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<list.size();i++) {< span><br><span class="line">            <span class="keyword">while</span>(stackIndex!=-<span class="number">1</span> && list.get(i)>list.get(stack[stackIndex])){</span><br><span class="line">                res[stack[stackIndex--]]=list.get(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//维护一个递减的栈</span></span><br><span class="line">            stack[++stackIndex]=i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>  Arrays.copyOf(res, list.size());</span><br><span class="line">}</span><br></list.size();i++)></span></pre></td></tr></tbody></table></figure></div><p>相比上面的方法一，采用了数组模拟队列(数据范围已经给定了)，30ms，80% 。仔细看看代码发现其实第一个循环完全没有必要，可以一边遍历一边存进去。</p><p><strong>一次遍历</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextLargerNodes6(ListNode head) {</span><br><span class="line">    List<integer> list=<span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    ListNode temp=head;</span><br><span class="line">    <span class="keyword">int</span> [] stack=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> stackIndex=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> [] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;temp!=<span class="keyword">null</span>;i++) {</span><br><span class="line">        list.add(temp.val);</span><br><span class="line">        <span class="keyword">while</span>(stackIndex!=-<span class="number">1</span> && list.get(i)>list.get(stack[stackIndex])){</span><br><span class="line">            res[stack[stackIndex--]]=list.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//维护一个递减的栈</span></span><br><span class="line">        stack[++stackIndex]=i;</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>  Arrays.copyOf(res, list.size());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>优化后发现比之前还慢了。。。</p><p><strong>数组模拟链表</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextLargerNodes7(ListNode head) {</span><br><span class="line">       <span class="keyword">int</span> [] list=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">       ListNode temp=head;</span><br><span class="line">       <span class="keyword">int</span> [] stack=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">       <span class="keyword">int</span> stackIndex=-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> [] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> i;</span><br><span class="line">       <span class="keyword">for</span> ( i=<span class="number">0</span>;temp!=<span class="keyword">null</span>;i++) {</span><br><span class="line">           list[i]=temp.val;</span><br><span class="line">           <span class="keyword">while</span>(stackIndex!=-<span class="number">1</span> && list[i]>list[stack[stackIndex]]){</span><br><span class="line">               res[stack[stackIndex--]]=list[i];</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">//维护一个递减的栈</span></span><br><span class="line">           stack[++stackIndex]=i;</span><br><span class="line">           temp=temp.next;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span>  Arrays.copyOf(res, i);</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div><p>这次提交了几次直接 8ms 100%了。。。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的排序算法总结</title>
      <link href="/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/"/>
      <url>/2018/12/11/chang-jian-pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="常见排序算法总结"><a href="#常见排序算法总结" class="headerlink" title="常见排序算法总结"></a>常见排序算法总结</h2><p>关于排序的部分一直想总结下一直没时间，现在来总结下吧。gif图来自微信上的文章 (<strong>五分钟学算法</strong>的公众号，挺不错干货挺多的)，原理性的东西就不讲了，图讲的比我好。如果还是不懂可以看看《算法》里面的轨迹图，那个也很直观 </p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>  <img alt="weixin" data-src="http://static.imlgw.top/f02ace7b7fb9b810274e683c2be54a02_640_wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1.gif" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaoPaoSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i>=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<i;j++){< span><br><span class="line">            <span class="keyword">if</span>(nums[j]>nums[j+<span class="number">1</span>]){</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></i;j++){<></span></pre></td></tr></tbody></table></figure></div><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img alt="weixin" data-src="http://static.imlgw.top/640.gif" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">        <span class="keyword">int</span> min=nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j<nums.length;j++){< span><br><span class="line">            <span class="keyword">if</span>(nums[j]<min){< span><br><span class="line">                min=nums[j];</span><br><span class="line">                swap(nums,j,i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></min){<></span></nums.length;j++){<></span></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><img alt="weixin" data-src="http://static.imlgw.top/640%20%281%29.gif" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++){< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j><span class="number">0</span>&&nums[j]<nums[j-<span class="number">1</nums[j-<span></span>];j--){</nums.length;i++){<></span><br><span class="line">            swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img alt="weixin" data-src="http://static.imlgw.top/640%20%282%29.gif" src="/img/loading.gif" class="lazyload"></p><h4 id="图上面的是递归版本的归并，实现如下"><a href="#图上面的是递归版本的归并，实现如下" class="headerlink" title="图上面的是递归版本的归并，实现如下"></a>图上面的是递归版本的归并，实现如下</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">    help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    MergerSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(left>=right){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用merger2的方式(也不好，应该保证辅助数组只初始化一次)</span></span><br><span class="line">    <span class="comment">//help=new int[nums.length];</span></span><br><span class="line">    <span class="keyword">int</span> mid=left+((right-left)>><span class="number">1</span>);</span><br><span class="line">    MergerSort(nums,left,mid);</span><br><span class="line">    MergerSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    merger(nums,left,mid,right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> []help;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//其实没区别空间复杂度，都是O(N) 后面这个会更加耗费时间</span></span><br><span class="line">    <span class="comment">//int []help=new int[right-left+1];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k<=right;k++){</span><br><span class="line">        <span class="comment">//一边的到达尽头,先判断两个边界,不然就要想下面那样写</span></span><br><span class="line">        <span class="keyword">if</span>(i>mid){</span><br><span class="line">            help[k]=nums[j++];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(j>right){</span><br><span class="line">            help[k]=nums[i++];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]>nums[j]){</span><br><span class="line">            help[k]=nums[j++];</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//相等的时候左边先进栈保证稳定性</span></span><br><span class="line">            help[k]=nums[i++];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*// 2 </span></span><br><span class="line"><span class="comment">            if( i<=mid &&j<=right && nums[i]>nums[j]){</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            }else if( i<=mid &&j<=right && nums[i]<=nums[j]){</span></span><br><span class="line"><span class="comment">                //相等的时候左边先进栈保证稳定性</span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            }else if(i>mid){</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            }else if(j>right){ </span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//复制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k<=right;k++){</span><br><span class="line">        nums[k]=help[k];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*while (p1 <= m && p2 <= r) {</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        while (p1 <= m) {</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1++];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        while (p2 <= r) {</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p2++];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        for (i = 0; i < help.length; i++) {</span></span><br><span class="line"><span class="comment">            arr[l + i] = help[i];</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序（非递归，方向不一样，时间复杂度一样都为O(NlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSortNoRecurse</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">    help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//控制合并的长度 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz=<span class="number">1</span>;sz<nums.length;sz*=<span class="number">2</nums.length;sz*=<span></span>){<br><span class="line">        <span class="comment">//控制合并的向后移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length-sz;i+=<span class="number">2</nums.length-sz;i+=<span></span>*sz){<br><span class="line">            <span class="keyword">int</span> r=i+<span class="number">2</span>*sz-<span class="number">1</span><nums.length-<span class="number">1</nums.length-<span></span>?i+<span class="number">2</span>*sz-<span class="number">1</span>:nums.length-<span class="number">1</span>;<br><span class="line">            merger(nums,i,i+sz-<span class="number">1</span>,r);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="三向切分的快排-荷兰国旗问题"><a href="#三向切分的快排-荷兰国旗问题" class="headerlink" title="三向切分的快排(荷兰国旗问题)"></a>三向切分的快排(荷兰国旗问题)</h3><p><img alt="weixin" data-src="http://static.imlgw.top/640%20%283%29.gif" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//快排 (不具有稳定性或者难以实现)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(l>r){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//随机一个数和r交换 ---随机快排</span></span><br><span class="line">    swap(nums, l + (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)), r);</span><br><span class="line">    <span class="keyword">int</span> []index=partition2(nums,l,r);</span><br><span class="line">    QuickSort(nums,l,index[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">    QuickSort(nums,index[<span class="number">1</span>]+<span class="number">1</span>,r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> base = l;</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">int</span> lo = l, hi = r;</span><br><span class="line">    <span class="comment">//这种partition的实现细节有点不好理解</span></span><br><span class="line">    <span class="comment">//这种partition不能随机基准元素。。。。</span></span><br><span class="line">    <span class="comment">//参照了左神的代码发现其实可以在partition之前随机一个变量和lo交换，也有同样的效果也消除了输入的影响</span></span><br><span class="line">    <span class="keyword">while</span> (lo < hi) {</span><br><span class="line">        <span class="comment">//必须先从右往左,主要是为了归位的时候不出现问题</span></span><br><span class="line">        <span class="comment">//比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是lo和一个比lo大的数然而比lo大的数应该放在右边</span></span><br><span class="line">        <span class="comment">//反之如果选的是hi为基准就要先从左往右</span></span><br><span class="line">        <span class="comment">// 7  0  1  2    10  11  22</span></span><br><span class="line">        <span class="keyword">while</span> (nums[hi] >= nums[base] && lo < hi) {</span><br><span class="line">            hi--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (nums[lo] <= nums[base] && lo < hi) {</span><br><span class="line">            lo++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (lo < hi) {</span><br><span class="line">            swap(nums, lo, hi);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//归位 lo==hi</span></span><br><span class="line">    swap(nums, hi, base);</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//荷兰国旗优化的快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition2(<span class="keyword">int</span> []arr ,<span class="keyword">int</span> l,<span class="keyword">int</span> r){</span><br><span class="line">    <span class="comment">// 7  0  1  2    10  11  22        </span></span><br><span class="line">    <span class="comment">//小于区为空</span></span><br><span class="line">    <span class="keyword">int</span> less=l-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//l ----> more 为待定区</span></span><br><span class="line">    <span class="keyword">int</span> more=r;</span><br><span class="line">    <span class="keyword">while</span>(l<more){< span><br><span class="line">        <span class="keyword">if</span>(arr[l]<arr[r]){< span><br><span class="line">            swap(arr,++less,l++);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(arr[l]>arr[r]){</span><br><span class="line">            <span class="comment">//大于基准时 , 大于区扩大(大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能l++)</span></span><br><span class="line">            swap(arr,--more,l);</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            l++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//和大于区间的第一个交换 保证归位正确,如果选取的是以最左边为基准元素 这里就应该和less交换</span></span><br><span class="line">    <span class="comment">//到这里  [less+1,more-1]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">    swap(arr,more,r);</span><br><span class="line">    <span class="comment">//到这  [less+1,more]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{less+<span class="number">1</span>,more};</span><br><span class="line">}</span><br></arr[r]){<></span></more){<></span></pre></td></tr></tbody></table></figure></div><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img alt="weixin" data-src="http://static.imlgw.top/640%20%284%29.gif" src="/img/loading.gif" class="lazyload"></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(nums.length<<span class="number">2</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//构建大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i<nums.length; i++) {< span><br><span class="line">        heapInsert(nums,i);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//交换堆顶和最后一个节点</span></span><br><span class="line">    <span class="keyword">int</span> size= nums.length;</span><br><span class="line">    swap(nums,size-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">while</span>(size><span class="number">1</span>){</span><br><span class="line">        <span class="comment">//调整</span></span><br><span class="line">        heapIfy(nums,<span class="number">0</span>,size);</span><br><span class="line">        <span class="comment">//每次都和最后一个孩子节点交换，然后size--</span></span><br><span class="line">        swap(nums,--size,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上爬</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> []nums, <span class="keyword">int</span> index)</span></span>{</span><br><span class="line">    <span class="comment">//迭代比较当前节点和父节点的值的大小</span></span><br><span class="line">    <span class="keyword">while</span>(nums[index]>nums[(index-<span class="number">1</span>)/<span class="number">2</span>]){</span><br><span class="line">        swap(nums,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        index=(index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下爬</span></span><br><span class="line"><span class="comment">//index位置的值变小后继续调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapIfy</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> index,<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">    <span class="comment">//左孩子</span></span><br><span class="line">    <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//节点有左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(left<size){< span><br><span class="line">        <span class="comment">//判断是否有右孩子.....</span></span><br><span class="line">        <span class="comment">//左右孩子里的最大值 有右孩子且右孩子大于左孩子</span></span><br><span class="line">        <span class="keyword">int</span> largest=left+<span class="number">1</span><size && nums[left]<nums[left+<span class="number">1</size></span>] ?left+<span class="number">1</span>:left;</size){<></span><br><span class="line">        largest=nums[largest]>nums[index]?largest:index;</span><br><span class="line">        <span class="comment">//最大值等于自己</span></span><br><span class="line">        <span class="keyword">if</span>(largest==index){</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//交换大孩子节点和自己</span></span><br><span class="line">        swap(nums,largest,index);</span><br><span class="line">        <span class="comment">//设置大孩子的index和左孩子</span></span><br><span class="line">        index=largest;</span><br><span class="line">        left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;></span></pre></td></tr></tbody></table></figure></div><h3 id="堆排序更优的做法"><a href="#堆排序更优的做法" class="headerlink" title="堆排序更优的做法"></a>堆排序更优的做法</h3><p>上面的做法并不是最优的堆排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> last=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//N构建大根堆</span></span><br><span class="line">    <span class="comment">//从倒数第二层开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length/<span class="number">2</span>-<span class="number">1</span> ;i>=<span class="number">0</span>;i--){</span><br><span class="line">        heapIfy(nums,i,last);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//printArray(nums);</span></span><br><span class="line">    <span class="keyword">while</span>(last>=<span class="number">1</span>){</span><br><span class="line">        swap(nums,<span class="number">0</span>,last--);</span><br><span class="line">        heapIfy(nums,<span class="number">0</span>,last);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//i 大根堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapIfy</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> last)</span></span>{</span><br><span class="line">    <span class="comment">//判断有没有子节点（左孩子）</span></span><br><span class="line">    <span class="keyword">int</span> left=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left<=last){</span><br><span class="line">        <span class="keyword">int</span> right=left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点最大值</span></span><br><span class="line">        <span class="keyword">int</span> larger=right<=last && nums[right] > nums[left]?right:left;</span><br><span class="line">        <span class="keyword">if</span>(nums[larger]>nums[i]){</span><br><span class="line">            swap(nums,larger,i);</span><br><span class="line">            i=larger;</span><br><span class="line">            left=larger*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>对比之前的方法，构造堆的方式发生了变化，上面那种通过自上而下的<code>insert</code>方式时间复杂度是<code>O(NlogN)</code>，其实仔细想想，这两种方式是完全相反的，insert的方式，最后一层每个元素最坏都可能调整<code>logN</code>次，而最后一层也是元素最多的一层，这样一来复杂度就会大大增加，相反如果采用从底向上的<code>heapIfy</code>方式最后一层都只需要调整<code>1</code>次，而根节点需要调整<code>logN</code>次，而根节点<strong>只有一个</strong>时间复杂度就会大大降低，最终的时间复杂度就是O(N)，<a href="https://www.zhihu.com/question/20729324" target="_blank" rel="noopener">具体推算过程可以看这些回答</a> </p><p><strong>手推过程</strong></p><p><img alt="img" data-src="http://static.imlgw.top/image/20190617/kVuvnMfjuSns.png?imageslim" src="/img/loading.gif" class="lazyload"></p><p>最后推得到得复杂度是小于<code>O(2N)</code>，也就是<code>O(N)</code>的时间复杂度，如果不是刷<code>leetCode</code> 看到了类似的题可能会一直被那样去写😂</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>实际上写排序就是基于插入排序的，在它之上进行了数学上的优化。</p><p><img alt="image" data-src="http://static.imlgw.top/640%20%285%29.gif" src="/img/loading.gif" class="lazyload"><br>    实际上从逆序对的角度来看，基于比较的排序就是为了消除逆序对的个数，而诸如冒泡选择每次都只是交换相邻的两个元素，每次交换最多只减少一个逆序对，而希尔排序扩大了这个间距，就增大了减少逆序对的可能。不过要研究他的时间复杂度就是数学上的研究的问题了，至于每次间距都减半这个也是根据大样本测试下这种递增序列性能会更好 O(∩_∩)O</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序的改进</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> h=nums.length>><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h><span class="number">0</span>){</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=h;i<nums.length;i++){< span><br><span class="line">            <span class="comment">//实际上是增大了插入排序的间隙，最后还是对进行一次插入排序,不过那个时候的数据已经是高度有序了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j-h>=<span class="number">0</span>&&nums[j]<nums[j-h];j-=h) {< span><br><span class="line">                swap(nums,j,j-h);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        h=h>><span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums[j-h];j-=h)></span></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><hr><h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h3><p>排个序还能排出Bug？对的没错就是排出了Bug🤣 看看我最开始写的交换函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    nums[a]=nums[a]^nums[b];</span><br><span class="line">    nums[b]=nums[a]^nums[b];</span><br><span class="line">    nums[a]=nums[a]^nums[b];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>为了抖这个机灵付出了惨痛的代价，之前用 >> 拿来当除2操作的时候就忽略了<code>优先级</code>的问题。。。那这里的机灵有什么问题呢？一个数异或同一个数两次就还原没毛病啊？But如果交换的两个数是同一个元素比如上面在数组中 a==b时 nums[a]异或了3次自己相当于<code>nums[a]^nums[a]^nums[a]^nums[a]=0^0=0</code>，最后就会出问题,其实开始前面的排序都没有出现问题，主要是后面的快排时发现了这个Bug因为快排为了避免数据分布的影响随机选取基准值，可能随机的是最后一个，而且快排的partition过程中也会有时也会自己和自己交换，最开始的第一步就是自己和直接交换，让小于区扩大。所以这个方法仅仅只能用来抖一抖机灵，没啥实际意义，以后还是要老老实实写，不然咋死的都不知道😁</p><blockquote><p> 未完待续……还有一类非基于比较的排序 桶排序之类的等后面再来总结加上去.</p></blockquote><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>直接拿的左神的对数器😄，所有排序都是经过对数器测试的。 <em>talk is cheap show me the code</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorts</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/*int []nums={1,0,-1,-22,213,4,535,-112,99999};</span></span><br><span class="line"><span class="comment">        //ShellSort(nums);</span></span><br><span class="line"><span class="comment">        //MaoPaoSort(nums);</span></span><br><span class="line"><span class="comment">        //SelectSort(nums);</span></span><br><span class="line"><span class="comment">        //MergerSort(nums,0,nums.length-1);</span></span><br><span class="line"><span class="comment">        QuickSort(nums,0,nums.length-1);</span></span><br><span class="line"><span class="comment">        printArray(nums);*/</span></span><br><span class="line">        <span class="keyword">int</span> testTime = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">        Boolean succeed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < testTime; i++) {</span><br><span class="line">            <span class="keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">            <span class="keyword">long</span> time=System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//冒泡</span></span><br><span class="line">            <span class="comment">//MaoPaoSort(arr1);</span></span><br><span class="line">            <span class="comment">//选择</span></span><br><span class="line">            <span class="comment">//SelectSort(arr1);</span></span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            <span class="comment">//InsertSort(arr1);</span></span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">            <span class="comment">//MergerSort(arr1);</span></span><br><span class="line">            <span class="comment">//非递归归并</span></span><br><span class="line">            <span class="comment">//MergerSortNoRecurse(arr1);</span></span><br><span class="line">            <span class="comment">//希尔</span></span><br><span class="line">            <span class="comment">//ShellSort(arr1);</span></span><br><span class="line">            <span class="comment">//快排</span></span><br><span class="line">            <span class="comment">//QuickSort(arr1,0,arr1.length-1);</span></span><br><span class="line">            <span class="comment">//堆排序</span></span><br><span class="line">            HeapSort(arr1);</span><br><span class="line">            <span class="keyword">long</span> time2=System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                System.out.println(time2-time);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//系统排序</span></span><br><span class="line">            comparator(arr2);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>){</span><br><span class="line">                System.out.println(System.currentTimeMillis()-time2);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!isEqual(arr1, arr2)) {</span><br><span class="line">                succeed = <span class="keyword">false</span>;</span><br><span class="line">                printArray(arr1);</span><br><span class="line">                printArray(arr2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(succeed ? <span class="string">"Nice!"</span> : <span class="string">"Fucking fucked!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//初级排序算法</span></span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//冒泡排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaoPaoSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i>=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j<i;j++){< span><br><span class="line">                <span class="keyword">if</span>(nums[j]>nums[j+<span class="number">1</span>]){</span><br><span class="line">                    swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">            <span class="keyword">int</span> min=nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j<nums.length;j++){< span><br><span class="line">                <span class="keyword">if</span>(nums[j]<min){< span><br><span class="line">                    min=nums[j];</span><br><span class="line">                    swap(nums,j,i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//直接插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i<nums.length;i++){< span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j><span class="number">0</span>&&nums[j]<nums[j-<span class="number">1</nums[j-<span></span>];j--){</nums.length;i++){<></span><br><span class="line">                swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//插入排序的改进</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> h=nums.length>><span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h><span class="number">0</span>){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=h;i<nums.length;i++){< span><br><span class="line">                <span class="comment">//实际上是增大了插入排序的间隙，最后还是对进行一次插入排序,不过那个时候的数据已经是高度有序了</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j-h>=<span class="number">0</span>&&nums[j]<nums[j-h];j-=h) {< span><br><span class="line">                    swap(nums,j,j-h);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            h=h>><span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">        help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        MergerSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left>=right){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//不能直接在这里创建数组，严重影响性能，可以在上面再套一层方法，或者采用merger2的方式(也不好，应该保证辅助数组只初始化一次)</span></span><br><span class="line">        <span class="comment">//help=new int[nums.length];</span></span><br><span class="line">        <span class="keyword">int</span> mid=left+((right-left)>><span class="number">1</span>);</span><br><span class="line">        MergerSort(nums,left,mid);</span><br><span class="line">        MergerSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        merger(nums,left,mid,right);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> []help;</span><br><span class="line">    <span class="comment">//归并操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//其实没区别空间复杂度，都是O(N) 后面这个会更加耗费时间</span></span><br><span class="line">        <span class="comment">//int []help=new int[right-left+1];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k<=right;k++){</span><br><span class="line">            <span class="comment">//一边的到达尽头,先判断两个边界,不然就要想下面那样写</span></span><br><span class="line">            <span class="keyword">if</span>(i>mid){</span><br><span class="line">                help[k]=nums[j++];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(j>right){</span><br><span class="line">                help[k]=nums[i++];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]>nums[j]){</span><br><span class="line">                help[k]=nums[j++];</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//相等的时候左边先进栈保证稳定性</span></span><br><span class="line">                help[k]=nums[i++];</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">/*// 2 </span></span><br><span class="line"><span class="comment">            if( i<=mid &&j<=right && nums[i]>nums[j]){</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            }else if( i<=mid &&j<=right && nums[i]<=nums[j]){</span></span><br><span class="line"><span class="comment">                //相等的时候左边先进栈保证稳定性</span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            }else if(i>mid){</span></span><br><span class="line"><span class="comment">                help[k]=nums[j++];</span></span><br><span class="line"><span class="comment">            }else if(j>right){ </span></span><br><span class="line"><span class="comment">                help[k]=nums[i++];</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k<=right;k++){</span><br><span class="line">            nums[k]=help[k];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//asddsdasdasdasd</span></span><br><span class="line">        <span class="comment">/*while (p1 <= m && p2 <= r) {</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        while (p1 <= m) {</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p1++];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        while (p2 <= r) {</span></span><br><span class="line"><span class="comment">            help[i++] = arr[p2++];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        for (i = 0; i < help.length; i++) {</span></span><br><span class="line"><span class="comment">            arr[l + i] = help[i];</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//归并排序（非递归，方向不一样，时间复杂度一样都为O(NlogN)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergerSortNoRecurse</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">        help=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//控制合并的长度 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz=<span class="number">1</span>;sz<nums.length;sz*=<span class="number">2</nums.length;sz*=<span></span>){</nums[j-h];j-=h)></span><br><span class="line">            <span class="comment">//控制合并的向后移动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length-sz;i+=<span class="number">2</nums.length-sz;i+=<span></span>*sz){</nums.length;i++){<></span><br><span class="line">                <span class="keyword">int</span> r=i+<span class="number">2</span>*sz-<span class="number">1</span><nums.length-<span class="number">1</nums.length-<span></span>?i+<span class="number">2</span>*sz-<span class="number">1</span>:nums.length-<span class="number">1</span>;</min){<></span><br><span class="line">                merger(nums,i,i+sz-<span class="number">1</span>,r);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//快排 (不具有稳定性或者难以实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(l>r){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//随机一个数和r交换 ---随机快排</span></span><br><span class="line">        swap(nums, l + (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)), r);</span><br><span class="line">        <span class="keyword">int</span> []index=partition2(nums,l,r);</span><br><span class="line">        QuickSort(nums,l,index[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">        QuickSort(nums,index[<span class="number">1</span>]+<span class="number">1</span>,r);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span> []nums ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> base = l;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> lo = l, hi = r;</span><br><span class="line">        <span class="comment">//这种partition的实现细节有点不好理解</span></span><br><span class="line">        <span class="comment">//这种partition不能随机基准元素。。。。</span></span><br><span class="line">        <span class="comment">//参照了左神的代码发现其实可以在partition之前随机一个变量和lo交换，也有同样的效果也消除了输入的影响</span></span><br><span class="line">        <span class="keyword">while</span> (lo < hi) {</span><br><span class="line">            <span class="comment">//必须先从右往左,主要是为了归位的时候不出现问题</span></span><br><span class="line">            <span class="comment">//比如这里选取的基准元素是 lo 也就是子数组的第一个元素，如果先从左往右最后交换的就是lo和一个比lo大的数然而比lo大的数应该放在右边</span></span><br><span class="line">            <span class="comment">//反之如果选的是hi为基准就要先从左往右</span></span><br><span class="line">            <span class="comment">// 7  0  1  2    10  11  22</span></span><br><span class="line">            <span class="keyword">while</span> (nums[hi] >= nums[base] && lo < hi) {</span><br><span class="line">                hi--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (nums[lo] <= nums[base] && lo < hi) {</span><br><span class="line">                lo++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (lo < hi) {</span><br><span class="line">                swap(nums, lo, hi);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//归位 lo==hi</span></span><br><span class="line">        swap(nums, hi, base);</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//荷兰国旗优化的快排</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition2(<span class="keyword">int</span> []arr ,<span class="keyword">int</span> l,<span class="keyword">int</span> r){</span><br><span class="line">        <span class="comment">// 7  0  1  2    10  11  22        </span></span><br><span class="line">        <span class="comment">//小于区为空</span></span><br><span class="line">        <span class="keyword">int</span> less=l-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//l ----> more 为待定区</span></span><br><span class="line">        <span class="keyword">int</span> more=r;</span><br><span class="line">        <span class="keyword">while</span>(l<more){< span><br><span class="line">            <span class="keyword">if</span>(arr[l]<arr[r]){< span><br><span class="line">                swap(arr,++less,l++);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(arr[l]>arr[r]){</span><br><span class="line">                <span class="comment">//大于基准时 , 大于区扩大(大于区的前一个元素和当前元素交换，但是不知道大于区的前一个元素是什么情况，所以不能l++)</span></span><br><span class="line">                swap(arr,--more,l);</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                l++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//和大于区间的第一个交换 保证归位正确,如果选取的是以最左边为基准元素 这里就应该和less交换</span></span><br><span class="line">        <span class="comment">//到这里  [less+1,more-1]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">        swap(arr,more,r);</span><br><span class="line">        <span class="comment">//到这  [less+1,more]之间都是等于 基准元素 arr【r】 的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{less+<span class="number">1</span>,more};</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.length<<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//构建大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i<nums.length; i++) {< span><br><span class="line">            heapInsert(nums,i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个节点</span></span><br><span class="line">        <span class="keyword">int</span> size= nums.length;</span><br><span class="line">        swap(nums,size-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size><span class="number">1</span>){</span><br><span class="line">            <span class="comment">//调整</span></span><br><span class="line">            heapIfy(nums,<span class="number">0</span>,size);</span><br><span class="line">            <span class="comment">//每次都和最后一个孩子节点交换，然后size--</span></span><br><span class="line">            swap(nums,--size,<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//向上爬</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> []nums, <span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="comment">//迭代比较当前节点和父节点的值的大小</span></span><br><span class="line">        <span class="keyword">while</span>(nums[index]>nums[(index-<span class="number">1</span>)/<span class="number">2</span>]){</span><br><span class="line">            swap(nums,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            index=(index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//向下爬</span></span><br><span class="line">    <span class="comment">//index位置的值变小后继续调整为大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapIfy</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> index,<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//节点有左孩子</span></span><br><span class="line">        <span class="keyword">while</span>(left<size){< span><br><span class="line">            <span class="comment">//判断是否有右孩子.....</span></span><br><span class="line">            <span class="comment">//左右孩子里的最大值 有右孩子且右孩子大于左孩子</span></span><br><span class="line">            <span class="keyword">int</span> largest=left+<span class="number">1</span><size && nums[left]<nums[left+<span class="number">1</size></span>] ?left+<span class="number">1</span>:left;</size){<></span><br><span class="line">            largest=nums[largest]>nums[index]?largest:index;</span><br><span class="line">            <span class="comment">//最大值等于自己</span></span><br><span class="line">            <span class="keyword">if</span>(largest==index){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//交换大孩子节点和自己</span></span><br><span class="line">            swap(nums,largest,index);</span><br><span class="line">            <span class="comment">//设置大孩子的index和左孩子</span></span><br><span class="line">            index=largest;</span><br><span class="line">            left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//************************************************************************</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="comment">//不知道为啥快排交换的时候这样写会出现很多0</span></span><br><span class="line">        <span class="comment">//查询知道，当a==b时自己和直接交换，a异或自己4次后a==0.....</span></span><br><span class="line">        nums[a]=nums[a]^nums[b];</span><br><span class="line">        nums[b]=nums[a]^nums[b];</span><br><span class="line">        nums[a]=nums[a]^nums[b];</span><br><span class="line">        <span class="comment">/*int temp=nums[a];</span></span><br><span class="line"><span class="comment">        nums[a]=nums[b];</span></span><br><span class="line"><span class="comment">        nums[b]=temp;*/</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// for test  对数器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">comparator</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) {</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr.length; i++) {</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) (maxValue * Math.random());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr) {</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr.length; i++) {</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> ((arr1 == <span class="keyword">null</span> && arr2 != <span class="keyword">null</span>) || (arr1 != <span class="keyword">null</span> && arr2 == <span class="keyword">null</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> && arr2 == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (arr1.length != arr2.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr1.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i]) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr.length; i++) {</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;></span></arr[r]){<></span></more){<></span></nums.length;j++){<></span></nums.length;i++){<></span></i;j++){<></span></pre></td></tr></tbody></table></figure></div><p>​        </p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS模仿Express封装路由</title>
      <link href="/2018/12/03/nodejs-mo-fang-express-feng-zhuang-lu-you/"/>
      <url>/2018/12/03/nodejs-mo-fang-express-feng-zhuang-lu-you/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="NodeJS模仿Express封装路由"><a href="#NodeJS模仿Express封装路由" class="headerlink" title="NodeJS模仿Express封装路由"></a>NodeJS模仿Express封装路由</h2><p><em>最近才开始学NodeJs也不知道为啥就突然对这个很感兴趣,(可能Java写烦了😄)，感觉用这个开发还是挺快的，而且性能也很好，借此也了解下函数式编程的特点和异步编程的思想。</em></p><ul><li><h3 id="没封装前"><a href="#没封装前" class="headerlink" title="没封装前"></a>没封装前</h3>原生的就差不多是这样的。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Node.js 未封装 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> http = require(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = require(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = require(<span class="string">"querystring"</span>); <span class="comment">//json转换</span></span><br><span class="line"><span class="keyword">const</span> scores = require(<span class="string">"./StudentScore.json"</span>);</span><br><span class="line"><span class="keyword">const</span> template = require(<span class="string">"art-template"</span>);</span><br><span class="line">http.createServer((req, resp) => {</span><br><span class="line">    <span class="keyword">if</span> (req.url.startsWith(<span class="string">"/query"</span>) && req.method == <span class="string">'GET'</span>) {</span><br><span class="line">        <span class="comment">//这里可以采用模板为了和下面的对比一下</span></span><br><span class="line">        fs.readFile(path.join(__dirname, <span class="string">"querypage.html"</span>), (err, content) => {</span><br><span class="line">            <span class="keyword">if</span> (err) {</span><br><span class="line">                resp.writeHead(<span class="number">500</span>, {</span><br><span class="line">                    <span class="string">'Content-Type'</span>: <span class="string">'text/plain;charset=utf8'</span></span><br><span class="line">                });</span><br><span class="line">                resp.end(<span class="string">'服务器错误'</span>);</span><br><span class="line">            }</span><br><span class="line">            resp.end(content);</span><br><span class="line">        });</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (req.url.startsWith(<span class="string">"/scores"</span>)) {</span><br><span class="line">        let pdata = <span class="string">''</span>;</span><br><span class="line">        <span class="comment">//事件绑定</span></span><br><span class="line">        <span class="comment">//获取数据（id）</span></span><br><span class="line">        req.on(<span class="string">'data'</span>, (ck) => {</span><br><span class="line">            pdata += ck;</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">//在这里返回</span></span><br><span class="line">        req.on(<span class="string">'end'</span>, () => {</span><br><span class="line">            let obj = querystring.parse(pdata); <span class="comment">//将参数 的字符串转换成 对象</span></span><br><span class="line">            let result = scores[obj.stunum];</span><br><span class="line">            let content = template(path.join(__dirname, <span class="string">"scores.art"</span>), result);</span><br><span class="line">            resp.end(content);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}).listen(<span class="number">9999</span>, () => {</span><br><span class="line">    console.log(<span class="string">'Server is runing on 9999'</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div><ul><li>Express的方式<br>通过const app=express(); 获得一个app的对象后面就通过这个来操作<br><img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/D~KS%28D1%5B%5DUS5TBZPO7KTJ88.png" src="/img/loading.gif" class="lazyload"></li><li>手动封装</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = require(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装方法改变res  绑定res.send()</span></span><br><span class="line"><span class="function">function <span class="title">changeRes</span><span class="params">(res)</span> </span>{</span><br><span class="line"></span><br><span class="line">    res.send = function(data) {</span><br><span class="line"></span><br><span class="line">        res.writeHead(<span class="number">200</span>, {</span><br><span class="line">            <span class="string">"Content-Type"</span>: <span class="string">"text/html;charset=utf-8"</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        res.end(data);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义暴露的模块  return 里面定义的模块</span></span><br><span class="line"><span class="keyword">var</span> Server = function() {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> G = <span class="keyword">this</span>; <span class="comment">/*全局变量*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理get和post请求</span></span><br><span class="line">    <span class="keyword">this</span>._get = {};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._post = {};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> app = function(req, res) {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        changeRes(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取路由</span></span><br><span class="line">        <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">        <span class="keyword">if</span> (!pathname.endsWith(<span class="string">'/'</span>)) {</span><br><span class="line">            pathname = pathname + <span class="string">'/'</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求的方式 get  post</span></span><br><span class="line">        <span class="keyword">var</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (G[<span class="string">'_'</span> + method][pathname]) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (method == <span class="string">'post'</span>) { <span class="comment">/*执行post请求*/</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> postStr = <span class="string">''</span>;</span><br><span class="line">                req.on(<span class="string">'data'</span>, function(chunk) {</span><br><span class="line"></span><br><span class="line">                    postStr += chunk;</span><br><span class="line">                })</span><br><span class="line">                req.on(<span class="string">'end'</span>, function(err, chunk) {</span><br><span class="line">                    <span class="comment">//添加请求属性</span></span><br><span class="line">                    req.myBody = postStr; <span class="comment">/*表示拿到post的值*/</span></span><br><span class="line">                    <span class="comment">/*执行方法*/</span></span><br><span class="line">                    G[<span class="string">'_'</span> + method][pathname](req, res);</span><br><span class="line">                })</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">/*执行get请求*/</span></span><br><span class="line">                G[<span class="string">'_'</span> + method][pathname](req, res); <span class="comment">/*执行方法*/</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res.end(<span class="string">'no router'</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的都是为了做注册的操作</span></span><br><span class="line">    app.get = function(string, callback) {</span><br><span class="line">        <span class="keyword">if</span> (!string.endsWith(<span class="string">'/'</span>)) {</span><br><span class="line">            string = string + <span class="string">'/'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!string.startsWith(<span class="string">'/'</span>)) {</span><br><span class="line">            string = <span class="string">'/'</span> + string;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    /login/</span></span><br><span class="line">        G._get[string] = callback;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    app.post = function(string, callback) {</span><br><span class="line">        <span class="keyword">if</span> (!string.endsWith(<span class="string">'/'</span>)) {</span><br><span class="line">            string = string + <span class="string">'/'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!string.startsWith(<span class="string">'/'</span>)) {</span><br><span class="line">            string = <span class="string">'/'</span> + string;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//    /login/</span></span><br><span class="line">        G._post[string] = callback;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//G._post['dologin']=function(req,res){</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = Server();</span><br></pre></td></tr></tbody></table></figure></div><ul><li>封装后<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = require(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> url = require(<span class="string">"url"</span>);</span><br><span class="line"><span class="comment">//引入自定义的路由模块</span></span><br><span class="line"><span class="keyword">const</span> myApp = require(<span class="string">"./model/express-route.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义的模块</span></span><br><span class="line">http.createServer(myApp).listen(<span class="number">9999</span>, () => {</span><br><span class="line">    console.log(<span class="string">'Running 9999'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">myApp.get(<span class="string">"/express"</span>, (req, resp) => {</span><br><span class="line">    resp.send(<span class="string">"模仿Express封装路由"</span>);</span><br><span class="line">    console.log(req);</span><br><span class="line">});</span><br><span class="line">myApp.post(<span class="string">"/postExpress"</span>, (req, resp) => {</span><br><span class="line">    resp.send(<span class="string">"模仿Express封装路由"</span>);</span><br><span class="line">    console.log(req.myBody);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div></li></ul><hr><p>通过这个体会下Express的封装</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java爬虫实战(一) ：爬取斗图社所有gif</title>
      <link href="/2018/11/30/java-pa-chong-shi-zhan/"/>
      <url>/2018/11/30/java-pa-chong-shi-zhan/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Java爬虫实战-一-：爬取斗图社所有gif"><a href="#Java爬虫实战-一-：爬取斗图社所有gif" class="headerlink" title="Java爬虫实战(一) ：爬取斗图社所有gif"></a>Java爬虫实战(一) ：爬取斗图社所有gif</h2><p>最近开始玩爬虫 , 还是挺有意思的 , 虽然写爬虫一般都是用Python比较方便，但是也没有必要为了写爬虫再学一门语言 ,虽然也挺简单，但是还是对Java比较习惯，后面可能会学Python但是目前还是先用java写着玩玩。</p><p><strong>目标</strong><br><a href="https://doutushe.com/" target="_blank" rel="noopener">斗图社 </a>  上所有的图片。<br><img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/%408Q0%601FQB2A2E4D%5D9M8%40VW8.png" src="/img/loading.gif" class="lazyload"></p><p><strong>技术选择</strong><br>Jsoup，最开始看见这个我看成了Jsonp。。。我寻思着不是解决跨域的那个么?还能搞爬虫?这么牛掰的么😄<br>关于Jsoup网上也有很多文档 <a href="http://www.open-open.com/jsoup/" target="_blank" rel="noopener">参考资料</a><br>还有一些其他的技术比如 httpclient+Xpath 还有htmlunit 还有 selenium 等等，等以后学了后再来秀一秀 😁</p><hr><p>其实我写的第一个爬虫是copy的别人的博客上的，不过它爬取的是京东的，我爬的是淘宝的<br>我也只是想参考下他的结构，但是我感觉他的有些类没什么实际意义。。然后我就直接自己写了。<br>结构如下：</p><ul><li>boot ：爬虫的入口</li><li>dao  ：dao</li><li>handle ：封装的处理查询结果集的类（这里没用）</li><li>model ：爬取的数据的模型</li><li>parse  ： 解析html的类</li><li>util     ： Jsoup工具类和dao的工具类和DB模板类</li></ul><p>首先建立数据模型DoutuModel</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoutuModel</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> String imgUrl;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库id自增</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoutuModel</span><span class="params">(String topic, String imgUrl, String title)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line">        <span class="keyword">this</span>.imgUrl = imgUrl;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTopic</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> topic;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTopic</span><span class="params">(String topic)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getImgUrl</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> imgUrl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgUrl</span><span class="params">(String imgUrl)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.imgUrl = imgUrl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>主要记录下parse类</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List<doutumodel> <span class="title">getData2</span><span class="params">(String url)</span> <span class="keyword">throws</span> Exception </doutumodel></span>{</span><br><span class="line">        <span class="comment">//获取的数据，存放在集合中</span></span><br><span class="line">        List<doutumodel> data = <span class="keyword">new</span> ArrayList();</doutumodel></span><br><span class="line">        <span class="comment">//采用Jsoup解析</span></span><br><span class="line">        <span class="comment">//String url="https://doutushe.com/portal/article/index/id/5gK";</span></span><br><span class="line">        String preurl = <span class="string">"https://doutushe.com"</span>;</span><br><span class="line">        <span class="comment">//取到当前页的document</span></span><br><span class="line">        <span class="comment">//取到内容页的所有图片</span></span><br><span class="line">        <span class="keyword">int</span> page = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            Document doc = JsoupUtils.getHtmlDocument(url);</span><br><span class="line">            Elements imgList = doc.select(<span class="string">"div[class=col-xs-12 col-sm-8 col-lg-9]"</span>).select(<span class="string">"img.lazy"</span>);</span><br><span class="line">            String topic = doc.select(<span class="string">"blockquote>p"</span>).text();</span><br><span class="line">            <span class="keyword">for</span> (Element imgelement : imgList) {</span><br><span class="line">                <span class="comment">//异步的坏处体现出来了,这个明显是懒加载,要找就找数据源,直接获取src获取不到</span></span><br><span class="line">                <span class="comment">//String imgUrl= imgelement.attr("src");</span></span><br><span class="line">                String imgUrl = imgelement.attr(<span class="string">"data-original"</span>);</span><br><span class="line">                String title = imgelement.attr(<span class="string">"title"</span>);</span><br><span class="line">                data.add(<span class="keyword">new</span> DoutuModel(topic, imgUrl, title));</span><br><span class="line">                <span class="comment">//System.out.println(topic + ":" + imgUrl + ":" + title);</span></span><br><span class="line">            }</span><br><span class="line">            Elements pageUrls = doc.select(<span class="string">"ul.pager"</span>).select(<span class="string">"a"</span>);</span><br><span class="line">            <span class="comment">//爬一页休息1秒</span></span><br><span class="line">            <span class="keyword">if</span> (page % <span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + (page/<span class="number">10</span>) + <span class="string">"页采集完 , 暂停-------"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//最后一页也有两个按钮。。。看来要多观察页面</span></span><br><span class="line">            <span class="comment">/*if (pageUrls.size() < 2) {</span></span><br><span class="line"><span class="comment">                //说明到最后一页了</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">            url = preurl + pageUrls.get(<span class="number">1</span>).attr(<span class="string">"href"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!url.matches(preurl + <span class="string">"/portal/article/index/id/[a-zA-Z0-9_]*"</span>)) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            page++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//返回数据</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实一开始写的一个版本是从主页面爬的先获取每一页的链接，再获取每一页的主题的链接，再获取每个主题下的图片链接，一个三重for循环，速度确实比较慢。。。</p><p>后来发现每一页都有下一页的链接。。。然后就可以直接从页面上爬，两个循环就可以了，但是一开始我判断边界的时候用的是在下面的链接的数量小于2但是一开始爬了好长时间结果报错了。。  然后我去看了下最后一页发现也有两个链接后面一个是全部的链接。。 。</p><p> <img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/AT5%7BUKZN%24M%5B59V%5B1OU0S%5B7N.png" src="/img/loading.gif" class="lazyload"><br>而且和上面的css是一样的但是和前面的每一页的链接的后缀不一样，所以就直接用正则表达式匹配url的后缀是否匹配<br>Regex ：<a href="https://doutushe.com/portal/article/index/id/[a-zA-Z0-9_]" target="_blank" rel="noopener">https://doutushe.com/portal/article/index/id/[a-zA-Z0-9_]</a>*  后面的就是直接匹配任意视频<br>而最后一页的全部链接是 ： <a href="https://doutushe.com/portal/index/index" target="_blank" rel="noopener">https://doutushe.com/portal/index/index</a> 所以就匹配不上直接break</p><p><strong>爬图片的小细节</strong> , 一开始没注意，他这个图片是懒加载的，也就是随着页面用js加载的， 直接src获取肯定获取不到的，因为jsoup是不支持异步的，用js操作的东西肯定爬不到。所以只能通过 data-orginal 获取。</p><p>github  <a href="https://github.com/imlgw/javaSpiders" target="_blank" rel="noopener">仓库地址</a></p><hr><p><strong>结果</strong><br><img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/X%28%7B%60H6YKH2LIW%24%25F2K4U53M.jpg" src="/img/loading.gif" class="lazyload"><br>4243张图片，后面可以自己写个脚本把图片全部下载到本地或者用迅雷之类的下载工具。</p><hr><p>后面会尝试下更多爬虫技术像 htmlunit这种支持异步的或者 selenium 这种直接操作浏览器的工具</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Java </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Security遇到的小问题</title>
      <link href="/2018/11/26/springsecurity-pei-zhi-de-ji-ge-xiao-wen-ti/"/>
      <url>/2018/11/26/springsecurity-pei-zhi-de-ji-ge-xiao-wen-ti/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Spring-Security-配置-intercept-url-的小问题"><a href="#Spring-Security-配置-intercept-url-的小问题" class="headerlink" title="Spring Security 配置 intercept-url 的小问题"></a>Spring Security 配置 intercept-url 的小问题</h2><p>文档： <a href="http://www.fengfly.com/document/springsecurity3/core-web-filters.html" target="_blank" rel="noopener">http://www.fengfly.com/document/springsecurity3/core-web-filters.html</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><bean id="<span" class="string">"filterInvocationInterceptor"</bean></span><br><span class="line">     <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.security.intercept.web.FilterSecurityInterceptor"</span>></span><br><span class="line">  <property name="<span" class="string">"authenticationManager"</property></span> ref=<span class="string">"authenticationManager"</span>/><br><span class="line">  <property name="<span" class="string">"accessDecisionManager"</property></span> ref=<span class="string">"accessDecisionManager"</span>/><br><span class="line">  <property name="<span" class="string">"runAsManager"</property></span> ref=<span class="string">"runAsManager"</span>/><br><span class="line">  <property name="<span" class="string">"securityMetadataSource"</property></span>><br><span class="line">    <security:filter-security-metadata-source path-type="<span" class="string">"regex"</security:filter-security-metadata-source></span>><br><span class="line">      <security:intercept-url pattern="<span" class="string">"\A/secure/super/.*\Z"</security:intercept-url></span> access=<span class="string">"ROLE_WE_DONT_HAVE"</span>/><br><span class="line">      <security:intercept-url pattern="<span" class="string">"\A/secure/.*\" access="</security:intercept-url></span>ROLE_SUPERVISOR,ROLE_TELLER<span class="string">"/></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure></div><p>模式总是根据他们定义的顺序进行执行。因此很重要的是，把更确定的模式定义到列表的上面。 这会反映在你上面的例子中，更确定的/secure/super/模式放在没那么确定的 /secure/模式的上面。如果它们被反转了。/secure/会一直<br> 被匹配，/secure/super/就永远也不会执行。</p><hr><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><http use-expressions="<span" class="string">"false"</http></span> entry-point-ref=<span class="string">"casProcessingFilterEntryPoint"</span>><br><span class="line"><intercept-url pattern="<span" class="string">"/**"</intercept-url></span> access=<span class="string">"ROLE_USER"</span>/><br><span class="line">        <!--经过SpringSecurity的环境上下文，偶然发现一个小坑--></span><br><span class="line">        <intercept-url pattern="<span" class="string">"/cart/*.do"</intercept-url></span> access=<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/><br><span class="line">        <csrf disabled="<span" class="string">"true"</csrf></span>/><br><span class="line">        <!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前  ，after表示放在指定的位置之后  --></span><br><span class="line">        <custom-filter ref="<span" class="string">"casAuthenticationFilter"</custom-filter></span>  position=<span class="string">"CAS_FILTER"</span> /><br><span class="line">        <custom-filter ref="<span" class="string">"requestSingleLogoutFilter"</custom-filter></span> before=<span class="string">"LOGOUT_FILTER"</span>/><br><span class="line">        <custom-filter ref="<span" class="string">"singleLogoutFilter"</custom-filter></span> before=<span class="string">"CAS_FILTER"</span>/><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure></div><p>一个小问题，就是大范围在前面会覆盖后面的小范围所以像我上面那么写/cart/*.do 就不会执行相当于没写，起不到作用。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS单点登陆系统Demo</title>
      <link href="/2018/11/17/cas-dan-dian-deng-lu-xi-tong-ru-men/"/>
      <url>/2018/11/17/cas-dan-dian-deng-lu-xi-tong-ru-men/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="单点登陆系统-–CAS"><a href="#单点登陆系统-–CAS" class="headerlink" title="单点登陆系统 –CAS"></a>单点登陆系统 –CAS</h2><ul><li>关于CAS的介绍网上都有。这里主要记录如何使用，如何配置和集成一些框架。</li><li>CAS架构图<br><img alt="OSS" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/CAS.PNG" src="/img/loading.gif" class="lazyload"><br>CAS 的 SSO 实现方式可简化理解为： 1 个 Cookie 和 N 个 Session 。 CAS Server 创建 cookie，在所有应用认证时使用，各应用通过创建各自的 Session 来标识用户是否已登录。<br>用 户在一个应用验证通过后，以后用户在同一浏览器里访问此应用时，客户端应用中的过滤器会在 session 里读取到用户信息，所以就不会去 CAS Server 认证。如果在此浏览器里访问别的 web 应用时，客户端应用中的过滤器在 session 里读取不到用户信息，就会去 CAS Server 的 login 接口认证，但这时CAS Server 会读取到浏览器传来的 cookie （ TGC ），所以 CAS Server 不会要求用户去登录页面登录，只是会根据 service 参数生成一个 Ticket ，然后再和 web 应用做一个验 证 ticket 的交互而已。</li></ul><h3 id="1-配置CAS服务端"><a href="#1-配置CAS服务端" class="headerlink" title="1. 配置CAS服务端"></a>1. 配置CAS服务端</h3><p>从上面的架构图也可以大概知道CAS运作的方式,首先配置好CAS的Server端，直接将CAS的war包拷到tomcat的webapp目录下然后启动tomcat自动解压就可以了，这里我设置的tomcat的端口是8888，地址栏输入localhost:8888/cas能看到CAS的登陆界面说明部署成功</p><ul><li><p>去除https<br> CAS默认使用的是HTTPS协议，如果使用HTTPS协议需要SSL安全证书（需向特定的机构申请和购买） 。如果对安全要求不高或是在开发测试阶段，可使用HTTP协议。我们这里讲解通过修改配置，让CAS使用HTTP协议。</p><ul><li><p>修改cas的WEB-INF/deployerConfigContext.xml找到下面的配置<br><bean class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpclient-ref="httpClient"><br>这里需要增加参数p:requireSecure=”false”，requireSecure属性意思为是否需要安全验证，即HTTPS，false为不采用</bean></p><ul><li><p>修改cas的/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml<br>找到下面配置<br><bean id="ticketGrantingTicketCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" p:cookiesecure="true" p:cookiemaxage="-1" p:cookiename="CASTGC" p:cookiepath="/cas"></bean></p></li><li><p>参数p:cookieSecure=”true”，同理为HTTPS验证相关，TRUE为采用HTTPS验证，FALSE为不采用https验证。<br>参数p:cookieMaxAge=”-1”，是COOKIE的最大生命周期，-1为无生命周期，即只在当前打开的窗口有效，关闭或重新打开其它窗口，仍会要求验证。可以根据需要修改为大于0的数字，比如3600等，意思是在3600秒内，打开任意窗口，都不需要验证。</p><p>我们这里将cookieSecure改为false , cookieMaxAge 改为3600</p></li></ul></li></ul><ul><li>修改cas的WEB-INF/spring-configuration/warnCookieGenerator.xml<br>   <bean id="warnCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" p:cookiesecure="true" p:cookiemaxage="-1" p:cookiename="CASPRIVACY" p:cookiepath="/cas"><br>我们这里将cookieSecure改为false , cookieMaxAge 改为3600</bean></li></ul></li></ul><ul><li><p>配置数据源</p><ul><li><p>cas有默认的密码但是实际中肯定是要从数据库中查的，所以我们需要配置下数据源</p></li><li><p>修改cas服务端中web-inf下deployerConfigContext.xml ，添加如下配置</p>   <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><bean id="<span" class="string">"dataSource"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <br><span class="line"> p:driverClass=<span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line"> p:jdbcUrl=<span class="string">"jdbc:mysql://127.0.0.1:3306/pinyougoudb?characterEncoding=utf8"</span></span><br><span class="line"> p:user=<span class="string">"root"</span></span><br><span class="line"> p:password=<span class="string">"123456"</span> /></span><br><span class="line"><bean id="<span" class="string">"passwordEncoder"</bean></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">"org.jasig.cas.authentication.handler.DefaultPasswordEncoder"</span> </span><br><span class="line"> c:encodingAlgorithm=<span class="string">"MD5"</span></span><br><span class="line"> p:characterEncoding=<span class="string">"UTF-8"</span> /></span><br><span class="line"><bean id="<span" class="string">"dbAuthHandler"</bean></span> <br><span class="line"> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"</span></span><br><span class="line"> p:dataSource-ref=<span class="string">"dataSource"</span></span><br><span class="line"> p:sql=<span class="string">"select password from tb_user where username = ?"</span></span><br><span class="line"> p:passwordEncoder-ref=<span class="string">"passwordEncoder"</span>/></span><br></pre></td></tr></tbody></table></figure></div><ul><li>然后在配置文件开始部分找到如下配置</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"> <bean id="<span" class="string">"authenticationManager"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.jasig.cas.authentication.PolicyBasedAuthenticationManager"</span>><br><span class="line">        <constructor-arg></constructor-arg></span><br><span class="line">            <map>               </map></span><br><span class="line">                <entry key-ref="<span" class="string">"proxyAuthenticationHandler"</entry></span> value-ref=<span class="string">"proxyPrincipalResolver"</span> /><br><span class="line">                <entry key-ref="<span" class="string">"primaryAuthenticationHandler"</entry></span> value-ref=<span class="string">"primaryPrincipalResolver"</span> /><br><span class="line">            </span><br><span class="line">              </span><br><span class="line">        <property name="<span" class="string">"authenticationPolicy"</property></span>><br><span class="line">            <bean <span class="class"><span class="keyword">class</span></bean></span>=<span class="string">"org.jasig.cas.authentication.AnyAuthenticationPolicy"</span> /><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p>其中 <entry key-ref="primaryAuthenticationHandler" value-ref="primaryPrincipalResolver">一句是使用固定的用户名和密码，我们在下面可以看到这两个bean ,如果我们使用数据库认证用户名和密码，需要将这句注释掉。<br>添加下面这一句配置</entry></p><entry key-ref="dbAuthHandler" value-ref="primaryPrincipalResolver">- 将三个jar包加入到cas的lib目录下![oss](https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/casjar.PNG)第一个和第三个大家应该很熟悉了，中间的那个是cas对jdbc的支持包</entry></li></ul></li></ul><hr><h3 id="2-普通的web项目集成CAS"><a href="#2-普通的web项目集成CAS" class="headerlink" title="2. 普通的web项目集成CAS"></a>2. 普通的web项目集成CAS</h3><p> 普通的web项目也就是没有使用Spring之类的框架而采用web.xml配置的普通项目</p><ul><li>2.1 为了方便我这里采用maven配置，先添加相应的依赖</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><!-- cas --></span><br><span class="line"><dependency></dependency></span><br><span class="line">    <groupid>org.jasig.cas.client</groupid></span><br><span class="line">    <artifactid>cas-client-core</artifactid></span><br><span class="line">    <version>3.3.3</version></span><br><span class="line"></span><br><span class="line"><dependency></dependency></span><br><span class="line">    <groupid>javax.servlet</groupid></span><br><span class="line">    <artifactid>servlet-api</artifactid></span><br><span class="line">    <version>2.5</version></span><br><span class="line">    <scope>provided</scope></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p>一个是cas客户端的核心包，一个是servlet的包，因为后面会写一些jsp<br>然后添加tomcat插件我设置的端口为9002</p><ul><li><p>2.2 因为是普通的web项目所以配置的方式主要是通过web.xml来配置，直接上配置</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><!--?xml version=<span class="string"-->"1.0"</span> encoding=<span class="string">"UTF-8"</span>?><br><span class="line"><web-app xmlns:xsi="<span" class="string">"http://www.w3.org/2001/XMLSchema-instance"</web-app></span><br><span class="line">         xmlns=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">         version=<span class="string">"2.5"</span>></span><br><span class="line">    <!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置 --></span><br><span class="line">    <listener></listener></span><br><span class="line">        <listener-<span class="class"><span class="keyword">class</span>><span class="title">org</span>.<span class="title">jasig</span>.<span class="title">cas</span>.<span class="title">client</span>.<span class="title">session</span>.<span class="title">SingleSignOutHttpSessionListener</span><!--<span class="title"-->listener</listener-<span></span>-<span class="title">class</span>><br><span class="line"><span class="class">    <!--<span class="title"-->listener</span>></span><br><span class="line"><span class="class">    <!-- 该过滤器用于实现单点登出功能，可选配置。 --></span></span><br><span class="line"><span class="class">    <<span class="title">filter</span>></span></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">name</span>><span class="title">CAS</span> <span class="title">Single</span> <span class="title">Sign</span> <span class="title">Out</span> <span class="title">Filter</span><!--<span class="title"-->filter</span>-<span class="title">name</span>></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">class</span>><span class="title">org</span>.<span class="title">jasig</span>.<span class="title">cas</span>.<span class="title">client</span>.<span class="title">session</span>.<span class="title">SingleSignOutFilter</span><!--<span class="title"-->filter</span>-<span class="title">class</span>></span><br><span class="line"><span class="class">    <!--<span class="title"-->filter</span>></span><br><span class="line"><span class="class">    <<span class="title">filter</span>-<span class="title">mapping</span>></span></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">name</span>><span class="title">CAS</span> <span class="title">Single</span> <span class="title">Sign</span> <span class="title">Out</span> <span class="title">Filter</span><!--<span class="title"-->filter</span>-<span class="title">name</span>></span><br><span class="line"><span class="class">        <<span class="title">url</span>-<span class="title">pattern</span>>/* <!--<span class="title"-->url</span>-<span class="title">pattern</span>></span><br><span class="line"><span class="class">    <!--<span class="title"-->filter</span>-<span class="title">mapping</span>></span><br><span class="line"><span class="class">    <!-- 该过滤器负责用户的认证工作，必须启用它 --></span></span><br><span class="line"><span class="class">    <<span class="title">filter</span>></span></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">name</span>><span class="title">CASFilter</span><!--<span class="title"-->filter</span>-<span class="title">name</span>></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">class</span>><span class="title">org</span>.<span class="title">jasig</span>.<span class="title">cas</span>.<span class="title">client</span>.<span class="title">authentication</span>.<span class="title">AuthenticationFilter</span><!--<span class="title"-->filter</span>-<span class="title">class</span>></span><br><span class="line"><span class="class">        <<span class="title">init</span>-<span class="title">param</span>></span></span><br><span class="line"><span class="class">            <<span class="title">param</span>-<span class="title">name</span>><span class="title">casServerLoginUrl</span><!--<span class="title"-->param</span>-<span class="title">name</span>></span><br><span class="line">            <param-value>http://localhost:8888/cas/login</param-value></span><br><span class="line">            <!--这里的server是服务端的IP --></span><br><span class="line">        </span><br><span class="line">        <init-param></init-param></span><br><span class="line">            <param-name>serverName</param-name></span><br><span class="line">            <param-value>http:<span class="comment">//localhost:9002</span></param-value></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <filter-mapping></filter-mapping></span><br><span class="line">        <filter-name>CASFilter</filter-name></span><br><span class="line">        <url-pattern><span class="comment">/*</span></url-pattern></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    <!-- 该过滤器负责对Ticket的校验工作，必须启用它 --></span></span><br><span class="line"><span class="comment">    <filter></filter></span></span><br><span class="line"><span class="comment">        <filter-name>CAS Validation Filter</filter-name></span></span><br><span class="line"><span class="comment">        <filter-class>org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter</filter-class></span></span><br><span class="line"><span class="comment">        <init-param></init-param></span></span><br><span class="line"><span class="comment">            <param-name>casServerUrlPrefix</param-name></span></span><br><span class="line"><span class="comment">            <param-value>http://localhost:8888/cas</param-value></span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        <init-param></init-param></span></span><br><span class="line"><span class="comment">            <param-name>serverName</param-name></span></span><br><span class="line"><span class="comment">            <param-value>http://localhost:9002</param-value></span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    <filter-mapping></filter-mapping></span></span><br><span class="line"><span class="comment">        <filter-name>CAS Validation Filter</filter-name></span></span><br><span class="line"><span class="comment">        <url-pattern>/*</url-pattern></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    <!-- 该过滤器负责实现HttpServletRequest请求的包裹， 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 --></span></span><br><span class="line"><span class="comment">    <filter></filter></span></span><br><span class="line"><span class="comment">        <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name></span></span><br><span class="line"><span class="comment">        <filter-class></filter-class></span></span><br><span class="line"><span class="comment">            org.jasig.cas.client.util.*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    <filter-mapping></filter-mapping></span></span><br><span class="line"><span class="comment">        <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name></span></span><br><span class="line"><span class="comment">        <url-pattern>/*</url-pattern></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    <!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --></span></span><br><span class="line"><span class="comment">    <filter></filter></span></span><br><span class="line"><span class="comment">        <filter-name>CAS Assertion Thread Local Filter</filter-name></span></span><br><span class="line"><span class="comment">        <filter-class>org.jasig.cas.client.util.AssertionThreadLocalFilter</filter-class></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    <filter-mapping></filter-mapping></span></span><br><span class="line"><span class="comment">        <filter-name>CAS Assertion Thread Local Filter</filter-name></span></span><br><span class="line"><span class="comment">        <url-pattern>/*</url-pattern></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></tbody></table></figure></div><ul><li>用户认证过滤器(必选)<strong>AuthenticationFilter</strong>在上面的配置中需要两个参数一个是casServerLoginUrl顾名思义就是CASserver登陆的地址，比如我的是<a href="http://localhost:8888/cas/login" target="_blank" rel="noopener">http://localhost:8888/cas/login</a> ，第二个参数是<strong>serverName</strong> ,因为登陆成功后还是要返回你当前的应用所以需要将你当前的应用的地址传递给CASserver比如我的当前应用 <a href="http://localhost:9002/" target="_blank" rel="noopener">http://localhost:9002/</a></li><li>Ticket的校验过滤器(必选)<strong>Cas20ProxyReceivingTicketValidationFilter</strong> 与上面的过滤器类似也需要那两个参数，                              配置了这两个过滤器CAS就能正常运行了</li><li>单点登出过滤器 <strong>SingleSignOutFilter</strong>，顾名思义就是用于单点登出  </li><li>另外还有两个过滤器都是为了获取登陆名配置的过滤器，配置一个就行。<br>#</li></ul></li><li><p>2.3 编写index.jsp(tomcat默认打开的页面)</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"utf-8"</span>%></span><br><span class="line">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <meta http-equiv="<span" class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>><br><span class="line">    <title>一品优购</title></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 采用web.xml配置的普通的web模块</span><br><span class="line"><%=request.getRemoteUser()%></span><br><span class="line"> <a href="http://localhost:8888/cas/logout?service=http://www.imlgw.top">退出登录</a>></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p>   如果想让cas退出后跳转到指定的页面而不是CAS默认的页面也需要修改配置<br>   修改cas系统的配置文件cas-servlet.xml<br>   <bean id="logoutAction" class="org.jasig.cas.web.flow.LogoutAction" p:servicesmanager-ref="servicesManager" p:followserviceredirects="${cas.logout.followServiceRedirects:true}"><br>  将cas.logout.followServiceRedirects改为true后，可以在退出时跳转页面到目标页面<br> 然后就可以启动cas和你的应用来测试了。</bean></p></li><li><p>2.4 服务端界面改造<br> 上面测试成功，但是真实的情况肯定不会用cas默认的那个页面做登陆需要改成你自己的登陆界面，然后你当前应用的登陆页面就没用了。</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><%@ page pageEncoding=<span class="string">"UTF-8"</span> %></span><br><span class="line"><%@ page contentType=<span class="string">"text/html; charset=UTF-8"</span> %></span><br><span class="line"><%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %></span><br><span class="line"><%@ taglib prefix=<span class="string">"spring"</span> uri=<span class="string">"http://www.springframework.org/tags"</span> %></span><br><span class="line"><%@ taglib prefix=<span class="string">"form"</span> uri=<span class="string">"http://www.springframework.org/tags/form"</span> %></span><br><span class="line"><%@ taglib prefix=<span class="string">"fn"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/functions"</span> %></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><meta charset="<span" class="string">"UTF-8"</span> /><br><span class="line"><title>Login</title></span><br><span class="line"><link rel="<span" class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">'bs/css/bootstrap.min.css'</span> /><br><span class="line"><script type="text/javascript" src="js/jquery.min.js"></script></span><br><span class="line"><script type="text/javascript" src="bs/js/bootstrap.min.js"></script></span><br><span class="line"><style></span><br><span class="line">img {</span><br><span class="line">height: <span class="number">200</span>px;</span><br><span class="line">border-radius: <span class="number">200</span>px;</span><br><span class="line">}</span><br><span class="line">.panel-title{</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line">.login {</span><br><span class="line">width: <span class="number">500</span>px;</span><br><span class="line">height: <span class="number">400</span>px;</span><br><span class="line">position: absolute;</span><br><span class="line">top: <span class="number">20</span>%;</span><br><span class="line">left: <span class="number">50</span>%;</span><br><span class="line">margin-left: -<span class="number">250</span>px;</span><br><span class="line">}</span><br><span class="line">.sub{</span><br><span class="line">text-align: center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></style></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"panel panel-primary login"</span>><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"panel-heading"</span>><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"panel-title"</span>><br><span class="line"><img class="string lazyload" data-src="<span" src="/img/loading.gif">"images/login.jpg"</span> /><br><span class="line"></span></div></span><br><span class="line"></span></div></span><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"panel-body"</span>><br><span class="line"><!--自定义的登陆界面修改 <span class="number">1</span> --></span><br><span class="line"><form:form method="<span" class="string">"post"</form:form></span> id=<span class="string">"fm1"</span> commandName=<span class="string">"${commandName}"</span> htmlEscape=<span class="string">"true"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"sui-form"</span>><br><span class="line"></span><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"form-group"</span>><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"input-group"</span>><br><span class="line"><span class="input-group-addon" id="basic-addon1"><span class="glyphicon glyphicon-user"></span></span></span><br><span class="line"><!--自定义的登陆界面修改 <span class="number">2</span> --></span><br><span class="line"><form:input <span class="class"><span class="keyword">class</span></form:input></span>=<span class="string">"form-control"</span> aria-describedby=<span class="string">"basic-addon1"</span> placeholder=<span class="string">"Username"</span>  id=<span class="string">"username"</span> size=<span class="string">"25"</span> tabindex=<span class="string">"1"</span> accesskey=<span class="string">"${userNameAccessKey}"</span> path=<span class="string">"username"</span> autocomplete=<span class="string">"off"</span> htmlEscape=<span class="string">"true"</span> /><br><span class="line"></span></div></span><br><span class="line"></span></div></span><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"form-group"</span>><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"input-group"</span>><br><span class="line"><span class="input-group-addon" id="basic-addon1"><span class="glyphicon glyphicon-lock"></span></span></span><br><span class="line"><!--自定义的登陆界面修改 <span class="number">3</span> --></span><br><span class="line"><form:password <span class="class"><span class="keyword">class</span></form:password></span>=<span class="string">"form-control"</span> placeholder=<span class="string">"password"</span> aria-describedby=<span class="string">"basic-addon1"</span> id=<span class="string">"password"</span> size=<span class="string">"25"</span> tabindex=<span class="string">"2"</span> path=<span class="string">"password"</span>  accesskey=<span class="string">"${passwordAccessKey}"</span> htmlEscape=<span class="string">"true"</span> autocomplete=<span class="string">"off"</span> /><br><span class="line"></span></div></span><br><span class="line"></span></div></span><br><span class="line"><div <span class="class"><span class="keyword">class</span>=<span class="string">"form-group sub"</span>><br><span class="line"><!--自定义的登陆界面修改 <span class="number">4</span> 登陆框 --></span><br><span class="line"><input type="<span" class="string">"hidden"</span> name=<span class="string">"lt"</span> value=<span class="string">"${loginTicket}"</span> /><br><span class="line">      <input type="<span" class="string">"hidden"</span> name=<span class="string">"execution"</span> value=<span class="string">"${flowExecutionKey}"</span> /><br><span class="line">      <input type="<span" class="string">"hidden"</span> name=<span class="string">"_eventId"</span> value=<span class="string">"submit"</span> /><br><span class="line">      <input <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-primary btn-lg"</span> name=<span class="string">"submit"</span> accesskey=<span class="string">"l"</span> value=<span class="string">"登陆"</span> type=<span class="string">"submit"</span> /><br><span class="line">      <!--自定义的登陆界面修改 <span class="number">4</span> 错误提示框 --></span><br><span class="line">      <form:errors path="<span" class="string">"*"</form:errors></span> id=<span class="string">"msg"</span> cssClass=<span class="string">"errors"</span> element=<span class="string">"div"</span> htmlEscape=<span class="string">"false"</span> /><br><span class="line"></span></div></span><br><span class="line"></span><br><span class="line"></span></div></span><br><span class="line"></span></div></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p>  可以直接将登陆的页面拷过来然后加上指令再根据cas的登陆页面稍加修改就可以了</p></li></ul><hr><h3 id="3-Spring项目集成CAS和Spring-security"><a href="#3-Spring项目集成CAS和Spring-security" class="headerlink" title="3. Spring项目集成CAS和Spring-security"></a>3. Spring项目集成CAS和Spring-security</h3><ul><li><p>pom依赖</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><properties></properties></span><br><span class="line">        <spring.version>4.2.0.RELEASE</spring.version></span><br><span class="line">    </span><br><span class="line">    <dependencies></dependencies></span><br><span class="line">        <!-- Spring --></span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework</groupid></span><br><span class="line">            <artifactid>spring-context</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework</groupid></span><br><span class="line">            <artifactid>spring-beans</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework</groupid></span><br><span class="line">            <artifactid>spring-webmvc</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework</groupid></span><br><span class="line">            <artifactid>spring-jdbc</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework</groupid></span><br><span class="line">            <artifactid>spring-aspects</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework</groupid></span><br><span class="line">            <artifactid>spring-jms</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework</groupid></span><br><span class="line">            <artifactid>spring-context-support</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <!--spring-security--></span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework.security</groupid></span><br><span class="line">            <artifactid>spring-security-web</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework.security</groupid></span><br><span class="line">            <artifactid>spring-security-config</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>javax.servlet</groupid></span><br><span class="line">            <artifactid>javax.servlet-api</artifactid></span><br><span class="line">            <version>3.1.0</version></span><br><span class="line">            <scope>provided</scope></span><br><span class="line">        </span><br><span class="line">        <!--集成包--></span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.springframework.security</groupid></span><br><span class="line">            <artifactid>spring-security-cas</artifactid></span><br><span class="line">            <version>${spring.version}</version></span><br><span class="line">        </span><br><span class="line">        <!--cas--></span><br><span class="line">        <dependency></dependency></span><br><span class="line">            <groupid>org.jasig.cas.client</groupid></span><br><span class="line">            <artifactid>cas-client-core</artifactid></span><br><span class="line">            <version>3.3.3</version></span><br><span class="line">            <exclusions></exclusions></span><br><span class="line">                <exclusion></exclusion></span><br><span class="line">                    <groupid>org.slf4j</groupid></span><br><span class="line">                    <artifactid>log4j-over-slf4j</artifactid></span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure></div><p>  添加tomcat插件指定端口为9001</p></li><li><p>web.xml配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><!--?xml version=<span class="string"-->"1.0"</span> encoding=<span class="string">"UTF-8"</span>?><br><span class="line"><web-app xmlns:xsi="<span" class="string">"http://www.w3.org/2001/XMLSchema-instance"</web-app></span><br><span class="line">         xmlns=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">         version=<span class="string">"2.5"</span>></span><br><span class="line"></span><br><span class="line">    <context-param></context-param></span><br><span class="line">        <param-name>contextConfigLocation</param-name></span><br><span class="line">        <param-value>classpath:spring/spring-*.xml</param-value></span><br><span class="line">    </span><br><span class="line">    <listener></listener></span><br><span class="line">        <listener-<span class="class"><span class="keyword">class</span>></listener-<span></span><br><span class="line"><span class="class">            <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span></span></span><br><span class="line"><span class="class">        <!--<span class="title"-->listener</span>-<span class="title">class</span>></span><br><span class="line"><span class="class">    <!--<span class="title"-->listener</span>></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <<span class="title">filter</span>></span></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">name</span>><span class="title">springSecurityFilterChain</span><!--<span class="title"-->filter</span>-<span class="title">name</span>></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">class</span>><span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">DelegatingFilterProxy</span><!--<span class="title"-->filter</span>-<span class="title">class</span>></span><br><span class="line"><span class="class">    <!--<span class="title"-->filter</span>></span><br><span class="line"><span class="class">    <<span class="title">filter</span>-<span class="title">mapping</span>></span></span><br><span class="line"><span class="class">        <<span class="title">filter</span>-<span class="title">name</span>><span class="title">springSecurityFilterChain</span><!--<span class="title"-->filter</span>-<span class="title">name</span>></span><br><span class="line"><span class="class">        <<span class="title">url</span>-<span class="title">pattern</span>>/*<!--<span class="title"-->url</span>-<span class="title">pattern</span>></span><br><span class="line"><span class="class">    <!--<span class="title"-->filter</span>-<span class="title">mapping</span>></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><!--<span class="title"-->web</span>-<span class="title">app</span>></span><br></pre></td></tr></tbody></table></figure></div><p>主要配置Spring容器和Spring-security的过滤器</p></li></ul><ul><li>spring-security.xml配置<br>其实就是把之前配置在web.xml里面的过滤器采用Spring的方式配置出来</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><!--?xml version=<span class="string"-->"1.0"</span> encoding=<span class="string">"UTF-8"</span>?><br><span class="line"><beans:beans xmlns="<span" class="string">"http://www.springframework.org/schema/security"</beans:beans></span><br><span class="line">             xmlns:beans=<span class="string">"http://www.springframework.org/schema/beans"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">             xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"</span>></span><br><span class="line"></span><br><span class="line">    <http pattern="/out.html" security="none"></http></span><br><span class="line">    <!--   entry-point-ref  入口点引用 因为登陆交给cas或者其他的登陆系统,就不会在本系统做登陆需要指定登陆点--></span><br><span class="line">    <http use-expressions="<span" class="string">"false"</http></span> entry-point-ref=<span class="string">"casProcessingFilterEntryPoint"</span>><br><span class="line">        <intercept-url pattern="<span" class="string">"/**"</intercept-url></span> access=<span class="string">"ROLE_USER"</span>/><br><span class="line">        <csrf disabled="<span" class="string">"true"</csrf></span>/><br><span class="line">        <!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前  ，after表示放在指定的位置之后  --></span><br><span class="line">        <custom-filter ref="<span" class="string">"casAuthenticationFilter"</custom-filter></span>  position=<span class="string">"CAS_FILTER"</span> /><br><span class="line">        <custom-filter ref="<span" class="string">"requestSingleLogoutFilter"</custom-filter></span> before=<span class="string">"LOGOUT_FILTER"</span>/><br><span class="line">        <custom-filter ref="<span" class="string">"singleLogoutFilter"</custom-filter></span> before=<span class="string">"CAS_FILTER"</span>/><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <!-- CAS入口点 开始 --></span><br><span class="line">    <beans:bean id="<span" class="string">"casProcessingFilterEntryPoint"</beans:bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.security.cas.web.CasAuthenticationEntryPoint"</span>><br><span class="line">        <!-- 单点登录服务器登录URL --></span><br><span class="line">        <beans:property name="<span" class="string">"loginUrl"</beans:property></span> value=<span class="string">"http://localhost:8888/cas/login"</span>/><br><span class="line">        <beans:property name="<span" class="string">"serviceProperties"</beans:property></span> ref=<span class="string">"serviceProperties"</span>/><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <beans:bean id="<span" class="string">"serviceProperties"</beans:bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.security.cas.ServiceProperties"</span>><br><span class="line">        <!--service 配置自身工程的根地址+/login/cas   --></span><br><span class="line">        <beans:property name="<span" class="string">"service"</beans:property></span> value=<span class="string">"http://localhost:9001/login/cas"</span>/><br><span class="line">    </span><br><span class="line">    <!-- CAS入口点 结束 --></span><br><span class="line">    <!-- 认证过滤器 开始 --></span><br><span class="line">    <beans:bean id="<span" class="string">"casAuthenticationFilter"</beans:bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.security.cas.web.CasAuthenticationFilter"</span>><br><span class="line">        <beans:property name="<span" class="string">"authenticationManager"</beans:property></span> ref=<span class="string">"authenticationManager"</span>/><br><span class="line">    </span><br><span class="line">    <!-- 认证管理器 --></span><br><span class="line">    <authentication-manager alias="<span" class="string">"authenticationManager"</authentication-manager></span>><br><span class="line">        <authentication-provider ref="<span" class="string">"casAuthenticationProvider"</authentication-provider></span>><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <!-- 认证提供者 --></span><br><span class="line">    <beans:bean id="<span" class="string">"casAuthenticationProvider"</beans:bean></span>     <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.security.cas.authentication.CasAuthenticationProvider"</span>><br><span class="line">        <beans:property name="<span" class="string">"authenticationUserDetailsService"</beans:property></span>><br><span class="line">            <beans:bean <span class="class"><span class="keyword">class</span></beans:bean></span>=<span class="string">"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"</span>><br><span class="line">                <beans:constructor-arg ref="<span" class="string">"userDetailsService"</beans:constructor-arg></span> /><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        <beans:property name="<span" class="string">"serviceProperties"</beans:property></span> ref=<span class="string">"serviceProperties"</span>/><br><span class="line">        <!-- ticketValidator 为票据验证器 --></span><br><span class="line">        <beans:property name="<span" class="string">"ticketValidator"</beans:property></span>><br><span class="line">            <beans:bean <span class="class"><span class="keyword">class</span></beans:bean></span>=<span class="string">"org.jasig.cas.client.validation.Cas20ServiceTicketValidator"</span>><br><span class="line">                <beans:constructor-arg index="<span" class="string">"0"</beans:constructor-arg></span> value=<span class="string">"http://localhost:8888/cas"</span>/><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        <beans:property name="<span" class="string">"key"</beans:property></span> value=<span class="string">"an_id_for_this_auth_provider_only"</span>/><br><span class="line">    </span><br><span class="line">    <!-- 认证类 --></span><br><span class="line">    <beans:bean id="<span" class="string">"userDetailsService"</beans:bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"top.imlgw.demo.UserDetailServiceImpl"</span>/><br><span class="line"></span><br><span class="line">    <!-- 认证过滤器 结束 --></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <!-- 单点登出  开始  --></span><br><span class="line">    <beans:bean id="<span" class="string">"singleLogoutFilter"</beans:bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.jasig.cas.client.session.SingleSignOutFilter"</span>/><br><span class="line">    <!--关联两个地址，相当于封装了前面的地址--></span><br><span class="line">    <beans:bean id="<span" class="string">"requestSingleLogoutFilter"</beans:bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.security.web.authentication.logout.LogoutFilter"</span>><br><span class="line">        <beans:constructor-arg value="<span" class="string">"http://localhost:8888/cas/logout?service=http://localhost:9001/out.html"</beans:constructor-arg></span>/><br><span class="line">        <beans:constructor-arg></beans:constructor-arg></span><br><span class="line">            <beans:bean <span class="class"><span class="keyword">class</span></beans:bean></span>=<span class="string">"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"</span>/><br><span class="line">        </span><br><span class="line">        <beans:property name="<span" class="string">"filterProcessesUrl"</beans:property></span> value=<span class="string">"/logout/cas"</span>/><br><span class="line">    </span><br><span class="line">    <!-- 单点登出  结束 --></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><ul><li><p>userDetailsService编写<br>这是一个认证类是属于Spring-security的，如果不使用CAS那么这个类就是用来验证密码是否正确是否放行的。但是整合了CAS后就不用在里面做认证了，只是为了返回后面的角色集合。</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.imlgw.demo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>{</span><br><span class="line">        System.out.println(<span class="string">"经过认证类"</span>);</span><br><span class="line">        List<grantedauthority> authorities=<span class="keyword">new</span> ArrayList();</grantedauthority></span><br><span class="line">        <span class="comment">//最开始把这里的role写错了，然后cas登陆成功后也一直被403 forbid，因为SpringSecurity认证没通过，一直没放行</span></span><br><span class="line">        authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_USER"</span>));</span><br><span class="line">        <span class="comment">//不通过本项目做登陆 所以密码无所谓，在执行这个方法的时候就已经登陆成功了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username,<span class="string">""</span>,authorities);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><hr><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><p>启动搭建好的两个服务器，和casServer，然后测试在一个应用登陆后另一个能否进入index页面 …..</p><hr><p>SpringBoot集成CAS和Spring-security的后面再补充，因为SpringBoot还不太熟悉。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道LeetCode引发的惨案</title>
      <link href="/2018/10/31/yi-dao-leetcode-yin-fa-de-can-an/"/>
      <url>/2018/10/31/yi-dao-leetcode-yin-fa-de-can-an/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="一道LeetCode搜索题引发的惨案"><a href="#一道LeetCode搜索题引发的惨案" class="headerlink" title="一道LeetCode搜索题引发的惨案"></a>一道LeetCode搜索题引发的惨案</h2><h3 id="1-先上-题目"><a href="#1-先上-题目" class="headerlink" title="1.先上 题目"></a>1.先上 <a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">题目</a></h3><p>给定两个单词（<em>beginWord _和 _endWord_）和一个字典，找到从 _beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。<br><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">原题链接</a><br><img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/3V6EQ77R_%28%292SCR%248R%5B%245F7.png" src="/img/loading.gif" class="lazyload">)其实这题明显是BFS(广搜) 题目类型也说了是广搜，但是我不信邪写了DFS(毕竟代码比较好写)，然后惨案就发生了。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">// 标记数组</span></span><br><span class="line"><span class="comment">// 默认都是0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mark;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List<string> wordList)</string></span> </span>{</span><br><span class="line"><span class="comment">// 不存在</span></span><br><span class="line">mark = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!wordList.contains(endWord)) {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// dfs开始</span></span><br><span class="line">dfs(beginWord, endWord, wordList);</span><br><span class="line"><span class="comment">// 无法转换</span></span><br><span class="line"><span class="keyword">if</span> (min == Integer.MAX_VALUE) {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String beginWord, String endWord, List<string> wordList)</string></span> </span>{</span><br><span class="line"><span class="comment">//当相等的时候</span></span><br><span class="line"><span class="keyword">if</span> (beginWord.equals(endWord)) {</span><br><span class="line"><span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < mark.length; i++) {</span><br><span class="line"><span class="keyword">if</span> (mark[i] == <span class="number">1</span>) {</span><br><span class="line">step++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//更新最小值</span></span><br><span class="line">min = step < min ? step : min;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < wordList.size(); i++) {</span><br><span class="line"><span class="keyword">if</span> (mark[i] == <span class="number">0</span> && cmp(beginWord, wordList.get(i))) {</span><br><span class="line">mark[i] = <span class="number">1</span>;</span><br><span class="line">dfs(wordList.get(i), endWord, wordList);</span><br><span class="line">mark[i] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个函数判段是否只变化了一个字母</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s1.length(); i++) {</span><br><span class="line"><span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) {</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>结果直接TLE了，后来想了想DFS每次都会<strong>尝试</strong>所有情况，而给的例子后面的数据量也比较大，而且这题是要统计最短路径，要全部递归完才能确定最小值，我把数据拿来自己测试跑了好长时间都没跑出来，而BFS没有递归只是会耗费的空间会比较大。从这里也可以总结出来DFS跟适合判断是否存在是否可达之类的问题，BFS更适合做找最短最小之类的问题。上BFS代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 标记数组</span></span><br><span class="line"><span class="comment">// 默认都是0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mark;</span><br><span class="line"><span class="comment">// 模拟队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Que</span> </span>{</span><br><span class="line">String word;</span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLengthBFS</span><span class="params">(String beginWord, String endWord, List<string> wordList)</string></span></span>{</span><br><span class="line">        <span class="comment">// 不存在</span></span><br><span class="line">mark = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!wordList.contains(endWord)) {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">Que[] que = <span class="keyword">new</span> Que[wordList.size() + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 循环促使话述祖</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < que.length; i++) {</span><br><span class="line">que[i] = <span class="keyword">new</span> Que();</span><br><span class="line">}</span><br><span class="line">que[tail].word = beginWord;</span><br><span class="line">que[tail].word = beginWord;</span><br><span class="line">que[tail].step = <span class="number">1</span>;</span><br><span class="line">tail++;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (head < tail) {</span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < wordList.size(); i++) {</span><br><span class="line"><span class="keyword">if</span> (mark[i] == <span class="number">0</span> && cmp(wordList.get(i), que[head].word)) {</span><br><span class="line">que[tail].word = wordList.get(i);</span><br><span class="line"><span class="comment">//这里是从head开始的，所以应该是head的步数+1</span></span><br><span class="line">que[tail].step=que[head].step+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 标记为已经走过</span></span><br><span class="line">mark[i] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (que[tail].word.equals(endWord)) {</span><br><span class="line"><span class="comment">//到这里说明已经到终点了，而且是最短的，之后的最多就是相等</span></span><br><span class="line"><span class="comment">//跳出循环</span></span><br><span class="line">                       flag=<span class="number">1</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">                    tail++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="comment">// 每次检查完一个单词就将其出队列</span></span><br><span class="line">head++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> que[tail].step;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个函数判段没吃是否只变化了一个字母</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s1.length(); i++) {</span><br><span class="line"><span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) {</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>PS：刚刚修改了下代码，我也佩服自己BFS都还没搞清楚就直接上了代码，然后结果居然还是对的，之前在if判断队尾元素是不是和endWord相等后还维护了一个最小值min，后来想了想不对，最后一个和endWord相等的元素已经进栈了，已经是最短的了，后面的即使可以转换到也最多只能和当前的相等了。 如果只是为了统计最小值就可以直接break了。那如果不仅仅要统计最小值还要记录路径要怎么搞？</p><h3 id="2-加强版-单词接龙-2"><a href="#2-加强版-单词接龙-2" class="headerlink" title="2. 加强版 单词接龙 2"></a>2. <a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">加强版</a> 单词接龙 2</h3><p>是一道困难等级的题，需要在上面的基础上找出所有的最短的路径。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Que</span> </span>{</span><br><span class="line">String word;</span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line">Que prev;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> (word + <span class="string">":"</span> + step);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">private</span>  List<list<string>> res=<span class="keyword">new</span> ArrayList<>();</list<string></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="keyword">public</span> List<list<string>> ladderLengthBFS(String beginWord, String endWord, List<string> wordList){</string></list<string></span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//List<list<string>> res=new ArrayList<>();</list<string></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在</span></span><br><span class="line">mark = <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!wordList.contains(endWord)) {</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">Que[] que = <span class="keyword">new</span> Que[wordList.size() + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 循环促使话述祖</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < que.length; i++) {</span><br><span class="line">que[i] = <span class="keyword">new</span> Que();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//先把第一个单词放进去</span></span><br><span class="line">que[tail].word = beginWord;</span><br><span class="line">que[tail].word = beginWord;</span><br><span class="line">que[tail].step = <span class="number">1</span>;</span><br><span class="line">tail++;</span><br><span class="line">List<que> quelist=<span class="keyword">new</span> ArrayList<>();</que></span><br><span class="line"><span class="keyword">while</span> (head < tail) {</span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < wordList.size(); i++) {</span><br><span class="line"><span class="keyword">if</span> (mark[i] == <span class="number">0</span> && cmp(wordList.get(i), que[head].word)) {</span><br><span class="line">que[tail].word = wordList.get(i);</span><br><span class="line"><span class="comment">//这里是从head开始的，所以应该是head的步数+1</span></span><br><span class="line">que[tail].step=que[head].step+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//que[head].next=que[tail];</span></span><br><span class="line"><span class="comment">// 标记为已经走过</span></span><br><span class="line">mark[i] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (que[tail].word.equals(endWord)) {</span><br><span class="line">   <span class="comment">//记录最小值</span></span><br><span class="line">   min=que[tail].step;</span><br><span class="line">   <span class="comment">//到这里队列后面就不用再插入元素了</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.把之前走过的路在下一个head</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//将队列变成list</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j<=tail;j++){</span><br><span class="line">   quelist.add(que[j]);</span><br><span class="line">   }</span><br><span class="line">   markDfs= <span class="keyword">new</span> <span class="keyword">int</span>[wordList.size() + <span class="number">1</span>]; </span><br><span class="line">   <span class="comment">// 1. 用DFS试一下</span></span><br><span class="line">   dfsBfs(que[<span class="number">0</span>],endWord,quelist);</span><br><span class="line">    }</span><br><span class="line">                    tail++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 每次检查完一个单词就将其出队列</span></span><br><span class="line">head++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsBfs</span><span class="params">(Que beginWord,String endWord,List<que> ques)</que></span></span>{</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < markDfs.length; i++) {</span><br><span class="line"><span class="keyword">if</span> (markDfs[i] == <span class="number">1</span>) {</span><br><span class="line">step++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(step>=min) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(step+<span class="number">1</span>==min&&endWord.equals(beginWord.word)){</span><br><span class="line">List<string> list=<span class="keyword">new</span> ArrayList<>();</string></span><br><span class="line">Stack<string> stack=<span class="keyword">new</span> Stack<>();</string></span><br><span class="line">System.out.println(beginWord.word+<span class="string">":"</span>+step);</span><br><span class="line">Que temp=beginWord;</span><br><span class="line"><span class="comment">//找到一条</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<min;i++){< span><br><span class="line">stack.push(temp.word);</span><br><span class="line">System.out.print(temp.word+<span class="string">"<--"</span>);</span><br><span class="line">temp=temp.prev;</span><br><span class="line">}</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<min;i++){< span><br><span class="line">list.add(stack.pop());</span><br><span class="line">}</span><br><span class="line">res.add(list);</span><br><span class="line">System.out.println(res);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < ques.size(); i++) {</span><br><span class="line"><span class="keyword">if</span> (markDfs[i] == <span class="number">0</span> && cmp(beginWord.word,ques.get(i).word)){</span><br><span class="line">markDfs[i] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//连接两个节点</span></span><br><span class="line"><span class="comment">//beginWord.next=ques.get(i);</span></span><br><span class="line">ques.get(i).prev=beginWord;</span><br><span class="line">dfsBfs(ques.get(i), endWord, ques);</span><br><span class="line">markDfs[i] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">// private int step = 0;</span></span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个函数判段没吃是否只变化了一个字母</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s1.length(); i++) {</span><br><span class="line"><span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) {</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">}</span><br></min;i++){<></span></min;i++){<></span></pre></td></tr></tbody></table></figure></div><p>整体上在Que上增加了一个prev的指针，遍历路径，一开始是用的BFS不过我想的太简单了，我只是把最后一个节点出队列然后再BFS，后来发现不行(居然还跑过了24个测试案例)，实际上这题我还是没有做出来，但是上面的方法应该是没问题的就是会TLE😭，大概思路就是先BFS缩短DFS需要遍历的字典然后控制每次递归的身体不能超过BFS的到的最短路径<br><img alt="img9" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/blog.PNG" src="/img/loading.gif" class="lazyload">一开始只能跑几个数据的，优化下能跑几十个的，但是还是太慢了，毕竟是一道难题等以后学了相关的东西再来试试看能不能做出来吧.</p><hr><p>算法，学着挺有意思，就是头有点凉。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你有FreeBug么? ---&gt;Spring-solr</title>
      <link href="/2018/10/05/solr-ni-you-freebug-me/"/>
      <url>/2018/10/05/solr-ni-you-freebug-me/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="FreeBug-哎呦，不错喔。"><a href="#FreeBug-哎呦，不错喔。" class="headerlink" title="FreeBug ? 哎呦，不错喔。"></a>FreeBug ? 哎呦，不错喔。</h2><p> 昨天从上午10点开始一直到晚上 11：58才把那几个Bug给解决了，前两个Bug确实蛮奇怪的，特别是第一个Bug ,最后一个Bug….纯属智障。把这几个Bug记录下┗|｀O′|┛ </p><h3 id="Bug1"><a href="#Bug1" class="headerlink" title="Bug1:"></a><strong><em>Bug1</em></strong>:</h3><p><img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/9642SBM2%60QFX4AMO1C%5D~A%5BM.png" src="/img/loading.gif" class="lazyload"><br>意思是没找到TbItemMapper的select方法还有这个类的其他方法。<br>估计是xml文件没有加载到classes路径下，之前一直好好的然后昨天突然抽风了，百度了下叫我把xml文件随便的改动下在里面加个空格换行之类的，然后就好了。。。。</p><h3 id="Bug2"><a href="#Bug2" class="headerlink" title="Bug2:"></a><strong><em>Bug2</em></strong>:</h3><p><img alt="img9" data-src="https://p4.cdn.img9.top/ipfs/Qmcg5dscbhYgod9vdN2SHaxywdaCPVgY28jX4imd53TH6J?4.png" src="/img/loading.gif" class="lazyload"><br>看着这些个Bug真的是一脸懵，写main方法执行就一点问题没有，首先是一波百度，说是jar包冲突了主要是HttpClient的冲突，然后我就尝试了下idea的maven依赖视图<br><img alt="img9" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/DJQYP%604SGOCL_VP%28LGN%7B_TN.png" src="/img/loading.gif" class="lazyload"><br>然后发现dubbo和spring-data-solr都有httpclient包和httpcore而且版本不一致，然后果断的把dubbo里面的httpclient和httpcore给exclusion了，不看不知道，整个项目的maven依赖好乱，有好多依赖冲突，不过没影响使用我就没有去改，怕再改出什么问题。你以为改完之后bug就结束了？</p><h3 id="Bug3"><a href="#Bug3" class="headerlink" title="Bug3:"></a><strong><em>Bug3</em></strong>:</h3><p><img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/%60Z3GBQ~K%29%7D%60DX%60P%60Q%257%25%7B%25S.png" src="/img/loading.gif" class="lazyload">)在controller层疯狂报错，service层一点问题没有<img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/NLKUXAM~LPOZ7K%60%28%29D52%40VD.png" src="/img/loading.gif" class="lazyload">可以，又一个FreeBug，在纠结了几个小时后看了一眼代码发现<br><img alt="oss" data-src="https://imlgwpicture.oss-cn-qingdao.aliyuncs.com/blogImage/L20FMBQ%28XNRQV6Y6%24ITFEYA.png" src="/img/loading.gif" class="lazyload">原来这里写掉了东西，返回了一个solr的结果集也没有实现序列化返回出去了前台也根本就解析不了难怪会再前台报错。。。</p><p>ps: 之前一直用的img9.top的无限图床，前几天突然崩溃了博客的图片都失效了，之前也有一个送的阿里云的oss的包所以就想拿那个当图床，这篇文章里面的图片也都是在oss上的，img9虽然也还可以但是是个去中心化的图床不好管理确实难搞，等有时间就用java写一个自动化的图床工具玩玩。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> Solr </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可以获取最小值的栈</title>
      <link href="/2018/09/27/ke-yi-huo-qu-zui-xiao-zhi-de-zhan/"/>
      <url>/2018/09/27/ke-yi-huo-qu-zui-xiao-zhi-de-zhan/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="如何实现可以获取最小值的栈？"><a href="#如何实现可以获取最小值的栈？" class="headerlink" title="如何实现可以获取最小值的栈？"></a>如何实现可以获取最小值的栈？</h2><p>这个问题是很久之前在微信公众号上看见的一个问题，突然想起来就来操作一下。<br>开发环境   : sublime+MinGW<br>先附上我自己实现的栈的结构</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//定义链栈的节点的结构体 </span></span><br><span class="line">typedef struct  StackNode</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">struct StackNode *next;</span><br><span class="line">}StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的结构体</span></span><br><span class="line">typedef struct LinkStack</span><br><span class="line">{</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">LinkStackPtr top;</span><br><span class="line"><span class="comment">//总数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">}LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">LinkStack *init(){</span><br><span class="line">LinkStack *stack=(LinkStack*)malloc(sizeof(LinkStack));</span><br><span class="line"><span class="keyword">if</span> (stack==NULL)</span><br><span class="line">{</span><br><span class="line">printf(<span class="string">"动态开辟空间失败"</span>);</span><br><span class="line">}<span class="keyword">else</span></span><br><span class="line"><span class="comment">//初始化空栈</span></span><br><span class="line">stack->top=NULL;</span><br><span class="line">stack->count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> stack;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="function">LinkStackPtr  <span class="title">creatNode</span><span class="params">()</span></span>{</span><br><span class="line">LinkStackPtr stack;</span><br><span class="line"><span class="comment">//开辟空间</span></span><br><span class="line">stack =(LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line"><span class="keyword">if</span>(stack==NULL){</span><br><span class="line">printf(<span class="string">"动态开辟空间失败"</span>);</span><br><span class="line">}</span><br><span class="line">scanf(<span class="string">"%d"</span>,&(stack->data));</span><br><span class="line">stack->next=NULL;</span><br><span class="line"><span class="keyword">return</span> stack;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LinkStack * s)</span></span>{</span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line">LinkStackPtr newStack= creatNode();</span><br><span class="line"><span class="comment">//保存当前的节点</span></span><br><span class="line">LinkStackPtr currentTopStack=s->top;</span><br><span class="line"><span class="comment">//栈顶变为刚进栈的元素</span></span><br><span class="line">s->top=newStack;</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">newStack->next=currentTopStack;</span><br><span class="line"><span class="comment">//数目加一</span></span><br><span class="line">s->count++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(LinkStack *s)</span></span>{</span><br><span class="line"><span class="comment">//将栈顶弹出</span></span><br><span class="line">LinkStackPtr topStack=s->top;</span><br><span class="line">s->top=topStack->next;</span><br><span class="line">s->count--;</span><br><span class="line">free(topStack);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Solution-1："><a href="#Solution-1：" class="headerlink" title="Solution 1："></a><strong>Solution 1</strong>：</h3><p>在进栈的时候用一个变量保存当前的最小值每次进栈就会和最小值比较如果比最小值要小就会更新这个变量的值，出栈的时候比较麻烦，如果最小值被弹出去了就需要遍历整个栈来获取最小值。</p><ul><li>Implement：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">typedef struct  StackNode</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">struct StackNode *next;</span><br><span class="line">}StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的结构体</span></span><br><span class="line">typedef struct LinkStack</span><br><span class="line">{</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">LinkStackPtr top;</span><br><span class="line"><span class="comment">//总数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line">}LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LinkStack * s)</span></span>{</span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line">LinkStackPtr newStack= creatNode();</span><br><span class="line"><span class="comment">//**********************************</span></span><br><span class="line"><span class="keyword">if</span>(s->count==<span class="number">0</span>){</span><br><span class="line">s->min=newStack->data;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(s->min>newStack->data){</span><br><span class="line">s->min=newStack->data;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="comment">//保存当前的节点</span></span><br><span class="line">LinkStackPtr currentTopStack=s->top;</span><br><span class="line"><span class="comment">//栈顶变为刚进栈的元素</span></span><br><span class="line">s->top=newStack;</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">newStack->next=currentTopStack;</span><br><span class="line"><span class="comment">//数目加一</span></span><br><span class="line">s->count++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(LinkStack *s)</span></span>{</span><br><span class="line"><span class="comment">//将栈顶弹出</span></span><br><span class="line">LinkStackPtr topStack=s->top;</span><br><span class="line"><span class="comment">//从第二个开始比较</span></span><br><span class="line">LinkStackPtr stackNode=topStack->next;</span><br><span class="line"><span class="comment">//弹出去的那个节点的数据</span></span><br><span class="line"><span class="keyword">int</span> min=topStack->data;</span><br><span class="line">s->top=topStack->next;</span><br><span class="line">s->count--;</span><br><span class="line">free(topStack);</span><br><span class="line"><span class="comment">//如果弹出的是最小值就需要从当前栈顶遍历数组获取最小值</span></span><br><span class="line"><span class="keyword">if</span>(min==s->min){</span><br><span class="line">min=stackNode->data;</span><br><span class="line">  <span class="keyword">do</span>{</span><br><span class="line">  <span class="keyword">if</span>(min>stackNode->data){</span><br><span class="line">  min=stackNode->data;</span><br><span class="line">  }</span><br><span class="line">stackNode=stackNode->next;</span><br><span class="line">   }<span class="keyword">while</span>(stackNode!=NULL);</span><br><span class="line">}</span><br><span class="line">s->min=min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这种方法进栈时间复杂度为O(1),但是出栈时间复杂度为O(n).显然不是很优雅。</p><h3 id="Solution-2："><a href="#Solution-2：" class="headerlink" title="Solution 2："></a><strong>Solution 2</strong>：</h3><p>空间换时间利用一个辅助栈，辅助栈里面存放最小值，辅助栈进栈时判断进栈的元素和当前栈顶的元素大小跟小就可以进栈。所以最小值就是辅助栈的栈顶元素，出栈时如果出栈的元素是最小值节点那辅助栈也同时弹栈 再取栈顶元素。</p><ul><li>Implement：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">#include <stdio.h></stdio.h></span><br><span class="line">#include <stdlib.h></stdlib.h></span><br><span class="line">#include <string.h></string.h></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链栈的节点的结构体 </span></span><br><span class="line">typedef struct  StackNode</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">struct StackNode *next;</span><br><span class="line">}StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的结构体</span></span><br><span class="line">typedef struct LinkStack</span><br><span class="line">{</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">LinkStackPtr top;</span><br><span class="line"><span class="comment">//总数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//辅助栈</span></span><br><span class="line">struct LinkStack *mins;</span><br><span class="line">}LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">LinkStack *init(){</span><br><span class="line">LinkStack *stack=(LinkStack*)malloc(sizeof(LinkStack));</span><br><span class="line"><span class="keyword">if</span> (stack==NULL)</span><br><span class="line">{</span><br><span class="line">printf(<span class="string">"动态开辟空间失败"</span>);</span><br><span class="line">}<span class="keyword">else</span></span><br><span class="line"><span class="comment">//初始化空栈</span></span><br><span class="line">stack->top=NULL;</span><br><span class="line">stack->count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> stack;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="function">LinkStackPtr  <span class="title">creatNode</span><span class="params">()</span></span>{</span><br><span class="line">LinkStackPtr stack;</span><br><span class="line"><span class="comment">//开辟空间</span></span><br><span class="line">stack =(LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line"><span class="keyword">if</span>(stack==NULL){</span><br><span class="line">printf(<span class="string">"动态开辟空间失败"</span>);</span><br><span class="line">}</span><br><span class="line">scanf(<span class="string">"%d"</span>,&(stack->data));</span><br><span class="line">stack->next=NULL;</span><br><span class="line"><span class="keyword">return</span> stack;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LinkStack * s)</span></span>{</span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line">LinkStackPtr newStack= creatNode();</span><br><span class="line"><span class="comment">//保存当前的节点</span></span><br><span class="line">LinkStackPtr currentTopStack=s->top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟空间 用于添加到辅助栈中，之前直接操作newStack，指针地址导致后面辅助栈和主栈混合到了一起，，，，</span></span><br><span class="line">LinkStackPtr minStackNode =(LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line"><span class="keyword">if</span>(minStackNode==NULL){</span><br><span class="line">printf(<span class="string">"动态开辟空间失败"</span>);</span><br><span class="line">}</span><br><span class="line">minStackNode->data=newStack->data;</span><br><span class="line">minStackNode->next=NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶变为刚进栈的元素</span></span><br><span class="line">s->top=newStack;</span><br><span class="line"><span class="comment">//辅助栈</span></span><br><span class="line">LinkStack *mins=s->mins;</span><br><span class="line"><span class="comment">//保存辅助栈当前栈顶</span></span><br><span class="line">LinkStackPtr  currentMinsTop=mins->top;</span><br><span class="line"><span class="keyword">if</span>(s->count==<span class="number">0</span>){</span><br><span class="line">   mins->top=newStack;</span><br><span class="line">   newStack->next=NULL;</span><br><span class="line">    }<span class="keyword">else</span></span><br><span class="line">    <span class="comment">//如果进栈的元素比当前辅助栈的栈顶小</span></span><br><span class="line">    <span class="comment">//相等的要进栈</span></span><br><span class="line">    <span class="keyword">if</span>(newStack->data<=mins->top->data){</span><br><span class="line">    mins->top=minStackNode;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    mins->top->next=currentMinsTop;</span><br><span class="line">    mins->count++;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">s->top->next=currentTopStack;</span><br><span class="line"><span class="comment">//数目加一</span></span><br><span class="line">s->count++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(LinkStack *s)</span></span>{</span><br><span class="line"><span class="comment">//将栈顶弹出</span></span><br><span class="line">LinkStackPtr topStack=s->top;</span><br><span class="line">    <span class="comment">//辅助栈</span></span><br><span class="line">LinkStack * mins=s->mins;</span><br><span class="line"><span class="comment">//保存辅助栈栈顶元素便于销毁</span></span><br><span class="line">LinkStackPtr minsTopStack=mins->top;</span><br><span class="line">s->top=topStack->next;</span><br><span class="line">s->count--;</span><br><span class="line"><span class="comment">//弹出的元素是最小值</span></span><br><span class="line"><span class="keyword">if</span> (topStack->data==mins->top->data)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//辅助栈同时弹栈</span></span><br><span class="line">mins->top=minsTopStack->next;</span><br><span class="line">mins->count--;</span><br><span class="line">free(minsTopStack);</span><br><span class="line">}</span><br><span class="line">free(topStack);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历栈（栈顶到栈底）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(LinkStack *stack)</span></span>{</span><br><span class="line"><span class="comment">//当前栈顶</span></span><br><span class="line">LinkStackPtr stackNode=stack->top;</span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line">printf(<span class="string">"%d\n"</span>,stackNode->data);</span><br><span class="line">stackNode=stackNode->next;</span><br><span class="line">}<span class="keyword">while</span>(stackNode!=NULL);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//申明并初始化栈结构</span></span><br><span class="line">LinkStack *stack=init();</span><br><span class="line"><span class="comment">//初始化这个链栈的辅助（C语言学的不好原谅这些很奇怪的操作）</span></span><br><span class="line">stack->mins=init();</span><br><span class="line">push(stack);</span><br><span class="line">push(stack);</span><br><span class="line">push(stack);</span><br><span class="line">push(stack);</span><br><span class="line">printf(<span class="string">"*******进栈******\n"</span>);</span><br><span class="line">printStack(stack);</span><br><span class="line">printf(<span class="string">"*********辅助栈*******\n"</span>);</span><br><span class="line">printStack(stack->mins);</span><br><span class="line">printf(<span class="string">"*******最小值******\n"</span>);</span><br><span class="line">printf(<span class="string">"%d\n"</span>, stack->mins->top->data);</span><br><span class="line">pop(stack);</span><br><span class="line">printf(<span class="string">"*******出栈******\n"</span>);</span><br><span class="line">printStack(stack);</span><br><span class="line">printf(<span class="string">"*******最小值******\n"</span>);</span><br><span class="line">printf(<span class="string">"%d\n"</span>, stack->mins->top->data);</span><br><span class="line">printf(<span class="string">"*********辅助栈*******\n"</span>);</span><br><span class="line">printStack(stack->mins);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>明显这个方法进栈出栈时间复杂度都是O(1)，空间复杂度相对会高一点，其实空间复杂度还可以优化，可以在辅助栈里面存索引，这样进栈时会避免存入相同的最小值，如  2 1 1 1 1 1 存到辅助栈就是  2 1 1 1 1 1 后面的1都是重复的，如果存索引就是 0 1 进栈时跟之前一样,出栈时判断索引是否和辅助栈存的索引一致，不一致就不动。这里因为这个是个链栈 ,要根据索引取值并不方便所以就不实现了.</p><p>这里我把代码全部贴上来了，C语言确实学的不怎么样，所以里面会有一些奇怪的操作，这个算法本身很简单但是用C语言一实现就会有一堆问题，昨天进栈的时候一个指针把辅助栈和主栈搞混了一直有bug, 今天早上上课才想起来，毕竟C语言写的少hahahaha,  所以后面我打算以后会同时用C语言和Java都实现一遍。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Redis遇到的bug</title>
      <link href="/2018/09/24/spring-redis-yu-dao-de-bug/"/>
      <url>/2018/09/24/spring-redis-yu-dao-de-bug/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="两个小bug记录一下"><a href="#两个小bug记录一下" class="headerlink" title="两个小bug记录一下"></a>两个小bug记录一下</h2><ol><li><p>Spring-data-redis和jedis整合的版本问题报错如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">严重: Exception sending context initialized event to listener instance of <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span></span></span><br><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisTemplate' defined in URL [jar:file:/E:/repository/com/pyg/pyg-common/0.0.1-SNAPSHOT/pyg-common-0.0.1-SNAPSHOT.jar!/spring/applicationContext-redis.xml]: Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V</init></span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:<span class="number">1578</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:<span class="number">545</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:<span class="number">482</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory$<span class="number">1</span>.getObject(AbstractBeanFactory.java:<span class="number">305</span>)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">230</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">301</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">196</span>)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:<span class="number">772</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:<span class="number">834</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">537</span>)</span><br><span class="line">at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:<span class="number">446</span>)</span><br><span class="line">at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:<span class="number">328</span>)</span><br><span class="line">at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:<span class="number">107</span>)</span><br><span class="line">at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:<span class="number">4939</span>)</span><br><span class="line">at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:<span class="number">5434</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">150</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1559</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1549</span>)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Caused by: java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V</init></span><br><span class="line">at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.<init>(JdkSerializationRedisSerializer.java:<span class="number">53</span>)</init></span><br><span class="line">at org.springframework.data.redis.core.RedisTemplate.afterPropertiesSet(RedisTemplate.java:<span class="number">117</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:<span class="number">1637</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:<span class="number">1574</span>)</span><br><span class="line">... <span class="number">21</span> more</span><br></pre></td></tr></tbody></table></figure></div><p>报错原因：Spring-data-reids 和 jedis的版本冲突（应该也和Spring的版本有关系,别人跟我一样的包都可以运行）。<br>我测试成功的版本：<br><jedis.version>2.6.2</jedis.version><br><spring.version>4.2.0.RELEASE</spring.version><br><spring-data-redis.version>1.4.2.RELEASE</spring-data-redis.version></p></li><li><p>Spring加载配置文件的问题<br>因为同时配置了MySql和Redis的配置文件而且不是同一个工程所以不是同时初始化然后出现了以下的问题。<br>同个模块中如果出现多个context:property-placeholder ，location properties文件后， 运行时出现Could not resolve placeholder ‘key’ in string value${key}。原因是在加载第一个context:property-placeholder时 会扫描所有的bean，而有的bean里面出现第二个 context:property-placeholder引入的properties的占位符${key}， 此时还没有加载第二个property-placeholder，所以解析不了${key}。<br>解决办法一，可以将通过模块的多个property-placeholder合并为一个，将初始化放在一起。<br>方法二，添加ignore-unresolvable=”true “，这样可以在加载第一个property-placeholder时出现解析不了的占位符进行忽略掉</p></li></ol><p>ps：目前的计划是先把品优购这个项目做完，然后搞一搞微信小程序之类的开发，然后开始着手研究源码，对Spring的源码非常好奇有种特别想了解她的欲望hahahahahaha….  看源码肯定会涉及到设计模式也顺便学一学，再就是数据结构和算法，这学期也正在学也不用着急跟着老师的进度再加自己的自学补充，这个东西也不是说今天学完了就会了的东西，大二上学期主要的打算就是这个了，还有就是不能挂科！！！！,再往后就是打算学下安卓和安卓逆向，不过暂时只是个打算😄。再往后就是大三了，还没打算到那个时候，想想还真快，不知不觉就一年过去了。Come on , add oil ! ! ! @imlgw</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Bug </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法及优化</title>
      <link href="/2018/09/06/kmp-suan-fa-ji-you-hua/"/>
      <url>/2018/09/06/kmp-suan-fa-ji-you-hua/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="KMP算法及优化"><a href="#KMP算法及优化" class="headerlink" title="KMP算法及优化"></a>KMP算法及优化</h2><p>   KMP算法是一种改进的<a href="https://baike.so.com/doc/9018958-9348545.html" target="_blank" rel="noopener">字符串匹配</a>算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特–莫里斯–普拉特操作(简称KMP算法)。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。<br> 开发环境   : sublime+MinGW </p><ul><li>暴力匹配法</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//暴力匹配   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BruteForce</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T,<span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>{ </span><br><span class="line"><span class="keyword">int</span> i=<span class="built_in">begin</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i<s.length&&j<t.length){< span><br><span class="line"><span class="keyword">if</span>(S.str[i]==T.str[j]){</span><br><span class="line">j++;</span><br><span class="line">i++;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="comment">//母串的当前位置+1向后移动</span></span><br><span class="line">i=i-j+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//子串从0开始</span></span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i<s(s.length-t.length))< span><br><span class="line"><span class="keyword">return</span> i-j-<span class="built_in">begin</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//没找到</span></span><br><span class="line">}</span><br></s(s.length-t.length))<></span></s.length&&j<t.length){<></span></pre></td></tr></tbody></table></figure></div><p>暴力匹配比较简单粗暴，就是一个个的比对如果不对母串就回溯直到配成功。<br>这个算法无疑时间复杂度较高，最糟糕情况为 O(m*n);而这个算法的缺陷就在于每次母串的不必要的回溯，于是KMP算法出现了</p><ul><li>KMP算法</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">String</span> S,<span class="keyword">int</span> next[])</span></span>{</span><br><span class="line"><span class="comment">//自己和自己匹配其实和kmp是一个道理</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//和标准的KMP不台一样,标准的KMP是从1开始的其实原理也一样，这样更习惯</span></span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环 n-2 次</span></span><br><span class="line"><span class="keyword">while</span>(i<s.length<span class="number">-1</s.length<span></span>){<br><span class="line"><span class="keyword">if</span>(S.str[i]==S.str[j]){</span><br><span class="line">++j;</span><br><span class="line">++i;</span><br><span class="line">next[i]=j;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line"><span class="comment">//如果和前缀第一个字符就不等，i后移下一个位置的next为0</span></span><br><span class="line">++i;</span><br><span class="line">next[i]=<span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span></span><br><span class="line">    <span class="comment">//j回退到之前的位置</span></span><br><span class="line">j=next[j];</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">String</span> S,<span class="keyword">String</span> T,<span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i=<span class="built_in">begin</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">100</span>];</span><br><span class="line">getNext(T,next);</span><br><span class="line"><span class="keyword">while</span>(i<s.length&&j<t.length){< span><br><span class="line"><span class="keyword">if</span>(S.str[i]==T.str[j]){</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"> j=next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i<s(s.length-t.length))< span><br><span class="line"><span class="keyword">return</span> i-j-<span class="built_in">begin</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//没找到</span></span><br><span class="line">}</span><br></s(s.length-t.length))<></span></s.length&&j<t.length){<></span></pre></td></tr></tbody></table></figure></div><p>这个算法的原理其实很好理解 ,母串不回溯，如果不相等字串就会跳到对应的位置继续比对</p><h1 id="a-b-a-b-c"><a href="#a-b-a-b-c" class="headerlink" title="a b a b c"></a>a b a b c</h1><h1 id="a-b-c"><a href="#a-b-c" class="headerlink" title="a b c"></a>a b c</h1><p>比如上面这种，c和a不相等 ，如果是暴力匹配那母串就会回溯到第二个字符b的位置继续比对，但是这并没有意义，因为子串的字符都不相等，正确的做法肯定是直接将字串右滑，或者说将子串回溯，回溯到a的位置，然后计较母串的第三个字符和子串的第一个字符…… 分析一下可以看出来这个算法最坏时间复杂度为O(n+m)<br>那么问题来了回溯的位置如何确定？这也是这个算法的关键之处。要得到一个对应每个位置的next数组储存当失配时回溯的位置，这个数组的确定只和子串本身的结构有关其代表的时最长的公共前后缀的长度，关于next数组的求法就不说了，人眼基本上一眼就能看出来。</p><ul><li>next数组编程实现</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">String</span> S,<span class="keyword">int</span> next[])</span></span>{</span><br><span class="line"><span class="comment">//自己和自己匹配其实和kmp是一个道理</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//和标准的KMP不台一样,标准的KMP是从1开始的其实原理也一样，这样更习惯</span></span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环 n-2 次</span></span><br><span class="line"><span class="keyword">while</span>(i<s.length<span class="number">-1</s.length<span></span>){<br><span class="line"><span class="keyword">if</span>(S.str[i]==S.str[j]){</span><br><span class="line">++j;</span><br><span class="line">++i;</span><br><span class="line">next[i]=j;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line"><span class="comment">//如果和前缀第一个字符就不等，i后移下一个位置的next为0</span></span><br><span class="line">++i;</span><br><span class="line">next[i]=<span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span></span><br><span class="line">    <span class="comment">//j回退到之前的位置</span></span><br><span class="line">j=next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>一开始看到这个我是比较懵的怎么这么短？仔细看了下这几行代码前面的其实都还好理解,相当于自己和自己匹配</p><h1 id="！！！关键是后面的不相等的情况"><a href="#！！！关键是后面的不相等的情况" class="headerlink" title="！！！关键是后面的不相等的情况"></a>！！！关键是后面的不相等的情况</h1><p>这里我也纠结了小半天随后在网上看到了一个图讲解这个的瞬间就开朗了这里就直接搬过来了（对<a href="https://blog.csdn.net/qq_30974369/article/details/74276186" target="_blank" rel="noopener">原文</a>加了一点自己的直观理解并另外加上了参考《大话数据结构》里面的对于KMP算法的优化）</p><h1 id="a-b-a-c-f-g-a-b-a-b-h"><a href="#a-b-a-c-f-g-a-b-a-b-h" class="headerlink" title="a b  a  c  f  g a  b a b h"></a>a b  a  c  f  g a  b a b h</h1><p><img alt="image" data-src="https://p1.cdn.img9.top/ipfs/QmQLpe9fWukFT9is6XnAmmAyBdTCVYSeV6oj7mn5yGVsy8?1.png" src="/img/loading.gif" class="lazyload"></p><h1 id="a-b-a-c-f-g-a-b-a-b-h-1"><a href="#a-b-a-c-f-g-a-b-a-b-h-1" class="headerlink" title="a b  a  c  f  g a  b a b  h"></a><strong>a b  a</strong>  c  f  g <strong>a  b a</strong> <em>b</em>  h</h1><p>红色的是当前匹配上的最长的前后缀，蓝色为当前匹配位置，也就是<em>i</em> 的位置 与上面对应的就是b 的位置了<br><img alt="image2" data-src="https://p3.cdn.img9.top/ipfs/QmaFp1PaEY5Ednc4wUdLatsuJ7e4fibKv7jXwroGGb8rXN?3.png" src="/img/loading.gif" class="lazyload"></p><h1 id="a-b-a-c-f-g-a-b-a-b-h-2"><a href="#a-b-a-c-f-g-a-b-a-b-h-2" class="headerlink" title="a b  a  c  f  g a  b  a b  h"></a><strong>a b  a</strong>  <em>c</em>  f  g <strong>a  b  a</strong> <em>b</em>  h</h1><p>绿色为当前匹配到的最长前缀的后一位也就是 <em>j</em>  的位置 对应 c 的位置<br>显然c b不相等  如果不相等那就不能继续往后找了 那像 aba 这么长的公共前后缀就用不了了，也就是你的next数组会变小，前后缀相似度会减小。<br><img alt="image3" data-src="https://p1.cdn.img9.top/ipfs/QmURa6y33pwvpWjoBZ6eSiyZzraBd9QPWSBF13gq2xdPnT?1.png" src="/img/loading.gif" class="lazyload"><br><img alt="image4" data-src="https://p2.cdn.img9.top/ipfs/QmVfW9VQ2JYhNigxskotFVRtgAYcEhksBBEKzSztKn3p9b?2.png" src="/img/loading.gif" class="lazyload"></p><h1 id="a-b-a-c-f-g-a-b-a-b-h-3"><a href="#a-b-a-c-f-g-a-b-a-b-h-3" class="headerlink" title="a  b  a  c  f  g  a  b  a b  h"></a><strong>a</strong>  <em>b</em>  <strong>a</strong>  c  f  g  <strong>a</strong>  b  <strong>a</strong> b  h</h1><p>如图四块灰色区域完全相等，关键步骤 j=next[j];之前的j在绿色区域 现在的 j 回溯到了紫色区域 也就是对应b的位置<br><img alt="image5" data-src="https://p1.cdn.img9.top/ipfs/QmYo2cscPKdCL9tGGn2frfrn6p4WuGXuma6W6yQSEw4bdx?1.png" src="/img/loading.gif" class="lazyload"><br>相信到这里应该就看明白了,四块区域相等，如果蓝色部分和紫色相等是不是就又有了公共的前后缀了呢？那如果不同就会继续递推。</p><ul><li>KMP优化<br>什么？这么吊的算法还可以优化？的确，KMP还可以优化，这里直接拿《大话数据结构》里面的例子来说明 (ps : 这里大话数据结构和KMP原始的是一样的，也就是next是从1开始的，我是从0开始的)<br><img alt="image6" data-src="https://p0.cdn.img9.top/ipfs/QmSum26wHswwEgRmR79oM75o8afbAMCy2ZMQcremrXpfka?0.png" src="/img/loading.gif" class="lazyload">    <ul><li>next优化</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNexval</span><span class="params">(<span class="keyword">String</span> S,<span class="keyword">int</span> next[])</span></span>{</span><br><span class="line"><span class="comment">//自己和自己匹配其实和kmp是一个道理</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//和标准的KMP不台一样,标准的KMP是从1开始的其实原理也一样，这样更习惯</span></span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环n-2次</span></span><br><span class="line"><span class="keyword">while</span>(i<s.length<span class="number">-1</s.length<span></span>){<br><span class="line"><span class="keyword">if</span>(S.str[i]==S.str[j]){</span><br><span class="line">++j;</span><br><span class="line">++i;</span><br><span class="line"><span class="comment">//下一对对应的位置（也就是正在求next值的位置）</span></span><br><span class="line"><span class="keyword">if</span>(S.str[j]==S.str[i]){</span><br><span class="line"><span class="comment">//这一步实际上是跳过了重复的部分 如果和这个位置的next值的字符相同就可以将这个位置的next字符设置为next位置字符的next值</span></span><br><span class="line">next[i]=next[j];</span><br><span class="line">}<span class="keyword">else</span></span><br><span class="line">next[i]=j;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>){</span><br><span class="line"><span class="comment">//如果和前缀第一个字符就不等，i后移下一个位置的next为0</span></span><br><span class="line">++i;</span><br><span class="line">next[i]=<span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span></span><br><span class="line">    <span class="comment">//j回退到之前的位置</span></span><br><span class="line">j=next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实优化的理由就是在进行和子串匹配的时候如果失配，在子串回溯时回溯到的那个值和当前的值相同那么我们可以直接回溯到 那个回溯值的回溯值，可能有点绕但是仔细想想就明白了。</p><h1 id="a-b-a-b-a-a-a-b-a"><a href="#a-b-a-b-a-a-a-b-a" class="headerlink" title="a b a b a a a b a"></a><strong>a b a b a a a b a</strong></h1><p>这个字符串的next应该是 next=[-1,0,0,1,2,3,1,1,2]<br>nextval=[-1,0,0,0,0,3,1,0,0] （这里有一个小问题，那就是前两位是不用考虑的，永远是-1 0，所以如果按照上面的说法可能会认为第三个是-1，其实不是的具体的可以看代码，如果时官方的那种从1开始就没有这种顾虑）。<br>拿这个实际的来说 ,  <strong>a b a b a a a b a</strong>当比对到该子串最后一个a时 不相等 ，按照之前的方法回溯，回溯到index=2的a位置，发现这货也是a那肯定也不相等，然后又回溯回溯到第一个a，这中间不就多回溯了一次么？为什么不一次到位呢？所以我们直接判断将要回溯的值和当前值是不是相等，相等就把将要回溯的值的回溯值赋给当前值。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向循环链表</title>
      <link href="/2018/08/18/shuang-xiang-xun-huan-lian-biao-c-shi-xian/"/>
      <url>/2018/08/18/shuang-xiang-xun-huan-lian-biao-c-shi-xian/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="C实现的双向循环链表"><a href="#C实现的双向循环链表" class="headerlink" title="C实现的双向循环链表"></a>C实现的双向循环链表</h2><p>很久没有用C了，都忘了，昨天下午又复习了一下然后实现了这个双向循环链表，后面每种数据结构都会在这里实现记录下来。<br>开发环境   : sublime+MinGW </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">#include <stdio.h></stdio.h></span><br><span class="line">#include <stdlib.h></stdlib.h></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line">typedef struct Node</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">struct Node *perv;</span><br><span class="line">struct Node *next;</span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line">Node* createNode(){</span><br><span class="line">Node * node;</span><br><span class="line"><span class="comment">//开辟空间</span></span><br><span class="line">node =(Node*)malloc(sizeof(Node));</span><br><span class="line"><span class="keyword">if</span>(node==NULL){</span><br><span class="line">printf(<span class="string">"动态开辟空间失败"</span>);</span><br><span class="line">}</span><br><span class="line">scanf(<span class="string">"%d"</span>,&(node->data));</span><br><span class="line">node->perv=NULL;</span><br><span class="line">node->next=NULL;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表 </span></span><br><span class="line">Node* createList(<span class="keyword">int</span> n)</span><br><span class="line">{</span><br><span class="line">    Node *tail,*p,*head;</span><br><span class="line">    <span class="comment">//初始化头结点 (这个节点只是个标志，标志链表的头并不存储数据,只是为了操作的统一性)</span></span><br><span class="line">    head=(Node*)malloc(sizeof(Node));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n >= <span class="number">1</span>)   <span class="comment">//结点的个数 >= 1 的时候</span></span><br><span class="line">    {</span><br><span class="line">        p = createNode();</span><br><span class="line">        head->next = p;</span><br><span class="line">        p->perv=head;</span><br><span class="line">        tail = p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>;i <= n;i++)    <span class="comment">//生成第一个结点以后的结点，并建立双向链表的关系 </span></span><br><span class="line">    {</span><br><span class="line">        p = createNode();</span><br><span class="line">        tail->next = p;</span><br><span class="line">        p->perv = tail;</span><br><span class="line">        <span class="comment">//尾指针后移</span></span><br><span class="line">        tail = p;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//连接头尾</span></span><br><span class="line">    head->perv=tail;</span><br><span class="line">    tail->next=head;</span><br><span class="line">    <span class="comment">//链表的长度</span></span><br><span class="line">    length = n;</span><br><span class="line">    <span class="keyword">if</span>(n >= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (head);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在头尾插入节点   （实际上这两个方法都可以通过下面的insAnywhere完成，主要为了效率,如果是尾结点插入getEle()时间复杂度过高）</span></span><br><span class="line"><span class="comment">//insAnywhere(head,0);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insHead</span><span class="params">(Node* head)</span></span>{</span><br><span class="line">Node *p=createNode();</span><br><span class="line">Node *q;</span><br><span class="line"><span class="comment">//保存第一个节点</span></span><br><span class="line">q=head->next;</span><br><span class="line"><span class="comment">//连接头结点</span></span><br><span class="line">head->next=p;</span><br><span class="line">p->perv=head;</span><br><span class="line"><span class="comment">//连接之前的第一个节点</span></span><br><span class="line">p->next=q;</span><br><span class="line">q->perv=p;</span><br><span class="line">++length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//insAnywhere(head,length);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insTail</span><span class="params">(Node* head)</span></span>{</span><br><span class="line">Node *p=createNode();</span><br><span class="line"><span class="comment">//先保存下之前的尾指针</span></span><br><span class="line">Node *tail=head->perv;</span><br><span class="line"><span class="comment">//连接头尾</span></span><br><span class="line">head->perv=p;</span><br><span class="line">p->next=head;</span><br><span class="line"><span class="comment">//连接之前的尾指针</span></span><br><span class="line">tail->next=p;</span><br><span class="line">p->perv=tail;</span><br><span class="line">++length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得某一位置的节点  时间复杂度为 O(n)</span></span><br><span class="line">Node * getEle(Node* head,<span class="keyword">int</span> n){</span><br><span class="line"><span class="comment">//将第一个节点赋值给p</span></span><br><span class="line">Node *p=head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < n; ++i)</span><br><span class="line">{</span><br><span class="line">p=p->next;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置插入，因为设置了头节点所以插入的操作具有一致性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insAnywhere</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">Node *newNode=createNode();</span><br><span class="line"><span class="comment">//取得对应位置的值</span></span><br><span class="line">Node *currentNode=getEle(head,n);</span><br><span class="line"><span class="comment">//保存当前位置的下一个</span></span><br><span class="line">Node *nextNode;</span><br><span class="line"><span class="comment">//保存下一个节点</span></span><br><span class="line">nextNode=currentNode->next;</span><br><span class="line"><span class="comment">//连接当前结点</span></span><br><span class="line">currentNode->next=newNode;</span><br><span class="line">newNode->perv=currentNode;</span><br><span class="line"><span class="comment">//连接之前的下一个节点</span></span><br><span class="line">newNode->next=nextNode;</span><br><span class="line">nextNode->perv=newNode;</span><br><span class="line">++length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置的删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delNode</span><span class="params">(Node *head,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">Node *delNode=getEle(head,n);</span><br><span class="line"><span class="comment">/*printf("%d\n", delNode->data);</span></span><br><span class="line"><span class="comment">printf("--------------\n");*/</span></span><br><span class="line"><span class="comment">//先保存当前节点的后一节点</span></span><br><span class="line">Node *nextNode=delNode->next;</span><br><span class="line"><span class="comment">//将后一个节点接在当前节点的前一个的后面</span></span><br><span class="line">delNode->perv->next=nextNode;</span><br><span class="line">nextNode->perv=delNode->perv;</span><br><span class="line"><span class="comment">//free这个节点</span></span><br><span class="line">free(delNode);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlnAll</span><span class="params">(Node *head)</span></span>{</span><br><span class="line">Node *p=head->next;</span><br><span class="line">   <span class="keyword">do</span>{</span><br><span class="line">     printf(<span class="string">"%d\n"</span>, p->data);</span><br><span class="line">     p=p->next;</span><br><span class="line">   }<span class="keyword">while</span>(p!=head);</span><br><span class="line"><span class="comment">// while(p->next!=head){</span></span><br><span class="line"><span class="comment">// printf("%d\n", p->data);</span></span><br><span class="line"><span class="comment">// //指针后移</span></span><br><span class="line"><span class="comment">// p=p->next;</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">Node* createList(<span class="keyword">int</span> n);</span><br><span class="line">Node* createNode();</span><br><span class="line"></span><br><span class="line">Node *head=createList(<span class="number">3</span>);</span><br><span class="line">printf(<span class="string">"遍历链表\n"</span>);</span><br><span class="line">printlnAll(head);</span><br><span class="line"></span><br><span class="line">insHead(head);</span><br><span class="line"><span class="comment">//insAnywhere(head,0);</span></span><br><span class="line">printf(<span class="string">"在头插入节点后\n"</span>);</span><br><span class="line">printlnAll(head);</span><br><span class="line"></span><br><span class="line">insTail(head);    <span class="comment">//下面的也可以但是效率比较低</span></span><br><span class="line"><span class="comment">//insAnywhere(head,getLength());</span></span><br><span class="line">printf(<span class="string">"在尾插入节点后\n"</span>);</span><br><span class="line">printlnAll(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第一个元素后面插入元素</span></span><br><span class="line">printf(<span class="string">"---------在第一个元素后面插入元素-----\n"</span>);</span><br><span class="line">insAnywhere(head,<span class="number">1</span>);</span><br><span class="line">printlnAll(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最后面的节点</span></span><br><span class="line">printf(<span class="string">"---------删除最后面的节点-------\n"</span>);</span><br><span class="line">delNode(head,<span class="number">6</span>);</span><br><span class="line">printlnAll(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第一个后面的节点</span></span><br><span class="line">printf(<span class="string">"-------删除第一个后面的节点---------\n"</span>);</span><br><span class="line">delNode(head,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//printf("%d\n", head->next->data);</span></span><br><span class="line">printlnAll(head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li>线性表<br><img alt="image" data-src="http://p0.cdn.img9.top/ipfs/QmUS62kkfTx4trGRmMukDCFuJNxrKDR2P2DdoERRqf1pcr?0.png" src="/img/loading.gif" class="lazyload"><br>这里面的链式存储结构里面的 <em>静态链表</em> 挺有意思的，不用指针实现链式结构。<br>线性表的这两种结构实际上是后面其他数据结构的基础，顺序储存结构和链式储存结构也各有优劣。<br><img alt="image" data-src="http://p1.cdn.img9.top/ipfs/QmUWbnXLv86uwuCrWkp2ft6fax7TgZ1kryaCPKrWTGidsy?1.PNG" src="/img/loading.gif" class="lazyload"></li></ul><p>注：代码中的String是我自定义的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">typedef struct{</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="comment">//内容</span></span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line"><span class="keyword">int</span> maxLength;</span><br><span class="line">}String;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(String *s,<span class="keyword">int</span> max,<span class="keyword">char</span> * string)</span></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">s->maxLength=max;</span><br><span class="line">s->length=strlen(string);</span><br><span class="line"><span class="comment">//开辟空间</span></span><br><span class="line">s->str=(<span class="keyword">char</span>*)malloc(sizeof(<span class="keyword">char</span>)*max);</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i<s->length;i++){</s-></span><br><span class="line">s->str[i]=string[i];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加其他的评论系统</title>
      <link href="/2018/07/01/hexo-tian-jia-ping-lun-xi-tong/"/>
      <url>/2018/07/01/hexo-tian-jia-ping-lun-xi-tong/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="最近换了一个Hexo的主题，也就是现在的这款，但是支持的评论系统两个已经关了，还有一个会被墙。所以就自己来加了一个"><a href="#最近换了一个Hexo的主题，也就是现在的这款，但是支持的评论系统两个已经关了，还有一个会被墙。所以就自己来加了一个" class="headerlink" title="最近换了一个Hexo的主题，也就是现在的这款，但是支持的评论系统两个已经关了，还有一个会被墙。所以就自己来加了一个"></a>最近换了一个Hexo的主题，也就是现在的这款，但是支持的评论系统两个已经关了，还有一个会被墙。所以就自己来加了一个</h2><h3 id="首先注册并登录LiveRe"><a href="#首先注册并登录LiveRe" class="headerlink" title="首先注册并登录LiveRe"></a>首先注册并登录LiveRe</h3><p>登陆注册过程就不多说了<br>   选择city版的安装，会得到一段代码 </p><h3 id="在个人博客中加入LiveRe代码"><a href="#在个人博客中加入LiveRe代码" class="headerlink" title="在个人博客中加入LiveRe代码"></a>在个人博客中加入LiveRe代码</h3><p>首先去如路径：hexo_bolg/themes/your-theme/layout/_partial/post下创建livere.ejs代码。livere.ejs的内容就是上一步中获取的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"><!-- 来必力City版安装代码 --></span><br><span class="line"><div id="lv-container" data-id="city" data-uid="MTAyMC8zMzM5MC85OTQ2"><br><span class="line">    <script type="text/javascript"></span><br><span class="line">   (function(d, s) {</span><br><span class="line">       var j, e = d.getElementsByTagName(s)[0];</span><br><span class="line"></span><br><span class="line">       if (typeof LivereTower === 'function') { return; }</span><br><span class="line"></span><br><span class="line">       j = d.createElement(s);</span><br><span class="line">       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';</span><br><span class="line">       j.async = true;</span><br><span class="line"></span><br><span class="line">       e.parentNode.insertBefore(j, e);</span><br><span class="line">   })(document, 'script');</span><br><span class="line">    </script></span><br><span class="line"><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></span><br><span class="line"></span></div></span><br><span class="line"><!-- City版安装代码已完成 --></span><br></pre></td></tr></tbody></table></figure></div><p>然后修改路径：hexo_bolg/themes/your-theme/layout/_partial下的article.ejs文件，在<code><% if (!index && post.comments){ %></code> 代码块下添加如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"><% if (!index){ %></span><br><span class="line">  <% if (post.comments){ %></span><br><span class="line">  <%- partial('post/livere') %></span><br><span class="line">  <% } else { %></span><br><span class="line">    <div class="lv-container"></div></span><br><span class="line">  <% } %></span><br><span class="line"><% } %></span><br></pre></td></tr></tbody></table></figure></div><p><img alt data-src="http://p0.cdn.img9.top/ipfs/QmWwSjQj5zqz5mAgEtYjgTBRXRqBapvZMaEzArt8xRqQm2?0.jpg" src="/img/loading.gif" class="lazyload"></p><p><del>此时LiveRe已经添加OK了，重新部署你的博客然后刷新页面就可以看到博客中添加好了LiveRe评论</del><br>换了 Valine</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap学习</title>
      <link href="/2018/06/17/nmap-xue-xi/"/>
      <url>/2018/06/17/nmap-xue-xi/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Nmap简介"><a href="#Nmap简介" class="headerlink" title="Nmap简介"></a>Nmap简介</h2><p>   Nmap是一个开源免费的网络发现和安全审计工具 ， 全称是NetWork  Mapper , 采用c++语言编写。纯命令行界面，Nmap官方提供了一个Zenmap的图形界面。</p><ul><li>关于端口<br>  ·    默认情况下，Namp会扫描1000个最有可能开放的TCP端口<br>·   open：开放<br>·   closed：关闭<br>·   filtered：被屏蔽<br>·   unfiltered：没有屏蔽还需要确认<br>·   open | filtered : 开放或者屏蔽<br>·   close | filtered : 关闭或屏蔽<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>主机扫描</li></ul><ol><li>nmap  192.168.1.100 直接扫描，会扫描常用前1000个端口 扫描我的宿主机</li></ol></li></ul><ol start="2"><li>nmap -F 192.168.1.100  快速扫描，会扫描常用的前100个端口</li><li>-v  显示扫描过程<br>root@kali:~# nmap -v -F  192.168.1.100<br>Starting Nmap 7.70 ( <a href="https://nmap.org" target="_blank" rel="noopener">https://nmap.org</a> ) at 2018-06-17 00:55 EDT<br>Initiating Ping Scan at 00:55<br>Scanning 192.168.1.100 [4 ports]<br>Completed Ping Scan at 00:55, 0.05s elapsed (1 total hosts)<br>Initiating Parallel DNS resolution of 1 host. at 00:55<br>Completed Parallel DNS resolution of 1 host. at 00:55, 0.01s elapsed<br>Initiating SYN Stealth Scan at 00:55<br>Scanning 192.168.1.100 [100 ports]<br>Discovered open port 135/tcp on 192.168.1.100<br>Discovered open port 139/tcp on 192.168.1.100<br>Discovered open port 445/tcp on 192.168.1.100<br>Discovered open port 3306/tcp on 192.168.1.100<br>Discovered open port 443/tcp on 192.168.1.100<br>Increasing send delay for 192.168.1.100 from 0 to 5 due to 43 out of 142 dropped probes since last increase.<br>Completed SYN Stealth Scan at 00:55, 7.68s elapsed (100 total ports)<br>Nmap scan report for 192.168.1.100<br>Host is up (1.8s latency).<br>Not shown: 94 closed ports<br>PORT     STATE    SERVICE<br>135/tcp  open     msrpc<br>139/tcp  open     netbios-ssn<br>443/tcp  open     https<br>445/tcp  open     microsoft-ds<br>514/tcp  filtered shell<br>3306/tcp open     mysql<br>Read data files from: /usr/bin/../share/nmap<br>Nmap done: 1 IP address (1 host up) scanned in 7.88 seconds<br>Raw packets sent: 166 (7.280KB) | Rcvd: 163 (6.688KB)</li><li>-sV  返回端口对应的服务信息（好慢）</li><li>-O  返回对应服务的系统信息</li></ol><ul><li>主机发现<br>  我们可以通过namp来嗅探整个局域网，扫描出局域网中在线的主机，通过ICMP ECHO扫描出在线的主机 （ping的底层原理） <ol><li>nmap -sS 192.168.1.100 隐蔽扫描 -sS ，也就是SYN扫描，只管发送数据包</li><li>查看存活主机<br>nmap -sP 192.168.239.* 或者 192.168.239.0/24</li><li>扫描主机的所有端口<br>nmap -p 1-65535 192.168.239.133</li><li>扫描主机的操作系统<br>nmap -O 192.168.239.133</li><li>查看主机个服务的版本详细信息<br>nmap -sV 192.168.239.133</li></ol></li><li>常见的Nmap扫描类型参数<br>-sT :TCP connect扫描 ，类似Metasploit中的tcp扫描<br>-sS : TCP SYN扫描，类似于Metasploit 中的syn扫描模块<br>-sF/-sX/-sN : 这些扫描通过发送一些特殊的标志位以避开设备或软件的监测<br>-sP :通过发送ICMP echo 请求探测主机是否存货原理同Ping.<br>-sU :探测主机开放了那些UDP端口。<br>-sA : TCP ACK 扫描，类似与Metasploit里的ack扫描模块<ul><li>常见的Nmap扫描选项</li></ul></li><li>Pn : 在扫描之前不发送ICMP echo请求测试目标是否活跃</li><li>O ：启用对于TCP/IP 协议栈的特征扫描以获取远程主机的操作系统</li><li>F ：快速扫描</li><li>p ：端口范围</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kali </tag>
            
            <tag> Nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群搭建</title>
      <link href="/2018/05/27/redis-ji-qun-da-jian/"/>
      <url>/2018/05/27/redis-ji-qun-da-jian/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h1><h1 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h1><h3 id="1．关于关系型数据库和nosql数据库"><a href="#1．关于关系型数据库和nosql数据库" class="headerlink" title="1．关于关系型数据库和nosql数据库"></a>1．关于关系型数据库和nosql数据库</h3><p>   关系型数据库是基于关系表的数据库，最终会将数据持久化到<a href>磁盘</a>上，而nosql数据  库是基于特殊的结构，并将数据存储到<a href>内存</a>的数据库。从性能上而言，nosql数据库  要优于关系型数据库，从安全性上而言关系型数据库要优于nosql数据库，所以在实  际开发中一个项目中nosql和关系型数据库会一起使用，达到性能和安全性的双保证</p><h3 id="2-Redis的安装"><a href="#2-Redis的安装" class="headerlink" title="2 . Redis的安装"></a>2 . Redis的安装</h3><p>这里关于Redis的安装不想多说，实际生产中都是将Reids安装在Linux上的，这里主要是说集群的搭建。</p><h3 id="3-Redis的使用"><a href="#3-Redis的使用" class="headerlink" title="3. Redis的使用"></a>3. Redis的使用</h3><p>   我也是第一次接触Redis，使用其实也没什么说的 <a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>上都有，挺简单的。</p><h3 id="3-集群的搭建"><a href="#3-集群的搭建" class="headerlink" title="3. 集群的搭建"></a>3. 集群的搭建</h3><p>Redis要做集群必须要有至少三个节点否则他的投票机制无法运行<br>必须要有超过半数的节点都认为某一台Redis机器挂掉了才会认为集群挂掉了<br><img alt="Redis" data-src="http://p3.cdn.img9.top/ipfs/QmX5E7BViadysS6bZLs7Eeu1VSkvCHEEcUrkSVgWBjwNCx?3.png" src="/img/loading.gif" class="lazyload"></p><p>这里再看看Redis集群的架构图<img alt="Redis" data-src="http://p3.cdn.img9.top/ipfs/QmZ6PpYPozPHppvXGRBMY5LgnrsjAqDaT2s1NoUCT8EFuD?3.png" src="/img/loading.gif" class="lazyload"><br>架构细节:</p><p>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p><p>(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.</p><p>(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</p><p>(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->value<br>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点，所以Redis节点最多也就16384个节点最少3个节点。</p><ul><li>开始搭建<br>这里搭建的是有3个节点的最小的集群为保证集群的高可用每个节点都有一台备份机一共需要6台服务器，就需要开6个虚拟机这里其实做测试没那个必要，搭建一个伪分布式的就可以了，在一台虚拟机上搭建6个Redis实例</li><li>集群搭建环境<br>1、使用ruby脚本搭建集群。需要ruby的运行环境。<br>安装ruby<br>yum install ruby<br>yum install rubygems<br>(我虚拟机yum的时候一直报错无法解析，然后加了DNS后报404很奇怪 然后yum makecache后就好了)<br>2、安装ruby脚本运行使用的包<a href="https://pan.baidu.com/s/1bW6EUyeEevR5h1cT-g51mQ" target="_blank" rel="noopener">redis-3.0.0.gem</a>。<br>gem install redis-3.0.0.gem<br>这个脚本在你Redis源代码的src目录下redis-trib.rb这个脚本<br>3、创建6个Redis实例<br>直接copy5份编译后的Redis文件然后改下端口 把redis.conf(在Redis源代码下copy过来)里 cluster-enabled yes前注释去掉<br>3 、启动6个Redis这里可以写一个shell<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">cd redis01</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis02</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis03</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis04</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis05</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis06</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br></pre></td></tr></tbody></table></figure></div>4、用Ruby搭建集群 只需要这条命令集群就搭建完毕了<br>./redis-trib.rb create –replicas 1 192.168.25.3:7001 192.168.25.3:7002 192.168.25.3:7003 192.168.25.3:7004 192.168.25.3:7005 192.168.25.3:7006<br>补 ：这里的ip不要写127.0.0.1 不然连接集群的时候就会报Too many Cluster redirections?错误 亲测。。。我不是写的127.0.0.1我是因为后来虚拟机ip变了然后<br>replicas后面参数1代表每个节点会有一台备份机所以后面的ip和端口号必须是偶数<h3 id="4-集群的使用"><a href="#4-集群的使用" class="headerlink" title="4. 集群的使用"></a>4. 集群的使用</h3>  redis01/redis-cli -p 7002 -c<br>后面的c代表连接的是集群 如果不加c就是单机的 如果存入数据的槽位不对应就会报错当然这是在命令行下的使用，windows下也有一些Redis的客户端。这里主要讲用Java代码连接Redis这就要用到Jedis了跟JDBC那一套差不多 这里直接讲在淘淘中实际是怎么用的吧<br>这里有两个版本集群版和单机版 平常测试就用单机版所以可以先写一个接口，抽取一些常用的方法</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> redis;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JedisClient</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">set</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"><span class="function">Boolean <span class="title">exists</span><span class="params">(String key)</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">ttl</span><span class="params">(String key)</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">incr</span><span class="params">(String key)</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">hset</span><span class="params">(String key, String field, String value)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">hget</span><span class="params">(String key, String field)</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">hdel</span><span class="params">(String key, String... field)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>然后写各自的实现类</p><ul><li>单机版</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> redis;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClientPool</span> <span class="keyword">implements</span> <span class="title">JedisClient</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">String result = jedis.set(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">String result = jedis.get(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">exists</span><span class="params">(String key)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">Boolean result = jedis.exists(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">Long result = jedis.expire(key, seconds);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">ttl</span><span class="params">(String key)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">Long result = jedis.ttl(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">incr</span><span class="params">(String key)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">Long result = jedis.incr(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">hset</span><span class="params">(String key, String field, String value)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">Long result = jedis.hset(key, field, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hget</span><span class="params">(String key, String field)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">String result = jedis.hget(key, field);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">hdel</span><span class="params">(String key, String... field)</span> </span>{</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">Long result = jedis.hdel(key, field);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li>集群版</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> redis;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClientCluster</span> <span class="keyword">implements</span> <span class="title">JedisClient</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.set(key, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.get(key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">exists</span><span class="params">(String key)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.exists(key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.expire(key, seconds);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">ttl</span><span class="params">(String key)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.ttl(key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">incr</span><span class="params">(String key)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.incr(key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">hset</span><span class="params">(String key, String field, String value)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.hset(key, field, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hget</span><span class="params">(String key, String field)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.hget(key, field);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">hdel</span><span class="params">(String key, String... field)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> jedisCluster.hdel(key, field);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li>使用<br> 使用的时候就可以写个bean然后在需要的时候就可以直接注入了</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><!--?xml version=<span class="string"-->"1.0"</span> encoding=<span class="string">"UTF-8"</span>?><br><span class="line"><beans xmlns="<span" class="string">"http://www.springframework.org/schema/beans"</beans></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line">xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xmlns:mybatis-spring=<span class="string">"http://mybatis.org/schema/mybatis-spring"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"</span>></span><br><span class="line"><!--单机版--></span><br><span class="line">    <!-- <bean id=<span class="string">"jedisClientPool"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"redis.JedisClientPool"</span>></span><br><span class="line"><property name=<span class="string">"jedisPool"</span> ref=<span class="string">"jedisPool"</span> /></span><br><span class="line"></bean></span><br><span class="line"><bean id=<span class="string">"jedisPool"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"redis.clients.jedis.JedisPool"</span>></span><br><span class="line"><constructor-arg name=<span class="string">"host"</span> value=<span class="string">"192.168.25.4"</span>/></span><br><span class="line"><constructor-arg name=<span class="string">"port"</span> value=<span class="string">"6379"</span>/></span><br><span class="line"></bean> --></span><br><span class="line"><!--集群版--></span><br><span class="line"><bean id="<span" class="string">"jedisClientCluster"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"redis.JedisClientCluster"</span>><br><span class="line"><property name="<span" class="string">"jedisCluster"</property></span> ref=<span class="string">"jedisCluster"</span>/><br><span class="line"></span><br><span class="line"></span><br><span class="line"><bean id="<span" class="string">"jedisCluster"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"redis.clients.jedis.JedisCluster"</span>><br><span class="line"><constructor-arg name="<span" class="string">"nodes"</constructor-arg></span>><br><span class="line"><set></set></span><br><span class="line"><bean <span class="class"><span class="keyword">class</span></bean></span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>><br><span class="line"><constructor-arg name="<span" class="string">"host"</constructor-arg></span> value=<span class="string">"192.168.25.4"</span>/><br><span class="line"><constructor-arg name="<span" class="string">"port"</constructor-arg></span> value=<span class="string">"7001"</span>/><br><span class="line"></span><br><span class="line"><bean <span class="class"><span class="keyword">class</span></bean></span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>><br><span class="line"><constructor-arg name="<span" class="string">"host"</constructor-arg></span> value=<span class="string">"192.168.25.4"</span>/><br><span class="line"><constructor-arg name="<span" class="string">"port"</constructor-arg></span> value=<span class="string">"7002"</span>/><br><span class="line"></span><br><span class="line"><bean <span class="class"><span class="keyword">class</span></bean></span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>><br><span class="line"><constructor-arg name="<span" class="string">"host"</constructor-arg></span> value=<span class="string">"192.168.25.4"</span>/><br><span class="line"><constructor-arg name="<span" class="string">"port"</constructor-arg></span> value=<span class="string">"7003"</span>/><br><span class="line"></span><br><span class="line"><bean <span class="class"><span class="keyword">class</span></bean></span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>><br><span class="line"><constructor-arg name="<span" class="string">"host"</constructor-arg></span> value=<span class="string">"192.168.25.4"</span>/><br><span class="line"><constructor-arg name="<span" class="string">"port"</constructor-arg></span> value=<span class="string">"7004"</span>/><br><span class="line"></span><br><span class="line"><bean <span class="class"><span class="keyword">class</span></bean></span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>><br><span class="line"><constructor-arg name="<span" class="string">"host"</constructor-arg></span> value=<span class="string">"192.168.25.4"</span>/><br><span class="line"><constructor-arg name="<span" class="string">"port"</constructor-arg></span> value=<span class="string">"7005"</span>/><br><span class="line"></span><br><span class="line"><bean <span class="class"><span class="keyword">class</span></bean></span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>><br><span class="line"><constructor-arg name="<span" class="string">"host"</constructor-arg></span> value=<span class="string">"192.168.25.4"</span>/><br><span class="line"><constructor-arg name="<span" class="string">"port"</constructor-arg></span> value=<span class="string">"7006"</span>/><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p>这里在集群的时候遇到了问题就是我上面提到的ip的问题不要写127.0.0.1要写实际的内网ip以后如果ip变了就只能重新来一次了，那个命令我试了下执行第二次，报错说我那个节点不为空，<strong>也许</strong>把数据清空了就可以了。</p><ul><li>测试<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedis</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">//初始化Spring容器</span></span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring/applicationContext-redis.xml"</span>);</span><br><span class="line"><span class="comment">//从容器中获取jedisClient对象 (单机版) </span></span><br><span class="line">JedisClient jedisClient=applicationContext.getBean(JedisClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">jedisClient.set(<span class="string">"testRedis"</span>, <span class="string">"Hello World"</span>);</span><br><span class="line">System.out.println(jedisClient.get(<span class="string">"testRedis"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淘淘商城 </tag>
            
            <tag> Redis </tag>
            
            <tag> 集群搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis逆向工程对text的特殊处理</title>
      <link href="/2018/05/23/mybatis-ni-xiang-gong-cheng-dui-text-de-te-shu-chu-li/"/>
      <url>/2018/05/23/mybatis-ni-xiang-gong-cheng-dui-text-de-te-shu-chu-li/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Mybatis对Mysql中text类型的特殊处理"><a href="#Mybatis对Mysql中text类型的特殊处理" class="headerlink" title="Mybatis对Mysql中text类型的特殊处理"></a>Mybatis对Mysql中text类型的特殊处理</h1><ul><li>昨天晚上在做cms的crud的时候遇到的问题，编辑的时候不回显内容，然后f12看了下响应的json里面content也为null，然后去service里面把那个pojo加了toString把几条数据直接打印出来 因为用了分页然后打印出来的也并不是数据</li></ul><p>（下次再来探究分页插件） 然后注释掉在打印发现还是没有然后我试了下单独查询，根据主键查询查出来的居然用有！！！这就很奇怪了。。。我当时就以为是byexample的mapper有问题 哈哈哈~~ 其实还是自己框架学的不好的问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EasyUIJsonResult <span class="title">listContent</span><span class="params">(<span class="keyword">long</span> categoryId,<span class="keyword">int</span> page,<span class="keyword">int</span> rows)</span> </span>{</span><br><span class="line">EasyUIJsonResult result=<span class="keyword">new</span> EasyUIJsonResult();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试过程中发现PageHelper的一些问题 等下再来研究</span></span><br><span class="line"><span class="comment">//PageHelper.startPage(page, rows);</span></span><br><span class="line">TbContentExample example =<span class="keyword">new</span> TbContentExample();</span><br><span class="line">example.createCriteria().andCategoryIdEqualTo(categoryId);</span><br><span class="line">List<tbcontent> contents = dao.selectByExample(example);</tbcontent></span><br><span class="line">PageInfo<tbcontent> info=<span class="keyword">new</span> PageInfo<>(contents);</tbcontent></span><br><span class="line"></span><br><span class="line"><span class="comment">//加上PageHelper后这里打印出来的就不是contents对象了就是Page对象</span></span><br><span class="line"><span class="comment">//而且查出来的数据里面content为null (数据库中有 猜想可能是逆向工程有问题);</span></span><br><span class="line">System.out.println(contents);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试下单独查询 主键查询没问题 取的到content</span></span><br><span class="line">System.out.println(dao.selectByPrimaryKey((<span class="keyword">long</span>)<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独测试下只查一个    也没有</span></span><br><span class="line">TbContentExample example2 =<span class="keyword">new</span> TbContentExample();</span><br><span class="line">Criteria criteria2 = example2.createCriteria();</span><br><span class="line">criteria2.andCategoryIdEqualTo((<span class="keyword">long</span>)<span class="number">90</span>);</span><br><span class="line">System.out.println(dao.selectByExample(example2 ));</span><br><span class="line"></span><br><span class="line">result.setTotal(info.getTotal());</span><br><span class="line">result.setRows(contents);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li>然后就面向百度了一波，还真就查到了遇到跟我一样的问题<a href="https://ask.csdn.net/questions/205320" target="_blank" rel="noopener">同道中人</a><br>selectByExampleWithBLOBs用这个方法就可以了 看名字就知道更这个有关哈哈哈<br>然后就愉快的解决了<img alt="image" data-src="http://p1.cdn.img9.top/ipfs/QmVhiMUQoFbiHc8BJxFtSzCUxVrZffnj9vYD7yM5YmCjGL?1.png" src="/img/loading.gif" class="lazyload"></li><li>不仅仅是select update也有这个方法<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TbContentMapper</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countByExample</span><span class="params">(TbContentExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByExample</span><span class="params">(TbContentExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(TbContent record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(TbContent record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List<tbcontent> <span class="title">selectByExampleWithBLOBs</span><span class="params">(TbContentExample example)</span></tbcontent></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List<tbcontent> <span class="title">selectByExample</span><span class="params">(TbContentExample example)</span></tbcontent></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TbContent <span class="title">selectByPrimaryKey</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleSelective</span><span class="params">(@Param(<span class="string">"record"</span>)</span> TbContent record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> TbContentExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleWithBLOBs</span><span class="params">(@Param(<span class="string">"record"</span>)</span> TbContent record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> TbContentExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExample</span><span class="params">(@Param(<span class="string">"record"</span>)</span> TbContent record, @<span class="title">Param</span><span class="params">(<span class="string">"example"</span>)</span> TbContentExample example)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(TbContent record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeyWithBLOBs</span><span class="params">(TbContent record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(TbContent record)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC - 处理静态资源 (转)</title>
      <link href="/2018/05/21/springmvc-chu-li-jing-tai-zi-yuan/"/>
      <url>/2018/05/21/springmvc-chu-li-jing-tai-zi-yuan/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="【1】第一种示例与解决办法"><a href="#【1】第一种示例与解决办法" class="headerlink" title="【1】第一种示例与解决办法"></a><strong>【1】第一种示例与解决办法</strong></h2><p>将DispatcherServlet请求映射设置为 / ，将会拦截所有的请求。不能访问静态资源。</p><p><strong>解决办法：</strong></p><p>在SpringMVC的配置文件中配置如下标签解决</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><mvc:<span class="keyword">default</mvc:<span></span>-servlet-handler/><br></pre></td></tr></tbody></table></figure></div><p>其XSD文档说明如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*配置一个handler通过转发请求到servlet容器的默认servlet来处理静态资源*/</span></span><br><span class="line">Configures a handler <span class="keyword">for</span> serving <span class="keyword">static</span> resources by forwarding to the Servlet container<span class="string">'s default Servlet.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*使用该handler将会允许DispatcherServlet 的url-pattern为'</span>/<span class="string">';同时使用servlet容器的默认servlet处理静态资源*/</span></span><br><span class="line"><span class="string">Use of this handler allows using a "/" mapping with the DispatcherServlet </span></span><br><span class="line"><span class="string">while still utilizing the Servlet container to serve static resources. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*该handler将会转发所有请求到默认servlet*/</span></span><br><span class="line"><span class="string">This handler will forward all requests to the default Servlet. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*因此将该handler的执行顺序放到所有请求处理的最后是非常重要的！！！*/</span></span><br><span class="line"><span class="string">Therefore it is important that it remains last in the order of all other URL HandlerMappings. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*使用<mvc:annotation-driven>标签或者设置HandlerMapping instance的order来确保DefaultServletHttpRequestHandler的order最大。*/</mvc:annotation-driven></span></span><br><span class="line"><span class="string">That will be the case if you use the "annotation-driven" element </span></span><br><span class="line"><span class="string">or alternatively if you are setting up your customized HandlerMapping instance </span></span><br><span class="line"><span class="string">be sure to set its "order" property to a value lower than </span></span><br><span class="line"><span class="string">that of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE.</span></span><br></pre></td></tr></tbody></table></figure></div><p><img alt="image" data-src="https://img-blog.csdn.net/20170914152551033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" src="/img/loading.gif" class="lazyload"></p><p><strong>解释如下：</strong></p><p><code><mvc:default-servlet-handler></mvc:default-servlet-handler></code>将在SpringMVC的上下文中定义一个DefaultServletHttpRequestHandler来处理静态资源(其实就是将请求转发给默认的servlet)。</p><p>一般WEB服务器默认的servlet的名称为default。若所使用的WEB服务器默认的Servlet名称不是default，则需要通过default-servlet-name 属性指定！</p><p><img alt="image" data-src="https://img-blog.csdn.net/20170224143539025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" src="/img/loading.gif" class="lazyload"></p><hr><p><strong>不同服务器下默认servlet名字对应如下：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Tomcat, Jetty, JBoss, and GlassFish  默认 Servlet的名字 -- <span class="string">"default"</span></span><br><span class="line">Google App Engine 默认 Servlet的名字 -- <span class="string">"_ah_default"</span></span><br><span class="line">Resin 默认 Servlet的名字 -- <span class="string">"resin-file"</span></span><br><span class="line">WebLogic 默认 Servlet的名字  -- <span class="string">"FileServlet"</span></span><br><span class="line">WebSphere  默认 Servlet的名字 -- <span class="string">"SimpleFileServlet"</span></span><br></pre></td></tr></tbody></table></figure></div><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20170914154653746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" src="/img/loading.gif" class="lazyload"></p><hr><p><strong>【Tips：】</strong></p><p>使用上述配置，你会发现正常的Controller跳转失效了！</p><p>XSD说明最后一段话如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*使用<mvc:annotation-driven>标签或者设置HandlerMapping instance的order来确保DefaultServletHttpRequestHandler的order最大。*/</mvc:annotation-driven></span></span><br><span class="line">That will be the <span class="keyword">case</span> <span class="keyword">if</span> you use the <span class="string">"annotation-driven"</span> element </span><br><span class="line">or alternatively <span class="keyword">if</span> you are setting up your customized HandlerMapping instance </span><br><span class="line">be sure to set its <span class="string">"order"</span> property to a value lower than </span><br><span class="line">that of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE.</span><br></pre></td></tr></tbody></table></figure></div><p>也就是说，要么配置<code><mvc:annotation-driven></mvc:annotation-driven></code>标签，要么手动注册请求映射处理bean于xml中，并设置order属性值，以其实现框架中处理请求映射的bean的order值小于DefaultServletHttpRequestHandler的order属性值！！！</p><p>常用的解决方式为配置<code><mvc:annotation-driven></mvc:annotation-driven></code>标签，详情点击查看<a href="http://blog.csdn.net/j080624/article/details/66969987" target="_blank" rel="noopener">请求映射失效</a>。</p><p>点击查看<a href="http://blog.csdn.net/J080624/article/details/66969987" target="_blank" rel="noopener">controller映射失效</a></p><hr><h2 id="【2】第二种示例与解决办法"><a href="#【2】第二种示例与解决办法" class="headerlink" title="【2】第二种示例与解决办法"></a><strong>【2】第二种示例与解决办法</strong></h2><p>解决静态资源的思路是，在SpringMVC.xml中，拦截设置为”*.do”，而不是”/”。</p><p>这样就不会拦截静态资源的请求。</p><p>需要注意的是，如果项目中用到了shiro或者其他权限框架。那么需要注意你的shiro.xml配置，示例如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><bean id="<span" class="string">"shiroFilter"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>><br><span class="line">      <!-- Shiro的核心安全接口,这个属性是必须的 --></span><br><span class="line">      <property name="<span" class="string">"securityManager"</property></span> ref=<span class="string">"securityManager"</span>/><br><span class="line">      <!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --></span><br><span class="line">      <property name="<span" class="string">"loginUrl"</property></span> value=<span class="string">"/login"</span>/><br><span class="line"></span><br><span class="line">      <!-- Shiro连接约束配置,即过滤链的定义 --></span><br><span class="line">      <property name="<span" class="string">"filterChainDefinitions"</property></span>><br><span class="line">          <value></value></span><br><span class="line">              <!-- <span class="comment">/** = anon所有url都可以匿名访问 --></span><br><span class="line"><span class="comment">              <!-- 对静态资源设置匿名访问 --></span></span><br><span class="line"><span class="comment">              /images/** = anon</span></span><br><span class="line"><span class="comment">              /js/** = anon</span></span><br><span class="line"><span class="comment">              /styles/** = anon</span></span><br><span class="line"><span class="comment">              <!-- 验证码，可匿名访问 --></span></span><br><span class="line"><span class="comment">              /validateCode = anon  <!--验证码--></span></span><br><span class="line"><span class="comment">              /doLogin = anon</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              <!-- /** = authc 所有url都必须认证通过才可以访问 --></span></span><br><span class="line"><span class="comment">              /**=authc</span></span><br><span class="line"><span class="comment">              <!--请求logout，shrio擦除sssion--></span></span><br><span class="line"><span class="comment">              /logout=logout</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">  </span></span><br></pre></td></tr></tbody></table></figure></div><p>需要注意的是虽然SpringMVC拦截的是.do，但是由于使用了shiro(或者你的其他权限框架)，那么未登录情况下是不能直接访问除shiro配置文件里面允许匿名访问的路径之外的静态资源文件。</p><p>举个例子，你把静态资源文件放在了项目根目录，但是参考上面配置文件，显然不在匿名访问路径列表之内，所以会提示你先登录，登录之后才可访问项目根目录的静态资源文件。</p><ul><li>未登录前访问项目根目录下1.jpg , 跳到登录页面：</li></ul><p><img alt="image" data-src="https://img-blog.csdn.net/20170518094647021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" src="/img/loading.gif" class="lazyload"></p><ul><li>登录后访问项目根目录下1.jpg :</li></ul><p><img alt="image" data-src="https://img-blog.csdn.net/20170518094717006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" src="/img/loading.gif" class="lazyload"></p><p>另外，建议最好参考shiro配置文件，比如1.jpg放到images文件夹下，那么不用登录就可以直接访问。</p><p><img alt="image" data-src="https://img-blog.csdn.net/20170518094833869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" src="/img/loading.gif" class="lazyload"></p><hr><h2 id="【3】第三种示例与解决办法"><a href="#【3】第三种示例与解决办法" class="headerlink" title="【3】第三种示例与解决办法"></a><strong>【3】第三种示例与解决办法</strong></h2><p><strong>通过配置，避免静态资源被拦截，示例如下：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><!-- 静态资源访问（不拦截此目录下的东西的访问） --></span><br><span class="line">   <mvc:resources location="<span" class="string">"/js/"</mvc:resources></span> mapping=<span class="string">"/js/**"</span>/><br><span class="line">   <mvc:resources location="<span" class="string">"/css/"</mvc:resources></span> mapping=<span class="string">"/css/**"</span>/><br><span class="line">   <mvc:resources location="<span" class="string">"/images/"</mvc:resources></span> mapping=<span class="string">"/images/**"</span>/><br><span class="line">   <mvc:resources location="<span" class="string">"/bootstrap/"</mvc:resources></span> mapping=<span class="string">"/bootstrap/**"</span>/><br></pre></td></tr></tbody></table></figure></div><p>该标签的xsd说明文档如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*配置handler为静态资源，如images，js和CSS文件并进行缓存头优化，以便在Web浏览器中高效加载。*/</span><br><span class="line">Configures a handler for serving static resources such as </span><br><span class="line">images, js, and, css files with cache headers optimized for efficient loading in a web browser. </span><br><span class="line">/*允许为任何可以通过spring处理的路径资源提供服务*/</span><br><span class="line">Allows resources to be served out of any path that is reachable via Spring's Resource handling.</span><br></pre></td></tr></tbody></table></figure></div><p>注册的handler如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">org.springframework.web.servlet.resource.ResourceHttpRequestHandler</span><br></pre></td></tr></tbody></table></figure></div><p><strong>即，该标签注册ResourceHttpRequestHandler为静态资源的访问提供服务。</strong></p><p>该handler的javadoc如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="meta">@code</span> HttpRequestHandler} that serves <span class="keyword">static</span> resources in an optimized way according to the guidelines of Page Speed, YSlow, etc.</span><br><span class="line"></span><br><span class="line"> * <p>The {@linkplain #setLocations "locations"} property takes a list of Spring<br><span class="line"> * {<span class="meta">@link</span> Resource} locations from which <span class="keyword">static</span> resources are allowed to</span><br><span class="line"> * be served by <span class="keyword">this</span> handler. Resources could be served from a classpath location,</span><br><span class="line"> * e.g. <span class="string">"classpath:/META-INF/public-web-resources/"</span>, allowing convenient packaging</span><br><span class="line"> * and serving of resources such as .js, .css, and others in jar files.</span><br></p></span></pre></td></tr></tbody></table></figure></div><hr><h2 id="【4】第四种示例与解决办法"><a href="#【4】第四种示例与解决办法" class="headerlink" title="【4】第四种示例与解决办法"></a><strong>【4】第四种示例与解决办法</strong></h2><p>确切说这里只解决不通过controller而直接访问jsp的问题。</p><p><code><mvc:view-controller></mvc:view-controller></code>直接访问view-name对应的jsp</p><ul><li>jsp路径依据视图解析器配置。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><!-- mvc:view-controller可使其直接访问路径 -->  </span><br><span class="line"><mvc:view-controller path="<span" class="string">"/i18n"</mvc:view-controller></span> view-name=<span class="string">"i18n"</span>/><br><span class="line"></span><br><span class="line"><mvc:view-controller path="<span" class="string">"/i18n2"</mvc:view-controller></span> view-name=<span class="string">"i18n2"</span>/><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo+zookeeper简单实现分布式</title>
      <link href="/2018/05/20/dubbo-zookeeper-jian-dan-shi-xian-fen-bu-shi/"/>
      <url>/2018/05/20/dubbo-zookeeper-jian-dan-shi-xian-fen-bu-shi/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><ul><li>其实我也是在做淘淘的时候才接触到分布式，也只是简单的了解了下，关于分布式的好处也不多说了.</li><li>实际应用<br>这里实际应用就是淘淘商城 由于淘淘商城是基于soa(面向服务)的架构，表现层和服务层是不同的工程。所以要实现商品列表查询需要两个系统之间进行通信。<br>ps: 在淘淘里面用的是dubbo+zookeeper这只是远程通信的一种方式常见的有三种<br>1.Webservice：效率不高基于soap协议。项目中不推荐使用。<br>2.使用restful形式的服务：http+json。很多项目中应用。如果服务太多，服务之间调用关系混乱，需要治疗服务。<br>3.使用dubbo。使用rpc协议进行远程调用，直接使用socket通信。传输效率高，并且可以统计出系统之间的调用关系、调用次数。</li><li>dubbo<br>Dubbo就是<strong>资源调度和治理中心</strong>的管理工具。<br>dubbo的架构<br><img alt="image" data-src="http://p0.cdn.img9.top/ipfs/QmNt5aeNWC6PSPY6Dak7p39H1tHY6y9u6ppxhNFoh8PUFn?0.png" src="/img/loading.gif" class="lazyload"></li></ul><p><strong>节点角色说明：</strong></p><p>  <strong>Provider:</strong> 暴露服务的服务提供方。</p><p>  <strong>Consumer:</strong> 调用远程服务的服务消费方。</p><p>  <strong>Registry:</strong> 服务注册与发现的注册中心。</p><p>  <strong>Monitor:</strong> 统计服务的调用次调和调用时间的监控中心。</p><p>  <strong>Container:</strong> 服务运行容器<br><strong>流程分析：</strong><br>  0. 服务容器负责启动，加载，运行服务提供者。</p><p>  1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>  2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p><p>  3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p><p>  4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p>  5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br><strong>如何使用</strong><br> Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</p><p>  <strong>单一工程中spring的配置</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><bean id="<span" class="string">"xxxService"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.XxxServiceImpl"</span> /><br><span class="line"> <bean id="<span" class="string">"xxxAction"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.XxxAction"</span>><br><span class="line"> <property name="<span" class="string">"xxxService"</property></span> ref=<span class="string">"xxxService"</span> /><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure></div><p><strong>远程服务：</strong></p><p>  在本地服务的基础上，只需做简单配置，即可完成远程化：<br>  将上面的local.xml配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部    分放在服务消费方remote-consumer.xml。<br>  并在提供方增加暴露服务配置<a href="dubbo:service">dubbo:service</a>，在消费方增加引用服务配置<a href="dubbo:reference">dubbo:reference</a>。</p><p>  发布服务：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><!-- 和本地服务一样实现远程服务 --></span><br><span class="line"></span><br><span class="line">  <bean id="<span" class="string">"xxxService"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.XxxServiceImpl"</span> /><br><span class="line"></span><br><span class="line">  <!-- 增加暴露远程服务配置 --></span><br><span class="line"></span><br><span class="line">  <dubbo:service <span class="class"><span class="keyword">interface</span></dubbo:service></span>=<span class="string">"com.xxx.XxxService"</span> ref=<span class="string">"xxxService"</span> /><br><span class="line"></span><br><span class="line">   调用服务：</span><br><span class="line"><!-- 增加引用远程服务配置 --></span><br><span class="line"></span><br><span class="line">  <dubbo:reference id="<span" class="string">"xxxService"</dubbo:reference></span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.XxxService"</span> /><br><span class="line"></span><br><span class="line">  <!-- 和本地服务一样使用远程服务 --></span><br><span class="line">  <bean id="<span" class="string">"xxxAction"</bean></span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xxx.XxxAction"</span>><br><span class="line">  <property name="<span" class="string">"xxxService"</property></span> ref=<span class="string">"xxxService"</span> /><br><span class="line">  </span><br></pre></td></tr></tbody></table></figure></div><ul><li>淘淘中的dubbo<br><img alt="image" data-src="http://p1.cdn.img9.top/ipfs/QmRPvtoW2JoEZKuXFExYrusKhDt7kM5iSk4JWeXHBLfMVA?1.png" src="/img/loading.gif" class="lazyload"><br>简单解释下<br> 上面的springmvc是web层的配置下面的service是服务层的配置</li></ul><p><strong>service层发布服务</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><dubbo:registry protocol="<span" class="string">"zookeeper"</dubbo:registry></span> address=<span class="string">"127.0.0.1:2181"</span> /><br></pre></td></tr></tbody></table></figure></div><p>这个是注册中心 淘淘采用的是zookeeper address就是zookeeper的地址我的zookeper安装在本机上所以就是127.0.0.1后面的是zookeper暴露的端口号默认2181  首先在service层发布服务发布的时候指明接口类和 实现类 这里<em>实现类的首字母要小写*或者你也可以自己定义一个bean然后指定id<br>*<!-- 声明需要暴露的服务接口 --><br>    <dubbo:service interface="”com.taoshop.service.ItemService”<br">        ref=”itemServiceImpl” /></dubbo:service></em><br>*<!-- 用dubbo协议在20880端口暴露服务 --><br>    <dubbo:protocol name="”dubbo”" port="”20880”">*<br>这个就是暴露端口的服务 这里还要注意一点就是有多个应用发布服务这里端口需要改。<br><strong>服务发布web层引用服务</strong></dubbo:protocol></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><dubbo:reference <span class="class"><span class="keyword">interface</span></dubbo:reference></span>=<span class="string">"com.taoshop.service.ItemService"</span> id=<span class="string">"itemService"</span> /><br></pre></td></tr></tbody></table></figure></div><p>这样就完成了服务的发布和引用然后就可以启动项目测试了 这里还要注意启动的顺序<br>先启动zookeeper –> 再启动service层 –>再启动web 层 主要是要先启动zookeepe</p><ul><li>最后贴一下maven依赖吧<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><!--Dubbo --></span><br><span class="line"><dependency></dependency></span><br><span class="line"><groupid>com.alibaba</groupid></span><br><span class="line"><artifactid>dubbo</artifactid></span><br><span class="line"><exclusions></exclusions></span><br><span class="line"><exclusion></exclusion></span><br><span class="line"><groupid>org.springframework</groupid></span><br><span class="line"><artifactid>spring</artifactid></span><br><span class="line"></span><br><span class="line"><exclusion></exclusion></span><br><span class="line"><groupid>org.jboss.netty</groupid></span><br><span class="line"><artifactid>netty</artifactid></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><dependency></dependency></span><br><span class="line"><groupid>org.apache.zookeeper</groupid></span><br><span class="line"><artifactid>zookeeper</artifactid></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div></li><li>关于分布式确实还了解的不够，远程通讯webservice也还没学后面要慢慢花点时间来学习下 还是挺有意思的</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淘淘商城 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring请求参数获取的几种方式（转）</title>
      <link href="/2018/05/17/spring-qing-qiu-can-shu-huo-qu/"/>
      <url>/2018/05/17/spring-qing-qiu-can-shu-huo-qu/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="springmvc请求参数获取的几种方法"><a href="#springmvc请求参数获取的几种方法" class="headerlink" title="springmvc请求参数获取的几种方法"></a><a href="http://www.cnblogs.com/xiaoxi/p/5695783.html" target="_blank" rel="noopener">springmvc请求参数获取的几种方法</a></h1><p><strong>1、直接把表单的参数写在Controller相应的方法的形参中，适用于get方式提交，不适用于post方式提交。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** * 1.直接把表单的参数写在Controller相应的方法的形参中</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span> <span class="meta">@RequestMapping</span>(<span class="string">"/addUser1"</span>) <span class="function"><span class="keyword">public</span> String <span class="title">addUser1</span><span class="params">(String username,String password)</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"username is:"</span>+username);</span><br><span class="line">    System.out.println(<span class="string">"password is:"</span>+password); <span class="keyword">return</span> <span class="string">"demo/index"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><a id="more"></a>url形式：[http://localhost/SSMDemo/demo/addUser1?username=lixiaoxi&password=111111](http://localhost/SSMDemo/demo/addUser1?username=lixiaoxi&password=111111) 提交的参数需要和Controller方法中的入参名称一致。<p><strong>2、通过HttpServletRequest接收，post方式和get方式都可以。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** 2、通过HttpServletRequest接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span> <span class="meta">@RequestMapping</span>(<span class="string">"/addUser2"</span>) <span class="function"><span class="keyword">public</span> String <span class="title">addUser2</span><span class="params">(HttpServletRequest request)</span> </span>{</span><br><span class="line">     String username=request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">     String password=request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">     System.out.println(<span class="string">"username is:"</span>+username);</span><br><span class="line">     System.out.println(<span class="string">"password is:"</span>+password); <span class="keyword">return</span> <span class="string">"demo/index"</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>3、通过一个bean来接收,post方式和get方式都可以。</strong><br>(1)建立一个和表单中参数对应的bean</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.model; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>{ <span class="keyword">private</span> String username; <span class="keyword">private</span> String password; <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>{ <span class="keyword">return</span> username;</span><br><span class="line">    } <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>{ <span class="keyword">this</span>.username = username;</span><br><span class="line">    } <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>{ <span class="keyword">return</span> password;</span><br><span class="line">    } <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>{ <span class="keyword">this</span>.password = password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>(2)用这个bean来封装接收的参数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** * 3、通过一个bean来接收</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span> <span class="meta">@RequestMapping</span>(<span class="string">"/addUser3"</span>) <span class="function"><span class="keyword">public</span> String <span class="title">addUser3</span><span class="params">(UserModel user)</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"username is:"</span>+user.getUsername());</span><br><span class="line">       System.out.println(<span class="string">"password is:"</span>+user.getPassword()); <span class="keyword">return</span> <span class="string">"demo/index"</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>4、通过@PathVariable获取路径中的参数</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*** 4、通过<span class="doctag">@PathVariable</span>获取路径中的参数</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span> <span class="meta">@RequestMapping</span>(value=<span class="string">"/addUser4/{username}/{password}"</span>,method=RequestMethod.GET) <span class="function"><span class="keyword">public</span> String <span class="title">addUser4</span><span class="params">(@PathVariable String username,@PathVariable String password)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"username is:"</span>+username);</span><br><span class="line">        System.out.println(<span class="string">"password is:"</span>+password); <span class="keyword">return</span> <span class="string">"demo/index"</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>例如，访问<a href="http://localhost/SSMDemo/demo/addUser4/lixiaoxi/111111" target="_blank" rel="noopener">http://localhost/SSMDemo/demo/addUser4/lixiaoxi/111111</a> 路径时，则自动将URL中模板变量{username}和{password}绑定到通过@PathVariable注解的同名参数上，即入参后username=lixiaoxi、password=111111。<br><strong>5、使用@ModelAttribute注解获取POST请求的FORM表单数据</strong><br>Jsp表单如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><form action="<span" class="string">"<%=request.getContextPath()%>/demo/addUser5" method=<span class="string">"post"</span>> 用户名: <input type="<span" class="string">"text" name=<span class="string">"username"</span>/><br> 密  码: <input type="<span" class="string">"password" name=<span class="string">"password"</span>/><br><br><span class="line">     <input type="<span" class="string">"submit"</span> value=<span class="string">"提交"</span>/> <br><span class="line">     <input type="<span" class="string">"reset"</span> value=<span class="string">"重置"</span>/> <br><span class="line"></span></form><br></span></pre></td></tr></tbody></table></figure></div><p>Java Controller如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** * 5、使用<span class="doctag">@ModelAttribute</span>注解获取POST请求的FORM表单数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span> <span class="meta">@RequestMapping</span>(value=<span class="string">"/addUser5"</span>,method=RequestMethod.POST) <span class="function"><span class="keyword">public</span> String <span class="title">addUser5</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> UserModel user) </span>{</span><br><span class="line">        System.out.println(<span class="string">"username is:"</span>+user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"password is:"</span>+user.getPassword()); <span class="keyword">return</span> <span class="string">"demo/index"</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>6、用注解@RequestParam绑定请求参数到方法入参</strong><br>当请求参数username不存在时会有异常发生,可以通过设置属性required=false解决,例如: @RequestParam(value=”username”, required=false)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** * 6、用注解<span class="doctag">@RequestParam</span>绑定请求参数到方法入参</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span> <span class="meta">@RequestMapping</span>(value=<span class="string">"/addUser6"</span>,method=RequestMethod.GET) <span class="function"><span class="keyword">public</span> String <span class="title">addUser6</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username,@<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>{</span><br><span class="line">        System.out.println(<span class="string">"username is:"</span>+username);</span><br><span class="line">        System.out.println(<span class="string">"password is:"</span>+password); <span class="keyword">return</span> <span class="string">"demo/index"</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS学习</title>
      <link href="/2018/05/16/fastdfs/"/>
      <url>/2018/05/16/fastdfs/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="FastDFS学习笔记"><a href="#FastDFS学习笔记" class="headerlink" title="FastDFS学习笔记"></a>FastDFS学习笔记</h1><ul><li>FastDFS简介<br>  FastDFS服务端有两个角色：跟踪器（tracker）和存储<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9" target="_blank" rel="noopener">节点</a>（storage）。跟踪器主要做调度工作，在访问上起负载均衡的作用。<br>存储节点存储文件，完成文件管理的所有功能：就是这样的存储、同步和提供存取接口，FastDFS同时对文件的metadata进行管理。所谓文件的meta data就是文件的相关属性，以键值对（key value）方式表示，如：width=1024，其中的key为width，value为1024。文件metadata是<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">文件属性</a>列表，可以包含多个键值对。<br>跟踪器和存储节点都可以由一台或多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。<br>为了支持大容量，存储<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9" target="_blank" rel="noopener">节点</a>（服务器）采用了分卷（或分组）的组织方式。<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">存储系统</a>由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">存储服务器</a>组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了<a href="https://baike.baidu.com/item/%E5%86%97%E4%BD%99%E5%A4%87%E4%BB%BD" target="_blank" rel="noopener">冗余备份</a>和负载均衡的作用。<br>在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。<br>当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">存储系统</a>的容量。<br>FastDFS中的文件标识分为两个部分：卷名和文件名，二者缺一不可。</li><li>大胆分析<br>这里在淘淘的后台上传图片的时候用到了,确实好用也是c语言开发的 搭配<em>Nginx</em>贼方便,确实佩服那些搞<strong>C</strong>的大佬，上面的说法不够直白文字总是苍白的(￣▽￣)~<em>让我来强行解释一波<img alt="image" data-src="http://p1.so.qhmsg.com/bdr/_240_/t0183119f547ca0bbc6.png" src="/img/loading.gif" class="lazyload"><br>上面说到了*</em>FastDFS**主要有两个节点<ol><li>储存节点Storage<br>顾名思义就是用来储存文件的服务器这个图中的是比较复杂的情况这里有一个stroage 群里又分了很多组每个组里又有很多服务器（这里的服务器里面储存的文件是一样的 会自动同步 方便加机器）</li><li>监控节点Tracker<br>这个就跟<a href="http://www.so.com/link?m=a0NGOfhwBC5nSFnUTBxpX2uhRysff5w5UsQFEqgCBRrJbwZpybFckcSRdwhuJdbgSApcIIqhL0gq5D6eIbBJ5pN22O2Z0k6ENTFGSjrRpsgETp2Dl" target="_blank" rel="noopener">zookeper</a>作用有点像先上图<br><img alt="image" data-src="http://p0.cdn.img9.top/ipfs/QmZynH9DgJJbePkn35LjhRTc6xyyWL64jNT6QU6jyBnrXE?0.png" src="/img/loading.gif" class="lazyload"><br>这个是上传的过程可以看到客户端要上传图片都是通过Tracker的而储存节点也会定时向Tracker发送状态的信息监控Storage的状态<br><code>可以看出上面Client在上传图片成功后Storage返回了一个file_id然后客户端就会储存这个id那客户端是如何通过这个id访问到这个图片的呢？ ---没错就是Nginx 用Nginx来处理这些静态资源再好不过了</code></li></ol></li><li>使用<br>说了这么多来实际用用看吧  <ol><li>首先我们要在虚拟机上安装FastDFS并配置Nginx这个过程比较复杂也不是我们重点关心的问题是运维应该关心的问题这里有一个搭建好的最简单的<a href="https://pan.baidu.com/s/1u5FLtQu71CueAJwq63ji6A" target="_blank" rel="noopener">FastDFS服务器</a>开机就可以直接用服务都是开机自启动的  <ol start="2"><li>然后我们要有客户端这里FastDFS作者已经写好了JAVA的客户端我们直接拿来用就好了<a href="https://pan.baidu.com/s/1KY5BKUr6f1PlCRR7hyhRSA" target="_blank" rel="noopener">fastdfs_client的jar包</a></li><li>开始使用吧  </li></ol></li></ol></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、加载配置文件，配置文件中的内容就是tracker服务的地址。</span></span><br><span class="line"><span class="comment">//配置文件内容：tracker_server=192.168.25.133:22122</span></span><br><span class="line">ClientGlobal.init(<span class="string">"D:\\JavaDemo\\taoshop-web\\src\\main\\resources\\conf\\client.conf"</span>);</span><br><span class="line"><span class="comment">//2、创建一个TrackerClient对象。直接new一个。</span></span><br><span class="line">TrackerClient trackerClient =<span class="keyword">new</span> TrackerClient();</span><br><span class="line"><span class="comment">//3、使用TrackerClient对象创建连接，获得一个TrackerServer对象。</span></span><br><span class="line">TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line"><span class="comment">//4、创建一个StorageServer的引用，值为null</span></span><br><span class="line">StorageServer storageServer =<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//5、创建一个StorageClient对象，需要两个参数TrackerServer对象、StorageServer的引用</span></span><br><span class="line">StorageClient storageCilent =<span class="keyword">new</span> StorageClient(trackerServer,storageServer);</span><br><span class="line"><span class="comment">//6、使用StorageCilent上传文件</span></span><br><span class="line">String[] strings = storageCilent.upload_file(<span class="string">"C:\\Users\\Administrator\\Desktop\\image\\222.jpg"</span>,<span class="string">"jpg"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">for</span> (String string : strings) {</span><br><span class="line">System.out.println(string);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里最后也就是为了的到StorageServer对象 我们可以写个工具类方便我们上传，将得到的file信息直接放在虚拟机ip/后面<br><img alt="image" data-src="http://p3.so.qhimgs1.com/bdr/_240_/t0151a407cda74a2153.png" src="/img/loading.gif" class="lazyload">成功访问到了这张图片！还是很方便的。</p><ul><li><p>在淘淘商城中的运用<br> 在淘淘中主要是用在后台的图片上传上的 这里用的是ssm的组合SpringMVC上传图片首先要有commons.io和fileupload的jar包还有配置多媒体解析器<br>在这里我也遇到了一个小问题 他在这里用的是<em>KingEditor</em> 上传图片时要求返回的格式是</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">//成功时</span></span><br><span class="line">  { </span><br><span class="line">        <span class="string">"error"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="string">"url"</span> : <span class="string">"http://www.example.com/path/to/file.ext"</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//失败时</span></span><br><span class="line">{</span><br><span class="line">        <span class="string">"error"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"message"</span> : <span class="string">"错误信息"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我直接返回的一个map然后前台解析不出来出现了问题后来用fastJson把map转成json后就好了但是其实传还是传到了图片服务器上去了</p></li><li><p>在做这个的时候还遇到了一些奇怪的问题就是如果修改代码后马上重新启动项目会报错clean一下就好了。</p></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> FastDFS </tag>
            
            <tag> 淘淘商城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习</title>
      <link href="/2018/05/13/nginx-xue-xi/"/>
      <url>/2018/05/13/nginx-xue-xi/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Nginx学习笔记"><a href="#Nginx学习笔记" class="headerlink" title="Nginx学习笔记"></a>Nginx学习笔记</h1><ul><li><p>Nginx简介<br><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.so.com/doc/5366073-5601774.html" target="_blank" rel="noopener">HTTP</a>和<a href="https://baike.so.com/doc/5345781-5581226.html" target="_blank" rel="noopener">反向代理</a>服务器，也是一个IMAP/POP3/SMTP<a href="https://baike.so.com/doc/4487696-4696885.html" target="_blank" rel="noopener">服务器</a>。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点(俄文:Рамблер)开发的，第一个公开版本0.1.0发布于2004年10月4日。<br>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<br>Nginx是一款<a href="https://baike.so.com/doc/585215-619452.html" target="_blank" rel="noopener">轻量级</a>的<a href="https://baike.so.com/doc/4230501-4432285.html" target="_blank" rel="noopener">Web</a> 服务器/<a href="https://baike.so.com/doc/5345781-5581226.html" target="_blank" rel="noopener">反向代理</a>服务器及<a href="https://baike.so.com/doc/928072-980969.html" target="_blank" rel="noopener">电子邮件</a>(IMAP/POP3)代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.so.com/doc/6916691-7138566.html" target="_blank" rel="noopener">并发</a>能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有:百度、京东、<a href="https://baike.so.com/doc/2204905-2333035.html" target="_blank" rel="noopener">新浪</a>、网易、<a href="https://baike.so.com/doc/1038695-1098608.html" target="_blank" rel="noopener">腾讯</a>、淘宝等。</p></li><li><p>Nginx主要作用</p></li></ul><ol><li>(Http服务器)处理静态文件<br><img alt="image" data-src="http://p0.cdn.img9.top/ipfs/QmdiKx1JUr7y9TabUQNNqu5dP8AwdsHSHe9QMwa487rsaS?0.png" src="/img/loading.gif" class="lazyload"><br>像这样配置的话当访问 <em>localhost:80</em> 时就会访问到相对当前路径下的 html文件夹下的index.html 或者index.htm</li><li>反向代理<br> <strong>反向代理</strong> 也是nginx用的最多的地方，既然有反向代理那就肯定有 <strong>正向代理</strong> 先来理解下正向代理<img alt="image" data-src="https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/zhidao/pic/item/a2cc7cd98d1001e96d753f76b10e7bec54e79779.jpg" src="/img/loading.gif" class="lazyload"><br>正向代理其实就是代理上网，<strong>客户端</strong>发送请求到代理服务器然后代理服务器转交请求给<strong>目标服务器</strong>目标服务器响应给代理服务器代理服务器再响应给<strong>客户端</strong>也就起到了代理的作用<br>那反向代理是什么呢？<br><img alt="image" data-src="https://gss0.baidu.com/7LsWdDW5_xN3otqbppnN2DJv/zhidao/pic/item/a8014c086e061d95f3f21c4172f40ad162d9ca17.jpg" src="/img/loading.gif" class="lazyload"><br>正向代理针对的是<strong>客户端</strong>而反向代理正对的是<strong>服务端</strong><br>当用户发送一个请求给ServerB然后ServerB判断用户是什么请求<br>是请求Server1就转发给Server1… 在生产中前端用一个Nginx处理用户的请求再分发到不同的后端服务器。</li></ol><p><strong>配置</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">upstream sina{</span><br><span class="line">server <span class="number">192.168</span><span class="number">.125</span><span class="number">.3</span>:<span class="number">8080</span>;</span><br><span class="line">    }</span><br><span class="line">    server {</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.sina.com.cn;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">            proxy_pass   http:<span class="comment">//sina;</span></span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     upstream sohu{</span><br><span class="line">server <span class="number">192.168</span><span class="number">.125</span><span class="number">.3</span>:<span class="number">8081</span>;</span><br><span class="line">    }</span><br><span class="line">    server {</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.sohu.com;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">#交给谁代理</span><br><span class="line">            proxy_pass   http:<span class="comment">//sohu;</span></span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>像这样配置客户端访问通过一个公网ip入口先到达Nginx然后转发给对应的服务器当用户访问<em><a href="http://www.sohu.com*时就会转发给http://sohu" target="_blank" rel="noopener">www.sohu.com*时就会转发给http://sohu</a> 这个就是上面的upstream sohu{…} 交给它处理<br>3. 负载均衡和容错<br>    负载均衡就是在反向代理的中间加上的 就是在upstream 里面加一个server，最简单的负载均衡就是轮询一人一次刷新就换(*默认的就是轮询</em>) 当然你也可以根据服务器性能配置权重权重越大访问到的机会越大</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">upstream sina{</span><br><span class="line">server <span class="number">192.168</span><span class="number">.125</span><span class="number">.3</span>:<span class="number">8080</span>;</span><br><span class="line">#weigth是权重</span><br><span class="line">server <span class="number">192.168</span><span class="number">.25</span><span class="number">.148</span>:<span class="number">8082</span> weight=<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    server {</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.sina.com.cn;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">            proxy_pass   http:<span class="comment">//sina;</span></span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">         }</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure></div><p>由于Nginx是我们网站的入口如果Nginx挂掉后面的服务就都失效了这时候就可以加备用Nginx服务器用 keepalive+Nginx实现主备<img alt="image" data-src="http://p0.cdn.img9.top/ipfs/Qmc3nC82Xsh1QANbUfAdDGUmTL2KJ2bQzoYzge7VHvRRWu?0.png" src="/img/loading.gif" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo第一篇博客</title>
      <link href="/2018/05/10/hexo-de-di-yi-pian-bo-ke/"/>
      <url>/2018/05/10/hexo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="第一篇Hexo博客"><a href="#第一篇Hexo博客" class="headerlink" title="第一篇Hexo博客"></a>第一篇Hexo博客</h1><ul><li>才开始接触<em>markdown</em>不太熟悉，不过感觉还是很有意思的 😂  </li></ul><p><img alt="image" data-src="http://p4.cdn.img9.top/ipfs/QmcPovxCWmXZdSB7GYz1RJUp1twhrnHEeZMDnidv4S5kvB?4.jpg" src="/img/loading.gif" class="lazyload"></p><ul><li>本来是想把这个博客放到我的阿里云上的，但是感觉日常写写博客也够了，移过去可以自己写写后台但感觉有点麻烦，等到以后有时间了再来折腾，日常用用这个静态的就够了 用了cdn加速访问速度还可以😉</li><li>其实之前自己也自己做了一个博客 前台后台都是自己写的 前端不太熟悉用的bs，后台是ssm的 本来想上线的 但是感觉太丑了了而且后台的代码也还有问题😂放张图对比下<br><img alt="image" data-src="http://p1.cdn.img9.top/ipfs/Qmc73XD1sHrvpEM2Wn8DMSXZcvRGjSW2x7GJPuzhjJa68c?1.jpg" src="/img/loading.gif" class="lazyload"> 就这个画风 响应式也被我禁用了 实在是响应的太诡异了 再看看<em>material</em><br><code>Hexo的一款主题</code><br><img alt="image" data-src="http://p1.cdn.img9.top/ipfs/QmcghHet9V1iE2CXxYnUh9VbwQq6STX3ZpsZqs6ruy657h?1.png" src="/img/loading.gif" class="lazyload"></li></ul><hr><p> <img alt="mark" data-src="http://static.imlgw.top///20190127/0ddQkCXFDNyh.png?imageslim" src="/img/loading.gif" class="lazyload"> 第2个主题</p><hr><p>目前的是第三个</p><ul><li>认认真真的写博客了。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 体验 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>留言板</title>
      <link href="/board/index.html"/>
      <url>/board/index.html</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Dj-drop-the-beat-ง-•-•-ง"><a href="#Dj-drop-the-beat-ง-•-•-ง" class="headerlink" title="Dj drop the beat(ง •_•)ง"></a>Dj drop the beat(ง •_•)ง</h2>        <div id="aplayer-XtMUlQLL" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","volume":"0.4","music":[{"title":"負けないで","author":"ZARD","url":"http://static.imlgw.top/ZARD%20-%20%E8%B2%A0%E3%81%91%E3%81%AA%E3%81%84%E3%81%A7.mp3","pic":"http://static.imlgw.top/image/20190712/8732e58f48a6243e538a1331928d6d8f_hd.jpg"},{"title":"我要你","author":"任素汐","url":"http://static.imlgw.top/%E4%BB%BB%E7%B4%A0%E6%B1%90%20-%20%E6%88%91%E8%A6%81%E4%BD%A0.mp3","pic":"http://p1.music.126.net/s059kMtY8NRM2HHIErbIAw==/19201871067699838.jpg?param=130y130"},{"title":"写给父亲","author":"卢恒宇 / 李姝洁","url":"http://static.imlgw.top/%E5%8D%A2%E6%81%92%E5%AE%87%20-%20%E5%86%99%E7%BB%99%E7%88%B6%E4%BA%B2.mp3","pic":"http://p2.music.126.net/RDQy2q05vy6SArA9W2LZ-Q==/3295236350128133.jpg?param=130y130"},{"title":"嘲笑声","author":"Big Daddy","url":"http://static.imlgw.top/Big%C2%A0Daddy%20-%20%E5%98%B2%E7%AC%91%E5%A3%B0.mp3","pic":"http://p2.music.126.net/ok_2pydxVx8o6iXcC_w-xg==/109951164035285206.jpg?param=130y130"},{"title":"第二履历","author":"Big Daddy","url":"http://static.imlgw.top/Am%20-%20%E7%AC%AC%E4%BA%8C%E5%B1%A5%E5%8E%86.mp3","pic":"https://p1.music.126.net/EwinkxB_RdScQyO5yKvGSQ==/109951163680107440.jpg?param=90y90"},{"title":"運命のルーレット廻して","author":"ZARD","url":"http://static.imlgw.top/ZARD%20-%20%E9%81%8B%E5%91%BD%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%AC%E3%83%83%E3%83%88%E5%BB%BB%E3%81%97%E3%81%A6.mp3","pic":"http://static.imlgw.top/image/20190712/8732e58f48a6243e538a1331928d6d8f_hd.jpg"}]};  options.element = document.getElementById("aplayer-XtMUlQLL");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="博主简介"><a href="#博主简介" class="headerlink" title="博主简介"></a>博主简介</h1><blockquote><p>大悲无泪，大悟无言，大笑无声。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String []nickName={<span class="string">"半岛铁盒"</span>,<span class="string">"iMlGw0"</span>,<span class="string">"Resolmi"</span>,...};</span><br><span class="line"><span class="keyword">boolean</span> isMale=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> age=<span class="number">19</span>;</span><br><span class="line">String []skills={<span class="string">"Java"</span>,<span class="string">"Web"</span>,<span class="string">"Sql"</span>,<span class="string">"Linux"</span>,...};</span><br><span class="line">String address=<span class="string">"Hubei"</span>;</span><br><span class="line">String weChat=<span class="string">"ZnFeMn"</span>;</span><br></pre></td></tr></tbody></table></figure></div><p><img alt="姐姐" data-src="http://static.imlgw.top/image/20190712/a17c8f3c1a5449ea19996c40ff14d0e3_hd.jpg" src="/img/loading.gif" class="lazyload"></p></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>大佬们</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Search</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body></body></html>]]></content>
      
    </entry>
    
    
  
</search>
